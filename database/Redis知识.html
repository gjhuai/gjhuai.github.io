<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<link rel="stylesheet" href="../theme/css/my.css" /><h1>1. Redis 适合做什么</h1>
<h2>1.1. 缓存</h2>
<ul>
<li>Redis 字符串、哈希表两种数据结构适合用来储存大量的键值对信息</li>
</ul>
<p>当用 jdk 默认的序列化方案时，对类的版本要求严格一直，否则抛出 ClassNotFoundException。比如：</p>
<ul>
<li>几个共用 redis 缓存的应用，它们共用的 jar 包版本有差异（serialNo），就会导致整个系统失败。 https://github.com/alexxiyang/shiro-redis/issues/78</li>
<li>class 一旦上线，就不能改变包名或位置，否则无法序列号。 https://www.cnblogs.com/technologykai/p/10097167.html</li>
</ul>
<h2>1.2. 队列</h2>
<ul>
<li>使用“列表”数据结构，可以实现普通级和优先级队列的功能。</li>
<li>使用 有序集合”数据结构，可以实现优先级队列：</li>
<li>使用“哈希表”数据结构，可以实现延时队列。</li>
</ul>
<h2>1.3. 去重</h2>
<ul>
<li>利用“集合”数据结构，可以实现小批量数据的去重</li>
<li>利用“字符串数据结构的位操作，可以实现布隆过滤器，从而实现超大规模的数据去重</li>
<li>利用 Redis 自带的 HyperLogLog 数据结构，可以实现超大规模数据的去重和计数。</li>
</ul>
<h2>1.4. 积分板</h2>
<ul>
<li>Redis 的“有序集合”功能可实现积分板功能，还 实现自动排序、排名功能。</li>
</ul>
<h2>1.5. “发布／订阅”</h2>
<ul>
<li>Redis 带的 “发布／ 订阅”模式可以实现多对多的 发布／订阅”功能</li>
</ul>
<h1>2. 八大数据类型</h1>
<h2>2.1. 字符串</h2>
<ul>
<li>用来存储 Key-Value 结构数据</li>
<li>字符串只应用在小量级的数据记录中。如果数据量超过百万级别，那么使用字符串来保存简单的映射关系将会浪费大量内存。此时需要使用 Redis 的另一种数据结构 Hash。储存相同量级的数据， Hash 结构消耗的内存只有字符串结构的 1/4 ，但查询速度却不会比字符串差。</li>
<li>如果 Redis 中有大量 Key ，那么执行 “keys ＊” 命令会对 Redis 性能造成短暂影响，甚至导致 Redis 失去响应。 因此，绝对不应该在不清楚当前有多少 Key 的情况下冒然列出当前所有的 Key。</li>
</ul>
<h2>2.2. 列表</h2>
<ul>
<li>给 10 万用户发送祝福短信。10 台服务器同时从 1 台公共的 Redis 列表左侧读取数据。由于 Redis 是单线程、单进程的数据库，因此 10 台服务器即使同时对列表执行“lpop”操作， redis 也会自动让它们排队，一个一个地弹出最左侧的数据。</li>
<li>列表就像是一根平放的水管，可以从左边往里塞入数据，也可以从右边往里塞入数据；以从左边读取数据，也可以从右边读取数据。</li>
<li>lpush, rpush, lrange(根据索引查看数据), lpop, rpop</li>
<li>在弹出数据的同时，被弹出的这个数据也会被从列表中删除。</li>
</ul>
<h2>2.3. Set</h2>
<ul>
<li>元素不能重复，没有顺序。</li>
<li>sadd, scard(获取数量), spop,smembers(获取所有数据), sismember, srem(删除)</li>
<li>sinter 交集, sunion 并集, sdiff 差集。</li>
<li>用途 1：根据集合内数据不重复的特性实现去重并记录信息。</li>
<li>用途 2：利用多个集合计算交集、并集和差集。</li>
</ul>
<h2>2.4. 哈希表（hash table）</h2>
<ul>
<li>哈希表在 Key 里面还有 “字段”的概念， “字段” 下面才是“值”。即一个哈希表的 Key 里面可以设置成百 千个 值对。</li>
<li>使用晗希表不仅可以减少 Redis 的个数， 还能优化储存空间。储存相同的内容，占用的内存比字符串要小很多。</li>
<li>hset, hmset, hkeys(获取所有字段名), hget, hmget, hgetall, hdel, hexists, hlen</li>
</ul>
<h2>2.5. 发布/订阅</h2>
<ul>
<li>方法：publish, pubsub, subscribe, listen</li>
</ul>
<h2>2.6. 有序集合（Sorted Set）zset</h2>
<ul>
<li>有序集合里面的数据跟集合一样，也是不能 复的，但是每一个元素又关联了一个分数 Score，根据这个分数可以对元素进行排序。 分数可以重复。</li>
<li>实现排行榜功能</li>
<li>zadd, zincrby(修改评分), zrangebyscore(基于分数从小到大排序), zrevrangebyscore(从大到小排序), zrange(基于位置排序), zrevrange, zrank(查询值排名), zrevrank, zscore, zcard(查询有序集合里面一共有多少个值), zcount(查询在某个评分范围内的值有 少)</li>
</ul>
<h1>3. Redis 应用案例</h1>
<p>Redis 比较适合的一些应用场景：</p>
<h2>3.1. 取最新 N 个数据的操作</h2>
<p>比如典型的取你网站的最新文章，通过下面方式，我们可以将最新的 5000 条评论的 ID 放在 Redis 的 List 集合中，并将超出集合部分从数据库获取</p>
<ul>
<li>使用 LPUSH latest.comments<ID>命令，向 list 集合中插入数据</li>
<li>插入完成后再用 LTRIM latest.comments 0 5000 命令使其永远只保存最近 5000 个 ID</li>
<li>然后我们在客户端获取某一页评论时可以用下面的逻辑（伪代码）</li>
</ul>
<pre><code class="language-javascript">FUNCTION get_latest_comments(start,num_items):
     id_list = redis.lrange(&quot;latest.comments&quot;,start,start+num_items-1)
     IF id_list.length &lt; num_items
          id_list = SQL_DB(&quot;SELECT ... ORDER BY time LIMIT ...&quot;)
     END
     RETURN id_list
END
</code></pre>
<p>如果你还有不同的筛选维度，比如某个分类的最新 N 条，那么你可以再建一个按此分类的 List，只存 ID 的话，Redis 是非常高效的。</p>
<h2>3.2. 排行榜应用，取 TOP N 操作</h2>
<p>这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的 sorted set 出马了，将你要排序的值设置成 sortedset 的 score，将具体的数据设置成相应的 value，每次只需要执行一条 ZADD 命令即可。</p>
<h2>3.3. 需要精准设定过期时间的应用</h2>
<p>比如你可以把上面说到的 sorted set 的 score 值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除 Redis 中的过期数据，你完全可以把 Redis 里这个过期时间当成是对数据库中数据的索引，用 Redis 来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。</p>
<h2>3.4. 计数器应用</h2>
<p>Redis 的命令都是原子性的，你可以轻松地利用 INCR，DECR 命令来构建计数器系统。</p>
<h2>3.5. Uniq 操作，获取某段时间所有数据排重值</h2>
<p>这个使用 Redis 的 set 数据结构最合适了，只需要不断地将数据往 set 中扔就行了，set 意为集合，所以会自动排重。</p>
<h2>3.6. 实时系统，反垃圾系统</h2>
<p>通过上面说到的 set 功能，你可以知道一个终端用户是否进行了某个操作，可以找到其操作的集合并进行分析统计对比等。没有做不到，只有想不到。</p>
<h2>3.7. Pub/Sub 构建实时消息系统</h2>
<p>Redis 的 Pub/Sub 系统可以构建实时的消息系统，比如很多用 Pub/Sub 构建的实时聊天系统的例子。</p>
<h2>3.8. 构建队列系统</h2>
<p>使用 list 可以构建队列系统，使用 sorted set 甚至可以构建有优先级的队列系统。</p>
<h2>3.9. 缓存</h2>
<p>这个不必说了，性能优于 Memcached，数据结构更多样化。</p>
<p>转自: http://blog.nosqlfan.com/html/2235.html?ref=rediszt</p>
<h1>4. 安全管理</h1>
<ul>
<li>Redis 默认没有密码，并且只能本机访问。使用 redis-cli 连上以后可以执行任意命令。如果要开放外网连接，则需要设置密码，同时禁用危险命令或者对危险命令进行改名。</li>
</ul>