<p>课程 一 PL/SQL 基本查询与排序</p>
<p>本课重点：</p>
<p>1、写SELECT语句进行数据库查询</p>
<p>2、进行数学运算</p>
<p>3、处理空值</p>
<p>4、使用别名ALIASES</p>
<p>5、连接列</p>
<p>6、在SQL PLUS中编辑缓冲，修改SQL SCRIPTS</p>
<p>7、ORDER BY进行排序输出。</p>
<p>8、使用WHERE 字段。</p>
<p>一、写SQL 命令：</p>
<pre><code> 不区分大小写。

 SQL 语句用数字分行，在SQL PLUS中被称为缓冲区。

 最后以；或 / 结束语句。

 也可以用RUN来执行语句
</code></pre>
<p>二、例1：</p>
<pre><code>SQL&gt; SELECT dept_id, last_name, manager_id

2 FROM s_emp;

SQL&gt; SELECT last_name, salary * 12, commission_pct

2 FROM s_emp;
</code></pre>
<p>对于数值或日期型的字段，可以进行相应的四则运算，优先级与标准的高级语言相同。</p>
<pre><code>SQL&gt; SELECT last_name, salary, 12 * (salary + 100)

2 FROM s_emp;
</code></pre>
<p>三、列的别名ALIASES：</p>
<pre><code>计算的时候特别有用；

紧跟着列名，或在列名与别名之间加“AS”；

如果别名中含有SPACE，特殊字符，或大小写，要用双引号引起。

例(因字体原因，读者请记住：引号为英文双引号Double Quotation)：

SQL&gt; SELECT last_name, salary,

2 12 * (salary + 100) ”Annual Salary”

3 FROM s_emp;
</code></pre>
<p>四、连接符号：||</p>
<pre><code>连接不同的列或连接字符串

使结果成为一个有意义的短语：



SQL&gt; SELECT first_name || ’ ’ || last_name

2 || ’, ’|| title ”Employees”

3 FROM s_emp;
</code></pre>
<p>五、管理NULL值：</p>
<pre><code>SQL&gt; SELECT last_name, title,

2 salary * NVL(commission_pct,0)/100 COMM

3 FROM s_emp;
</code></pre>
<p>此函数使NULL转化为有意义的一个值，相当于替换NULL。</p>
<p>六、SQL PLUS的基本内容，请参考<SQL PLUS 简单实用精髓篇 ></p>
<p>七、ORDER BY 操作：</p>
<p>与其他SQL92标准数据库相似，排序如：SELECT expr FROM table [ORDER BY [ASC|DESC]];</p>
<p>从Oracle7 release 7.0.16开始，ORDER BY 可以用别名。</p>
<p>另：通过位置判断排序：</p>
<pre><code>SQL&gt; SELECT last_name, salary*12

2 FROM s_emp

3 ORDER BY 2;
</code></pre>
<p>这样就避免了再写一次很长的表达式。</p>
<p>另：多列排序：</p>
<pre><code>SQL&gt; SELECT last name, dept_id, salary

2 FROM s_emp

3 ORDER BY dept_id, salary DESC;
</code></pre>
<p>八、限制选取行：</p>
<p>SELECT expr FROM table [WHERE condition(s)] [ORDER BY expr];</p>
<p>例1：</p>
<pre><code>SQL&gt; SELECT first_name, last_name, start_date

2 FROM s_emp

3 WHERE start_date BETWEEN ’09-may-91’

4 AND ’17-jun-91’;
</code></pre>
<p>例2：</p>
<pre><code>SQL&gt; SELECT last_name

2 FROM s_emp

3 WHERE last_name LIKE ’_a%’; //显示所有第二个字母为 a的last_name
</code></pre>
<p>例3：如果有列为NULL</p>
<pre><code>SQL&gt; SELECT id, name, credit_rating

2 FROM s_customer

3 WHERE sales_rep_id IS NULL;
</code></pre>
<p>优先级：</p>
<p>Order        Evaluated Operator</p>
<p>1   All comparison operators (=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IN, LIKE, IS NULL, BETWEEN)</p>
<p>2   AND</p>
<p>3   OR</p>
<p>总结：我们今天主要学习了如何进行查询SELECT操作，具体的组合查询与子查询将在以后的课堂中学习，同时希望大家可以工作、学习中多多摸索，实践!</p>
<p>课程 二 PL/SQL 查询行函数</p>
<p>本课重点：</p>
<p>1、掌握各种在PL/SQL中可用的ROW函数</p>
<p>2、使用这些函数的基本概念</p>
<p>3、SELECT语句中使用函数</p>
<p>4、使用转换函数</p>
<p>一、FUNCTION的作用：</p>
<p>进行数据计算，修改独立的数据，处理一组记录的输出，不同日期显示格式，进行数据类型转换</p>
<p>函数分为：单独函数(ROW)和分组函数</p>
<p>注意：可以嵌套、可以在SELECT, WHERE, 和 ORDER BY中出现。</p>
<p>语法：function_name (column|expression, [arg1, arg2,...])</p>
<p>二、字符型函数</p>
<pre><code>1、LOWER 转小写

2、UPPER

3、INITCAP 首字母大写

4、CONCAT 连接字符，相当于 ||

5、SUBSTR SUBSTR(column|expression,m[,n])

6、LENGTH   返回字符串的长度

7、NVL    转换空值

其中，1、2经常用来排杂，也就是排除插入值的大小写混用的干扰，如：

SQL&gt; SELECT first_name, last_name

2 FROM s_emp

3 WHERE UPPER(last_name) = ’PATEL’;



FIRST_NAME LAST_NAME

-------------------- --------------------

Vikram    Patel

Radha     Patel
</code></pre>
<p>三、数学运算函数</p>
<p>1、ROUND  四舍五入</p>
<p>ROUND(45.923，2) = 45.92</p>
<p>ROUND(45.923，0) = 46</p>
<p>ROUND(45.923，-1) = 50</p>
<p>2、TRUNC  截取函数</p>
<p>TRUNC(45.923，2)= 45.92</p>
<p>TRUNC(45.923)= 45</p>
<p>TRUNC(45.923，-1)= 40</p>
<p>3、MOD 余除</p>
<p>MOD(1600，300)</p>
<p>实例：</p>
<p>SQL&gt; SELECT ROUND(45.923,2), ROUND(45.923,0),</p>
<p>2 ROUND(45.923,-1)</p>
<p>3 FROM SYS.DUAL;</p>
<p>四、ORACLE 日期格式和日期型函数：</p>
<p>1、默认格式为DD-MON-YY.</p>
<p>2、SYSDATE是一个求系统时间的函数</p>
<p>3、DUAL［'dju:el] 是一个伪表，有人称之为空表，但不确切。</p>
<pre><code>SQL&gt; SELECT SYSDATE

2 FROM SYS.DUAL;
</code></pre>
<p>4、日期中应用的算术运算符</p>
<p>例：</p>
<pre><code>SQL&gt; SELECT last_name, (SYSDATE-start_date)/7 WEEKS

2 FROM s_emp

3 WHERE dept_id = 43;
</code></pre>
<p>DATE+ NUMBER = DATE</p>
<p>DATE-DATE= NUMBER OF DAYS</p>
<p>DATE + (NUMBER/24) = 加1小时</p>
<p>5、函数：</p>
<p>MONTHS_BETWEEN(date1, date2) 月份间隔，可正，可负，也可是小数</p>
<p>ADD_MONTHS(date,n) 加上N个月，这是一个整数，但可以为负</p>
<p>NEXT_DAY(date,‘char’) 如：NEXT_DAY (restock_date,’FRIDAY’),从此日起下个周五。</p>
<p>ROUND(date[,‘fmt’])</p>
<p>TRUNC(date[,‘fmt’])</p>
<p>解释下面的例子：</p>
<pre><code>SQL&gt; SELECT id, start_date,

2 MONTHS_BETWEEN (SYSDATE,start_date) TENURE,

3 ADD_MONTHS(start_date,6) REVIEW

4 FROM s_emp

5 WHERE MONTHS_BETWEEN (SYSDATE,start_date)&lt;48;
</code></pre>
<p>我们看到：</p>
<pre><code>MONTHS_BETWEEN (SYSDATE,start_date)&lt;48，说明至今工作未满一年的员工。

LAST_DAY (restock_date) 返回本月的最后一天

SQL&gt; select round(sysdate,'MONTH') from dual



ROUND(SYSD

----------

01-11月-01
</code></pre>
<p>round(sysdate,'YEAR') = 01-1月 -02  </p>
<pre><code>ROUND 之后的值比基值大的最小符合值，大家可以用更改系统时间的方法测试，以15天为分界线，也是非常形象的四舍五入，而TRUNC恰好相反，是对现有的日期的截取。
</code></pre>
<p>五、转换函数：</p>
<p>1、TO_CHAR    使一个数字或日期转换为CHAR</p>
<p>2、TO_NUMBER  把字符转换为NUMBER</p>
<p>3、TO_DATE    字符转换为日期</p>
<p>这几个函数较为简单，但要多多实践，多看复杂的实例。</p>
<pre><code>SQL&gt; SELECT ID,TO_CHAR(date_ordered,’MM/YY’) ORDERED

2 FROM s_ord

3 WHERE sales_rep_id = 11;
</code></pre>
<p>转换时，要注意正确的缺省格式：</p>
<pre><code>SELECT TO_DATE('03-MAR-92') CORRECT FROM DUAL；//正确

SELECT TO_DATE('031092') CORRECT FROM DUAL；//不正确

SELECT TO_DATE('031095','MMDDYY') ERRORR FROM DUAL  // 输出 3月10日

SELECT TO_DATE('031095','DDMMYY') ERRORR FROM DUAL  // 输出 10月3日
</code></pre>
<p>4、实例：</p>
<pre><code>select to_char(sysdate,'fmDDSPTH "of" MONTH YYYY AM') TODAYS FROM DUAL;



TODAYS

--------------------------------

SIXTEENTH of 11月 2001 下午
</code></pre>
<p>大小写没有什么影响，引号中间的是不参与运算。</p>
<p>实例 ：</p>
<pre><code>SELECT ROUND(SALARY*1.25) FROM ONE_TABLE；

意义：涨25%工资后，去除小数位。在现实操作中，很有意义。
</code></pre>
<p>5、混合实例：</p>
<pre><code>SQL&gt; SELECT last_name, TO_CHAR(start_date,

2 ’fmDD ”of” Month YYYY’) HIREDATE

3 FROM s_emp

4 WHERE start_date LIKE ’%91’;



LAST_NAME HIREDATE

------------ --------------------

Nagayama 17 of June 1991

Urguhart 18 of January 1991

Havel 27 of February 1991
</code></pre>
<p>这里要注意：fmDD 和 fmDDSPTH之间的区别。</p>
<pre><code>SQL&gt; SELECT id, total, date_ordered

2 FROM s_ord

3 WHERE date_ordered =

4 TO_DATE(’September 7, 1992’,’Month dd, YYYY’);
</code></pre>
<p>六、独立的函数嵌套</p>
<pre><code>SQL&gt; SELECT CONCAT(UPPER(last_name),

2 SUBSTR(title,3)) ”Vice Presidents”

3 FROM s_emp

4 WHERE title LIKE ’VP%’;
</code></pre>
<ul>
<li>嵌套可以进行到任意深度，从内向外计算。</li>
</ul>
<p>例：</p>
<pre><code>SQL&gt; SELECT TO_CHAR(NEXT_DAY(ADD_MONTHS

2 (date_ordered,6),’FRIDAY’),

3 ’fmDay, Month ddth, YYYY’)

4 ”New 6 Month Review”

5 FROM s_ord

6 ORDER BY date_ordered;



SQL&gt; SELECT last_name,

2 NVL(TO_CHAR(manager_id),’No Manager’)

3 FROM s_emp

4 WHERE manager_id IS NULL;

对于例子，大家重要的理解，并多做测试，并注意英文版和中文版在日期上的区别。

有些教材上的例子，不要盲目的相信其结果，实践后才有发言权，希望大家能够在学习的过程中不要忽略了用，多想一想为什么实例要如此设计，在何种情况下应用此实例来解决问题。这样，我们才真正掌握了知识。
</code></pre>
<p>课程 三 从多个表中提取数据</p>
<p>本课重点：</p>
<p>1、SELECT FROM 多个表，使用等连接或非等连接</p>
<p>2、使用外连接OUTER JOIN</p>
<p>3、使用自连接</p>
<p>一、连接的概念：</p>
<p>是指一个从多个表中的数据进行的查询。连接一般使用表的主键和外键。</p>
<p>连接类型：等连接、不等连接、外连接、自连接</p>
<p>二、Cartesian product（笛卡儿集）</p>
<p>指的是当JOIN条件被省略或无效时，所有表的行(交叉)都被SELECT出来的现象。</p>
<p>Cartesian product可以产生大量的记录，除非是你有意如此，否则应该加上某种条件限制。</p>
<p>SQL&gt; SELECT name, last_name</p>
<p>2 FROM s_dept, s_emp;</p>
<p>300 rows selected.</p>
<p>其中一个表12行，一个表25行。</p>
<p>三、简单连接查询：</p>
<p>语法结构：SELECT table.column, table.column...</p>
<p>FROM table1, table2</p>
<p>WHERE table1.column1 = table2.column2;</p>
<p>如：</p>
<p>SQL&gt; SELECT s_emp.last_name, s_emp.dept_id,</p>
<p>2 s_dept.name</p>
<p>3 FROM s_emp, s_dept</p>
<p>4 WHERE s_emp.dept_id = s_dept.id;</p>
<p>*注意：表前缀的重要性：</p>
<p>SQL&gt; SELECT s_dept.id ”Department ID”,</p>
<p>2 s_region.id ”Region ID”,</p>
<p>3 s_region.name ”Region Name”</p>
<p>4 FROM s_dept, s_region</p>
<p>5 WHERE s_dept.region_id = s_region.id;</p>
<p>在WHERE 段中，如果没有前缀，两个表中都有ID字段，就显得的模棱两可，AMBIGUOUS。</p>
<p>这在实际中应该尽量避免。</p>
<p>WHERE 字段中，还可以有其他的连接条件，如在上例中，加上：</p>
<p>INITCAP(s_dept.last_name) = ’Menchu’;</p>
<p>再如：WHERE s_emp.dept_id = s_dept.id AND s_dept.region_id = s_region.id AND s_emp.commission_pct &gt; 0;</p>
<p>四、表别名ALIAS：</p>
<p>1、使用别名进行多表查询 。</p>
<p>2、仅在这个查询中生效，一旦用了表别名，就不能再用表的原有的名字进行连接。</p>
<p>实例：</p>
<p>SQL&gt; SELECT c.name ”Customer Name”,</p>
<p>2 c.region_id ”Region ID”,</p>
<p>3 r.name ”Region Name”</p>
<p>4 FROM s_customer c, s_region r</p>
<p>5 WHERE c.region_id = r.id;</p>
<p>别名最多可以30个字符，但当然越少越好。最好也能容易识别。</p>
<p>五、非等连接</p>
<p>非等连接一般用在没有明确的等量关系的两个表；</p>
<p>最简单的说：非等连接就是在连接中没有“=”出现的连接。</p>
<p>SQL&gt; SELECT e.ename, e.job, e.sal, s.grade</p>
<p>2 FROM emp e, salgrade s</p>
<p>3 WHERE e.sal BETWEEN s.losal AND s.hisal;</p>
<p>*说明：Create a non-equijoin to evaluate an employee’s salary grade. The salary 必须在另一个表中最高和最低之间。</p>
<p>其他操作符&lt;= &gt;= 也可以实现，但是BETWEEN是非常简单实用的。</p>
<p>BETWEEN ....AND是指闭区间的，这点要注意 ，请大家测试。</p>
<p>六、外连接</p>
<p>语法结构：SELECT table.column, table.column</p>
<p>FROM table1, table2</p>
<p>WHERE table1.column = table2.column(+);</p>
<p>实例：</p>
<p>SQL&gt; SELECT e.last_name, e.id, c.name</p>
<p>2 FROM s_emp e, s_customer c</p>
<p>3 WHERE e.id (+) = c.sales_rep_id</p>
<p>4 ORDER BY e.id;</p>
<p>显示.....，即使有的客户没有销售代表。</p>
<ul>
<li>可以理解为有+号的一边出现了NULL，也可以做为合法的条件。</li>
</ul>
<p>外连接的限制：</p>
<p>1、外连接符只能出现在信息缺少的那边。</p>
<p>2、在条件中，不能用 IN 或者 OR做连接符。</p>
<p>七、自连接</p>
<p>同一个表中使用连接符进行查询；</p>
<p>FROM 的后面用同一个表的两个别名。</p>
<p>实例：</p>
<p>SQL&gt; SELECT worker.last_name||’ works for ’||</p>
<p>2 manager.last_name</p>
<p>3 FROM s_emp worker, s_emp manager</p>
<p>4 WHERE worker.manager_id = manager.id;</p>
<p>意味着：一个员工的经理ID匹配了经理的员工号，但这个像绕口令的连接方式并不常用。</p>
<p>以后我们会见到一种 子查询：</p>
<p>select last_name from s_emp where salary=(select max(salary) from s_emp)</p>
<p>也可以看作是一种变向的自连接，但通常我们将其归类为子查询。</p>
<p>课程 四 组函数</p>
<p>本课重点：</p>
<p>1、了解可用的组函数</p>
<p>2、说明每个组函数的使用方法</p>
<p>3、使用GROUP BY</p>
<p>4、通过HAVING来限制返回组</p>
<p>一、概念：</p>
<pre><code>  组函数是指按每组返回结果的函数。

  组函数可以出现在SELECT和HAVING 字段中。

  GROUP BY把SELECT 的结果集分成几个小组。

  HAVING 来限制返回组，对RESULT SET而言。
</code></pre>
<p>二、组函数：(#号的函数不做重点)</p>
<p>1、AVG</p>
<p>2、COUNT</p>
<p>3、MAX</p>
<p>4、MIN</p>
<p>5、STDDEV #</p>
<p>6、SUM</p>
<p>7、VARIANCE #</p>
<p>语法：</p>
<p>SELECT column, group_function</p>
<pre><code>  FROM table

 [WHERE condition]

  [GROUP BY group_by_expression]

   [HAVING group_condition]

     [ORDER BY column];
</code></pre>
<p>实例1：</p>
<p>SQL&gt; SELECT AVG(salary), MAX(salary), MIN(salary),</p>
<p>2 SUM(salary)</p>
<p>3 FROM s_emp</p>
<p>4 WHERE UPPER(title) LIKE ’SALES%’;</p>
<p>AVG(SALARY) MAX(SALARY) MIN(SALARY) SUM(SALARY)</p>
<hr />
<p>1476       1525          1400        7380</p>
<p>*说明：很多函数，我们在讲函数的已经向大家介绍过，但在此为何叫分组函数呢，主要是因为它们可以与GROUP BY来形成对不同组的计算，相当于在很多值中进行挑选。</p>
<ul>
<li>MIN MAX函数可以接任何数据类型。</li>
</ul>
<p>如果是MIN(last_name), MAX(last_name)，返回的是什么呢？</p>
<p>千万记住，不是指LAST_NAME的长度，而是指在FIRST字母的前后顺序，第一个相同，然后比较第二个，如：xdopt &gt; cssingkdkdk &gt;   adopt &gt; acccc</p>
<p>实例2：(返回所有非空行个数)</p>
<p>SQL&gt; SELECT COUNT(commission_pct)</p>
<p>2 FROM s_emp</p>
<p>3 WHERE dept_id = 31;</p>
<p>三、GROUP BY的应用：</p>
<p>先看一个简单实例：</p>
<p>SQL&gt; SELECT credit_rating, COUNT(*) ”# Cust”</p>
<p>2 FROM s_customer</p>
<p>3 GROUP BY credit_rating;</p>
<p>*注意这里别名的应用，复习一下从前的课程，加了引号后，就可以用特殊字符，但也仅有三个：#$_，什么对象的名字都如此。当然空格也是可以的。</p>
<p>复杂实例：</p>
<p>SQL&gt; SELECT title, SUM(salary) PAYROLL</p>
<p>2 FROM s_emp</p>
<p>3 WHERE title NOT LIKE ’VP%’</p>
<p>4 GROUP BY title</p>
<p>5 ORDER BY SUM(salary);</p>
<p>这里要注意一下几个CLAUSE的先后次序。WHERE在这里主要是做参与分组的记录的限制。</p>
<p>**另外，如果要选取出来一个不加组函数的列，如上面的TITLE，就要把这个列GROUP BY !否则要出错的!信息为：</p>
<p>ERROR at line 1:</p>
<p>ORA-00937: not a single-group group function</p>
<p>理论很简单，如果不GROUP BY TITLE，显示哪一个呢？这个在试题中经常出现。</p>
<p>结论：不加分组函数修饰的列必定要出现在GROUP BY 里。</p>
<p>错误实例：</p>
<p>SQL&gt; SELECT dept_id, AVG(salary)</p>
<p>2 FROM s_emp</p>
<p>3 WHERE AVG(salary) &gt; 2000</p>
<p>4 GROUP BY dept_id;</p>
<p>5 WHERE AVG(salary) &gt; 2000</p>
<p>ERROR at line 3:</p>
<p>ORA-00934: group function is not allowed here</p>
<p>应在GROUP BY 后面加上HAVING AVG(salary) &gt; 2000;因为是用来限制组的返回。</p>
<p>多级分组实例：</p>
<p>SQL&gt; SELECT dept_id, title, COUNT(*)</p>
<p>2 FROM s_emp</p>
<p>3 GROUP BY dept_id, title;</p>
<p>就是先按照DEPT_ID分组，当DEPT_ID相同的时候，再按TITLE分组，而COUNT(*)以合成的组计数。顺序对结果有决定性的影响。</p>
<p>总结：本课我们主要学习了分组函数的使用及如何进行分组查询，我们可以想像一下，SQL SERVER中有COMPUTE BY，来进行分组总数的计算，但在ORACLE中是没有的。大家可以建立一个有多个列，多个重复值的表，然后进行各种分组的演示，用得多了，自然明了。    </p>
<p>课程 五 子查询</p>
<p>本课重点：</p>
<p>1、在条件未知的情况下采用嵌套子查询</p>
<p>2、用子查询做数据处理</p>
<p>3、子查询排序</p>
<p>一、概述：</p>
<p>子查询是一种SELECT句式中的高级特性，就是一个SELECT语句作为另一个语句的一个段。我们可以利用子查询来在WHERE字段中引用另一个查询来攻取值以补充其无法事先预知的子结果。子查询可以用在WHERE子句，HAING子句，SELECT或DELETE语句中的FROM 子句。</p>
<p>*注意：</p>
<p>1、子查询必须在一对圆括号里。</p>
<p>2、比较符号：&gt;, =, 或者 IN.</p>
<p>3、子查询必须出现在操作符的右边</p>
<p>4、子查询不能出现在ORDER BY里   (试题中有时出现找哪行出错)</p>
<p>二、子查询的执行过程：</p>
<p>NESTED QUERY                            MAIN QUERY</p>
<p>SQL&gt; SELECT dept_id                     SQL&gt; SELECT last_name, title</p>
<p>2 FROM s_emp                            2 FROM s_emp</p>
<p>3 WHERE UPPER(last_name)=’BIRI’;        3 WHERE dept_id =</p>
<p>这里 ，每个查询只运行一次。当然，子查询要首先被执行，大家设想一下，如果子查询中有一个以上的人的LASTNAME为BIRI，会如何？-----会出错，因为不能用=来连接。</p>
<pre><code>  ORA-1427: single-row subquery returns more than one row
</code></pre>
<p>以上的查询也被称之为单行子查询。</p>
<p>DELECT子查询实例：</p>
<p>delete from new_table</p>
<p>where cata_time &gt; to_date('19990901','yyyymmdd') and pro_name=(</p>
<p>select pro_name from new_product where pro_addr in ('bj','sh'))</p>
<p>三、子查询中的GROUP 函数的应用</p>
<p>实例 1：</p>
<p>SQL&gt; SELECT last_name, title, salary</p>
<p>2 FROM s_emp</p>
<p>3 WHERE salary &lt;</p>
<p>4 (SELECT AVG(salary)</p>
<p>5 FROM s_emp);</p>
<p>实例2：选择出工资最高的员工的家庭住址：</p>
<p>select emp_addr from employees where salary =</p>
<p>(select max(salary) from employees);</p>
<p>这是一个简单实用的例子，可以衍生出很多情况，在实际应用经常出现，请大家多多思考。</p>
<p>实例3：</p>
<p>SQL&gt; SELECT dept_id, AVG(salary)</p>
<p>2 FROM s_emp</p>
<p>3 GROUP BY dept_id</p>
<p>4 HAVING AVG(salary) &gt;</p>
<p>5 (SELECT AVG(salary)</p>
<p>6 FROM s_emp</p>
<p>7 WHERE dept_id = 32);</p>
<p>子查询被多次执行，因为它出现在HAVING 子句中。</p>
<p>SQL&gt; SELECT title, AVG(salary)</p>
<p>2 FROM s_emp</p>
<p>3 GROUP BY title</p>
<p>4 HAVING AVG(salary) =</p>
<p>5 (SELECT MIN(AVG(salary))</p>
<p>6 FROM s_emp</p>
<p>7 GROUP BY title);</p>
<p>对子查询，我们了解这么多在理论上已经覆盖了所有的知识点，对于UPDATE 和DELETE的子查询，不作为重点，但也要练习掌握。今天到这，谢谢大家。   </p>
<p>课程 六 运行时应用变量</p>
<p>本课重点：</p>
<p>1、创建一个SELECT语句，提示USER在运行时先对变量赋值。</p>
<p>2、自动定义一系列变量，在SELECT运行时进行提取。</p>
<p>3、在SQL PLUS中用ACCEPT定义变量</p>
<p>一、概述：</p>
<p>变量可以在运行时应用，变量可以出现在WHERE 字段，文本串，列名，表名等。</p>
<p>1、我们这里的运行时，指的是在SQL PLUS中运行。</p>
<p>2、ACCEPT ：读取用户输入的值并赋值给变量</p>
<p>3、DEFINE：创建并赋值给一个变量</p>
<p>4、在做REPORT时经常使用，比如对某个部门的销售信息进行统计，部门名称可以以变量代替。</p>
<p>SQL PLUS不支持对输入数据的有效性检查，因此提示要简单且不模棱两可。</p>
<p>二、应用实例：</p>
<p>1、</p>
<p>SQL&gt; SELECT id, last_name, salary</p>
<p>2 FROM s_emp</p>
<p>3 WHERE dept_id = &amp;department_number;</p>
<p>2、可以在赋值前后进行比较：</p>
<p>SET VERIFY ON </p>
<p>..... </p>
<p>1* select * from emp where lastname='&amp;last_name'</p>
<p>输入 last_name 的值: adopt</p>
<p>原值  1: select * from emp where lastname='&amp;last_name'</p>
<p>新值  1: select * from emp where lastname='adopt'</p>
<p>----如果在原语句中没有单引号，那么在输入值的时候要手工加上单引号。一般字符和日期型要在语句中加上单引号。</p>
<p>SET VERIFY OFF 之后，原值和新值这两句消失。这在ORACLE8I中是默认为ON。</p>
<p>3、子句为变量：WHERE &condition; 要注意引号</p>
<p>三、DEFINE和ACCEPT的应用：</p>
<p>1、</p>
<p>SET ECHO OFF   //使内容不 显示在用户界面</p>
<p>ACCEPT p_dname PROMPT ’Provide the department name: ’</p>
<p>SELECT d.name, r.id, r.name ”REGION NAME”</p>
<p>FROM s_dept d, s_region r</p>
<p>WHERE d.region_id = r.id AND UPPER(d.name) LIKE UPPER(’%&amp;p_dname%’)</p>
<p>/</p>
<p>SET ECHO ON</p>
<p>存为文件：l7prompt.SQL</p>
<p>SQL&gt; START l7prompt</p>
<p>Provide the department name: sales</p>
<p>2、</p>
<p>SQL&gt; DEFINE dname = sales</p>
<p>SQL&gt; DEFINE dname</p>
<p>DEFINE dname = ”sales” (CHAR)</p>
<p>SQL&gt; SELECT name</p>
<p>2 FROM s_dept</p>
<p>3 WHERE lower(name) = ’&amp;dname’;</p>
<p>可以正常执行了。</p>
<p>SQL&gt; DEFINE dname 主要是显示当前的变量是否赋值，值是什么。当然，我们可以用UNDEFINEGO 来使变量恢复初始，不然它会一直保持下去。</p>
<p>3、如果变量在SQL SCRIPT文件中确定 ：可以SQL&gt; START l7param President 来赋值。</p>
<p>总结：本课主要针对较古老的SQLPLUS方法，在REPORT和结果集生成方面使用变量，达到方便操作，动态修改的目的。 </p>
<p>课程 七   其他数据库对象</p>
<p>SEQUENCE</p>
<p>创建实例：</p>
<p>SQL&gt; CREATE SEQUENCE s_dept_id</p>
<p>2 INCREMENT BY 1</p>
<p>3 START WITH 51</p>
<p>4 MAXVALUE 9999999</p>
<p>5 NOCACHE</p>
<p>6 NOCYCLE;</p>
<p>Sequence created.</p>
<p>1、NEXTVAL和CURRVAL的用法</p>
<p>只有在INSERT中，才可以作为子查询出现。</p>
<p>以下几个方面不可用子查询：</p>
<pre><code>SELECT子句OF A VIEW

有DISTINCT的出现的SELECT。

有GROUP　BY，HAVING，ORDER　BY的SELECT　子句。

SELECT　或DELETE，UPDATE　中的子查询。

DEFAULT选项中不能用。
</code></pre>
<p>2、编辑SEQUENCE</p>
<p>只有OWNER或有ALTER权限的用户才能修改SEQUENCE</p>
<p>未来的NUMBER受修改的影响。</p>
<p>不能修改START　WITH，如果变，则要RE－CREATE。</p>
<p>修改会受到某些有效性检验的限制，如MAXVALUE</p>
<p>3、删除：</p>
<p>DROP SEQUENCE sequence;</p>
<p>ORACLE对象之INDEX</p>
<p>一、INDEX概述：</p>
<p>是ORACLE的一种数据对象，用POINTER来加速查询行。通过快速路径存取方法定位数据并减少I/O。　INDEX独立于表。INDEX由ORACLE　SERVER来使用和保持。</p>
<p>二、索引如何建立？</p>
<p>1、自动：通过PRIMARY　KEY和UNIQUE KEY约束来建立。</p>
<p>2、用户手工建立非唯一性索引。</p>
<p>三、创建方法：</p>
<p>语法：CREATE INDEX index ON table (column[, column]...);</p>
<p>何时建立INDEX：</p>
<pre><code>此列经常被放到WHERE字段或JOIN来作条件查询。

此列含有大量的数据。

此列含有大量的空值。

两个或几个列经常同时放到WHERE字段进行组合查询

表很大而且只有少于2-4% 的ROW可能被查询的时候。

以下情况不要建立索引：

表很小；

表被更新频繁。
</code></pre>
<p>四、查看已经存在的索引：</p>
<p>1、USER_INDEXES可以查询索引名和类型。</p>
<p>2、USER_IND_COLUMNS包含索引名、表名、列名。</p>
<p>实例：</p>
<pre><code>SQL&gt; SELECT ic.index_name, ic.column_name,

2 ic.column_position col_pos, ix.uniqueness

3 FROM user_indexes ix, user_ind_columns ic

4 WHERE ic.index_name = ix.index_name

5 AND ic.table_name = ’S_EMP’;
</code></pre>
<p>五、删除索引：</p>
<pre><code> DROP INDEX index;
</code></pre>
<p>SYNONYMS 同义词</p>
<p>语法：CREATE [PUBLIC] SYNONYM synonym for object;</p>
<p>*注意：此对象不能包含在一个包里；一个私有的同义词不能与同一USER的其他对象重名。</p>
<pre><code>DROP SYNONYM D_SUM；
</code></pre>
<p>课程 八 用户访问控制</p>
<p>本课重点：</p>
<p>1、创建用户</p>
<p>2、创建角色来进行安全设置</p>
<p>3、使用GRANT或REVOKE 来控制权限</p>
<p>一、概述：</p>
<pre><code>ORACLE通过用户名和密码进行权限控制。

数据库安全：系统安全和数据安全

系统权限：使用户可以访问数据库

对象权限：操纵数据库中的对象

SCHEMA：各种对象的集合
</code></pre>
<p>二、系统权限：</p>
<p>1、超过80个权限可用。</p>
<p>2、DBA有最高的系统权限：</p>
<pre><code>CREATE NEW USER

REMOVE USERS

REMOVE ANY TABLE

BACKUP ANY TABLE
</code></pre>
<p>三、创建用户</p>
<p>1、CREATE USER user IDENTIFIED BY password;</p>
<p>2、系统权限：</p>
<pre><code>CREATE SESSION Connect to the database.

CREATE TABLE Create tables in the user’s schema.

CREATE SEQUENCE Create a sequence in the user’s schema.

CREATE VIEW Create a view in the user’s schema.

CREATE PROCEDURE Create a stored procedure, function, or package in the user’s schema.
</code></pre>
<p>3、授权用户系统权限：</p>
<pre><code>GRANT privilege [, privilege...] TO user [, user...];

GRANT CREATE TABLE TO SCOTT；
</code></pre>
<p>四、角色的使用</p>
<p>1、概念：角色是一组权限的命名，可以授予给用户。这样就如同给了某个用户一个权限包。</p>
<p>2、创建、授予给角色：</p>
<pre><code>CREATE ROLE MANAGER；

GRANT CREATE TABLE，CREATE VIEW TO MANAGER；

GRANT MANAGER TO CLARK
</code></pre>
<p>五、修改密码：</p>
<pre><code>ALTER USER user IDENTIFIED BY password;
</code></pre>
<p>六、对象权限：</p>
<p>1、语句：</p>
<p>GRANT {object_priv(, object_priv...)|ALL}[(columns)]</p>
<p>ON object</p>
<p>TO {user[, user...]|role|PUBLIC}</p>
<p>[WITH GRANT OPTION];</p>
<p>2、实例：</p>
<pre><code>最简单：

SQL&gt; GRANT select

2 ON s_emp

3 TO sue, rich;



稍复杂：

SQL&gt; GRANT update (name, region_id)

2 ON s_dept

3 TO scott, manager;



SQL&gt; GRANT select, insert

2 ON s_dept

3 TO scott

4 WITH GRANT OPTION;
</code></pre>
<p>课程 九 声明变量</p>
<p>本课重点：</p>
<p>1、了解基本的PLSQL块和区域</p>
<p>2、描述变量在PLSQL中的重要性</p>
<p>3、区别PLSQL与非PLSQL变量</p>
<p>4、声明变量</p>
<p>5、执行PLSQL块</p>
<p>一、概述：</p>
<p>1、PLSQL 块结构：</p>
<pre><code>DECLARE --- 可选    变量声明定义

BEGIN ---- 必选     SQL 和PLSQL 语句

EXCEPTION ---- 可选    错误处理

END；---- 必选
</code></pre>
<p>二、实例：</p>
<pre><code>declare

    vjob varchar(9);

    v_count number:=0;

    vtotal date:=sysdate +7;

    c_tax constant number(3,2):=8.25;

    v_valid boolean not null:=true;

begin

    select sysdate into vtotal from dual;

end;

/

上例中，如果没有这个SELECT语句，会如何？

出错，说明必须有STATEMENTS

如果： select sysdate from dual into vtotal ;

同样，也不行。而且变量与赋值的类型要匹配。
</code></pre>
<p>三、%TYPE的属性</p>
<pre><code>声明一个变量使之与数据库某个列的定义相同或与另一个已经定义过的变量相同，所以%TYPE要作为列名的后缀：如：

v_last_name s_emp.last_name%TYPE;

v_first_name s_emp.first_name%TYPE; --这样做的好处是我们不必去知晓此列的类型与定义

或：

v_balance NUMBER(7,2);

v_minimum_balance v_balance%TYPE := 10;
</code></pre>
<p>四、声明一个布尔类型的变量</p>
<pre><code>1 只有TRUE、FALSE、NULL可以赋值给BOOLEAN变量

2 此变量可以接逻辑运算符NOT、AND、OR。

3、变量只能产生TRUE、FALSE、NULL。
</code></pre>
<p>实例：</p>
<pre><code>VSAL1：=50000；

VSQL2：=60000；

VCOMMSAL BOOLEAN：=(VSAL1&lt;VSQL2)；  --其实是把TRUE赋值给此变量。
</code></pre>
<p>五、LOB 类型的变量</p>
<pre><code>共有CLOB、BLOB、BFILE、NCLOB几种，这里不做为重点。
</code></pre>
<p>六：使用HOST VARIABLES</p>
<pre><code>SQL&gt; variable n number

SQL&gt; print n

:n=v_sal /12;
</code></pre>
<p>:n这个加了：前缀的变量不是PLSQL变量，而是HOST。</p>
<p>七、以下几个PLSQL声明变量，哪个不合法？</p>
<pre><code>A 、DECLARE

      V_ID NUMBER(4)；

B、DECLARE

      V_X，V_Y，V_Z VARCHAR2(9)；

C、DECLARE

   V_BIRTH DATE NOT NULL；

D、DECLARE

   V_IN_STOCK BOOLEAN：=1；

E、DECLARE

   TYPE NAME_TAB IS TABLE OF VARCHAR2(20) INDEX BY BINARY_INTEGER；

   DEPT_NAME NAME_TAB；

上面的习题我会在下章给出答案，这也正是声明变量的规则和难点。
</code></pre>
<p>课程 十 写执行语句</p>
<p>本课重点：</p>
<p>1、了解PLSQL执行区间的重要性</p>
<p>2、写执行语句</p>
<p>3、描述嵌套块的规则</p>
<p>4、执行且测试PLSQL块</p>
<p>5、使用代码惯例</p>
<p>一、PLSQL 块的语法规则：</p>
<pre><code>1、语句可以跨跃几行。

2、词汇单元可以包括：分隔符、标识符、文字、和注释内容。

3、分隔符： +-*/=&lt;&gt;||....

4、标识符：

    最多30个字符，不能有保留字除非用双引号引起。

    字母开头，不与列同名。

5、文字串：如 V_ENAME:='FANCY';要用单引号括起来。

    数值型可以用简单记数和科学记数法。

6、注释内容：单行时用--    多行用/*   */

    与C很相似
</code></pre>
<p>二、SQL函数在PL/SQL的使用：</p>
<p>1、可用的：单行数值型、字符型和转换型，日期型。</p>
<p>2、不可用的：最大、最小、DECODE、分组函数。</p>
<p>实例：</p>
<pre><code>BEGIN

 SELECT TO_CHAR(HIREDATE,'MON,DD,YYYY') FROM EMP;

END;

V_comment:=user||':'||sysdate; -- 会编译出错

V_comment:=user||':'||to_char(sysdate); --正确
</code></pre>
<p>如果有可能，PLSQL都会进行数据一致性的转换，但ORACLE推荐你应该进行显示的转换，因为这样会提高性能。</p>
<p>三、嵌套块和变量作用区域</p>
<p>1、执行语句允许嵌套时嵌套。</p>
<p>2、嵌套块可以看作正常的语句块。</p>
<p>3、错误处理模块可以包括一个嵌套块</p>
<p>4、exponential指数 逻辑、算数、连接、小括号</p>
<p>5、看正面实例：</p>
<pre><code>declare

vjob varchar(9);

v_count number:=0;

vtotal date:=sysdate +7;

c_tax constant number(3,2):=8.25;

v_valid boolean not null:=true;

ttt vtotal%type;

begin

--select sysdate into vtotal from dual;--体会有无此句与结果的影响

dbms_output.put_line (vtotal);

end;

/
</code></pre>
<p>*注意：在执行块之前，要在SQL PLUS中执行：SET SERVEROUTPUT ON</p>
<p>三、以实例来说明函数的参数声明作用域</p>
<pre><code>declare

   v_weight number(3):=600;

v_message varchar2(255):='product10000';

begin

declare

   --sub-block

v_weight number(3):=1;

v_message varchar2(255):='pro300';

begin

v_weight:=v_weight +1;

end;

v_weight:=v_weight +1;

v_message:=v_message || 'my name';

end;

/
</code></pre>
<p>子块中的V_WEIGHT值为 2</p>
<p>我们可以在子块中加入：dbms_output.put_line('subblock value is '||v_weight);</p>
<p>在主体中加入：dbms_output.put_line('main value is '||v_weight);</p>
<p>我们发现MAINBLOCK中V_WEIGHT为 601</p>
<p>改动：</p>
<p>1、在主块的声明中加 v_date date default sysdate;</p>
<p>在子块中加入：dbms_output.put_line('subblock date value is '||v_date);</p>
<p>执行结果：subblock date value is 22-11月-01</p>
<p>*说明：主块中的变量，如果子块中没有同名变量声明，则继承主块中的声明和初始化值；</p>
<p>2、在子块中加入：v_sub char(9);</p>
<p>dbms_output.put_line('subblock char value is '||v_sub);</p>
<p>此时正常输出。</p>
<p>在主块中加入：dbms_output.put_line('main char value is '||v_sub);</p>
<p>输出：ORA-06550: 第 21 行, 第 45 列:</p>
<p>PLS-00201: 必须说明标识符 'V_SUB'</p>
<p>*说明：</p>
<p>子块中声明的变量主块中并不知晓，因此出错。了解了此实例，一切情况的变量的值的走向就都明了了。 </p>
<p>课程 十一 与ORACLE SERVER交互</p>
<p>本课重点：</p>
<p>1、在PLSQL中成功的写SELECT语句</p>
<p>2、动态声明PLSQL变量类型与SIZE</p>
<p>3、在PLSQL中写DML语句</p>
<p>4、在PLSQL中控制事务</p>
<p>5、确定DML操作的结果</p>
<p>一、PLSQL中的SQL语句：</p>
<pre><code>SELECT、DML、COMMIT、ROLLBACK、SAVEPOINT、CURSOR

特殊强调：PLSQL不支持DCL，不要问为什么。(DBMS_SQL package allows you to issue DDL and DCL statements.)
</code></pre>
<p>二、SELECT</p>
<pre><code>SELECT select_list INTO variable_name | record_name

FROM table WHERE condition;
</code></pre>
<p>例：</p>
<pre><code>SQL&gt; r

1 declare

2 v_deptno number(2);

3 v_loc varchar2(15);

4 begin

5     select deptno,loc

6       into v_deptno,v_loc

7      from dept

8      where dname='SALES';

9 DBMS_OUTPUT.PUT_LINE (V_deptno ||' and '||v_loc);

10* end;

30 and CHICAGO
</code></pre>
<p>选取字段与变量个数和类型要一致。声明的变量一定要在SIZE上大于返回的赋值，否则提示缓冲区溢出。</p>
<p>如果SELECT语句没有返回值：ORA-01403: 未找到数据</p>
<pre><code>                       ORA-06512: 在line 5
</code></pre>
<p>如果有多个值返回：ORA-01422: 实际返回的行数超出请求的行数</p>
<p>这些我们到了错误处理时会逐一讲解。</p>
<p>例：</p>
<p>上面的例子可以改为：</p>
<pre><code>declare

   v_deptno dept.deptno%type;

   v_loc dept.loc%type;

begin

     select deptno,loc

        into v_deptno,v_loc

        from dept

        where dname='SALES';

   DBMS_OUTPUT.PUT_LINE (V_deptno ||' and '||v_loc);

end;

/
</code></pre>
<p>这样，可以在未知其他字段大小和类型的时候定义变量，提高兼容性。</p>
<p>三、DML 操作：</p>
<p>1、实例：</p>
<pre><code>declare

    v_empno emp.empno%type;

begin

    select max(empno)

     into v_empno

     from emp;

    v_empno:=v_empno+1;

     insert into emp(empno,ename,job,deptno)

       values(v_empno,'asdfasdf','ddddd',10);

end;

/
</code></pre>
<p>这样也可以实现如SEQUENCE一样的编号唯一递增。</p>
<p>2、更新和删除：</p>
<p>这个较为简单：</p>
<pre><code>DECLARE

    V_DEPTNO EMP.DEPtno%type :=10;

begin

    delete from emp where deptno=v_deptno;

end;

/
</code></pre>
<p>PLSQL首先检查一个标识符是否是一个数据库的列名，如果不是，再假定它是一个PLSQL的标识符。所以如果一个PLSQL的变量名为ID，列中也有个ID，如：</p>
<pre><code>SELECT date_ordered, date_shipped

INTO date_ordered, date_shipped

FROM s_ord

WHERE id = id;
</code></pre>
<p>就会返回TOO MANY ROWS，这是要尽量避免的。   </p>
<p>四、SQL CURSOR</p>
<p>游标是一个独立SQL工作区，有两种性质的游标：</p>
<p>隐式游标： 当PARSE 和EXECUTE 时使用隐式游标。</p>
<p>显式游标： 是由程序员显式声明的。</p>
<p>游标的属性：</p>
<pre><code>SQL%ROWCOUNT：一个整数值，最近SQL语句影响的行数。

SQL%FOUND    BOOLEAN属性，如果为TRUE，说明最近的SQL STATEMENT有返回值。

SQL%NOTFOUND 与SQL%FOUND相反

SQL%ISOPEN   在隐式游标中经常是FALSE，因为执行后立即自动关闭了。



SQL&gt; variable row_de number

SQL&gt; r

1 declare

2    v_deptno number:=10;

3 begin

4      delete from emp where

5       deptno=v_deptno;

6       :row_de:=sql%rowcount;

7* end;
</code></pre>
<p>PL/SQL 过程已成功完成。</p>
<pre><code>SQL&gt; print row_de --这是一个SQL PLUS变量

ROW_DE

----------

     4
</code></pre>
<p>这时其实并没有真正的删除，而是需要 COMMIT或ROLLBACK，来完成事务。   </p>
<p>课程 十二 编写控制结构语句</p>
<p>本课重点：</p>
<p>1、结构控制的的用途和类型</p>
<p>2、IF 结构</p>
<p>3、构造和标识不同的循环</p>
<p>4、使用逻辑表</p>
<p>5、控制流和嵌套</p>
<p>一、控制执行流</p>
<p>可以是分支和循环：IF THEN END IF</p>
<pre><code>IF condition THEN

    statements;

[ELSIF condition THEN

    statements;]

[ELSE

    statements;]

END IF;
</code></pre>
<p>例子：</p>
<pre><code>IF V_ENAME='OSBORNE' THEN

    V_MGR:=22;

END IF;
</code></pre>
<p>这里我们可以注意，PLSQL和C语言或JAVA在条件上的不同，=代表关系运算，而：=代表赋值。</p>
<p>看一个函数：</p>
<pre><code>create FUNCTION calc_val

(v_start IN NUMBER)

RETURN NUMBER

IS

BEGIN

IF v_start &gt; 100 THEN

RETURN (2 * v_start);

ELSIF v_start &gt;= 50 THEN

RETURN (.5 * v_start);

ELSE

RETURN (.1 * v_start);

END IF;

END calc_val;
</code></pre>
<p>现在，虽然我们尚未讲解CREATE 函数或过程，但可以看到IF 条件在其中的作用。</p>
<p>二、注意LOGIC TABLE中的逻辑对应关系</p>
<p>1、NOT、AND、OR</p>
<p>2、任何表达式中含有空值结果都为 NULL</p>
<p>3、连接字符串中含有空值会把NULL作为 EMPTY STRING</p>
<pre><code>declare

v_deptno dept.deptno%type;

v_loc dept.loc%type;

V_FLAG BOOLEAN ;

V_REC BOOLEAN :=FALSE; --此值改为TRUE、NULL、FALSE进行不同的比较

V_AVA BOOLEAN:=NULL;

begin

V_FLAG:=V_REC AND V_AVA;

IF V_FLAG=TRUE THEN

DBMS_OUTPUT.PUT_LINE ('TRUE');

ELSIF V_FLAG=FALSE THEN

DBMS_OUTPUT.PUT_LINE ('FALSE');

ELSE

DBMS_OUTPUT.PUT_LINE ('NULL');

END IF;

end;

/
</code></pre>
<p>值得注意的是：NULL AND FALSE ---&gt; FALSE ，这是在实践中总结出来的。</p>
<p>三、基本循环基础：</p>
<p>1、LOOP</p>
<pre><code>statement1;

statement2;

. . .

EXIT [WHEN condition];

END LOOP;

v_ord_id s_item.ord_id%TYPE := 101;

v_counter NUMBER (2) := 1;

BEGIN

. . .

LOOP

INSERT INTO s_item (ord_id, item_id)

VALUES (v_ord_id, v_counter);

v_counter := v_counter + 1;

EXIT WHEN v_counter &gt; 10;

END LOOP;
</code></pre>
<p>2、FOR循环：</p>
<pre><code>FOR index IN [REVERSE] lower_bound..upper_bound LOOP

statement1;

statement2;

. . .

END LOOP;
</code></pre>
<p>实例：</p>
<pre><code>DECLARE

V_LOWER NUMBER:=1;

V_UPPER NUMBER:=23;

BEGIN

DBMS_OUTPUT.PUT_LINE('');

FOR I IN V_LOWER..V_UPPER LOOP

DBMS_OUTPUT.PUT_LINE(I);

END LOOP;

END;

/
</code></pre>
<p>3、WHILE 循环：</p>
<pre><code>WHILE condition LOOP

statement1;

statement2;

. . .

END LOOP;
</code></pre>
<p>4、循环是可以多层嵌套的。可以用&lt;<LABEL>&gt;做循环的标签。</p>
<pre><code>...

BEGIN

&lt;&lt;Outer–loop&gt;&gt;LOOP

v_counter :=v_counter+1;

EXIT WHEN v_counter&gt;10;

&lt;&lt;Inner–loop&gt;&gt;LOOP

...

EXIT Outer_loop WHEN total_done = ’YES’;

–– Leave both loops

EXIT WHEN inner_done = ’YES’;

–– Leave inner loop only

...

END LOOP Inner_Loop;

...

END LOOP Outer_loop;

END;
</code></pre>
<p>总结：本章内容较为繁杂，虽然不是很难，而且多数与其他高级语言有某种共性，但大家要多多练习，用实践来检验对某些含糊的猜测。</p>
<p>课程十三 使用组合数据类型* 游标操纵数据</p>
<p>本课重点：</p>
<p>1、创建用户自定义的PLSQL记录</p>
<p>2、利用%ROWTYPE属性来创建记录</p>
<p>3、创建PLSQL表</p>
<p>4、描述记录、表、记录的表之间的区别</p>
<p>一、合成数据类型</p>
<p>1、类型分为PLSQL记录和PLSQL表</p>
<p>2、包含内部组件</p>
<p>3、可重用</p>
<p>二、PLSQL记录</p>
<p>与3GL中的记录结构相似，与数据库表是两回事</p>
<p>是一个方便的途径FETCH一些行FROM一个表来进行相关处理。</p>
<p>标准语法格式我们暂不介绍，因为每本书上均有。</p>
<p>看例子：</p>
<pre><code>declare

vjob varchar(9);

v_count number:=0;

vtotal date:=sysdate +7;

c_tax constant number(3,2):=8.25;

v_valid boolean not null:=true;

ttt vtotal%type;

type emp_record_type is record

(empno number not null:=100,

ename emp.ename%type,

job　emp.job%type);

emp_record emp_record_type;

begin

--select sysdate into vtotal from dual;--体会有无此句与结果的影响

dbms_output.put_line (vtotal);

end;

/
</code></pre>
<p>主要看TYPE RECORD出现的位置。每一个例子都是可以成功执行的。</p>
<p>我们也可以利用原有的表结构：</p>
<p>DECLARE</p>
<p>EMP_RECORD EMP%ROWTYPE；</p>
<p>游标操纵数据</p>
<p>PLSQL游标提供了一种从数据库提取多行数据，然后对每行数据进行单独处理的方法。</p>
<p>一、两种游标：</p>
<p>显式游标</p>
<p>隐式游标</p>
<p>二、显式游标：操纵步骤如下：声明游标、打开游标、从游标中取回数据、关闭游标</p>
<p>三、声明游标：</p>
<p>DECLARE CURSOR_NAME</p>
<p>IS</p>
<p>SELECT STATMENT</p>
<p>能够控制游标的，唯一参数是INIT.ORA中的OPEN_CURSORS，我原来以为是客户端最多可以打开多少个游标，但有</p>
<p>本书上讲这是用于管理游标的内存的数量。</p>
<p>DECLARE</p>
<p>CURSOR C_NAME</p>
<p>IS</p>
<p>SELECT ENAME FROM EMP</p>
<p>WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT</p>
<p>WHERE CITY_ID=‘BJ’)</p>
<p>--- 说明游标可以用子查询</p>
<p>四、打开游标</p>
<p>OPEN CURSOR_NAME；</p>
<p>这时游标将它的指针指向活动集的开始，指针指向第一条记录的前面是因为它还没有执行FETCH命令。如果试图打开一个已经打开的游标，将出错：</p>
<p>ORA-06511：PL/SQL：CURSOR ALREADY OPEN</p>
<p>我们可以这样：</p>
<p>IF NOT C_NAME%ISOPEN</p>
<p>THEN</p>
<p>OPEN C_NAME；</p>
<p>END IF；</p>
<p>五、从游标中取回数据</p>
<p>FETCH CURSOR_NAME INTO RECOR-LIST；</p>
<p>关闭游标：CLOSE CURSOR_NAME</p>
<p>六、实例：</p>
<p>DECLARE</p>
<p>myname varchar2(22);</p>
<p>CURSOR C_NAME</p>
<p>IS</p>
<p>SELECT ENAME FROM EMP;</p>
<p>begin</p>
<p>IF NOT C_NAME%ISOPEN</p>
<p>THEN</p>
<p>OPEN C_NAME;</p>
<p>end if;</p>
<p>LOOP</p>
<p>FETCH c_name into myname;</p>
<p>dbms_output.put_line (myname);</p>
<p>exit when c_name%notfound;</p>
<p>end loop;</p>
<p>close c_name;</p>
<p>end;</p>
<p>/--我们将对以上程序进行变形，形成复杂的光标利用。</p>
<p>DECLARE</p>
<p>myname varchar2(22);</p>
<p>thisdeptno scott.emp.deptno%type;</p>
<p>CURSOR C_NAME</p>
<p>IS</p>
<p>SELECT ENAME,deptno FROM EMP order by deptno desc;</p>
<p>begin</p>
<p>IF NOT C_NAME%ISOPEN</p>
<p>THEN</p>
<p>OPEN C_NAME;</p>
<p>end if;</p>
<p>LOOP</p>
<p>FETCH c_name into myname,thisdeptno;</p>
<p>dbms_output.put_line (myname||','||thisdeptno || ',' || to_char(c_name%rowcount));</p>
<p>exit when c_name%notfound;</p>
<p>end loop;</p>
<p>dbms_output.put_line ('the Total record is fetched is ' || to_char(c_name%rowcount));</p>
<p>close c_name;</p>
<p>end;</p>
<p>/</p>
<p>我们增加变量，进行用了排序，使用了光标属性，大家看结果发生的变化，想想为什么。</p>
<p>实例精华!!!：</p>
<pre><code>DECLARE
</code></pre>
<p>myname varchar2(22);</p>
<p>ii number;</p>
<p>thisdeptno scott.emp.deptno%type;</p>
<p>CURSOR C_NAME</p>
<p>IS</p>
<p>SELECT * FROM EMP order by deptno desc;</p>
<p>emp_record c_name%rowtype;</p>
<p>begin</p>
<p>ii:=1;</p>
<p>for emp_record in c_name loop</p>
<p>dbms_output.put_line(ii);</p>
<p>ii:=ii+1;</p>
<p>end loop;</p>
<p>end;</p>
<p>/</p>
<p>--这里使用了游标FOR循环，在FOR循环的开始，进行、和END LOOP，分别隐式进行了游标的打开、FETCH和CLOSE。</p>
<p>我们甚至可以不声明游标：FOR emp_record in (SELECT * FROM DEPT) loop</p>
<p>这种技术被称为显式游标的自动化。</p>
<p>在上面，我们可以将一个表的所有字段输出,如我们将PUT_LINE的II改为emp_record.ename，就可以输出一个字段内容。</p>
<p>这种方式非常简单而且效率较高。</p>
<hr />
<p>为了测试光标属性的重要性，我们做一个以下的过程：</p>
<p>create or replace PROCEDURE change_salary</p>
<p>(v_emp_id IN NUMBER, -- formal parameters</p>
<p>v_new_salary IN NUMBER)</p>
<p>IS</p>
<p>BEGIN -- begin PL/SQL block</p>
<p>UPDATE emp</p>
<p>SET sal = v_new_salary</p>
<p>WHERE empno = v_emp_id;</p>
<p>COMMIT;</p>
<p>END change_salary;</p>
<p>/</p>
<p>这样，我们在匿名块中，</p>
<p>UPDATE DEPT</p>
<p>SET DNAME='MY DEPT' WHERE ....;</p>
<p>IF SQL%FOUND THEN</p>
<p>COMMIT;</p>
<p>ELSE</p>
<p>change_salary(7369,9000);</p>
<p>END IF;</p>
<p>我们看到我们通过流程控制了不同的执行结果，对于过程，我们可以用以下几种方法调用：</p>
<p>在SQLPLUS中：</p>
<pre><code>CALL change_salary(7369,9000);
</code></pre>
<p>EXECUTE change_salary(7369,9000);</p>
<p>在一个块中，如：</p>
<p>begin</p>
<p>change_salary(7369,9000);</p>
<p>end;</p>
<p>/</p>
<p>最后一课 异常处理</p>
<p>本章重点：</p>
<pre><code>1、定义PLSQL异常

2、列举不同的异常处理方法

3、捕获非预期的错误

4、描述异常的影响

5、定制异常的返回信息
</code></pre>
<p>一、PLSQL异常处理</p>
<p>异常是由ORACLE错误或显式的抛出一个错误产生的。</p>
<p>如何处理：用一个处理程序来捕获它；将它传递给CALLING ENVIRONMENT</p>
<p>二、异常的类型：</p>
<p>1、ORACLE SERVER 预定义错误</p>
<p>2、非ORACLE SERVER 预定义错误，但也是ORACLE SERVER 的标准错误</p>
<p>3、用户自定义异常</p>
<p>三、捕捉异常的要点：</p>
<p>Place the WHEN OTHERS clause after all other exception handling clauses.</p>
<p>You can have at most one WHEN OTHERS clause.</p>
<p>Begin exception-handling section of the block with the keyword EXCEPTION.</p>
<p>Define several exception handlers, each with their own set of actions, for the</p>
<p>block.</p>
<p>When an exception occurs, PL/SQL will process only one handler before leaving</p>
<p>the block.</p>
<p>EXCEPTION</p>
<p>WHEN exception1 [OR exception2 . . .] THEN</p>
<p>statement1;</p>
<p>四、常用错误：</p>
<p>NO_DATA_FOUND ORA-01403</p>
<p>TOO_MANY_ROWS ORA-01422</p>
<p>INVALID_CURSOR ORA-01001</p>
<p>ZERO_DIVIDE ORA-01476</p>
<p>DUP_VAL_ON_INDEX ORA-00001</p>
<p>五、实例</p>
<p>PROCEDURE elim_inventory</p>
<pre><code>　　(v_product_id IN s_product.id%TYPE) IS

v_id s_product.id%TYPE;
</code></pre>
<p>BEGIN</p>
<pre><code>　　SELECT id INTO v_id FROM s_product WHERE id = v_product_id;

　　DELETE FROM s_inventory

　　WHERE product_id = v_product_id;

　　COMMIT;

　　EXCEPTION

　　WHEN NO_DATA_FOUND THEN

　　ROLLBACK;

　　TEXT_IO.PUT_LINE(TO_CHAR(v_product_id)||’ is invalid.’);

　　WHEN TOO_MANY_ROWS THEN

　　ROLLBACK;

　　TEXT_IO.PUT_LINE(’Data corruption in S_PRODUCT.’);

　　WHEN OTHERS THEN

　　ROLLBACK;

　　TEXT_IO.PUT_LINE(’Other error occurred.’);
</code></pre>
<p>END elim_inventory;</p>
<p>在SCOTT环境中使用要稍加改动</p>
<p>六、使用non-predefined Oracle7 Server error</p>
<p>DECLARE</p>
<p>E_PRO　 EXCEPTION;</p>
<p>PRAGMA EXCEPTION_INIT(E_PRO,ERROR_NUMBER);</p>
<p>BEGIN</p>
<p>......</p>
<p>EXCEPTION</p>
<p>WHEN E_PRO THEN</p>
<p>DBMS_OUTPUT.PUT_LINE('ASDLKFJKASDJFASJDFLKASDF');</p>
<p>......</p>
<p>END;</p>
<p>七、用户自定义</p>
<p>exception EXCEPTION;</p>
<p>RAISE exception;　　EXCEPTION</p>
<p>WHEN E_PRO THEN</p>
<p>DBMS_OUTPUT.PUT_LINE('ASDLKFJKASDJFASJDFLKASDF');</p>
<p>......</p>
<p>END;</p>
<p>这里，只有用户自定义异常是要显式声明的，其他两个不用。在SUN OS5.8中，进行SVRMGRL&gt; OERR ORA 01840　可返回信息或查错误代码：</p>
<p>HTTP://TECHNET.ORACLE.COM/DOC/SERVER.815/A67785/E1500.HTM</p>
<p>说回来，以下两个函数：</p>
<p>SQLCODE ----Returns the numeric value for the error code. You can assign it to a NUMBER variable.</p>
<p>SQLERRM ----Returns character data containing the message associated with the error number.</p>
<p>一般这样，</p>
<p>EXCEPTION</p>
<p>... WHEN OTHERS THEN</p>
<p>ROLLBACK;</p>
<p>v_error_code:=SQLCODE;</p>
<p>V_ERROR_MESSAGE:=SQLERRM;</p>
<p>INSERT INTO ........</p>
<p>END;</p>
<p>八、调用外围环境</p>
<p>SQLPLUS</p>
<p>PROCEDURE BUILDER</p>
<p>DEVELOPER 2000</p>
<p>OTHER .........</p>
<p>---- 也就是把ERROR NUMBER和MESSAGE输出到SCREEN。</p>
<p>九、使用RAISE_APPLICATION_ERROR</p>
<p>EXCEPTION</p>
<p>WHEN NO_DATA_FOUND THEN</p>
<p>RAISE_APPLICATION_ERROR(-20201,'NO MATCH RECORD YOU WANNA');</p>
<pre><code>END;
</code></pre>
<p>当然，RAISE_APPLICATION_ERROR也是可以放在EXECUTE区的</p>
<pre><code>IF...THEN

    RAISE_APPLICATION_ERROR();

END IF;
</code></pre>