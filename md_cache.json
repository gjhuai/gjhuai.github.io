{"architecture/02-分布式事务.md": "springcloud微服务微服务架构的分布式事务解决方案www.roncoo.com/article/detail/124243分布式事务的典型处理方式:2PC、TCC、异步确保和最大努力型kaimingwan.com/post/fenbushi/fenbushishiwudedianxingchulifangshi2pctccyibuquebaohezuidanulixingACIDzh.wikipedia.org/wiki/ACIDAtomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。即，事务不可分割、不可约简。Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Readuncommitted）、提交读（readcommitted）、可重复读（repeatableread）和串行化（Serializable）。Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。RDBMS事务隔离级别并发问题几个场景脏读：一个事务读取了另一个事务操作但未提交的数据。比如A、B两个事务，都操作同一张表，A刚刚对数据进行了操作（插入、修改等）但还没有提交，这时B读取到了A刚刚操作的数据，因为A有可能回滚，所以这部分数据有可能只是临时的、无效的，即脏数据。不可重复读：一个事务中的多个相同的查询返回了不同数据。比如A、B两个事务，A中先后有两次查询相同数据的操作，第一次查询完之后，B对相关数据进行了修改，造成A事务第二次查询出的数据与第一次不一致。幻读：事务并发执行时，其中一个事务对另一个事务中操作的结果集的影响。比如A、B两个事务，事务A操作表中符合条件的若干行。事务B插入符合A操作条件的数据行，然后再提交。后来发现事务A并没有如愿对“所有”符合条件的数据行做了修改。四个事务隔离级别Readuncommitted读未提交：如果设置了该隔离级别，则当前事务可以读取到其他事务已经修改但还没有提交的数据。这种隔离级别是最低的，会导致上面所说的脏读Readcommitted读已提交：如果设置了该隔离级别，当前事务只可以读取到其他事务已经提交后的数据，这种隔离级别可以防止脏读，但是会导致不可重复读和幻读。这种隔离级别最效率较高，并且不可重复读和幻读在一般情况下是可以接受的，所以这种隔离级别最为常用。Repeatableread可重复读：如果设置了该隔离级别，可以保证当前事务中多次读取特定记录的结果相同。可以防止脏读、不可重复读，但是会导致幻读。Serializable串行化：如果设置了该隔离级别，所有的事务会放在一个队列中执行，当前事务开启后，其他事务将不能执行，即同一个时间点只能有一个事务操作数据库对象。这种隔离级别对于保证数据完整性的能力是最高的，但因为同一时刻只允许一个事务操作数据库，所以大大降低了系统的并发能力。CAP定理一致性（Consistency）（等同于所有节点访问同一份最新的数据副本）可用性（Availability）（每次请求都能获取到非错的响应――但是不保证获取的数据为最新数据）分区容错性（Partitiontolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择3。）根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项4。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。BASE理论（在微服务下的事务管理必然要遵循新的法则）BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性，应用应该可以采用合适的方式达到最终一致性。BASE是指基本可用（BasicallyAvailable）、软状态（SoftState）、最终一致性（EventualConsistency）。基本可用：指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。软状态：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。最终一致性：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。参考：对比5种分布式事务方案，还是宠幸了阿里的Seata（原理+实战）mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247497767&idx=3&sn=727bff63c4598e93f6f6e4a67e780e37&chksm=fbb171d9ccc6f8cff428ec385babf069fc4d3bce9a5258446cd0e1763d4e80f886c1ea14fbec&&xtrack=1&scene=90&subscene=93&sessionid=1606710118&clicktime=1606710436&enterid=1606710436rd分布式事务，这一篇就够了xiaomiinfo.github.io/2020/01/02/distributedtransaction/分布式事务的典型处理方式：2PC、TCC、异步确保和最大努力型kaimingwan.com/post/fenbushi/fenbushishiwudedianxingchulifangshi2pctccyibuquebaohezuidanulixing分布式事务有哪5中方案常见的比如基于XA协议的2PC、3PC，基于业务层的TCC，还有应用消息队列+消息表实现的最终一致性方案，还有今天要说的Seata中间件开发中幂等性是极为重要的。简单来说，对于同一个系统，在同样条件下，一次请求和重复多次请求对资源的影响是一致的，就称该操作为幂等的。2PCXA协议中分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、MYSQL这些数据库都实现了XA接口，而事务管理器则作为一个全局的调度者。优点：严格保障事务ACID特性；想使用本地事务一样透明；对业务侵92很小。缺点：强一致性的同步阻塞协议，锁定全部资源。3PC是2PC的一种改进版本。CanCommit、PreCommit、DoCommit三个阶段。在第一阶段，只是询问所有参与者是否可可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。2PC中只有协调者有超时机制，3PC在协调者和参与者中都引入了超时机制，协调者出现故障后，参与者就不会一直阻塞。多了一次网络通信，性能上反而变得更差TCCTCC为在业务层编写代码实现的两阶段提交。TCC分别指Try、Confirm、Cancel，一个业务操作要对应的写这三个方法。以下单扣库存为例，Try阶段去占库存，Confirm阶段则实际扣库存，如果库存扣减失败Cancel阶段进行回滚，释放库存。TCC不存在资源阻塞的问题，因为每个方法都直接进行事务的提交，一旦出现异常通过则Cancel来进行回滚补偿，这也就是常说的补偿性事务。TCC对业务的侵入性很强。消息事务（最终一致性）消息事务其实就是基于消息中间件的两阶段提交，将本地事务和发消息放在同一个事务里，保证本地操作和发送消息同时成功。!消息事务（最终一致性）_v_images/20210625094850448_27262.pngSeataSeata也是从两段提交演变而来的一种分布式事务解决方案，提供了AT、TCC、SAGA和XA等事务模式，这里重点介绍AT模式。几种角色TransactionCoordinatorTC:全局事务协调者，用来协调全局事务和各个分支事务（不同服务）的状态，驱动全局事务和各个分支事务的回滚或提交。TransactionManager64:事务管理者，业务层中用来开启/提交/回滚一个整体事务（在调用服务的方法中用注解开启事务）。ResourceManagerRM:资源管理者，一般指业务数据库代表了一个分支事务（BranchTransaction），管理分支事务与TC进行协调注册分支事务并且汇报分支事务的状态，驱动分支事务的提交或回滚。!Seata角色_v_images/20210625094929103_13071.pngSeata实现分布式事务，设计了一个关键角色UNDO_LOG（回滚日志记录表），我们在每个应用分布式事务的业务库中创建这张表，这个表的核心作用就是，将业务数据在更新前后的数据镜像组织成回滚日志，备份在UNDO_LOG表中，以便业务异常能随时回滚。Seata执行的两个阶段第一个阶段：本地事务提交，业务数据的更新和前面生成的UNDOLOG数据一并提交，并将本地事务提交的结果上报给全局事务协调者TC。第二阶段：根据各分支的决议做提交或回滚。Seata实践file.conf文件用于配置持久化事务日志的模式，目前提供file、db、redis三种方式。registry.conf文件设置注册中心和配置中心：目前注册中心支持nacos、eureka、redis、zk、consul、etcd3、sofa七种。SeataClient注册服务：新建三个服务orderserver（下单服务）、storageserver（扣减库存服务）、accountserver（账户金额服务），分别服务注册到注册中心。用@GlobalTransactional注解开启一个全局事务即可。", "architecture/09 秦仓面试总结.md": "主要技术问题jvm参数配置hashmap实现原理线程池缺点rpc框架实现原理微服务内存回收数据库隔离级别kafka的原理我的思考这份工作虽然薪水比我现在高很多，但是我不准备跳。原因有：这次面试的确没有准备，不是最佳状态，需要搞清楚上面的技术问题，就这样状态都能达到40w，提升自己才有更好结果。这次是一个试水，看看自己离互联网公司的架构大拿有多少差距，以后没隔一段时间要去互联网公司面试，称称自己。**架构能做到50岁吗？以后怎样转管理？是否还有人要我这种技术人员，后路在何方？**（必须在3年内达到架构顶点，再看看接下来的路怎么走）最近也有一些创业机会，我这边也想尝试一下，即使不成功，也要从现在开始准备创业需要的技术。我的目标我3年内的目标有以下几个：**技术加深，关注高薪职位**。3年内达到架构大牛的级别（站在高处看看43岁以后的路怎么走）**积累部件，关注创业机会**。准备创业需要的技术、行业知识、人脉学习财务、理财知识，以后即便不做软件也要能财务自由", "architecture/25 移动网关设计.md": "Featureapp登录认证（可以供手机app或桌面程序登录使用）基于URL的权限校验控制（授权有平台的portal完成）服务转发（将dubbo服务转换为httpjson服务）待完成的功能服务反向路由，网关要负责将外部请求反向路由到内部具体的微服务，这样虽然企业内部是复杂的分布式微服务结构，但是外部系统从网关上看到的就像是一个统一的完整服务，网关屏蔽了后台服务的复杂性，同时也屏蔽了后台服务的升级和变化。安全认证和防爬虫，所有外部请求必须经过网关，网关可以集中对访问进行安全控制，比如用户认证和授权，同时还可以分析访问模式实现防爬虫功能，网关是连接企业内外系统的安全之门。限流和容错，在流量高峰期，网关可以限制流量，保护后台系统不被大流量冲垮，在内部系统出现故障时，网关可以集中做容错，保持外部良好的用户体验。监控，网关可以集中监控访问量，调用延迟，错误计数和访问模式，为后端的性能优化或者扩容提供数据支持。日志，网关可以收集所有的访问日志，进入后台系统做进一步分析。除以上基本能力外，网关还可以实现线上引流，线上压测，线上调试Surgicaldebugging，金丝雀测试CanaryTesting，数据中心双活ActiveActiveHA等高级功能。网关通常工作在7层，有一定的计算逻辑，一般以集群方式部署，前置LB进行负载均衡。开源的网关组件有Netflix的Zuul，特点是动态可热部署的过滤器filter机制，其它如HAproxy，Nginx等都可以扩展作为网关使用。设计原理请求认证过程!_v_images/20191129171128.pnglogin获取AccessKey和SecretKey。AccessKey是有一定的时效性，过期后需要重新登录获取。请求httpjson服务。所有的服务都需要进行header的签名校验。对应的程序调用过程如下：!_v_images/20191129171137.png签名算法签名算法的原理如下图所示，用户登录后，获取AccessKey和SecretKey（这两个key都有一定的时效性），客户端和服务端各自保存同一个SecretKey，SecretKey不在请求中传递的；stringToSign是有客户端生成的，并要传递到服务端，客户端和服务端用SecretKey和stringToSign生成签名Signature；客户端的Signature需要传递到服务端，服务端收到客户端的Signature后，和服务端自己生成的Signature进行比较，如果相等则认为是合法请求，否则不合法；这个签名Signature每次请求是不一样的。!_v_images/20191129171202.png移动网关中除了login之外，所有请求服务端API接口的请求均使用此签名算法进行校验。!_v_images/20191129171207.png算法如上图所示，对于客户端来说，AccessKey和SecretKey是用户登录后获得到的；HttpMethod、ContentType、requestURI是HTTP的请求属性，可以统一设置；ContentMD5是用户请求内容的MD5后的字符串，date是当前时间的长整形值（毫秒）。权限校验控制权限校验是采用基于URL的校验，即将用户可访问的URL放入用户权限缓存中，用户发出每次请求时，校验用户是否具有该URL的访问权限，如果有权限，则http的返回码是200，否则返回码为401。服务转发系统所使用的所有服务接口是以dubbo服务的形式发布，移动网关将dubbo服务转换为httpjson的API，网关只是做一个请求的转发，并将结果返回给客户端app。代码如下：```javaStringinterfaceName=getPara\"interface\";StringmethodName=getPara\"method\";StringparaValues=getParaValues\"params\";log.debug\"AccessAPI:{}{}\",interfaceName,methodName;Class<?>clazz=null;try{clazz=Class.forNameinterfaceName;}catchClassNotFoundExceptione{thrownewIllegalArgumentException\"Couldnotfindinterface\"+interfaceName+\"\";}DubboReferenceFactory.initPropertyHolder.get\"dubbo.register.center\",\"APIGATEWAY\";Objectobj=DubboReferenceFactory.createReferenceclazz,\"dubbo\";Objectresult=ReflectionUtil.invokeMethodByNameobj,methodName,paraValues;ifresult!=null{renderJsonresult;}```客户端调用```javaURLurl=newURLbaseUrl+\"admin\";HttpPostmethod=newHttpPosturl.toURI;StringcontentType=\"application/json;charset=utf8\";Stringentity=\"ladygaga\";Headerheaders=buildHeaderApiKey.ADMIN2,method,contentType,entity;method.setHeadersheaders;method.setEntitynewStringEntityentity,ContentType.createcontentType;HttpResponseexecute=client.executemethod;StatusLinestatusLine=execute.getStatusLine;```完整的调用过程参见测试用例HmacTest", "architecture/OAuth2认证.md": "参考：帮你深入理解OAuth2.0协议blog.csdn.net/seccloud/article/details/8192707OAuth2集成――《跟我学Shiro》jinnianshilongnian.iteye.com/blog/2038646一、OAuth基础介绍目前实现开放授权的方法分为两种：一种是使用OAuth协议1；另一种是使用IAM服务2。OAuth协议主要适用于针对个人用户对资源的开放授权，比如Google的用户Alice。OAuth的特点是“现场授权”或“在线授权”：客户端主要通过浏览器去访问资源，授权时需要认证Alice的资源所有者身份，并且需要Alice现场审批。OAuth一般在SNS服务中广泛使用，如微博。IAM服务则不同，它的特点是“预先授权”或“离线授权”：客户端主要通过RESTAPI方式去访问资源，资源所有者可以预先知道第三方应用所需要的资源请求，一次授权之后，很少会变更。IAM服务一般在云计算服务中使用，如AWS服务、阿里云计算服务。OAuth角色**资源拥有者（resourceowner）**：能授权访问受保护资源的一个实体，可以是一个人，那我们称之为最终用户；如新浪微博用户zhangsan；**资源服务器（resourceserver）**：存储受保护资源，客户端通过accesstoken请求资源，资源服务器响应受保护资源给客户端；存储着用户zhangsan的微博等信息。**授权服务器（authorizationserver）**：成功验证资源拥有者并获取授权之后，授权服务器颁发授权令牌（AccessToken）给客户端。**客户端（client）**：如新浪微博客户端weico、微格等第三方应用，也可以是它自己的官方应用；其本身不存储资源，而是资源拥有者授权通过后，使用它的授权（授权令牌）访问受保护资源，然后客户端把相应的数据展示出来/提交到服务器。“客户端”术语不代表任何特定实现（如应用运行在一台服务器、桌面、手机或其他设备）。OAuth协议流程!_v_images/20191129175350.png1.客户端从资源拥有者那请求授权。授权请求可以直接发给资源拥有者，或间接的通过授权服务器这种中介，后者更可取。2.客户端收到一个授权许可，代表资源服务器提供的授权。3.客户端使用它自己的私有证书及授权许可到授权服务器验证。4.如果验证成功，则下发一个访问令牌。5.客户端使用访问令牌向资源服务器请求受保护资源。6.资源服务器会验证访问令牌的有效性，如果成功则下发受保护资源。授权类型授权码AuthorizationCodeGrant、最核心、最难理解、也是最广泛使用的一种授权类型隐式授权ImplicitGrant、RO凭证授权ResourceOwnerPasswordCredentialsGrant、Client凭证授权ClientCredentialsGrant。二、SessionAuthenticationvsTokenAuthentication参考：SessionAuthenticationvsTokenAuthenticationsecurity.stackexchange.com/questions/81756/sessionauthenticationvstokenauthenticationControltheSessionwithSpringSecuritywww.baeldung.com/springsecuritysession1.In**SessionbasedAuthentication**theServerdoesalltheheavyliftingserverside.Broadlyspeakingaclientauthenticateswithitscredentialsandreceivesasession_idwhichcanbestoredinacookieandattachesthistoeverysubsequentoutgoingrequest.Sothiscouldbeconsidereda\"token\"asitistheequivalentofasetofcredentials.Thereishowevernothingfancyaboutthissession_idString.Itisjustanidentifierandtheserverdoeseverythingelse.Itisstateful.Itassociatestheidentifierwithauseraccounte.g.inmemoryorinadatabase.Itcanrestrictorlimitthissessiontocertainoperationsoracertaintimeperiodandcaninvalidateitiftherearesecurityconcernandmoreimportantlyitcandoandchangeallofthisonthefly.Furthermoreitcanlogtheuserseverymoveonthewebsites.Possibledisadvantagesarebadscaleabilityespeciallyovermorethanoneserverfarmandextensivememoryusage.2.In**TokenbasedAuthentication**nosessionispersistedserversidestateless.Theinitialstepsarethesame.CredentialsareexchangedagainstatokenwhichisthenattachedtoeverysubsequentrequestItcanalsobestoredinacookie.Howeverforthepurposeofdecreasingmemoryusage,easyscaleabilityandtotalflexibilitytokenscanbeexchangedwithanotherclientastringwithallthenecessaryinformationisissuedthetokenwhichischeckedaftereachrequestmadebytheclienttotheserver.Thereareanumberofwaystouse/createtokens:ausingahashmechanisme.g.HMACSHA1>token=user_id|expiry_date|HMACuser_id|expiry_date,kidandexpiry_idaresentinplaintextwiththeresultinghashattachedkisonlyknowtotheserverbencryptingthetokensymmetricallye.g.withAES>token=AESuser_id|expiry_date,xxrepresentstheen/decryptionkeycencryptingitasymmetricallye.g.withRSA>token=RSAuser_id|expiry_date,privatekey**Productivesystems**areusuallymorecomplexthanthosetwoarchetypes.Amazonforexampleusesbothmechanismsonitswebsite.Alsohybridscanbeusedtoissuetokensasdescribedin2andalsoassociateausersessionwithitforusertrackingorpossiblerevocationandstillretaintheclientflexibilityofclassictokens.AlsoOAuth2.0usesshortlivedandspecificbearertokensandlongerlivedrefreshtokense.g.togetbearertokens.", "architecture/Sharding-JDBC.md": "TOC一、什么是ShardingJDBCShardingJDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。二、ShardingJDBC能做什么分库&分表读写分离分布式主键分布式事务三、适用项目框架ShardingJDBC适用于：任何基于Java的ORM框架，如：JPA,Hibernate,Mybatis,SpringJDBCTemplate或直接使用JDBC。基于任何第三方的数据库连接池，如：DBCP,C3P0,BoneCP,Druid,HikariCP等。支持任意实现JDBC规范的数据库，目前支持MySQL，Oracle，SQLServer和PostgreSQL。四、Maven依赖```XML<!shardingjdbc开始><dependency><groupId>io.shardingsphere</groupId><artifactId>shardingcore</artifactId><version>${sharding.version}</version></dependency><dependency><groupId>io.shardingsphere</groupId><artifactId>shardingjdbcspringnamespace</artifactId><version>${sharding.version}</version></dependency><!如果不配置分布式事务的话配置上边两个就够了><!分布式事务引用依赖><dependency><groupId>io.shardingsphere</groupId><artifactId>shardingtransaction2pcxa</artifactId><version>${sharding.version}</version></dependency><dependency><groupId>io.shardingsphere</groupId><artifactId>shardingtransactionspring</artifactId><version>${sharding.version}</version></dependency><!shardingjdbc结束><!AspectJAOP支持><dependency><groupId>org.aspectj</groupId><artifactId>aspectjweaver</artifactId><version>${aspectjweaver.version}</version></dependency>```五、读写分离5.1数据源配置先配置数据源也可以配置读写分离以下配置是ds0和ds1两个数据库的主和从一共四个数据源。parentDs是数据源公共的配置，抽出去以免写重复代码。```XML<!ds0的主><beanid=\"ds0_master\"class=\"com.alibaba.druid.pool.DruidDataSource\"destroymethod=\"close\"parent=\"parentDs\"><propertyname=\"driverClassName\"value=\"\"/><propertyname=\"url\"value=\"\"/></bean><!ds0的从><beanid=\"ds0_slave\"class=\"com.alibaba.druid.pool.DruidDataSource\"destroymethod=\"close\"parent=\"parentDs\"><propertyname=\"driverClassName\"value=\"\"/><propertyname=\"url\"value=\"${sharding.connection.url.0}\"/></bean><!ds1的主><beanid=\"ds1_master\"class=\"com.alibaba.druid.pool.DruidDataSource\"destroymethod=\"close\"parent=\"parentDs\"><propertyname=\"driverClassName\"value=\"\"/><propertyname=\"url\"value=\"${sharding.connection.url.1}\"/></bean><!ds1的从><beanid=\"ds1_slave\"class=\"com.alibaba.druid.pool.DruidDataSource\"destroymethod=\"close\"parent=\"parentDs\"><propertyname=\"driverClassName\"value=\"\"/><propertyname=\"url\"value=\"${sharding.connection.url.1}\"/></bean>```5.2读写分离配置只配置主从不配置分库分表的情况如下，如果要配置分库分表则不需要下面这个配置。masterdatasourcename是主数据源IDslavedatasourcenames是从数据源ID```XML<masterslave:datasourceid=\"masterSlaveDataSource\"masterdatasourcename=\"ds0_master,ds1_master\"slavedatasourcenames=\"ds0_slave,ds1_slave\"><masterslave:props><propkey=\"sql.show\">${sql_show}</prop><propkey=\"executor.size\">10</prop><propkey=\"foo\">bar</prop></masterslave:props></masterslave:datasource>```5.3读写分离和分库分表一起配置如果读写分离和分库分表一起使用的话把主从路由配置到shardingdatasource下就可以了。sharding:masterslaverule的id就是配置出来的逻辑的数据源的名称，如果多个从的话还可以通过配置strategyref来配置负载均衡。masterdatasource配置的是主库数据源ID。slavedatasource配置的是从库数据源ID，多个以逗号分开。```XML<!sharding数据源><sharding:datasourceid=\"shardingDataSource\"><!读写分离的话要把所有的主从数据源都写在这里><sharding:shardingruledatasourcenames=\"ds0_master,ds0_slave,ds1_master,ds1_slave\"><!读写分离的路由一主一从配置strategyref><sharding:masterslaverules><sharding:masterslaveruleid=\"ds0\"masterdatasourcename=\"ds0_master\"slavedatasourcenames=\"ds0_slave\"/><sharding:masterslaveruleid=\"ds1\"masterdatasourcename=\"ds1_master\"slavedatasourcenames=\"ds1_slave\"/></sharding:masterslaverules><!读写分离配置结束><sharding:tablerules><!―这里是分库分表路由的配置></sharding:tablerules><sharding:bindingtablerules><!―绑定表的配置></sharding:bindingtablerules></sharding:shardingrule><sharding:props><!显示SQL><propkey=\"sql.show\">true</prop></sharding:props></sharding:datasource>```六、数据分片6.1分片支持ShardingJDBC提供了5种分片策略。由于分片算法和业务实现紧密相关，因此ShardingJDBC并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。**StandardShardingStrategy**标准分片策略。提供对SQL语句中的=,IN和BETWEENAND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片；RangeShardingAlgorithm是可选的，用于处理BETWEENAND分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEENAND将按照全库路由处理。**ComplexShardingStrategy**复合分片策略。提供对SQL语句中的=,IN和BETWEENAND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此ShardingJDBC并未做过多的封装，而是直接将分片键值组合以及分片操作符交于算法接口，完全由应用开发者实现，提供最大的灵活度。**InlineShardingStrategy**Inline表达式分片策略。使用Groovy的Inline表达式，提供对SQL语句中的=和IN的分片操作支持。InlineShardingStrategy只支持单分片键，对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如:tuser${user_id%8}表示t_user表按照user_id按8取模分成8个表，表名称为t_user_0到t_user_7。**HintShardingStrategy**通过Hint而非SQL解析的方式分片的策略。**NoneShardingStrategy**不分片的策略。6.2分片配置标准分片配置```XML<!标准分片策略。><beanid=\"demoUserStandardStrategy\"class=\"shard.strategy.DemoUserStandardStrategy\"/><sharding:standardstrategyid=\"shardingDemoUserStandardStrategy\"precisealgorithmref=\"demoUserStandardStrategy\"shardingcolumn=\"id\"rangealgorithmref=\"\"/>```DemoUserStandardStrategy标准分片要实现PreciseShardingAlgorithm接口，doSharding的两个参数一个是所有数据源的cllection.另一个参数是执行SQL时传过来的分片的值。```JAVA/***根据ID取*标准分片策略*用于处理=和IN的分片*@authoryulonggao*@date2019/1/3114:35*/@Slf4jpublicclassDemoUserStandardStrategyimplementsPreciseShardingAlgorithm<Long>{@OverridepublicStringdoShardingCollection<String>collection,PreciseShardingValue<Long>preciseShardingValue{//这个里边有异常会被处理掉，然后导致拿不到分片。但出异常一般是业务代码写错了。//每条指定分片的操作都会调用此方法，如果是in条件查询的话每个值会调用一次此方法，如果是批量插入也是每一条都要调用一次进行分片log.info\"DemoUserStandardStrategy_preciseShardingValue={}\",preciseShardingValue;Longsuffix=preciseShardingValue.getValue%4;log.info\"suffix={}\",suffix;finalStringtargetDb=String.valueOfMath.abssuffix.intValue;StringshardingValue=collection.stream.filterp>p.endsWithtargetDb.findFirst.get;log.info\"preciseShardingValue={},shardingValue={}\",preciseShardingValue,shardingValue;returnshardingValue;}```强制分片```xml<!强制路由分片策略><beanid=\"demoUserHintStrategy\"class=\"shard.strategy.DemoUserHintStrategy\"/><!强制路由例子使用><sharding:hintstrategyid=\"shardingDemoUserHintStrategy\"algorithmref=\"demoUserHintStrategy\"/>```DemoUserHintStrategy的Java如下，强制分片要实现HintShardingAlgorithm接口。```JAVA/***DemoUserHint强制路由分片策略,其实可以共用，只是例子*@authoryulonggao*@date2019/1/3114:35*/@Slf4jpublicclassDemoUserHintStrategyimplementsHintShardingAlgorithm{@OverridepublicCollection<String>doShardingCollection<String>availableTargetNames,ShardingValueshardingValue{//availableTargetNames这个参数是所有的dataSource的集合，shardingValue是HintManager传过来的分片信息log.info\"DemoUserHintStrategy_availableTargetNames={}\",availableTargetNames;log.info\"DemoUserHintStrategy_shardingValue={}\",shardingValue;ListShardingValuelistShardingValue=ListShardingValueshardingValue;CollectionshardingValueList=listShardingValue.getValues;//因为调用的时候分片是直接传的DataSource的名称，所以直接返回就可以了，如果传其它值则要加业务逻辑进行分片筛选//返回结果只能是availableTargetNames里边所包含的returnshardingValueList;}}```生成分部式ID的配置，生成主键的类要实现KeyGenerator接口。```XML<!―主键生成><beanid=\"keyId\"class=\"shard.key.DefaultKeyGenerator\"/>```!ShardingJDBC配置_v_images/20200604065002540_18818.png七、分布式事务把下面这行代码配置在spring里，shardingTransaction.xml是jar包里边带的。文件的源码只有两行配置：```XML<beanid=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"><propertyname=\"dataSource\"ref=\"shardingDataSource\"></property></bean><tx:annotationdriventransactionmanager=\"transactionManager\"/><!事务支持><importresource=\"classpath:METAINF/shardingTransaction.xml\"/>```使用注解配置事务要同时使用ShardingTransactionType和Transactional两个注解。```JAVA/***注意：@ShardingTransactionType需要同Spring的@Transactional配套使用，事务才会生效。*@paramparam*@return*/@ShardingTransactionTypeTransactionType.XA@TransactionalrollbackFor=Exception.class@OverridepublicintaddParamDemoParamparam{log.info\"addParamparam={}\",param;returndemoParamDao.addParamparam;}```7.1支持程度完全支持非跨库事务，例如：仅分表或分库但是路由的结果在单库中。完全支持因逻辑异常导致的跨库事务。例如：同一事务中跨两个库更新，更新完毕后，抛出空指针，则两个库的内容都能回滚。支持数据库字段约束造成的回滚。八、其他问题关于orderby排序，如果排序的字段不在查询结果中，生成的SQL也会被带上，但结果不返回给你。不支持因网络、硬件异常导致的跨库事务。例如：同一事务中跨两个库更新，更新完毕后、未提交之前，第一个库死机，则只有第二个库数据提交。!_v_images/20200604065318535_1841.png九、参考文档shardingsphere.apache.org/document/current/cn/manual/shardingjdbc/usage/sharding/www.cnblogs.com/yixinjishu/p/10876071.html", "architecture/SSO与反向代理.md": "", "architecture/Web性能测试.md": "系统吞吐量（TPS）、用户并发量、性能测试概念和公式www.ha97.com/5095.html吞吐率、吞吐量、TPS、性能测试，纸上不谈兵一步一步构建高性能Web站点rubychina.org/topics/26221十个免费的Web压力测试工具coolshell.cn/articles/2589.html一个完整的压力测试需要关注三个方面：如何正确产生压力、如何定位瓶颈、如何预估系统的承载能力1首先说一下如何产生压力，产生压力的方法有很多，通常可以写脚本产生压力机器人对服务器进行发包和收包操作，也可以使用现有的工具像jmeter、LoadRunner这些），所以说产生压力其实并不难，难点在于产生的压力是不是真实地反映了实际用户的操作场景。举个例子来说，对游戏来说单纯的并发登陆场景在整个线上环境中的占比可能并不大新开服等特殊情况除外，相反“登陆开始战斗结束战斗”、不同用户执行不同动作这种“混合模式”占了更大的比重。所以如何从实际环境中提炼出具体的场景比重，并且把这种比重转化成实际压力是一个重要的关注点。2产生压力之后，通常我们可以拿到TPS、响应时延等性能数据，那么如何定位性能问题呢？TPS、响应时延只能告诉你服务器是否存在问题，但不能帮助你定位问题。这些表面背后是整个后台处理逻辑综合作用的结果，这时候可以先关注系统的CPU、内存、IO、网络，对比在tps、时延达到瓶颈时这些系统数据的情况，确定性能问题是系统哪一部分造成的，然后再回到代码的逻辑中逐个优化这些点。3当服务器的整体性能可以相对稳定下来，这时候就需要对自己服务器的承载能力有一个预估，通过产生真实压力、对比系统数据，大致可以对单套系统的处理能力有个真实的评价，然后结合业务规模配置服务器数量。可以看下腾讯wetest的这个压测工具wetest.qq.com/gaps/总结一下：通过产生真实压力来发现问题、结合系统性能来解决问题性能测试（PerformanceTest）、负载测试（LoadTest）和压力测试（StressTest）性能测试vs负载测试vs压力测试developer.51cto.com/art/201106/267717.htm1）性能测试性能测试主要评价系统或组件的性能是否和具体的性能需求一致，例如：对访问速度的性能需求或对内存使用情况的需求。特定性能测试的关注点在于组件或系统在规定的时间内和特定的条件下响应用户或系统输入的能力。不同的性能的度量方法取决于不同的被测对象。对于一个单独软件组件，其性能可以根据CPU主频来判定。而带客户端的系统，其性能则要根据系统处理特定用户请求的响应时间来判定。对于那些由多种组件（如客户端、服务器、数据库）构成的系统，则要进行各组件之间的性能测试。2）负载测试负载测试是一种通过增加负载来评估组件或系统的性能的测试方法。例如：通过增加并发用户数和（或）事务数量来测量组件或系统能够承受的负载。负载测试和性能测试的主要区别在于负载测试时，系统负载是逐渐增加的，而不是一步到位，负载测试需要观察系统在各种不同的负载情况下是否都能够正常工作。3）压力测试压力测试是评估系统处于或超过预期负载时系统的运行情况。压力测试的关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。在压力级别逐渐增加时，系统性能应该按照预期缓慢下降，但是不应该崩溃。压力测试还可以发现系统崩溃的临界点，从而发现系统中的薄弱环节。例如：系统最大支持的同时在线用户数是1000个，压力测试需要测试在1000个用户甚至2000个用户同时在线时系统的表现。虽然测试时负载已经超过了系统的设计能力，但是在这种情况下被测试系统也不应该发生崩溃。压力测试也可以针对系统资源进行测试，例如：在系统内存耗尽情况下，测试系统的运行情况，这种情况下被测试系统也不应该崩溃。", "architecture/WonderWare.md": "历史InTouch>收购SystemPlatform>在SP基础重新构建InTouch，提供丰富的HMI组成结构!_v_images/20191129170347.png!_v_images/20191129170411.pngMESMES制造执行系统manufacturingexecutionsystem，简称MES），包含**生产运营和资产管理**等，在WW中包括四个部分：生产管理Operations,设备绩效Performance,质量管理Quality,EnterpriseIntegration。**制造业信息化的三层模型**<divalign=\"center\">!_v_images/20191129170431.png</div>MES更多内容：MES互动百科www.baike.com/wiki/MES1.生产管理Operations生产流程2.设备绩效Performance设备使用率3.质量管理Quality生产事件自动触发：通过对设备的监控，根据监控的结果发起某一个生产流程SPC分析>报警样本计划4.批次管理Batch配方定义管理5.工作流Workflow事件触发工作流程SOP标准化工作流程整合不同的系统6.移动巡检作业IntelaTrac管理非智能设备现场作业与资产管理对接7.资产管理Avantis自动触发，维护工单8.历史数据库HistorianDB<divalign=\"center\">!_v_images/20191129170506.png</div>9.Data采集广泛的数据连接性设备的数据如何采集上来的？<divalign=\"center\">!_v_images/20191129170526.png</div>10.运营绩效分析Intelligence各种各样的数据集成开发环境11.EnterpriseIntegration预定义映射交换订单、物料、工艺集成ERP、MES支持多种Data交换格式**两化融合**：自动化+信息化InTouchHMI构建与WWSP之上。基于面向对象设计，所以设备都是对象，有对象定义，有对象实例。支持IDE来定义模板（定义对象），实例化对象（设备）。（替代方案：使用脚本？）**SituationalAwareness**：情景感知，扁平、简明、动画元素、高性能。WW新的HMI设计源于这本树《TheHighPerformanceHMIHandBook》的理念。!_v_images/20191129170551.png!_v_images/20191129170602.png!_v_images/20191129170611.png!_v_images/20191129170621.png!_v_images/20191129170627.png案例案例1：蓝鸟市政水业务介绍!_v_images/20191129170641.png组织架构!_v_images/20191129170651.png企业主要智能!_v_images/20191129170658.png系统框架!_v_images/20191129170705.png水务支持系统!_v_images/20191129170712.png案例2：能源管理系统解决方案What？它是什么？自动化+信息化动态监控+数字化管理!_v_images/20191129170721.pngGoal，系统目标!_v_images/20191129170727.pngHow，如何实现1）数据有效捕获2）建立能源管理规程3）PDCA持续改进方法论4）软硬件支持**PDCA方法论**!_v_images/20191129170741.png企业信息化架构!_v_images/20191129170749.png能源管理软件架构!_v_images/20191129170800.png影响能耗成本的因素!_v_images/20191129170806.png系统功能!_v_images/20191129170820.png", "architecture/XSS跨站漏洞.md": "What:XSS（crosssitescript）跨站脚本是由于web应用程序对用户的输入过滤不严而产生的。攻击者利用网站漏洞把恶意的脚本代码注入到网页中，当其他用户浏览这些网页时，就会执行其中的恶意代码，对受害用户可能采用cookie资料窃取，会话劫持，钓鱼欺骗等攻击手段。如：```js//使用xss弹出恶意警告框，代码为：<script>alert\"xss\"</script>//xss输入也可能是html代码段，如果使网页不停的刷新，代码为<metahttpequiv=\"refresh\"content=\"0;\">//嵌入其他网站链接的代码为：<iframesrc=http:/liuwx.cnwidth=0height=0></iframe>```XSS分类反射型XSS：非持久化，只执行一次。如：www.liuwx.cn/xss.php?id=<script>alert1</script>DOM型XSS：存储型XSS：脚本被上传到ServerHow:如何防范？常见的防xss代码：```$x=preg_replace“/script/”,””,$x;$x=preg_replace“/script/i”,””,$x;$x=preg_replace“/alert/i”,””,$x;$x=preg_replace“/script/i”,””,$x;```Java防止XSS使用Filter过滤转换浏览器提交的内容。可以使用Spring的工具类：HtmlUtils.htmlEscape，或者commonslang提供的StringEscapeUtils.escapeHtml。例如：```javapublicclassXSSFilterimplementsFilter{@OverridepublicvoidinitFilterConfigfilterConfigthrowsServletException{}@Overridepublicvoiddestroy{}@OverridepublicvoiddoFilterServletRequestrequest,ServletResponseresponse,FilterChainchainthrowsIOException,ServletException{chain.doFilternewXSSRequestWrapperHttpServletRequestrequest,response;}}publicclassXSSRequestWrapperextendsHttpServletRequestWrapper{publicXSSRequestWrapperHttpServletRequestservletRequest{superservletRequest;}@OverridepublicStringgetParameterValuesStringparameter{Stringvalues=super.getParameterValuesparameter;ifvalues==null{returnnull;}intcount=values.length;StringencodedValues=newStringcount;forinti=0;i<count;i++{encodedValuesi=stripXSSvaluesi;}returnencodedValues;}@OverridepublicStringgetParameterStringparameter{Stringvalue=super.getParameterparameter;returnstripXSSvalue;}@OverridepublicStringgetHeaderStringname{Stringvalue=super.getHeadername;returnstripXSSvalue;}privateStringstripXSSStringvalue{returnHtmlUtils.htmlEscapevalue;}}```参考XSS跨站漏洞详解zhuanlan.zhihu.com/p/26375200java防止XSS攻击的常用方法总结itindex.net/detail/55334javaxss%E6%94%BB%E5%87%BB", "architecture/《分布式Java应用：基础与实践》.md": "第一章：分布式Java应用网络通信协议TCP/IPUDP/IPMulticastIOBIO同步，阻塞NIO同步，事件驱动，非阻塞ReactorAIO异步，事件驱动Proactor同步与异步有何不同？reactor原理epoll与nionio的事件驱动原理aio与nio区别JAVA的aioproactor原理消息方式的系统间通信基于Java包TCP/IPBIO:Socket、ServerSocketNIO:SocketChannel、ServerSocketChannelUDP/IPBIO:DatagramSocket、DatagramPacketNIO:DatagramChannel、ByteBufferMulticastMulticastSocket、DatagramPackatSRM基于开源框架MinaNetty性能角度连接管理连接池连接复用短连接、长连接远程调用方式的系统间通信基于Java包RMIUnicastRemoteObjectLocateRegistryWebService基于开源框架SpringRMIApacheCXF性能反射序列化、反序列化第二章：大型分布式Java应用与SOA为什么需要SOA系统多元化系统拆分SOA是什么系统之间统一以Service的方式进行交互eBay的SOA平台服务多级调用带来的延时调试/跟踪困难更高的安全/检测的要求现有应用移植QoS的支持高可用和高度可伸缩多版本和依赖管理可实现SOA的方法SCA标准发布服务调用服务支持的通信以及交互方式SCA框架Tuscany发布服务调用服务支持的通信以及交互方式ESB发布服务调用服务支持的通信以及交互方式ESB框架Mule发布服务调用服务支持的通信以及交互方式第4章：分布式与JDK类库集合包ArrayList如何插入、删除？LinkedListVectorStackHashSetTreeSetHashMapTreeMap并发包ConcurrentHashMapCopyOnWriteArrayListCopyOnWriteArraySetArrayBlockingQueueAtomicIntegerThreadPoolExecutorExecutorsFutureTaskSemaphoreCountDownLatchCyclicBarrierReentrantLockReentrantReadWriteLock反序列化序列化反序列化", "architecture/《大型网站技术架构》读书笔记.md": "《大型网站技术架构》读书笔记：当我们架设一个系统的时候通常需要考虑到如何与其他系统交互，所以我们首先需要知道各种系统之间是如何交互的，使用何种技术实现。1.不同系统不同语言之间的交互现在我们常见的不同系统不同语言之间的交互使用WebService，Http请求。WebService，即“Web服务”，简写为WS。从字面上理解，它其实就是“基于Web的服务”。而服务却是双方的，有服务需求方，就有服务提供方。服务提供方对外发布服务，服务需求方调用服务提供方所发布的服务。如果说得再专业一点，WS其实就是建立在HTTP协议上实现异构系统通讯的工具。没错！WS说白了还是基于HTTP协议的，也就是说，数据是通过HTTP进行传输的。最早我们是用CXF开发SOAP服务实现WS，后面我们是用REST服务实现WS这个目前使用比较多，也最我用得最多的这一种。基于CXF也可以开发REST服务，不过我们一般直接使用springMVC或者其他MVC框架实现REST服务。但是在很多人的印象中Webservice的话一般指十来年前IBM主导的基于XML的各种交互技术，现在除了一些公司在用之外用得人也很少了。广义的话Webservice就是Web服务了，一切皆服务。2.不同系统相同语言之间的交互常见的不同系统相同语言之间的交互用RPC远程过程调用，或者RMI远程方法调用实现，不用对外部提供服务，当然上面说的也可以使用在相同语言之间的交互,只是我常用的是RPC。1.1大型网站软件系统的特点与传统企业应用系统相比，大型互联网应用系统有以下特点。高并发，大流量高可用海量数据用户分布广泛，网络情况复杂安全环境恶劣需求快速变更，发布频繁渐进式发展1.2大型网站架构演化发展历程大型网站的技术挑战主要来自于庞大的用户，高并发的访问和海量的数据，任何简单的业务一旦需要处理数以P计的数据和面对数以亿计的用户，问题就会变得很棘手。大型网站架构主要就是解决这类问题1.2.1初始阶段的网站架构!_v_images/20191121205813.png初始阶段的小型系统应用程序、数据库、文件等所有的资源都在一台服务器上通俗称为LAMP特征：应用程序、数据库、文件等所有的资源都在一台服务器上。描述：通常服务器操作系统使用linux，应用程序使用PHP开发，然后部署在Apache上，数据库使用Mysql，汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。1.2.2应用服务和数据服务分离!_v_images/20191121205833.png好景不长，发现随着系统访问量的再度增加，webserver机器的压力在高峰期会上升到比较高，这个时候开始考虑增加一台webserver特征：应用程序、数据库、文件分别部署在独立的资源上。描述：数据量增加，单台服务器性能及存储空间不足，需要将应用和数据分离，并发处理能力和数据存储空间得到了很大改善。1.2.3使用缓存改善网站性能!_v_images/20191121210027.png特征：数据库中访问较集中的一小部分数据存储在缓存服务器中，减少数据库的访问次数，降低数据库的访问压力。描述：系统访问特点遵循二八定律，即80%的业务访问集中在20%的数据上。缓存分为本地缓存和远程分布式缓存，本地缓存访问速度更快但缓存数据量有限，同时存在与应用程序争用内存的情况。1.2.4使用应用服务器集群改善网站的并发处理能力!_v_images/20191121210041.png在做完分库分表这些工作后，数据库上的压力已经降到比较低了，又开始过着每天看着访问量暴增的幸福生活了，突然有一天，发现系统的访问又开始有变慢的趋势了，这个时候首先查看数据库，压力一切正常，之后查看webserver，发现apache阻塞了很多的请求，而应用服务器对每个请求也是比较快的，看来是请求数太高导致需要排队等待，响应速度变慢特征：多台服务器通过负载均衡同时向外部提供服务，解决单台服务器处理能力和存储空间上限的问题。描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。1.2.5数据库读写分离!_v_images/20191121210054.png享受了一段时间的系统访问量高速增长的幸福后，发现系统又开始变慢了，这次又是什么状况呢，经过查找，发现数据库写入、更新的这些操作的部分数据库连接的资源竞争非常激烈，导致了系统变慢特征：多台服务器通过负载均衡同时向外部提供服务，解决单台服务器处理能力和存储空间上限的问题。描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，使得服务器的负载压力不在成为整个系统的瓶颈。1.2.6使用反向代理和CDN加速网站响应!_v_images/20191121210109.png特征：采用CDN和反向代理加快系统的访问速度。描述：为了应付复杂的网络环境和不同地区用户的访问，通过CDN和反向代理加快用户访问的速度，同时减轻后端服务器的负载压力。CDN与反向代理的基本原理都是缓存。1.2.7使用分布式文件系统和分布式数据库系统!_v_images/20191121210120.png随着系统的不断运行，数据量开始大幅度增长，这个时候发现分库后查询仍然会有些慢，于是按照分库的思想开始做分表的工作特征：数据库采用分布式数据库，文件系统采用分布式文件系统。描述：任何强大的单一服务器都满足不了大型系统持续增长的业务需求，数据库读写分离随着业务的发展最终也将无法满足需求，需要使用分布式数据库及分布式文件系统来支撑。分布式数据库是系统数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。1.2.8使用NoSQL和搜索引擎!_v_images/20191121210138.png特征：系统引入NoSQL数据库及搜索引擎。描述：随着业务越来越复杂，对数据存储和检索的需求也越来越复杂，系统需要采用一些非关系型数据库如NoSQL和分数据库查询技术如搜索引擎。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。1.2.9业务拆分!_v_images/20191121210149.png特征：系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。描述：为了应对日益复杂的业务场景，通常使用分而治之的手段将整个系统业务分成不同的产品线，应用之间通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的Web应用系统纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。1.2.10分布式服务!_v_images/20191121210202.png参考知识库大型网站架构知识库", "architecture/《构建高可用Linux服务器（第4版）》.md": "前言第1章　Linux服务器的性能调优11.1网站架构设计相关11.1.1评估网站性能涉及的专业名词术语11.1.2CDN业务的选项21.1.3IDC机房的选择31.2如何根据服务器应用来选购服务器41.3硬件对Linux性能的影响91.4CentOS6.8x86_64最小化安装后的优化111.4.1系统的基础优化111.4.2优化Linux下的内核TCP参数以提高系统性能191.4.3CentOS6.8x86_64系统最小化安装优化脚本211.4.4Linux下CPU使用率与机器负载的关系与区别231.5服务器调优实际案例251.6小结28第2章　Shell脚本在生产环境下的应用292.1Shell编程基础292.1.1Shell脚本基本元素302.1.2Shell基础正则表达式302.1.3Shell特殊字符322.1.4变量和运算符332.2Shell中控制流结构452.3Sed的基础用法及实用举例482.3.1Sed的基础语法格式482.3.2Sed的用法举例说明532.4awk的基础用法及实用举例562.5Shell基础正则表达式举例612.6Shell开发中应该掌握的系统知识点682.7生产环境下的Shell脚本742.7.1AmazonLinux系统简介742.7.2生产环境下的备份类脚本752.7.3生产环境下的监控类脚本782.7.4生产环境下的运维开发类脚本842.8小结88第3章　利用Vagrant搭建分布式环境893.1Vagrant简单介绍893.2Vagrant安装903.3使用Vagrant配置本地开发环境913.3.1Vagrant的具体安装步骤913.3.2Vagrant配置文件详解933.3.3Vagrant常用命令详解953.4使用Vagrant搭建分布式环境963.5小结99第4章　轻量级自动化运维工具介绍1004.1轻量级自动化运维工具pssh介绍1014.1.1pssh的安装1034.1.2pssh的使用1034.2轻量级自动化运维工具Fabric介绍1054.2.1Fabric的安装1054.2.2Fabric的命令行入口fab命令详细介绍1074.2.3Fabric的环境变量设置1084.2.4Fabric的核心API1094.2.5Fabric的执行逻辑1124.2.6如何利用进程池大小来限制Fabric并发进程数1144.3Fabric在工作中应用实例1144.3.1开发环境中Fabric应用实例1154.3.2工作场景中常见的Fabric应用实例1164.4小结120第5章　Linux集群及其项目案例分享1215.1负载均衡高可用核心概念及常用软件1215.1.1什么是负载均衡高可用1215.1.2以F5BIGIP作为负载均衡器1225.1.3以LVS作为负载均衡器1235.1.4以Nginx作为负载均衡器1325.1.5以HAProxy作为负载均衡器1325.1.6高可用软件Keepalived1345.1.7高可用软件Heartbeat1345.1.8高可用块设备DRBD1355.2负载均衡关键技术1365.2.1什么是Session1365.2.2什么是Session共享1365.2.3什么是会话保持1375.3负载均衡器的会话保持机制1385.3.1LVS的会话保持机制1385.3.2Nginx负载均衡器中的ip_hash算法1425.3.3HAProxy负载均衡器的source算法1455.4服务器健康检测1505.5Linux集群的项目案例分享1515.5.1用LVS+Keepalived建高可用集群1515.5.2用Nginx+Keepalived实现在线票务系统1545.5.3企业级Web负载均衡高可用之Nginx+Keepalived1575.5.4HAProxy双机高可用方案之HAProxy+Keepalived1695.5.5巧用DNS轮询作负载均衡1795.5.6百万级PV高可用网站架构设计1845.5.7千万级PV高性能高并发网站架构设计1875.6软件级负载均衡器的特点介绍与对比1935.7四层负载均衡和七层负载均衡工作流程的对比1945.8Linux集群的总结和思考1965.9小结198第6章　MySQL性能调优及高可用案例分享2006.1MySQL数据库的优化2006.1.1服务器物理硬件的优化2006.1.2MySQL配置文件的优化2016.1.3MySQL上线后根据status状态进行适当优化2046.1.4利用tuningprimer脚本进行数据库调优2126.1.5MySQL架构设计调优2166.2MySQL数据库的高可用架构方案2166.2.1生产环境下的DRBD+Heartbeat+MySQL双机高可用2176.2.2生产环境下的MySQL数据库主从Replication同步2286.3小结240第7章　Linux防火墙介绍2427.1基础网络知识2427.1.1OSI网络参考模型2427.1.2TCP/IP三次握手的过程详解2437.1.3Socket应用2457.1.4其他基础网络知识2477.2Linux防火墙的状态机制2477.3Linux防火墙在企业中的应用2477.4Linux防火墙的语法2487.5iptables的基础知识2527.5.1iptables的状态state2527.5.2iptables的Conntrack记录2547.5.3关于iptables模块的说明2557.5.4iptables防火墙初始化的注意事项2567.5.5如何保存运行中的iptables规则2567.6如何流程化编写iptables脚本2577.7学习iptables应该掌握的工具2607.7.1命令行的抓包工具TCPDump2607.7.2图形化抓包工具Wireshark2617.7.3强大的命令行扫描工具Nmap2647.7.4使用TCPPing工具检测TCP延迟2667.8iptables的简单脚本学习2677.8.1普通的Web主机防护脚本2677.8.2如何让别人ping不到自己，而自己能ping通别人呢？2697.8.3建立安全的vsftpd服务器2717.9线上生产服务器的iptables脚本2757.9.1安全的主机iptables防火墙脚本2757.9.2自动分析黑名单及白名单的iptables脚本2787.9.3利用recent模块限制同一IP的连接数2817.9.4利用DenyHosts工具和脚本来防止SSH暴力破解2857.10　工作中的Linux防火墙总结2877.11　小结289第8章　Linux系统安全相关篇2908.1TCP_wrappers应用级防火墙的介绍和应用2908.2DDos攻击和运营商劫持2928.3Linux服务器的安全防护2948.3.1Linux服务器基础防护篇2948.3.2Linux服务器高级防护篇2958.4Linux系统如何防止入侵3018.5小结301附录A　GibLab在开发工作中的实际应用302附录B　SublimeText3的快捷键操作308附录C　调试网络接口的利器Postman315附录D　RSYNC及INOTIFY在工作中的应用321", "architecture/优化网站加载速度的14个技巧.md": "优化了加载速度的网站不仅可以提高其搜索引擎的排名，同时也可以降低网站的跳出率，提高其转换率，还能提供更好的终端用户体验，这是当今基于Web环境取得成功的关键。下面我将介绍几个优化网站加载网页速度的简单方法，一起来看一下。1.服务器响应时间即使网站已经格外优化，但是除非服务器响应时间非常快，否则就不会有什么大的效果。当涉及到提高网站的速度，服务器响应时间起着重要的作用。下面是一些提高服务器响应时间的小贴士。有独立的服务器，而不是选择共享/托管服务器。提高Web服务器的质量。移除不必要的插件，只有那些必要的插件，才需要一直保持启用状态。2.浏览器缓存浏览器缓存可以减少HTTP请求，从而反过来提高网站的加载速度。下面就是如何利用浏览器缓存的代码示例：Java代码<IfModulemod_expires.c>ExpiresActiveOnExpiresByTypeimage/jpg\"access1year\"ExpiresByTypeimage/jpeg\"access1year\"ExpiresByTypeimage/gif\"access1year\"ExpiresByTypeimage/png\"access1year\"ExpiresByTypetext/css\"access1month\"ExpiresByTypetext/html\"access1month\"ExpiresByTypeapplication/pdf\"access1month\"ExpiresByTypetext/xjavascript\"access1month\"ExpiresByTypeapplication/xshockwaveflash\"access1month\"ExpiresByTypeimage/xicon\"access1year\"ExpiresDefault\"access1month\"</IfModule><IfModulemod_expires.c>ExpiresActiveOnExpiresByTypeimage/jpg\"access1year\"ExpiresByTypeimage/jpeg\"access1year\"ExpiresByTypeimage/gif\"access1year\"ExpiresByTypeimage/png\"access1year\"ExpiresByTypetext/css\"access1month\"ExpiresByTypetext/html\"access1month\"ExpiresByTypeapplication/pdf\"access1month\"ExpiresByTypetext/xjavascript\"access1month\"ExpiresByTypeapplication/xshockwaveflash\"access1month\"ExpiresByTypeimage/xicon\"access1year\"ExpiresDefault\"access1month\"</IfModule>注意：如果过期时间与文件挂钩，而此时文件中的内容需要更改的话，那必须先重命名文件，以便浏览器可以获取新添加的代码。3.gzip压缩gzip压缩是一个压缩实用程序，我们可以用它来快速加载网站。它的工作原理是在发送HTML和CSS文件到互联网浏览器之前，先压缩文件大小。允许mod_defalte模块启用Gzip压缩，下面是如何使用它的代码示例：Java代码<IfModulemod_deflate.c>CompressHTML,CSS,JavaScript,Text,XMLAddOutputFilterByTypeDEFLATEapplication/javascriptAddOutputFilterByTypeDEFLATEapplication/xhtml+xmlAddOutputFilterByTypeDEFLATEapplication/xmlAddOutputFilterByTypeDEFLATEtext/cssAddOutputFilterByTypeDEFLATEtext/htmlAddOutputFilterByTypeDEFLATEtext/javascriptAddOutputFilterByTypeDEFLATEtext/plainAddOutputFilterByTypeDEFLATEtext/xmlRemovebrowserbugsonlyneededforreallyoldbrowsersBrowserMatch^Mozilla/4gziponlytext/htmlBrowserMatch^Mozilla/4\\.0678nogzipBrowserMatch\\bMSIE!nogzip!gziponlytext/htmlHeaderappendVaryUserAgent</IfModule><IfModulemod_deflate.c>CompressHTML,CSS,JavaScript,Text,XMLAddOutputFilterByTypeDEFLATEapplication/javascriptAddOutputFilterByTypeDEFLATEapplication/xhtml+xmlAddOutputFilterByTypeDEFLATEapplication/xmlAddOutputFilterByTypeDEFLATEtext/cssAddOutputFilterByTypeDEFLATEtext/htmlAddOutputFilterByTypeDEFLATEtext/javascriptAddOutputFilterByTypeDEFLATEtext/plainAddOutputFilterByTypeDEFLATEtext/xmlRemovebrowserbugsonlyneededforreallyoldbrowsersBrowserMatch^Mozilla/4gziponlytext/htmlBrowserMatch^Mozilla/4\\.0678nogzipBrowserMatch\\bMSIE!nogzip!gziponlytext/htmlHeaderappendVaryUserAgent</IfModule>4.异步脚本还有一个可以提高网站页面速度的超棒选择就是异步加载脚本。如此一来网页负载就并不必依赖于这些异步脚本，网站访问者也不再需要不得不按捺下性子，等待所有的脚本加载完之后才能呈现页面。在异步模式中，脚本是在后台下载的。通常，我们会将第三方脚本作为异步脚本，因为下载这些脚本时常会让网站速度变得非常慢。Css代码<scriptasyncsrc=\"www.yoursite.com/script.js\"></script><scriptasyncsrc=\"www.yoursite.com/script.js\"></script>5.内容分发网络（CDN）内容分发网络（CDN）是位于不同地理位置的服务器组成的网络。每个服务器都拥有所有网站的文件副本。要是有网站访问者请求文件和网页时，就可以直接从就近的网站服务器发送过来（也可以是从负载最小的服务器）。6.优化JavaScript、HTML和CSS优化JavaScript和CSS也可以提高一个网站的网页速度，而且这个方法非常简单。优化JavaScript、HTML和CSS就是删除所有不必要的空格和注释，从而减小文件大小。下面是一些最小化JavaScript和CSS的流行工具，非常有用。CSSMinifierAvivoHTMLCompressor7.置于顶部的样式表和底部的脚本将样式表放在顶部有助网站的迅速加载，因为这样可以使得网页渐进式呈现。一般地，所有的互联网浏览器都支持在给定时间内并行下载两个组件（图像、样式和脚本）。但是通常而言，霸道的脚本会在并行下载时会阻止其他的下载，直到脚本下载完毕。8.避免阻塞型的JavaScript和CSS在浏览器呈现网页之前，它首先需要通过解析HTML标记语言来构建一个DOM树。在此过程中，如果遇到了脚本，此过程就会中止，转而先执行脚本，完了才会继续原先的活动。因此建议避免阻塞型的JavaScript，尤其是外部脚本。阻塞型JavaScript还会导致网站的延迟。所以不妨推迟加载那些不重要的JavaScript，或者采用异步加载的方式。另一种选择是将这些HTML代码内嵌到网站上，同时需要确保CSS的优化。9.JavaScript的延迟解析为了加载网页，浏览器必须解析所有的<script>标记内容，从而增加了网站的加载时间。通过延迟解析脚本，那么就可以减少初始网站的加载时间了。10.启用KeepAlive当用户通过浏览器请求网页时，浏览器首先需要访问HTML文件。然后它才能读取这些文件，并请求与其他资料相关联（此处的资料可以是CSS，JavaScript，也可以是任何相关的图像）。如果“KeepAlive”选项被禁止，那么下载网站的进程通常就会增加，从而拖累了网站速度。启用KeepAlive的另一个好处是，它可以减少CPU的使用。引用语法:KeepAliveOn11.图像和文件格式图像对于任何网站都非常有价值，因为它能传达一些强有力的信息给网站的访问者。最常见的图像格式是GIF、JPEG、PNG等。每种格式都有其长处和局限。建议使用JPEG格式，而不是GIF和PNG图像，除非图像包含Alpha因子或者是透明的。12.优化代码：不使用内联CSS内联了样式就不能清清楚楚地将内容从设计中剥离开来。同时可能还会需要大量的维护工作，给网站管理员带来各种不便，还会进一步增加网页的大小。13.文件分离网站的文件可以分为CSS、JavaScripts和图像。文件分离虽然并不能直接改善网站的加载时间。但是，这么做可以提高服务器的稳定性，特别是当网站流量突然出现了尖峰的时候。子域也可以用于托管文件，这样可以增加并行下载的数量。14.尽量减少HTTP请求还有一种简单的优化网页速度的方法是，减少HTTP请求。当一个网站一下子收到太多的HTTP请求，它的访客就会有响应时间延迟的体验，这不仅增加了CPU使用率也增加了页面的加载时间。那么，又该如何减少HTTP请求？请见以下步骤。减少网站上的对象数量；最小化网站上的重定向数量；使用CSSSprites技术（只要你需要的那部分图片内容）；结合JavaScripts和CSS。上述建议已被证明在优化网站的页面加载速度上非常有效。总之，炫彩夺目的图形，有趣的内容和更好的导航可以帮助你获得更多的网站访问者，但更快的网页加载速度则能帮助你留住他们。", "architecture/关于技术选型.md": "原则1.选择流行的技术**社区提供各种扩展和插件解决方案**。流行的技术社区必大。一种技术用的人多了，就会碰到各种各样的问题，他们会把自己的解决方案提交到社区，这解决了很多人类似需求，不需要从头投入时间去研究。比如：Bootstrap的各种插件组件很丰富，特别是各种独特显示需求，大多数我们能在社区找到解决方案。再比如，绝大多数的Java技术都会支持Spring，为Spring提供各种扩展解决方案；选择Spring就是选择了一系列的解决方案，而不仅仅是Spring本身。**架构考虑全面**。流行的框架需要应对各种需求，必须全面设计好其架构，以保证其扩展性和稳定性等。比如：Spring架构是基于接口实现的，方便扩展定制其功能；而JFinal是基于类设计的，必须改动其源码才能扩展；为了使Freemaker支持多template的basePath（classpath和webappDir），JFinal需要重写FreemakerRender类，而Spring则不用修改其源码。**流行的框架Bug少**。想当年选择JSF、JBossSeam、jBPM4时，那个Bug可真多，最终只能放弃。**发展延续性**。流行技术的发展和维护延续的时间会更长，不会搞个几年就没人维护了。2.同时选择两个相似的解决方案，那是浪费时间**节约精力**。选择一种技术或框架，是一种时间和精力的投入。如果对解决相同问题、功能相似的多个技术或框架同时学习，那是两法时间；比如：对于Web开发，可以选择Spring和JFinal，而它们的多数据源问题的处理方式是不一样的，我们需要对这两个框架同时研究，这种没有技术含量的东西，真心没必要同时研究两个。**加强深度**。可以选择一种技术或框架，从各种技术需求和业务需求出发，研究其解决方法。比如数据库访问可以选择基于JDBC方案和基于ORM框架（Hibernate），选择其中的一种，深入的研究其分库分表、缓存、读写分离怎么实现的。**积累**。选择一种技术长期投入时间和精力，遇到问题多，积累的知识多；长期使用一种技术，那么对其就更熟练。3.选择自己要用功能，避免纯净洁癖症一种技术和框架往往包括内容挺多，而我们需要使用的功能很少。不要看到多余的内容就觉得碍眼，非要去找一个更纯粹纯净的解决方案，使用我们需要的功能即可。JVM对没有使用的类是不会实例化成对象放入内存中的，就是占点磁盘空间，体积大程序未必耗资源，体积小的程序未必不占资源，比如病毒木马等。", "architecture/分布式服务框架.md": "1、服务的远程调用（RPC）产品Google:gRPC（ProtocolBuffersRPC）Facebook:ThriftTwitter:FinagledubboWebServiceshprosecommonRPCspringhttpInvokerRMIEJBICE:ICE介绍zh.wikipedia.org/zhcn/ICE_%E4%B8%AD%E9%97%B4%E4%BB%B6\\序列化和反序列化www.infoq.com/cn/articles/serializationanddeserialization:介绍了Corba/COM/XML/JSON/Protobuf/Thrift/Avro等方式。孙立：软件系统开发中的数据交换协议www.infoq.com/cn/news/2011/05/sldataexchangeprotocol:文中对各种数据交换协议进行了对比.JavaRemoting远程服务（上）www.infoq.com/cn/articles/lpjavaremoting1JavaRemoting远程服务（下）www.infoq.com/cn/articles/lpjavaremoting2:介绍了RMI/EJB/WebService/Hessian/NIOMina/Netty几个远程调用方式。2、服务的分布式调用链及服务状态跟踪统计Google:DapperTwitter:zipkin3、服务的配置管理。包括服务发现、负载均衡及服务依赖管理。ZooKeeperserfdomconsui。4、服务之间的调度及生命周期管理Apache:MesosApache:YARN参考：RPC框架性能基本比较测试www.useopen.net/blog/2015/rpcperformance.html：比较了gRPC/Thrift/WildflyEJB/Dubbo/RedhatJBossEAP的性能。分布式服务框架的4项特性timyang.net/distributed/servicearchitecture/RSF分布式服务框架设计my.oschina.net/u/1166271/blog/316686：模拟淘宝的HSF设计？", "architecture/初创公司构建数据分析平台.md": "干货推荐：www.infoq.com/cn/presentations/startupcompaniesbuilddataanalysisplatformTOC常用数据分析解决方案（WHY）1.第三方统计服务：GoogleAnalytcs、友盟、百度统计好处使用简单免费不足无法与业务数据交叉分析分析能力较弱，无法覆盖深度分析指标无法自定义数据无法取回数据安全存在顾虑2.业务数据库写SQL好处可根据需求灵活定制数据准确、实时可分析业务数据不足历史状态被覆盖能力有限，无法水平扩展开发维护代价大需额外开发工作查询逻辑随着业务的演进复杂化，不好维护（SQL、脚本、结果数据）和业务数据无法解耦随分析需求增加字段、数据表3.基于日志写统计脚本好处与业务数据库解耦不足开发效率低（2天/个，重复开发）准确性无法保证计算能力有限有技术门槛打好日志是一件很难的事情数据流难以管理数据分析平台的推荐方案（HOW）!_v_images/20191129174112.png1、数据记录（采集）生成高质量的源数据全准数据类型行为数据业务数据：用户、订单、库存数据规范行为数据：操作系统、应用版本、是否WIFI、屏幕尺寸、设备型号、商品ID、商品价格等。用户属性数据：性别、年龄、婚姻状况、注册时间、收入级别、是否有小孩等。!_v_images/20191129174125.png数据格式非格式化文本Vs.Json、Thrift、ProtocolBuffer、Avro数据采集点尽量在后端打前端打（压缩、加密、批量）数据落地写网络写本地文件2、数据传输需关注的问题时效性（实时？批量？）可靠性（丢？重？）扩展性方案FTPKafkaScribe、Flume3、数据建模/存储数据模型抽象Event：EventType+Properties+UserIDUserProfile：UserID+Properties（年龄、所在地、Tag等）Event：记录所有的历史状态变更ETLExtract,TransformandLoadIDMappingMerge批量or实时存储单机文件关系型数据库（Mysql、Vertica、Teradata）NosqlHBase、MongoDBHDFS4、数据统计/分析/挖掘批处理交互式OLAPOnlineAnalyticalProcessing维度指标数据魔方!_v_images/20191129174140.png分析模型基于事件分析漏斗留存5、数据可视化/反馈展现方式曲线柱状图饼状图热力图地域分布可视化工具OpenChartsHighChartsEChartsTableauSoftwareOracleBIEE数据分析的结果直接反馈到产品系统中，提升产品体验（BI只是数据分析的很小一部分）反馈方式推送个性化推荐风控CRM集成总体架构!_v_images/20191129174148.png", "architecture/前后端分离开发.md": "1、前后端分离前提需求明确，需求领先开发一个周期有明确的设计，特别是接口设计，接口文档需要管理，可以采用软件，如swagger公共组件MockServer支持持续集成+单元测试（方便debug、回归测试）公共业务接口（如：findById、查询接口可配置），接口遵循REST接口转换层（easyui格式转换）需要解决的问题web层权限控制（Freemarker标签？）接口API权限控制session管理webpage框架（SpringMVCvsRatpackvsNodeJS）图片上传前端校验国际化优点前后端重构更容易；后端引入单元测试后，质量有提升前端更多自主权，页面可做更多个性化的设计要注意的前端人员须到位，后端人员可以减半后端负责业务逻辑，前端负责View+Controller，校验、上传、权限等API遵循Restful风格前后须加强沟通，接口必有文档，可通过MockServer模拟接口开发过程设计接口：前端参与UI设计，决定前后端开发协作模式及职责，前后端一起确定业务接口。开发阶段：前后端并行开发，后端使用JUnit进行单元测试，前端使用MockServer进行测试；开发过程中双方可以协商变动接口。部署：前后端集成测试MockServer根据接口文档自动生成假数据mocogithub.com/dreamhead/mocowiremockwiremock.org/index.html接口管理加入jsonschema规则，实现了对http请求的参数校验。RAPrap.taobao.org/org/index.doswaggerswagger.io/.模板用着一样的模版语言XTemplate，一样的渲染引擎JavaScript在不同的渲染环境（Serverside、PCBrowser、MobileBrowser、WebView、etc.）渲染出一样的结果。参考架构该解决方案，session，登录态什么的仍然是后端管理;前端仍然只管理模板，只不过起了后台来管理模板；对后端来说，除了nginx配置改变几乎没有任何新的东西。!_v_images/20191129175312.png技术储备BigPipe基于Thrift前后端分离Demo一个难点在于web与services的数据交互。好在facebook开源的一个项目Thriftthrift.apache.org/为我们解决了这个问题。Demo中使用了Nodejs的Express搭建web服务，使用Thrift生成Node的client和server的接口文件。**Client**:```javascriptvarclient=thrift.createClientCalculator,connection;router.get'/',functionreq,res,next{client.add10,100.thenfunctionresponse{res.render'index',{title:'Express+Thrift',desc:'：1+1='+response};};};/*jade*/blockcontenth1=titlepWelcometo{title}```**Server**```javascript/*Nodejsserver*/...varserver=thrift.createServerCalculator,{add:functionn1,n2{varresult=n1+n2;returnresult;}};console.log\"localhost:9090\";server.listen9090;```参考：前后端分离想法的一些实践github.com/weivea/FEseparate2、Node.js+后端REST架构node.js不适合做全栈其实，没有哪个语言或框架适合做全栈，即使如Spring也不行（web层不轻量）。node.js有一下缺陷：臭名昭著的异步回调。上8层的异步调用嵌套实在难读和难以维护。javascript的不严谨和灵活性导致了程序在运行过程中很容易出现难以调试的Bug，而Bug的日志会让人摸不着头脑。完全异步化带来的另一个问题就是调试困难。没法直接发挥多核、多CPU的服务器的优势。没有像Java一样的工程化体系、中间件、开源库。要真正以node来支撑开发一个电商平台对JS工程师的要求非常高，我觉得业内这样的人才依然相当难觅，上手容易不等于高级功能也容易。只作为web层：如果你要做的是小型项目，或者逻辑非常简单的项目，可以选择Node.js，因为开发、调试都很很快。如果你要做的是逻辑简单，而并发大的项目，可以选择Node.js，它还是很适合左右游戏的聊天服务器，长连接消息推送服务器之类的项目的。在真正的重要的、大型的项目上请不要盲目，追求一些比如“语言层面的前后端统一”这样的议题，这是没有意义的。paypal只是把web端开发从JSP切换成了node.js，系统平台里的该是什么还是什么。还有类似的例子就是Groupon，他们也用node重构了网页部分内容，沃尔玛亦然。结论：1、如果能用Java做，就用Java做，参考淘宝网。2、如果做大了需要升级用户体验，后端服务器接口化，前端服务器用Node.js替换，参考淘宝网前后端分离实践。3、考虑到电商项目的失败率，项目有很大的可能走不到第二步，请先考虑第一步。4、不是所有公司都像淘宝一样有大量的技术储备力量，去完成前后端分离，创业公司或不大的公司还是选择一种技术栈比较合适。PS:Web服务器端一直都存在两个阵营，以Java/C为代表的工业设计语言和以PHP/RoR为代表的快速开发语言。前者一直牢牢地占据着企业应用开发市场，而后者则普遍认为更适合灵活多变的互联网，Node.JS显然是属于后者的。用Java/JSP来开发网站太过于重量过于繁琐了，不如RoR/PHP等动态脚本语言灵活快速。Node.jsWeb选型**Sinatralike**Expressexpressjs.com/koa.jskoajs.cn/hapihapijs.com/koa.js比Express先进最重要的一点：koa.js在coroute上所做工作，引入yield，不再需要多层的异步调用嵌套。**Railslike**sailssailsjs.org/sails在windows下安装需要python2.7，VC++2010的支持，太麻烦，我没有安装试用。**Node.js渲染模板**ICanHaz.js/mustache/hogan.js/Jade/Haml//Slim/CoffeeKup/Markaby/ejs/eco等使用node做web前端的好处前后端分离是的业务层独立，更容易结合多种前端，如web和app。如果可以用JavaScript来渲染页面，前端工程师就可以有更大的空间。前端想要对页面进行重构优化的时候也不再需要打扰后端工程师，大家都可以更专注于自己的事情。REST后端接口Java做后端优势：熟悉Java的工程师很多，我们很容易找到需要的人。Java平台的性能已经的到多年的验证。Java平台上众多的第三方产品、类库无所不有。基于JVM的动态/函数式语言也给了Java平台良好的扩展性。3、基于dubbo的前后端分离基于dubbo的前后端分离分为两大类，一类是dubbo+阻塞前端WebServer，如dubbo+tomcat，dubbo+ApachePHP；另一类是duboo+异步非阻塞WebService，如：dubbo+nodejs，dubbo+ratpack。涉及到的前端WebServer有基于Java和非Java的，列举流行的几种说明：1.dubbo+nodejsnodejs与dubbo服务通信有两种方式：Hessian,jsonrpc。Hessian协议dubbo原本就支持，而jsonrpc协议需要另外实现，不过万幸Github上已经有人做了。jsonrpcQianmiOpen/dubborpcjsonrpcgithub.com/QianmiOpen/dubborpcjsonrpcQianmiOpen/dubbonodeclientgithub.com/QianmiOpen/dubbonodeclient**另一个nodedubbo客户端：**nodejsonrpcdubbogithub.com/hufeng/nodejsonrpcdubbo使用jsonrpc协议，使node可以调用dubbo的服务```javascriptvarclient=require'./dubboclient';varprovider='com.ofpay.demo.api.UserProvider';//简单的调用一个接口client.getProviderprovider,functionerr,userProvider{err?console.logerr:userProvider.queryAllfunctionerr,data{console.logerr,data;};};//groupversionsupportclient.getProviderprovider,'test1','2.1',functionerr,userProvider{err?console.logerr:userProvider.queryAllfunctionerr,data{console.logerr,data;};};```Hessian基于Dubbo的Hessian协议实现远程调用shiyanjun.cn/archives/349.htmlnodejszookeper客户端通过hessian与dubbo交互github.com/xuyan2680/nodejava2.dubbo+vert.xwebVert.xWebvertx.io/docs/vertxweb/java/3.dubbo+servlet4.dubbo+ratpackRatpackisasetofJavalibrariesthatfacilitatefast,efficient,evolvableandwelltestedHTTPapplications.ItisbuiltonthehighlyperformantandefficientNettyeventdrivennetworkingengine.RatpackfocusesonallowingHTTPapplicationstobeefficient,modular,adaptivetonewrequirementsandtechnologies,andwelltestedovertime.Ratpack可以使用Groovy和Java，运行与JVM上，调用dubbo服务很方便。Ratpack的问题是服务器集群方案、负载均衡等没有现成案例。5.dubbo+python/php可以通过Hessian协议来调用。", "architecture/区块链.md": "TOC学习过程区块链（BlockChain）结构解析blog.csdn.net/yinanmo5569/article/details/80313710Python开发区块链Python实现最简单的区块链mp.weixin.qq.com/s?src=11&timestamp=1570764209&ver=1905&signature=Fo09EY6xZp2oEL6cH7XjnOhKIiPn63xU0ey2*Ws3yCEzOEZ0nfrStidxbVzmWcaAIQeyvzxbCJn5CfgCZZ7KVM2liEKThiiXCPeYqttVPBFUhj893uKxmmxC9T5ibKr&new=1用Python从零开始创建区块链learnblockchain.cn/2017/10/27/build_blockchain_by_python/1第1课1.1比特币1.1.1比特币起源BitcoinBTC:APeertoPeerElectronicCashSystem点对点电子现金系统中本聪在2009年初挖出第一批比特币总量不超过2100万枚1.1.2比特币底层机制去中心化，P2P分布式数字货币系统共识机制POW工作量证明非对称加密算法数字签名区块链账本技术1.1.3比特币特性硬通货跨境交易易携带只需一个私钥隐秘性只暴露钱包地址无货币超发1.1.4比特币钱包钱包就是P2P里的P节点，主要用来管理私钥和比特币转账地址钱包分类轻钱包只存储维护跟你自己交易相关的数据中心化钱包数字货币交易所钱包下载地址：bitcoin.org/zh_CN/download1.1.5比特币产生比特币由矿工挖矿产生生成的比特币被记录在矿工的名下比特币通过矿工的公钥哈希值锁定比特币通过交易UTXO在节点之间转移UTXO未花费的交易1.2区块链1.2.1区块链分布式账本系统!_v_images/20191120203705.png共识机制POW工作量证明通过挖矿证明自己是善意节点，并获得生成区块和在该区块记账的权利基于P2P网络，每个全节点都存储着最全的比特币交易记录新区块通过包含前一个区块头部的哈希值区块的唯一标识建立链接关系区块里装的就是所有的比特币交易记录UTXO1.2.2区块链网络区块链节点矿工运行于强大或专用的硬件（比如ASIC）之上，主要目的是挖矿全节点这些节点验证矿工挖出来的块的有效性，并对交易进行确认。SPV节点简单支付验证，如钱包节点1.2.3区块链挖矿在全网中和其他节点竞争计算解一个难题的过程证明自己是非恶意节点获得的权利和义务记账权把交易写入区块里广播义务把区块在全网广播获得的奖励挖矿奖励12.5BTC收取交易手续费1.2.4区块链共识机制拜占庭将军问题共识机制之一!_v_images/20191120203727.pngPOWProofofWork工作量证明通过付出大量工作代价证明自己是非恶意节点计算一个随机数nonce，算出的正确随机数即POW获取记账权利打包交易并通知其它节点理性人都是逐利的，POW抑制了节点的恶意动机1.2.5区块链交易确认当一项交易被链上的区块收录后，就是交易确认在此区块之后每产生一个区块，此项交易的确认数相应加1经过6个以上区块确认的交易才是安全确认的，因为篡改成本巨大比特币钱包可以设置交易确认数1.2.6区块链区块生成!_v_images/20191120203748.png矿工在挖矿前要组建区块将coinbase交易打包进区块将交易池中高优先级的交易打包进区块创建区块头部!_v_images/20191120203804.png挖矿成功后，将计算出来的随机数noncePOW填入区块头部，并向临近节点传播1.2.7区块链区块验证相邻节点收到新区块后，立即做以下验证验证POW的nonce值是否符合难度值检查时间戳是否小于当前时间两小时检查merkle树根是否正确检查区块size要小于区块size的上限第一笔交易必须是coinbase交易验证每个交易1.2.8区块链分类公有链任何人都可以参与使用和维护，信息公开，如比特币，以太坊等联盟链若干组织共同维护，使用有权限限制，信息受保护，如银联组织私有链集中管理者进行限制，内部少数人可以使用，信息不公开1.2.9区块链篡改账本双花问题：同一笔比特币被支付多次!_v_images/20191120203825.png!_v_images/20191120204008.png!_v_images/20191120204032.png!_v_images/20191120204051.png1.3密码学1.3.1密码学对称加密对称加密加解密钥相同缺点：无法确保密钥被安全传递常用算法：DES、3DES（TripleDES）、AES等!_v_images/20191120204311.png1.3.2密码学非对称加密非对称加密公私钥加密对，公钥加密，私钥解密!_v_images/20191120204322.png!_v_images/20191120204333.png公钥由私钥生成，私钥可以推导出公钥从公钥无法推导出私钥优点：解决了密钥传输中的安全行问题常用算法：RSA、ECC（椭圆曲线加密算法使用场景：SSH安全验证等问题：解决了信息传送的问题，如何验证发送方是正确的了?1.3.3密码学哈希Hash哈希将一段数据任意长度经过计算转换成一段定长的数据不可逆性几乎无法通过哈希的结果推导出原文无碰撞性两个不同原文哈希后的结果一定不同常用算法：MD5，SHA256使用场景数据库中的用户密码存储MD5挖矿计算SHA2561.3.4密码学数字签名数字签名公私钥加密对，私钥签名，公钥解签名使用场景比特币交易验证等!_v_images/20191120204346.png1.3.5Java实现区块链与比特币区块链结构挖矿生成新区块共识机制比特币交易比特币钱包区块链P2P网络通讯!_v_images/20191120204402.png比特派第2课区块链整体结构设计与实现共识机制工作量证明原理挖矿算法!_v_images/20191120204416.png```java//挖矿算法//创建一个空的区块链List<Block>blockchain=newArrayList<>;//生成创世区块Blockblock=newBlock1,System.currentTimeMillis,newArrayList<Transaction>,1,\"1\",\"1\";//加入创世区块到区块链里blockchain.addblock;System.out.printlnJSON.toJSONStringblockchain;//创建一个空的交易结合List<Transaction>txs=newArrayList<>;Transactiontx1=newTransaction;Transactiontx2=newTransaction;Transactiontx3=newTransaction;txs.addtx1;txs.addtx2;txs.addtx3;//加入系统奖励的交易TransactionsysTx=newTransaction;txs.addsysTx;//获取当前区块链里的最后一个区块BlocklatestBlock=blockchain.getblockchain.size1;intnonce=1;Stringhash=\"\";whiletrue{hash=CryptoUtil.SHA256latestBlock.getHash+JSON.toJSONStringtxs+nonce;ifhash.startsWith\"0000\"{System.out.println\"=====计算结果正确，计算次数为：\"+nonce+\",hash:\"+hash;break;}nonce++;System.out.println\"计算错误，hash:\"+hash;}BlocknewBlock=newBlocklatestBlock.getIndex+1,System.currentTimeMillis,txs,nonce,latestBlock.getHash,hash;blockchain.addnewBlock;System.out.println\"挖矿后的区块链：\"+JSON.toJSONStringblockchain;```!_v_images/20191120204437.png密码学非对称加密非对称加密公私钥加密对，共要加密，私钥解密公钥由私钥生成，私钥可以推到出公钥从公钥无法推导出私钥优点：解决了密钥传输中的安全问题常用算法：RSA、ECC（椭圆曲线加密算法）使用场景：SSH安全验证等问题：解决了信息传送的问题，如何验证发送方是正确的？!_v_images/20191120204516.png```JAVA@TestpublicvoidtestEncryptthrowsException{System.err.println\"公钥加密――私钥解密\";StringinputStr=\"abc\";bytedata=inputStr.getBytes;byteencodedData=RSACoder.encryptByPublicKeydata,publicKey;bytedecodedData=RSACoder.decryptByPrivateKeyencodedData,privateKey;StringoutputStr=newStringdecodedData;System.err.println\"加密前:\"+inputStr+\"\\n\\r\"+\"解密后:\"+outputStr;assertEqualsinputStr,outputStr;}```密码学哈希（Hash）哈希讲一段数据（任意长度）经过计算转换成一段定长的数据不可逆性几乎无法通过哈希的结果推导出原文无碰撞行两个不同原文哈希后的结果一定不同常用算法：MD5、SHA256使用场景：数据库中的用户密码存储（MD5）挖矿计算（SHA256）密码学数字签名1、数字签名：公私钥加密对，私钥签名，公钥验证签名。2、使用场景：比特币交易验证等。!_v_images/20191120204542.png```JAVA@TestpublicvoidtestSignthrowsException{System.err.println\"私钥签名――公钥验证签名\";StringinputStr=\"sign\";bytedata=inputStr.getBytes;//产生签名Stringsign=RSACoder.signdata,privateKey;System.err.println\"签名:\\r\"+sign;//验证签名booleanstatus=RSACoder.verifydata,publicKey,sign;System.err.println\"状态:\\r\"+status;assertTruestatus;}```生成钱包```JAVA//本地生成公私钥对Map<String,Object>initKey=RSACoder.initKey;StringpublicKey=RSACoder.getPublicKeyinitKey;StringprivateKey=RSACoder.getPrivateKeyinitKey;returnnewWalletpublicKey,privateKey;```3第3课：比特币的设计与实现比特币交易UTXO交易输出交易输入比特币余额3.1比特币UTXOUTXOunspenttransactionoutput未花费交易输出比特币拥有者的公钥锁定（加密）的一个数字UTXO就是比特币，比特币系统中只有UTXO,没有比特币新的UTXO由挖矿或交易产生UTXO存在全节点的数据库里转账交易消耗自己的UTXO,同时生成新的UTXO,并用接受者的公钥锁定比特币系统中用户的“余额”实际上并不直接存在，而是通过计算得来3.2比特币交易模型交易输出（UTXO）锁定的比特币数量锁定脚本（用接收者的公钥哈希）交易输入（UTXO+解锁脚本）解锁脚本（发送者的签名和公钥）签名对发送者和接收者的公钥哈希以及整个交易签名!_v_images/20191120204624.png!_v_images/20191120204643.png3.2比特币交易全流程!_v_images/20191120204701.pngcoinbase的系统交易，input为空。3.3交易代码```JAVA//交易发起方WalletwalletSender=Wallet.generateWallet;//交易接收方WalletwalletReciptent=Wallet.generateWallet;TransactionInputtxIn=newTransactionInputtx2.getId,10,null,walletSender.getPublicKey;TransactionOutputtxOut=newTransactionOutput10,walletReciptent.getHashPubKey;Transactiontx3=newTransactionCryptoUtil.UUID,txIn,txOut;//假定tx2之前已经被打包进区块，也就是已经被记录进账本了tx3.signwalletSender.getPrivateKey,tx2;txs.addtx3;```3.4签名代码对发送者和接收者的公钥哈希以及整个交易签名```java/***用私钥生成交易签名**@paramprivateKey*@paramprevTx*/publicvoidsignStringprivateKey,TransactionprevTx{ifcoinbaseTx{return;}if!prevTx.getId.equalstxIn.getTxId{System.err.println\"交易签名失败：当前交易输入引用的前一笔交易与传入的前一笔交易不匹配\";}TransactiontxClone=cloneTx;txClone.getTxIn.setPublicKeyprevTx.getTxOut.getPublicKeyHash;Stringsign=\"\";try{sign=RSACoder.signtxClone.hash.getBytes,privateKey;}catchExceptione{e.printStackTrace;}txIn.setSignaturesign;}/***生成用于交易签名的交易记录副本**@return*/publicTransactioncloneTx{TransactionInputtransactionInput=newTransactionInputtxIn.getTxId,txIn.getValue,null,null;TransactionOutputtransactionOutput=newTransactionOutputtxOut.getValue,txOut.getPublicKeyHash;returnnewTransactionid,transactionInput,transactionOutput;}```", "architecture/图片播放技术总结.md": "1概述由于工作的项目上的需求，需要在浏览器上不间断的播放图片，即像播放视频一样播放图片。后端支持采用Java实现，需要用Java编写一个Http服务器，并提供WebSocket服务。前后端通过Http链接或WebSocket提供图片浏览服务，前端采用JS轮询或WebSocket推送的方式获取图片，浏览器显示图片有两种方式：一种是采用<img>连续切换图片源，实现播放效果；另一种采用将图片画在canvas上面，实现播放。要完成这个功能涉及到以下技术：Http服务器的实现高速的读文件WebSocket原理及实现基于浏览器pull方式的http资源获取基于服务器端push方式的http资源获取JS播放图片帧的性能2技术分析2.1Http服务器的实现实现HTTP服务器比较容易，实现方式也有如下多种：基于jdk中com.sun包下面的HttpServer来实现。（不推荐，com.sun不在java规范内，jdk升级可能会不兼容）基于jetty或tomcat的嵌入式包来实现。此方式基于Servlet规范来实现的，较简单且易于理解。基于netty的方式实现。性能好，需要对NIO有了解，编程难度相对大一些。基于vert.x的实现。这种方式底层还是采用netty实现，较简单，但是也需要熟悉vert.x的编程模型。我们采用jetty的方式实现，基于servlet3.0规范，可以支持异步请求方式。代码如下：<pre>publicstaticvoidmainStringargs{Serverserver=newServer;ServerConnectorconnector=newServerConnectorserver;connector.setPort8080;server.addConnectorconnector;ServletContextHandlercontext=newServletContextHandlerServletContextHandler.SESSIONS;context.setContextPath\"/\";context.addServletnewServletHoldernewHelloServlet,\"/hello\";server.setHandlercontext;try{//Initializejavax.websocketlayerServerContainerwscontainer=WebSocketServerContainerInitializer.configureContextcontext;//AddWebSocketendpointtojavax.websocketlayerwscontainer.addEndpointEventSocket.class;server.start;server.dumpSystem.err;server.join;}catchThrowablet{t.printStackTraceSystem.err;}}</pre>2.2高速的读文件关于Java高速读取文件可参考这篇文章：Howtoreadfilesquicklynadeausoftware.com/articles/2008/02/java_tip_how_read_files_quickly这篇文章得出四个结论：为了减少I/O操作，每次应该读一个byte数组，而不是一个byte字节，8K的byte数组就是一个好的选择。为了减少方法调用的开销，每次应该获取一个byte数组的数据，而不是一个byte字节。为了减少线程同步锁的开销，要么减少线程同步方法的调用，要么采用非线程安全的类，如：FileChannel和MappedByteBuffer。为了减少在JVM/OS、internalbuffers和应用程序数组之间的数据拷贝，要么使用带有内存映射的FileChannel类，要么使用adirectorwrappedarrayByteBuffer.下面提高两种高速读取文件方法：<pre>forStringfilePath:fileList{tryFileChannelch=newRandomAccessFilefilePath,\"r\".getChannel{intsize=intch.size;MappedByteBufferbuf=ch.mapMapMode.READ_ONLY,0,size;//处理buf....}catchIOExceptione{e.printStackTrace;}}</pre><pre>forStringfilePath:fileList{trySeekableByteChannelsbc=Files.newByteChannelPaths.getfilePath,StandardOpenOption.READ{ByteBufferbuf=ByteBuffer.allocate10;//Readthebyteswiththeproperencodingforthisplatform.If//youskipthisstep,youmightseesomethingthatlookslike//ChinesecharacterswhenyouexpectLatinstylecharacters.//Stringencoding=System.getProperty\"file.encoding\";whilesbc.readbuf>0{buf.rewind;//处理buf...//System.out.printCharset.forNameencoding.decodebuf;buf.flip;}}catchIOExceptionx{System.out.println\"caughtexception:\"+x;}}</pre>2.3WebSocket原理及实现WebSocket的原理以及与Http区别可以参考：WebSocket与http的区别，以及它的原理blog.sina.com.cn/s/blog_bf397e780102w25k.html，总体来说，原理及区别如下：WebSocket和Http协议没有太大的关系，WS只是借助Http实现了第一次握手，之后从http协议upgrade为ws://协议。WS是持久性连接（类似socket），而HTTP的短连接、长连接都不是持久的。WS协议是支持全双工的，可以pull，亦可以push。用Java实现WebSocket服务端：<pre>@ClientEndpoint@ServerEndpointvalue=\"/events/\"publicclassEventSocket{privatestaticintDEFAULT_BUFFER_SIZE=128*1024;//8192privatebytebytes;@OnOpenpublicvoidonWebSocketConnectSessionsession,EndpointConfigconfig{session.setMaxBinaryMessageBufferSizeDEFAULT_BUFFER_SIZE;}@OnMessagepublicvoidonWebSocketTextSessionsession,StringmessagethrowsException{System.out.println\"ReceivedTEXTmessage:\"+message;bytes=...//读取图片文件字节//发送图片文件session.getAsyncRemote.sendBinaryByteBuffer.wrapthis.bytes;}@OnClosepublicvoidonWebSocketCloseSessionsession,CloseReasonreason{System.out.println\"SocketClosed:\"+reason;}@OnErrorpublicvoidonWebSocketErrorSessionsession,Throwablecause{cause.printStackTraceSystem.err;}}</pre>2.4浏览器并发请求与长连接浏览器请求一般都是拉取服务器的资源，而请求方式分为短连接和长连接两种，这篇文章介绍很清楚：HTTP的长连接和短连接www.cnblogs.com/cswuyg/p/3653263.html浏览器对后端资源的请求都是并发的执行的，不同的浏览器并发连接数不同。现在大多数浏览器都支持http1.1协议，默认都会开启keepalive，支持长连接。在浏览器对后端的资源发出请求，在开启keepalive情况下，都会复用连接通道。如果是不间断的下载图片，应该使用的是长连接通道复用功能。2.5Web服务器Push技术实现服务器端Push有以下几种方式：Ajax轮询。采用setInterval方法不停的调用Ajax长轮询。俗称Comet方式，不需要重复建立连接，没有响应就一直等，等到才关闭连接。WebSocketserversenteventsAjax轮询原理还是pull的方式，不算真正的push，但是对一些老版本的浏览器是适用的。WebSocket优点是支持全双工、可跨域。serversentserver实现简单，但只支持server到client单向传输，且IE系列都不支持。详细内容参考：web服务器端推送技术简介w3ctech.com/topic/1754除了上面一些方法外，还有一些其他方式，如：FlashXMLSocket，JavaApplet等非主流。而在本案例中，如果采用WebSocket传送图片，可实现真正的服务器端不间断的推送图片数据，但是如果要实现并发传送，必须自己在浏览器端来实现，否则，仅仅单连接的情况下不一定比浏览器的并发连接快。2.6JS播放图片帧的性能JS播放图片有多种方式，如：采用<img>标签，不停改变img的src属性，实现播放。采用Html5的Canvas，将Image对象画在Canvas上，实现播放。将图片设置为Div的背景，不停的更换背景，实现播放。采用<img>标签方式实现如下：<pre>function{vari=0;varpics=\"andy_white.jpg\",\"andy_black.jpg\";varel=document.getElementById'img_to_flip';//eldoesn'tchangefunctiontoggle{el.src=picsi;//settheimagei=i+1%pics.length;//updatethecounter}setIntervaltoggle,2000;};</pre>这种方式下浏览器CPU占用率非常高，在IE11和Chrome下，i3的CPU（T440P）占用都在60%左右，内存占用较少，大约在100M左右。CPU的消耗主要在浏览器对图片的渲染上。用Canvas替代<img>标签，CPU占用方面，IE11仍然占用那么高，Chrome能降一半。更换背景的方式没有实验。基于以上，采用Canvas的方式是一种比较好的选择。", "architecture/基于HMAC的REST安全认证.md": "REST中如何安全地处理用户登录问题？segmentfault.com/q/1010000000610275首先，服务器端的身份验证基本上有两类方式：一是基于Cookie的验证，一是基于Token的验证。选择哪一种要看你的实际情况。基于Cookie的验证历史悠久了，原理和做法无需赘言；近几年涌现了大量的公共API服务，它们基本上都使用了基于Token的验证，这主要是因为：1.处理跨域资源分享（CORS）――虽然Cookie＋CORS也不是完全不可能，但是比较难搞2.无状态性――有利于服务端扩展（伸缩性强）3.C/S解藕――服务器端和客户端可以完全分离，进而静态资源可以用CDN来处理，服务器端完全变成APIService4.CSRFFree――不依赖Cookie，完全不担心跨域伪造请求攻击（这点尚有疑虑，有待考证）……呃，忽然觉得有点跑题了，我的意思是你首先得选择一个验证方式，很明显基于Token的认证是趋势。接下来，假定选择了基于Token认证这条路，你首先得搞明白Token是怎么玩的。简单地说：**客户端先发送正确的认证信息（比如电子邮件＋密码），服务器端检查OK之后生成一个token返回给客户端，之后客户端所有的请求都要包含这个token，服务器端只需要验证该token是否有效即可**。这里有一张图，对比了Cookie－basedAuthtication和Token－basedAuthentication，挺不错的：!_v_images/20191129171255.png好，按照REST的设计原则，我们需要一个Endpoint供用户来请求认证并获取Token，比如像这样：*POST/authentication*在这里，“资源”就是认证（按照REST的要求，用名词来表示资源），使用POST方法去请求，附带数据为认证用的信息，返回结果看你的业务逻辑，但至少要有一个token。客户端拿到token之后，先把它存起来（比如存到SessionStorage里），设置请求时的HEADER里Authorization的值为Bearer<token>，完事了。综上所述，这事和REST的关系也就是设计一个获取Token的Endpoint而已，没啥了不起的，剩下的事情都属于业务逻辑，该怎么写就看你的需求了。怎样创建安全的RestWebServiceAPI请求dengyin2000.iteye.com/blog/548859**APIKey+SecretKey签名**比上一种跟复杂的一种方式就是用一个secretkey去签名每一刻APIURL请求，AmazonWebServices就是使用这种方式。当用户注册完后，你会给用户2个keys：APIKey（比如：username）和secretkey（比如password），APIkey会附在每个请求url上面，但是secretkey不会。secretkey是用来签名每个请求的。通常会加上另外一个参数比如（Signature）。Amazon会把所有的请求信息作为请求的参数，然后按照参数名排序，再按照secretkey进行hash。这个hash的值会作为一个新的参数（Signature）附加到请求的url上。在server端做相同的事情，获得所有的参数（除了Signature），排序，用sercetkeyhash，如果这个值跟传过来的Signature参数的值相等的话，则认为这个请求是合法的。融云Server开发指南www.rongcloud.cn/docs/server.html完全可以照这个文档来开发。注意以下几点：1.访问所有的API都需要签名Signature2.Signature由用户Key+SecretKey+随机数+时间数进行hash计算而来。3.Secretkey分别保存在客户端和服务端，随机数、时间数、Signature通过header传到server，结合SecretKey进行hash，然后进行校验。4.用户登录成功后，获得访问Token。Token作为客户端访问的凭证，可以设置一定的过期时间。5.授权信息可以通过Token作为key，缓存在shiro的缓存中。这篇文章的几张图很能说明原理，需要保存下来。hmacauthgithub.com/gjhuai/hmacauth第二十章无状态Web应用集成――《跟我学Shiro》jinnianshilongnian.iteye.com/blog/2041909", "architecture/基于数据同步的云服务架构实践.md": "www.infoq.com/cn/presentations/cloudservicesarchitecturepracticebsedondatasynchronizationTOC野狗的数据同步理念Wilddog是什么？一个云端树形数据库一个App的所有的数据存到一个大JSON中事件驱动客户端Schemafree数据存储树形数据库像一颗Json树面向聚合数据之间的关系更直观完美的与Url结合每条数据都能通过url来唯一定位Path为key，keyvalue基于野狗的应用架构是这样的!_v_images/20191129173720.png数据副本的同步!_v_images/20191129173729.png数据同步的基本模型初始化慢同步fullsyncconditionsync增量同步本地besteffortpushoplog基于长连接保证有序性重连需要初始化慢同步!_v_images/20191129173811.png数据同步的架构演进架构特点写多读少写同步越实时越好读容忍一定延迟最终一致性并行写冲突实时操作幂等v0.1架构框图面向早期用户物化路径存储!_v_images/20191129173828.pngv0.2架构框图动态建库，app数据隔离Mongo提升读写性能副本集多活机枪换导弹（批量Batch数据操作）!_v_images/20191129173839.pngv0.3架构框图appIdtopic大大提升写性能（写缓冲队列kafka）类似Nagle减低写压力读性能下降!_v_images/20191129173848.png解决读的不一致问题幂等的覆盖模式操作!_v_images/20191129173858.pngv0.3.1架构框图keysxxx*引发的血案需要PerformanceMonitoring!_v_images/20191129173907.pngPerformanceMonitoring流量统计调用延迟异常报警!_v_images/20191129173916.png数据同步的细节问题问题一并发写静态一致性写隔离解决方案中心化锁机制进程间协商机制!_v_images/20191129173927.png分布式树形锁注意问题tryLock/release需要2次交互注册Lock的有效期等待Lock超时动态hash连接异常时退化!_v_images/20191129173936.png性能问题吞吐量下降每个app一个树形锁，单进程，终究有吞吐上限任何操作，包括没有冲突操作，都需要先获得锁主要性能的点单次pushsync量大，可以导致阻塞异步pushsync令人恶心的架构诞生了缩减了write操作的过程保证云端与客户端一致性太过复杂，不确定因素累加过多!_v_images/20191129174007.png", "architecture/多核与多线程.md": "编程思想之多线程与多进程1――以操作系统的角度述说线程与进程blog.csdn.net/luoweifu/article/details/46595285关键词：多核、多线程、超线程技术、内核线程、用户线程多核心处理器是指在一个处理器上集成多个**运算核心**从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。**内核线程**（KernelThread，KLT）*就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。*现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，*如你的电脑是双核四线程，打开“任务管理器\\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。***超线程技术**就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术如双核四线程由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口――**轻量级进程**（LightWeightProcess，LWP），轻量级进程就是我们通常意义上所讲的线程我们在这称它为**用户线程**，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：**一对一模型、多对一模型、多对多模型**，在这以4个内核线程、3个用户线程为例对三种模型进行说明。", "architecture/大型网站架构技术一览.md": "大型网站架构技术一览大型网站的挑战主要来自庞大的用户，高并发的访问和海量数据，任何简单的业务一旦需要处理数以P计的数据和面对数以亿计的用户，问题就会变得棘手。大型网站架构主要就是解决这类问题。更多内容也可以阅读各大互联网公司架构演进之路汇总、大型网站架构演化历程两篇文章。本文内容大部分来自《大型网站技术架构》,这本书很值得一看，强烈推荐。网站系统架构层次如下图所示：!_v_images/20191129175744.png1.前端架构前端指用户请求到达网站应用服务器之前经历的环节，通常不包含网站业务逻辑，不处理动态内容。浏览器优化技术并不是优化浏览器，而是通过优化响应页面，加快浏览器页面的加载和显示，常用的有页面缓存、合并HTTP减少请求次数、使用页面压缩等。CDN内容分发网络，部署在网络运营商机房，通过将静态页面内容分发到离用户最近最近的CDN服务器，使用户可以通过最短路径获取内容。动静分离，静态资源独立部署静态资源，如JS、CSS等文件部署在专门的服务器集群上，和Web应用动态内容服务分离，并使用专门的（二级）域名。图片服务图片不是指网站Logo、按钮图标等，这些文件属于上面提到的静态资源，应该和JS、CSS部署在一起。这里的图片指用户上传的图片，如产品图片、用户头像等，图片服务同样适用独立部署的图片服务器集群，并使用独立（二级）域名。反向代理部署在网站机房，在应用服务器、静态资源服务器、图片服务器之前，提供页面缓存服务。DNS域名服务，将域名解析成IP地址，利用DNS可以实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后指向CDN服务器。2.应用层架构应用层是处理网站主要业务逻辑的地方。开发框架网站业务是多变的，网站的大部分软件工程师都是在加班加点开发网站业务，一个好的开发框架至关重要。一个号的开发框架应该能够分离关注面，使美工、开发工程师可以各司其事，易于协作。同时还应该内置一些安全策略，防护Web用攻击。页面渲染将分别开发维护的动态内容和静态页面模板集成起来，组合成最终显示给用户的完整页面。负载均衡将多台应用服务器组成一个集群，通过负载均衡技术将用户请求分发到不同的服务器上，以应对大量用户同时访问时产生的高并发负载压力。Session管理为了实现高可用的应用服务器集群，应用服务器通常设计为无状态，不保存用户请求上下文信息，但是网站业务通常需要保持用户会话信息，需要专门的机制管理Session，使集群内甚至跨集群的应用服务器可以共享Session。动态页面静态化对于访问量特别大而更新又不很频繁的动态页面，可以将其静态化，即生成一个静态页面，利用静态页面的优化手段加速用户访问，如反向代理、CDN、浏览器缓存等。业务拆分将复杂而庞大的业务拆分开来，形成多个规模较小的产品，独立开发、部署、维护，除了降低系统耦合度，也便于数据库业务分库。按业务对关系数据库进行拆分，技术难度相对较小，而效果又相对较好。虚拟化服务器将一台物理服务器虚拟化成多态虚拟服务器，对于并发访问较低的业务，更容易用较少的资源构架高可用的应用服务器集群。3.服务层架构提供基础服务，供应用层调用，完成网站业务。分布式消息利用消息队列机制，实现业务和业务、业务和服务之间的异步消息发送及低耦合的业务关系。分布式服务提供高性能、低耦合、易复用、易管理的分布式服务，在网站实现面向服务架构（SOA）。分布式缓存通过可伸缩的服务器集群提供大规模热点数据的缓存服务，是网站性能优化的重要手段。分布式配置系统运行需要配置许多参数，如果这些参数需要修改，比如分布式缓存集群加入新的缓存服务器，需要修改应用程序客户端的缓存服务器列表配置，并重启应用程序服务器。分布式配置在系统运行期提供配置动态推送服务，将配置修改实时推送到应用系统，无需重启服务器。4.存储层架构提供数据、文件的持久化存储访问与管理服务。分布式文件网站在线业务需要存储的文件大部分都是图片、网页、视频等比较小的文件，但是这些文件的数量非常庞大，而且通常都在持续增加，需要伸缩性设计比较好的分布式文件系统。关系数据库大部分万丈的主要业务是基于关系数据库开发的，但是关系数据库对集群伸缩性的支持表较差。通过在应用程序的数据访问层增加数据库访问的路由功能，根据业务配置将数据库访问路由到不同的物理数据库上，可实现关系数据库的分布式访问。NoSQL数据库目前各种NoSQL数据库层出不穷，在内存管理、数据模型、集群分布式管理等方面各有优势，不过从社区活动性角度看，HBase无疑是目前最好的。数据同步在支持全球范围内数据共享的分布式数据库技术成熟之前，拥有多个数据中心的网站必须在多个数据中心之间进行数据同步，以保证每个数据中心都拥有完整的数据。在实践中，为了减轻数据库压力，将数据库的事物日志（或者NoSQL的写操作Log）同步到其他数据中心，根据Log进行数据重演，实现数据同步。5.后台架构网站应用中，除了要处理用户的实时访问请求外，还有一些后台非实时数据分析要处理。搜索引擎即使是网站内部的搜索引擎，也需要进行数据增量更新及全量更新、构建索引等。这些操作通过后台系统定时执行。数据仓库根据离线数据，提供数据分析与数据挖掘服务。推荐系统社交网站及购物网站通过挖掘人与人之间的关系，人和商品之间的关系，发展潜在的人际关系和购物兴趣，为用户提供个性化推荐服务。6.数据采集与监控监控网站访问情况与系统运行情况，为网站运营决策和运维管理提供支持保障。浏览器数据采集通过在网站页面中嵌入JS脚本采集用户浏览器环境与操作记录，分析用户行为。服务器业务数据采集服务器业务数据包括两种，一种是采集在服务器端记录的用户请求操作日志；一种是采集应用程序运行期业务数据，比如待处理消息数目等。服务器性能数据采集采集服务器性能数据，如系统负载、内存使用率、网卡流量等。系统监控将前述采集的数据以图表的方式展示，以便运营和运维人员监控网站运行状况，做到这一步仅仅是系统监视。更先进的做法是根据采集的数据进行自动化运维，自动处理系统异常状况，是吸纳自动化控制。系统报警如果采集来的数据超过预设的正常情况的阀值，比如系统负载过高，就通过邮件、短信、语音电话等方式发出警报信号，等待工程师干预。7.安全架构保护网站免遭攻击及敏感信息泄露。Web攻击以HTTP请求的方式发起的攻击，危害最大的就是XSS和SQL注入攻击。但是只要措施得当，这两种攻击都是比较容易防范的。数据保护敏感信息加密传输与存储，保护网站和用户资产。8.数据中心机房架构大型网站需要的服务器规模数以十万计，机房物理架构也需要关注。机房架构对于一个拥有十万台服务器的大型网站，每台服务器耗电（包括服务器本身耗电及空调耗电）每年大约需要人民币2000元，那么网站每年机房电费就需要两亿人民币。数据中心能耗问题日趋严重，Google、Facebook选择数据中心地理位置的时候趋向选择散热良好，供电充裕的地方。机柜架构包括机柜大小，网线布局、指示灯规格、不间断电源、电压规格（是48V直流电还是220V民用交流电）等一系列问题。服务器架构大型网站由于服务器采购规模庞大，大都采用定制服务器的方式代替购买服务器整机。根据网站应用需求，定制硬盘、内存、甚至CPU，同时去除不必要的外设接口（显示器输出接口，鼠标、键盘输入接口），并使空间结构利于散热。", "architecture/实时数据库.md": "1实时数据库vs关系型DB写入速度：实时数据库要求写入速度快，没有事务处理要求。读取方式和速度：SQL的读取方式不适应实时数据，RDB读取的速度也难满足要求。压缩性：由于实时数据具有连续性、重复性、关联性等特征，实时数据常常要求常驻内存，不压缩难以保存大量数据。数据备份存储：RDB只能整体备份存储，存储部分是无意义的，而实时DB要求可以部分存储和恢复。2现有的方案美国OSIsoft公司，PI；在国内应用最多，主要用于大型行业用户，如电力、石油、化工和冶金等。美国Wonderware公司，IndustrialSQLServer，简称INSQL；美国AspenTech公司，InfoPlus；北京庚顿：www.goldendata.com.cn**报价**：PI10万美元，每个接口6000美元，OPC接口收费；InfoPlus.2111万美元，每个接口1万美元，OPC接口不收费；IndustrialSQLServer6.5万美元，每个IDAS1200美元，OPCLink免费。优势：入门快。能借用这些企业快速的进入我们不熟悉的行业。方案成熟，坑少。劣势：成本高。技术基础受限制。参考：实时数据库简介和比较www.cnblogs.com/guohu/p/5165163.html实时数据库简介blog.csdn.net/liqfyiyi/article/details/6862886实时数据库www.voidcn.com/article/pftegnynisc.html3开源或替代方案**开源方案：**BekeleyDb只支持单机的，不支持网络访问，基本不适用。**替代方案：**采用Redis替代。读写速度能满足要求，但没有压缩存储能力，备份机制可能支持。采用HBase替代。参考：基于分布式存储的开源系统在实时数据库海量历史数据存储项目上的预研blog.csdn.net/rjj510/article/details/7987074劣势：Redis、HBase替代方案都只满足部分要求，不满足的部分必然影响功能或性能，可用于小规模应用，如果要支持大规模、稳定性要求高的应用，需要投入开发成本。4结论开源方案基本没有；如果是要求高的大型应用，建议选择购买，国外厂商太贵，国内厂商可以咨询一下北京庚顿价格；如果做一个要求不高的应用，从成本考虑，可以选择替代方案。", "architecture/容灾系统.md": "类型数据容灾定义：建立一个异地的数据系统，该系统是本地关键应用数据的一个可用复制。又称为异地数据复制技术主要技术数据备份数据复制实现的技术方式同步传输方式异步传输方式按容灾的距离分远程数据容灾近程数据容灾应用容灾定义：在数据容灾的基础上，在异地建立一套完整的与本地生产系统相当的备份应用系统主要技术负载均衡集群技术按容灾的距离分本地系统集群和热备份网络故障切换机制，应用切换到其它服务器远程故障切换能力和故障诊断能力等级第0级：本地备份仅能应付本地的硬件损坏或人为因素造成的灾难第1级：异地数据冷备份成本低、易于配置存储介质难管理，恢复慢第2级：异地数据热备份在异地建立一个热备份点，通过网络进行数据备份备份站点一般只备份数据，不承担业务数据丢失量小，恢复速度慢第3级：异地应用级容灾建立两个数据中心，它们都处于工作状态，并进行相互数据备份分类：①两个数据中心之间只限于关键数据的相互备份②两个数据中心之间互为镜像，即零数据丢失等衡量指标RPO：能容忍的数据丢失量RTO：恢复时间关键技术SAN或NAS技术远程镜像技术定义镜像是在多个系统上产生同一个数据的存储过程分类本地镜像远程镜像又叫远程复制分类同步远程镜像异步远程镜像快照技术快照是通过软件对数据快速扫描，建立要备份数据的快照逻辑单元号LUN和快照cache远程镜像技术往往同快照技术结合实现远程备份快照是通过内存作为缓冲区（快照cache）快照技术将其备份到磁带库或光盘库中基于IP的SAN的互连技术基于SAN的远程复制：早期即通过光纤通道FC，把两个SAN连接起来，进行远程镜像（复制）实现成本高、设备的互操作性差、跨越的地理距离短可以跨越LAN、MAN和WAN成本低、可扩展性好基于IP的互连协议：FCIP、iFCP、Infiniband、iSCSI等", "architecture/工业4.0时代的物联网架构实践之道.md": "物联网四要素物体、数据、连接、分析智能制造对终端平台的需求平台扩展性通用开发框架硬件外设驱动低成本的芯片低耗电传感器链接无线链接BLE,WiFi,MBB有线链接Ethernet,USB集成MCU/功能单元GPIO,I2C,SPI工业协议链接Modbus安全性数据传输安全平台架构安全平台升级远程在线平台升级应用管理终端应用的远程部署/更新云集成云端集成或适配集成AMQP,MQTT数据采集!_v_images/20191129172636.png!_v_images/20191129172648.png数据分析!_v_images/20191129172656.png!_v_images/20191129172706.png参考架构!_v_images/20191129172717.png", "architecture/常见算法题目.md": "TOC递归之逆序打印输入一组数，然后以相反的顺序输出。分析:根据函数递归调用的进栈和出栈基本原理，即读入数据，进栈，遇到结束递归条件，出栈，输出数据。因为读入数据和输出数据恰好相反，实现了逆序。```cinclude<stdio.h>voidreversePrint{intn;scanf\"%d\",&n;ifn!=0{reversePrint;printf\"%4d\",n;}else{printf\"\\n输出一组反序数：\\n\";}}voidmain{printf\"输入一组整数（以0结束）：\";reversePrint;}```汉诺塔汉诺塔问题（又称河内塔问题）是根据一个传说形成的一个问题：有三根杆子A，B，C。A杆上有N个N>1穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：每次只能移动一个圆盘；大盘不能叠在小盘上面。提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须尊循上述两条规则。问：如何移？最少要移动多少次？```Cinclude<stdio.h>voidhanoiintn,charA,charB,charC{ifn==1{printf\"Movedisk%dfrom%cto%c\\n\",n,A,C;//把第n个盘子从A移到C}else{hanoin1,A,C,B;//把剩下的n1个盘子借助C从A移到Bprintf\"Movedisk%dfrom%cto%c\\n\",n,A,C;hanoin1,B,A,C;//把剩下的n1个盘子借助A从B移到C}}voidmain{intn;printf\"请输入数字n以解决n阶汉诺塔问题：\\n\";scanf\"%d\",&n;hanoin,'A','B','C';}```枚举法下列问题具有的共同特点是：不能用方程求解，只能一一列举各种情况，选取满足要求的解。（1）鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、母、雏各几何？分析：公鸡i,母鸡j,小鸡ki+j+k=1005*i+3*j+k/3=100```Cinclude<stdio.h>voidmain{inti,j,k;printf\"鸡翁母鸡鸡雏\\n\";printf\"\\n\";fori=1;i<20;i++{forj=0;j<33;j++{k=100ij;ifi*15+j*9+k==300printf\"%5d%5d%5d\\n\",i,j,k;}}}```最大公约数和最小公倍数使用辗转相除法求最大公约数；然后，利用最大公约数和最小公倍数的关系：lcmm,n*gcdm,n=m*n来求最小公倍数```Cinclude<stdio.h>//辗转相除法求最大公约数（基于递归）intgcdintm,intn{intmod=m%n;//求m和n的余数ifmod==0{//mod==0,则n为最大公约数,否则求（n,mod的最大公约数returnn;}else{returngcdn,mod;}}//辗转相除法求最大公约数（基于循环）intgcd2intm,intn{intmod;do{mod=m%n;//求m和n的余数m=n;n=mod;//修改m,n的值}whilemod!=0;returnm;}intlcmintm,intn{returnm*n/gcdm,n;}voidmain{intresult=gcd26,9;printf\"\\ngcd=%d\\n\",result;}```对字符数组进行排序非字典顺序```java/**在JAVA中对数组K,q,a,F,j,A,f排序，要求排序结果为：A,a,F,f,K,q.*/importjava.util.*;publicclassCharCaseSort{publicstaticvoidmainStringargs{chararray=newchar{'K','q','a','F','j','A','f'};newCharCaseSort.doSortarray;System.out.printlnarray;//输出:AaFfjKq}//排序,采用最简单的冒泡排序publicchardoSortchararray{charch;forinti=0;i<array.length;++i{forintj=0;j<array.lengthi1;++j{ifthis.comparearrayj,arrayj+1>0{ch=arrayj;arrayj=arrayj+1;arrayj+1=ch;}}}returnarray;}//比较a和b忽略大小写,同时同一个大小写字母,大写的小于小写的privateintcomparechara,charb{charaa=chara|32;charbb=charb|32;ifaa==bb{returna<b?1:1;}elseifaa<bb{return1;}else{return1;}}}```字符串反转的函数分析：把字符串数组的从两端向中心对调。```Cinclude<stdio.h>include<string.h>voidreverse_strchar*ch;voidreverse_str2char*ch;intmainvoid{charc=\"Canyoureverseme?\";printf\"originalstringc:\\n%s\\n\",c;reverse_strc;printf\"reversedstringaftercallingreverse_str:\\n%s\\n\",c;reverse_str2c;printf\"reversedstringaftercallingreverse_str2:\\n%s\\n\",c;system\"pause\";return0;}voidreverse_strchar*ch/*使用中间变量*/{intlen;inti;len=strlench1;charctemp;fori=0;i<leni;i++{ctemp=chi;chi=chleni;chleni=ctemp;}chlen+1=0;}voidreverse_str2char*ch/*不用中间变量*/{intlen;inti;len=strlench1;charctemp;fori=0;i<leni;i++{chi=chi^chleni;chleni=chi^chleni;chi=chi^chleni;}chlen+1=0;}```Fibonacci数列与兔子繁殖问题一般而言，兔子在出生两个月后，就有繁殖能力，此后一对兔子每个月能生出一对小兔子来。小兔长两个月，第三个月生小兔子，如此类推，如果所有兔都不死，那么一年以后可以繁殖多少对兔子？分析：假设在n月有新生及可生育的兔子总共a对，n+1月就总共有b对。在n+2月必定总共有a+b对：因为在n+2月的时候，所有在n月就已存在的a对兔子皆已可以生育并诞下a对后代；同时在前一月n+1月之b对兔子中，有ba对在当月属于新诞生的兔子尚不能生育，所以n+2月兔子数为a+a+ba=a+b。这正是一个Fibonacci数列，递推公式为：fn=fn1+fn2。所以可以用递归程序来解答。```Cinclude<stdio.h>longflongn{ifn<3return1;elsereturnfn2+fn1;}voidmain{printf\"一年后，有兔子%ld对.\\n\",f12;getch;}```1123581321345589...可以把递归改写为循环：```Cinclude<stdio.h>f2intn{longf1,f2;inti;f1=f2=1;fori=1;i<=n/2;i++{printf\"%12ld%12ld\",f1,f2;ifi%2==0printf\"\\n\";/*控制输出，每行四个*/f1=f1+f2;/*前两个月加起来赋值给第三个月*/f2=f1+f2;/*前两个月加起来赋值给第四个月*/}}voidmain{printf\"一年后，有兔子%ld对.\\n\",f212;getch;}```````javapublicclassFibonacci...{publicstaticvoidmainStringargs...{intfib=newint20;fib0=0;fib1=1;forinti=2;i<fib.length;i++fibi=fibi1+fibi2;forinti=0;i<fib.length;i++System.out.printfibi+\"\";System.out.println;}}```求素数算法分析求某一个范围内的素数（质数）。素数是指只能被1和自身整除的整数。分析：检查一个正整数N是否为素数，最简单的方法就是试除法，将该数N用小于等于sqrtN的所有素数去试除，若均无法整除，则N为素数。那么，我们先来一个算法简单的，将该数N用小于等于sqrtN的所有整数去试除：```Cinclude<stdio.h>include\"math.h\"prime_number1intbegin,intend{intm,i,k,h=0,leap=1;form=begin;m<=end;m++{k=sqrtm+1;fori=2;i<=k;i++ifm%i==0{leap=0;break;}ifleap{printf\"%4d\",m;h++;ifh%10==0printf\"\\n\";}leap=1;}printf\"\\nThetotalis%d\",h;}intmain{prime_number1100,200;return0;}```用小于等于sqrtN的所有整数去试除，有点浪费，我们用小于等于sqrtN的所有素数去试除该数，程序如下：```Cinclude<stdio.h>include\"math.h\"definetrue1definefalse0_Booldivisibleintn,intprimes{inti;fori=0;primesi>0;i++{ifn%primesi==0{returntrue;}}returnfalse;}voidget_primesintLIMIT{inti,j,primesLIMIT;j=0,primes0=2;fori=3;i<=LIMIT;i+=2{if!divisiblei,primes//用小于等于sqrtN的所有素数去试除该数primes++j=i;}fori=j+1;i<LIMIT;i++primesi=0;//输出结果fori=0;primesi>0;i++{printf\"%8d\",primesi;ifi%10==9printf\"\\n\";}}intmain{get_primes150;printf\"\\n\\n\";return0;}```下面说说，筛法求1nn≤200以内素数。分析:由希腊著名数学家埃拉托色尼提出的所谓“筛法”，步骤如下：①将所有候选数放入筛中；②找筛中最小数（必为素数）next，放入集合primes中；③将next的所有倍数从筛中筛去；④重复②～④直到筛空。程序如下：```Cinclude<stdio.h>include\"math.h\"definetrue1definefalse0voidprime2{inti,j,h,k=0,p100={0},a200={0};fori=1;i<200;i++ai=i+1;/*将所有候选数放入筛中*/fori=0;i<200;i++forj=0;j<200;j++ifai!=0{pk=ai;/*将最小数放入素数集合p中*/forh=k;h<200;h++ifah%pk==0ah=0;/*将这个素数的倍数从筛中删去*/k++;}i=0;printf\"primes:\";whilepi!=0{printf\"%5d\",pi;/*打印出所有素数*/i++;}}intmain{prime2;printf\"\\n\\n\";return0;}```在zh.wikipedia.org上看到一种效率更高的算法，大致看了一下，应该可行，但是求100以内的素数，会丢掉97这个素数。具体算法如下：欲求出小于x的所有素数……根据素数分布特性可以把数除以6，得其余数（n为大于0,小于x的平方根/6的正整数。）：6n+0……偶数（2的倍数）。6n+1……可能樗厥？6n+2……偶数（2的倍数）。6n+3……3的倍数。6n+4……偶数（2的倍数）。6n+5……可能为素数？所以，如果预先排除了2与3的，那只要算6n+1c6n+5是否樗厥就可以了。这样，搜寻范围减少至原先的2/3，也比单独排除偶数少了1/3。程序如下：```Cinclude<stdio.h>include\"math.h\"definetrue1definefalse0intprimeintLIMIT{_BoolsieveLIMIT+1;inti,p,j,p2;intnLIMIT=LIMIT6;fori=7;i<=nLIMIT;i+=6{sievei=true;sievei+2=false;sievei+4=true;}p=5;whilej=p*p<=LIMIT{p2=p<<1;whilej<=LIMIT{sievej=false;j+=p2;}do{p+=2;}whilesievep==false;}printf\"Primenumbers:\\n\";printf\"2,3,5\";nLIMIT=LIMIT4;fori=7;i<=nLIMIT;i+=2{ifsieveiprintf\",%d\",i;i+=4;ifsieveiprintf\",%d\",i;}return0;}intmain{prime100;printf\"\\n\\n\";return0;}```", "architecture/技术知识体系层次.md": "技术知识体系层次理论基础。非常重要；应该从书上获取，在笔记中不应收集；技术入门使用。技术入门使用方面知识不应收集到笔记中；最好以代码形式放入Github中，如learning库；技术架构解决方案。多种技术的组合使用，如：kafka+sparkstreaming实时数据处理；行业典型解决方案；专题总结，总结成熟的技术方案，如：报表；技术架构解决方案可以收集到笔记中，能代码实现的方案，一定需要代码实现，放入Github中；产品。包括中间件、平台、项目等。**总结**：笔记中以收集【技术架构解决方案】为主，清理其他内容；【技术入门使用】知放入Github的learning库中空余学习性编程主要是三个方面：技术入门使用、技术架构解决方案、产品；日常工作中，应该是工作任务+（理论基础|学习性编程）；避免碎片化学习问题式学习方法原则**缩小关注圈，扩大影响圈。**自己完全搞不懂的知识不要花时间、收藏，努力加深已知知识深度，扩大自己已知知识的外延（广度）。知识结构化。用思维导图来组织自己的所有知识。721原则。70%时间和精力花在练习上，20%花在思考与讨论上，10%花在碎片化信息浏览上。互联网时代学习知识方法!_v_images/20191129175216.png", "architecture/插件容器文档.md": "1.插件容器原理1.1插件容器提供的功能容器主要提供统一的权限管理（认证、授权、鉴权）和插件管理功能。权限管理采用Shiro、redis在应用层来实现，抛弃了tomcat等web服务器提供的session管理功能。结构如下图：!_v_images/20191129170204.png统一认证认证功能是由容器提供，插件不提供认证功能。用户在容器中认证后，容器将已认证的jSessionId传送给插件，插件通过jSessionId从redis中获取用户的认证信息，即完成统一的认证过程。用户可以通过Shiro的提供的API来获取用户的认证信息，可以参考SecurityUtils.getSubject的用法。统一授权统一授权是指统一管理插件的资源，统一授予给用户。插件注册时，将自身的资源注册到容器中，容器统一管理所有插件的资源；管理员可以通过容器提供的权限管理功能，将这些资源分配给用户。统一鉴权判断用户是否具有资源的访问权限，即鉴权。统一鉴权是指在容器和插件中，采用统一的权限校验方式来判断用户是否可以访问某资源，插件无需为鉴权开发任何功能。用户通过认证后，将获取所拥有的插件资源访问权限，并将此权限信息缓存入redis数据库，而插件通过jSessionId从redis中获取用户的权限信息，完成权限校验。页面的鉴权是通过tag完成的，目前提供freemaker和jsp两套标签。鉴权标签是通过资源url来判断的，所以插件必须保证自身提供的资源url在所有插件资源中是唯一的。插件管理与监控插件管理提供插件注册、启用/停用、修改、删除等功能，而插件监控主要是监控插件的运行状况，当插件异常停止时，发出告警信息。1.2统一认证和授权的过程用户访问业务系统的认证及鉴权过程如下：!_v_images/20191129170238.png插件获取认证授权信息过程如下：!_v_images/20191129170246.png2.插件开发文档2.1插件注册插件注册到应用插件容器有两种方式：插件启动时注册容器容器提供的插件注册接口：url：xxx.xxx.xxx.xxx:port/{contextPath}/uaa/reg,参数：插件自解释JSON，参见下面的插件自解释接口返回值：{status:,message:}，status为0表示调用成功，1表示失败；message为返回信息插件启动后，在容器段手动添加插件提供自解释接口（接口返回内容参见下面插件自解释接口），在插件容器输入该自解释地址，手动添加插件**插件自解释接口**标准如下：```javascript{\"id\":\"pluginId\",\"name\":\"插件Demo\",\"uaaUrl\":\"192.168.0.209:8080/uaa/ck\",\"menuJson\":\"{'id':'pluginId','name':'插件2','pid':null,'description':null,'pageurl':null,'type':1,'state':'是','sort':null,'icon':null},{'id':'pluginId_list','name':'列表','pid':'pluginId','description':null,'pageurl':'/system/plugin/list','type':1,'state':'是','sort':null,'icon':null},{'id':'pluginId_update','name':'修改','pid':'pluginId','description':null,'pageurl':'/system/plugin/update','type':0,'state':'是','sort':null,'icon':null},{'id':'pluginId_delete','name':'删除','pid':'pluginId','description':null,'pageurl':'/system/plugin/delete','type':0,'state':'是','sort':null,'icon':null}\"}```插件自解释接口中的menuJson字段的值是一个JSON字符串，用来传递插件资源，是资源的列表。除menuJson之外的信息是插件自身的信息。2.2插件接收授权的URL地址插件必须实现一个接收认证授权信息的URL，该URL接收成功认证后的jSessionId。在用户登录时，这个URL链接将被客户端浏览器访问，插件将该jSessionId存入浏览器的Cookie中，这个cookie作为用户通过认证的唯一标识。浏览器拥有这个Cookie后，表明插件的权限管理被容器接管，插件资源已被容器授权控制。PS:这个URL需要填入到插件自解释接口的uaaUrl中。这个地址实现的功能是将jSessionId写入浏览器Cookie，此jSessionId是采用DES对称加密过的，实现参考：idbpuaashiro工程中UaaConsumer类writeCookie方法，如下：```javaStringCryptodes=newStringCrypto;jid=des.decryptjid;//针对IE，必须加P3P到header中，否则无法写入cookieresponse.addHeader\"P3P\",\"CP=\\\"CURaADMaDEVaPSAoPSDoOURBUSUNIPURINTDEMSTAPRECOMNAVOTCNOIDSPCOR\\\"\";Cookiecookie=newCookie\"SHAREJSESSIONID\",jid;cookie.setMaxAge1;//浏览器关闭此Cookie时效cookie.setPath\"/\";response.addCookiecookie;//加入Cookies```2.3ShiroRedis缓存配置ShiroRedis缓存配置有两种方式：基于Spring配置、基于INI配置。Spring配置参考：idbpplugin1的applicationContextshiroprod.xml文件INI配置参考：idbpplugin2jfinal的shiro.ini文件", "architecture/敏捷项目管理-在互联网公司中的应用.md": "toc参考书籍《管理3.0:培养和提升敏捷领导力》《Scrum敏捷软件开发》我们需要什么样的管理和流程？无流程反复无常无管理成本，所有工作都是为了软件产出人数多了后，开发过程混乱，质量降低管理者随时提出需求，产品经理考虑不周全无组织无纪律写单元测试？没时间。系统太复杂。太简单没必要强流程例行公事繁琐的文档，大量的规范、标准和管理活动，每一个环节可控过度的设计会议多，成本高，效率低，最要命的是降低团队的主动性、创新性遵循规范，但是不知道规范背后的道理写单元测试，但是自己都不知道有没有效果，集中在一起写为什么写单元测试？更快的反馈产品质量完全由测试人员保障现状：复杂系统理论**当过程运行根本机制相当简单的情况下，典型的做法使用预定义建模方式（在做之前把所有东西想清楚），但是过程复杂程度超过预定义的能力范围，我们会选择经验性方式。**!_v_images/20191129174848.png自适应驾驭自如主管是考理解去做事情。为什么要这样做丰富的经验和技巧，拥有敏锐的“嗅觉”团队拥有自己的流程，规则都是根据团队需要去制定，不多不少自觉遵守团队的流程和纪律产品的计划、质量和问题都是开发和可视化的主动发现和暴露问题，从根源上解决问题有节奏的进行开发**经验型过程的3大支柱：可见性、检查及适应**敏捷缺陷或盲点假设每一个人的能力都很强假设每一个都很守纪律一、造物先造人找一个牛人管理者二流的管理者只会招三流的下属产品经理（掌舵者）开发（齿轮）培养团队文化/价值观/原则（开放、工作激情）有组织有预谋的学习团队分享、读书会教练式的管理者（指导人们正确的做事）授权&&目标指导经验只能从犯错中学习表扬式的管理，鲸鱼哲学**培养团队例子：**有组织有计划的培养，读书计划，检查，所有的例子用TDD方式写一遍学习性团队：每天早上浙江站会一起CodeReview训练营：做题讨论二、清晰的管理模型1、项目规划项目视图/立项制度**项目规划**：各个部门或中心的项目规划――心中有树/术半年/季度**项目要求**：明确的目标、里程碑、规模、各个角色的负责人，开始和结束时间**各个层次的目标**：产品目标、项目目标、发布目标、迭代目标特性团队符合SMART原则搭班子、定战略、带队伍2、项目启动（Quickstart）立项书项目背景、目标/愿景里程碑Userpersonal用户界面原型业务流程图/技术架构图粗粒度的功能列表沟通计划：每天/每迭代/每发布告诉团队项目的管理流程原则：详略得当，不要面面俱到WBS工作任务分解文档不是目的，思考过程，清楚和透彻3、自适应的软件开发方法敏捷（流程可视化）XP、Scrum变态编程：既然这个东西很好，那么我们就要把它做到极致。结对编程<CodeReview，时时刻刻做codereview敏捷Value观Communication（沟通）Simplicity（简单）Feedback（反馈）Courage（勇气）Respect（尊重）4、可视化管理kanban燃尽图。做出燃尽图，表明可控。燃尽图工期是骗人的，一定要有工作量质量可视化（只有两个指标）千行代码的测试密度人均单元测试代码行5、纪律可视化纪律x技能=能力!_v_images/20191129174904.png团队规则需求评审咋做？如何测试？需求变更规则？三、持续的反馈敏捷整个过程都强调反馈PDCA：Plan计划、Do执行、Check检查和Action行动!_v_images/20191129174919.png敏捷PDCA精髓：!_v_images/20191129174928.png各个层面的反馈需求评审/设计评审需求/设计层面的反馈单元测试方法/类层面的反馈交叉编程设计讨论&CodeReview详细设计和代码质量层面的反馈自测/功能验收/测试功能层面的反馈Showcase/灰度上线站立会议/UserStoryWall/燃尽图/回顾会议反馈的有效性更快和频繁的反馈，降低反馈的周期自动化小结文化：工作热情＋开放传统敏捷的错误假设卓越自律我的敏捷＝能力＋反馈纪律×技能＝能力每一个团队都不一样忘记所学，团队自适应全盘思考，增量工作问题驱动，解决实际问题天时、地利、人和用心", "architecture/数据交换.md": "KettleKettleGithubgithub.com/pentaho/pentahokettle数据对接―kettle使用www.niubua.com/?tag=etl&paged=2Kettle中有两种脚本文件，transformation和job，transformation完成针对数据的基础转换，job则完成整个工作流的控制。Kettle家族目前包括4个产品：Spoon、Pan、CHEF、Kitchen。**SPOON**允许你通过图形界面来设计ETL转换过程（Transformation）。**PAN**允许你批量运行由Spoon设计的ETL转换例如使用一个时间调度器。Pan是一个后台执行的程序，没有图形界面。**CHEF**允许你创建任务（Job）。任务通过允许每个转换，任务，脚本等等，更有利于自动化更新数据仓库的复杂工作。任务通过允许每个转换，任务，脚本等等。任务将会被检查，看看是否正确地运行了。**KITCHEN**允许你批量使用由Chef设计的任务例如使用一个时间调度器。KITCHEN也是一个后台运行的程序。scriptella使用简单，使用xml配置、javaapi调用，没有提供Job管理的功能，没有配置界面。scriptellaGithubgithub.com/scriptella/scriptellaetlTwoMinuteTutorialscriptella.javaforge.com/tutorial.htmlScriptellaETLReferencescriptella.javaforge.com/reference/index.htmlCommonsJEXLSyntaxcommons.apache.org/proper/commonsjexl/reference/syntax.htmlDataXDataX是淘宝开源的数据导入导出的工具，解决异构环境的数据交换问题，支持HDFS集群与各种关系型数据库之间的数据交换，对于不同数据库的支持都是插件式的，对于新增的数据源类型，只要新开发一个插件就好了。!_v_images/20191129171418.png其特点在于：1）官方版本支持的Hadoop版本较低（0.19），暂不支持高版本（如CDH4）。2）支持从一个HDFS集群到另一个HDFS集群之间的数据导入导出。3）支持数据不落地的并行导入导出。在异构的数据库/文件系统之间高速交换数据采用Framework+plugin架构构建，Framework处理了缓冲，流控，并发，上下文加载等高速数据交换的大部分技术问题，提供了简单的接口与插件交互，插件仅需实现对数据处理系统的访问运行模式：standalone数据传输过程在单进程内完成，全内存操作，不读写磁盘，也没有IPC开放式的框架，开发者可以在极短的时间开发一个新插件以快速支持新的数据库/文件系统。（具体参见《DataX插件开发指南》）DataX结构模式（框架+插件）!_v_images/20191129171549.pngJob:一道数据同步作业Splitter:作业切分模块，将一个大任务与分解成多个可以并发的小任务.Subjob：数据同步作业切分后的小任务ReaderLoader:数据读入模块，负责运行切分后的小任务，将数据从源头装载入DataXStorage:Reader和Writer通过Storage交换数据WriterDumper:数据写出模块，负责将数据从DataX导入至目的数据地DataX框架内部通过双缓冲队列、线程池封装等技术，集中处理了高速数据交换遇到的问题，提供简单的接口与插件交互，插件分为Reader和Writer两类，基于框架提供的插件接口，可以十分便捷的开发出需要的插件。比如想要从oracle导出数据到mysql，那么需要做的就是开发出OracleReader和MysqlWriter插件，装配到框架上即可。并且这样的插件一般情况下在其他数据交换场合是可以通用的。更大的惊喜是我们已经开发了如下插件：Reader插件hdfsreader:支持从hdfs文件系统获取数据。mysqlreader:支持从mysql数据库获取数据。sqlserverreader:支持从sqlserver数据库获取数据。oraclereader:支持从oracle数据库获取数据。streamreader:支持从stream流获取数据（常用于测试）httpreader:支持从httpURL获取数据。Writer插件hdfswriter：支持向hdbf写入数据。mysqlwriter：支持向mysql写入数据。oraclewriter：支持向oracle写入数据。streamwriter：支持向stream流写入数据。（常用于测试）您可以按需选择使用或者独立开发您自己的插件具体参见《DataX插件开发指南》SqoopSqoop是Apache下的顶级项目，用来将Hadoop和关系型数据库中的数据相互转移，可以将一个关系型数据库（例如：MySQL，Oracle，PostgreSQL等）中的数据导入到Hadoop的HDFS中，也可以将HDFS的数据导入到关系型数据库中。目前在各个公司应用广泛，且发展前景比较乐观。其特点在于：1）专门为Hadoop而生，随Hadoop版本更新支持程度好，且原本即是从CDH版本孵化出来的开源项目，支持CDH4应该没问题。2）支持并行导入，宣称速度很快（由于时间紧，未来得及进行真实环境的测试），可以指定按某个字段进行拆分并行化导入过程。3）支持按字段进行导入与导出。4）自带的辅助工具比较丰富，如sqoopimport、sqooplistdatabases、sqooplisttables等。!_v_images/20191129171637.pngDataXvsSqoopDataX直接在运行DataX的机器上进行数据的抽取及加载。而Sqoop充分里面了mapreduce的计算框架。Sqoop根据输入条件，生成一个mapreduce的作业，在Hadoop的框架中运行。从理论上讲，用mapreduce框架同时在多个节点上进行import应该会比从单节点上运行多个并行导入效率高。而实际的测试中也是如此，测试一个Oracletohdfs的作业，DataX上只能看到运行DataX上的机器的数据库连接，而Sqoop运行时，4台tasktracker全部产生一个数据库连接。调起的Sqoop作业的机器也会产生一个数据库连接，应为需要读取数据表的一些元数据信息，数据量等，做分区。Sqoop现在作为Apache的顶级项目，如果要我从DataX和Sqoop中间选择的话，我想我还是会选择Sqoop。而且Sqoop还有很多第三方的插件。早上使用了Quest开发的OraOop插件，确实像quest说的一样，速度有着大幅的提升，Quest在数据库方面的经验，确实比旁人深厚。在我的测试环境上，一台只有700m内存的，IO低下的oracle数据库，百兆的网络，使用Quest的Sqoop插件在4个并行度的情况下，导出到HDFS速度有5MB/s，这已经让我很满意了。相比使用原生Sqoop的2.8MB/s快了将近一倍，sqoop又比DataX的760KB/s快了两倍。另外一点Sqoop采用命令行的方式调用，比如容易与我们的现有的调度监控方案相结合，DataX采用xml配置文件的方式，在开发运维上还是有点不方便。参考DataX官方Wiki、代码code.taobao.org/p/datax/wiki/index/大数据异构环境数据同步工具DataX与Sqoop之比较www.xiaohui.org/archives/545.html淘宝异构数据源数据交换工具DataXwww.openopen.com/lib/view/1325771223625中软数据交换平台解决方案www.sinosoft.com.cn/khyal/K_ccbx_news/ccbx_news_0009.htmlRiDolDE数据交换平台www.ritoinfo.com/html/software/WhiteBook/20120914913.html", "architecture/日志审计系统.md": "tocblog.csdn.net/cheng_fangang/article/details/42418017blog.csdn.net/qq_38265137/article/details/106790419www.youxia.org/2015/01/13547.html日志审计系统简介什么是日志审计？综合日志审计平台，通过集中采集信息系统中的系统安全事件、用户访问记录、系统运行日志、系统运行状态等各类信息，经过规范化、过滤、归并和告警分析等处理后，以统一格式的日志形式进行集中存储和管理，结合丰富的日志统计汇总及关联分析功能，实现对信息系统日志的全面审计。通过日志审计系统，企业管理员随时了解整个IT系统的运行情况，及时发现系统异常事件；另一方面，通过事后分析和丰富的报表系统，管理员可以方便高效地对信息系统进行有针对性的安全审计。遇到特殊安全事件和系统故障，日志审计系统可以帮助管理员进行故障快速定位，并提供客观依据进行追查和恢复。为什么需要日志审计平台？1.日志审计的合规要求，由于网络安全法的颁布实施，由原先的不合规转变成了不合法。如果不对要求的相关日志不做留存6个月以上，一旦追查，将面临法律责任。2.安全运营的挑战。随着网络设备的增多，以及服务器数量的增多，如果没有统一的综合日志审计平台，那么需要登录到每台设备上查看日志，不利于运维人员管理。而且众多设备会产生海量的日志，无法有效管理。多种设备形成信息孤岛，日志无法关联分析。通过统一的日志审计平台，将所有设备日志都收集到日志平台进行统一管理，统一分析。日志审计的核心目标：多源数据归一化日志存储集中化关联分析自动化安全态势立体化需求背景但是随着信息安全系统的部署和发展，该银行的信息安全工作面临如下的需求：需要建设全面的日志采集需求：需要将接入网络、网站范围内的安全日志及主机系统日志，统一采取日志，集中管理分析。日志规范化需求：由于全网设备种类繁多，各设备日志信息存储格式、字段含义、通信协议差异较大。需要对采集到的各种设备日志进行归一化处理，提取审计记录完整信息，为后续审计分析提供依据。基于策略的日志过滤、归并：面对海量原始日志，需要按照相关策略进行过滤和归并，减轻日志数据传输压力和存储压力。关联分析及审计需求：对于来自各个资源的日志信息，提供多维的关联分析功能。面向系统用户，将一个用户在多个设备上的操作进行横向关联分析，形成以用户为主题的操作行为审计；面向特定安全事件，对于发生在多个设备上的事件痕迹进行关联分析，形成一个完整的事件相关操作过程的审计；从设备角度，形成本设备全部访问情况的安全审计报告。日志存储需求：原始日志信息是来自网络的第一手数据，需要长期存储，并确保它们的完整性、保密性，不得随意访问、修改和删除。同时，由于日志量较大，应提供压缩存储机制。通过实施告警标准化系统，可以达到对告警分级分类展现，提高工作效率的目的。因此，该银行用户希望通过建设一个日志审计平台，实现对各类安全日志进行集中管理并解决以上安全工作难题。日志审计的主要功能统一日志采集：对不同日志源主机系统、网络设备、安全设备、应用中间件、数据库等所产生的日志进行收集，实现日志的集中管理和存储。支持解析任意格式、任意来源的日志，通过解析规则标准化。使用无代理的方式收集日志。支持代理方式的日志收集。关联分析：预置多种事件关联规则。定位外部威胁、黑客攻击、内部违规操作，设备异常。简单灵活定义关联规则。实时告警：通过邮件、短信、声音对发生的告警进行及时通知，并可通过接口调用自动运行程序或脚本。通过告警策略定义，对各类风险和事件进行及时告警或预警，提升运维效率。日志取证分析：深入分析原始日志事件，快速定位问题的根本原因。生成取证报表，例如攻击威胁报表、Windows/Linux系统审计报表以及合规性审计报表等。监管合规：提供Windows审计、Linux审计、PCI、SOX、ISO27001等合规性报表。支持创建自定义合规性报表功能结构!图：日志审计系统产品功能结构_v_images/20200731161608676_3747.png日志的转发方式：日志转发一般可以通过：Syslog转发，Kafka转发，http转发。日志收集一般支持：Syslog、SNMP等日志协议。日志审计系统常见模块：日志事件获取模块：安全事件监控系统是实时掌握全网的安全威胁状况的重要手段之一。通过事件监控模块监控各个网络设备、主机系统等日志信息，以及安全产品的安全事件报警信息等，及时发现正在和已经发生的安全事件，通过响应模块采取措施，保证网络和业务系统的安全、可靠运行。资产管理模块：资产管理实现对网络安全管理平台所管辖的设备和系统对象的管理。它将其所辖IP设备资产信息按其重要程度分类登记入库，并为其他安全管理模块提供信息接口。规则库模块：规则库已支持主流网络设备、主机系统、数据库系统等，而且还应涵盖已经部署的安全系统，包括防火墙系统、防病毒系统等。并提供新日志格式适配功能，支持从安全运营中心平台接收新日志解析映射规则配置。用户可以根据该适配功能，对新日志格式进行自行适配。统计报表功能：具备强大的统计功能，可快速生成多种专业化的报表并支持自定义图表的设定集展示。权限管理模块：超级管理员可根据用户角色分配平台查看、操作各模块的权限，用户可以访问而且只能访问自己被授权的资源", "architecture/时间序列数据库.md": "TOC阅读参考工业大数据漫谈12：实时数据库与时序数据库blog.csdn.net/guanhui1997/article/details/72840769时序列数据库武斗大会之什么是TSDBliubin.org/blog/2016/02/18/tsdbintro/时序列数据库武斗大会之TSDB名录Part1liubin.org/blog/2016/02/25/tsdblistpart1/时序列数据库武斗大会之TSDB名录Part2liubin.org/blog/2016/03/01/tsdblistpart2/InfluxDB与OpenTSDB对比测试blog.fatedier.com/2016/07/06/testinfluxdbandopentsdb/InfluxDBinfluxdb写入数据遇到的错误www.jianshu.com/p/e1e4326f3bf0GettingstartedwithInfluxDBOSSdocs.influxdata.com/influxdb/v1.6/introduction/gettingstarted/InfluxDB使用总结与性能优化blog.csdn.net/eric_sunah/article/details/76274188influxDB与Grafana初体验blog.csdn.net/marksinoberg/article/details/79339140InfluDBdockerinstallhub.docker.com/_/influxdb/", "architecture/明略大数据项目实践分享.md": "问题1.关系数据库到Hadoop的增量同步开源的方案Sqoop基于自增主键的增量同步要求主键自增，且主键丌会被更新基于最新更新时间戳的增量同步要求表中含有最后更新时间戳字段不足之处数据源丌一定都满足使用场景性能损失，每次重做数据数据丌一致，主键更新时导致数据丌一致我们的增强方案基于数据库操作日志的实时增量数据同步方案!_v_images/20191129172746.png优势数据秒级同步性能消耗低，目标数据无需重做数据一致性好，支持主键更新试用场景多，骋求源表有主键戒唯一索引问题2.数据权限需求简单粗暴83为每个权限需求新做数据89数据冗余89笨重丌灵活Hive权限管理+View83可能会有非常多的view需要行管理83可能成千上万的企业用户映射到Hive用户83丌能支撑复杂查询83缺乏统一的跨引擎的权限控制89诚拗Hive查询，限制丌了Impala和SparkSQL明略方案ACRE基于ApacheHadoop精确到cell级别的跨引擎的统一权限管理工具**业务能力**支持基于ACL和RBAC的混合授权模型可以限制开发人员支持Hive、Impala、Spark的统一授权管理支持行列（Cell）基本访问控制基于访问过滤的实现无需修改原数据库/表结构!_v_images/20191129172757.pngCell级别的跨引擎的统一权限管理ACRE原理权限模型行权限Where语句控制库、表、列权限语法树分析!_v_images/20191129172805.png问题3.百亿数据、百万用户的OLAP方案1：传统方案数据库分库把丌同商户分布到丌同的mysql数据库上前端做Proxy行路由问题大数据平台和Mysql之间的数据同步MysqlHA单个用户的数据量过大不易扩展运维成本方案2：基于Impala/SparkSQL等的方案问题商户数据存入一张表戒者多张表时没办法满足高并发按商户分表的话可能会建立非常多的表定制化的处理提高流程的复杂度方案3：明略方案基于Hbase支撑OLAP需求原始数据同步到Hbase构建数据表根据用户查询的各个维度，通过MapReduce行预构建查询索引索引的key为纬度的丌同组合索引的value中存入用户常用的各种metric计算结果**优势**百亿级的数据在秒级甚至亚秒级返回结果基于Hbase的实现轻松支撑高并发请求可视化配置、灵活定义的索引源自于Hadoop系统的超强扩展能力简单总结Hadoop平台面对的是异构多源的数据源，需要能够支持增量同步这些异构数据源的数据安全不权限是企业级客户永丌缺席的需求海量数据高并发的实时BI需求越来越多数据是基础，好的数据应用需要更丰富的数据关键字：数据中心方案、大数据、数据挖掘、Mining、Hadoop、Hive、Hbase、Sqoop、数据权限", "architecture/权限管理模型.md": "1概述各行各业中企业的管理方式千差万别、且纷繁复杂，权限管理设计往往迷失在这种复杂的关系中。而由于企业所在行业和管理方式差别，导致不可能拥有一个统一的模型能满足所有企业的权限管理需求。处理企业特殊的复杂的行政管理关系、建立理想权限模型方式是以RBAC模型为基础，在其上面作一些扩展来实现。这种方式的难点是理清行政管理关系不容易，理不清则建立权限模型也会不合理。2基于RBAC权限模型这篇文章对RBAC权限模型描述的比较清楚：RBAC权限管理模型：基本模型及角色模型解析及举例www.woshipm.com/pd/440765.html。RBAC权限管理模型有四种，分别是RBAC0，RBAC1，RBAC2，RBAC3。它们的区别是RBAC1有继承关系，RBAC2对用户、角色和权限三者之间增加了一些限制，RBAC3=RBAC1+RBAC2。最常用的是RBAC0，其次是RBAC1。现实业务中除了有特殊的要求，否则最好前两种基础上进行扩展，例如：增加Group支持。2.1RBAC+Group!_v_images/20191129180141.png3RBAC与组织机构的结合RBAC是一个理想的模型，而企业的组织机构和管理方式各不相同，必须把RBAC模型和企业组织模型抽象融合在一起，才能适应企业业务需求。这篇文章对非矩阵型结构的企业的权限模型做了详细描述：统一权限管理与组织机构的结合（缩水版）blog.sina.com.cn/s/blog_6df370b70100u8zj.html>岗位的层次表明了不仅在某个组织下的岗位有层次，实际所有岗位组成一颗完整的岗位树，都是树状层次结构中的节点。这是由于每个岗位都有直接上级，也就是他汇报工作的对象。>给部门分配权限和给岗位分配权限是有区别的。由于用户必须隶属于岗位，而岗位隶属于部门，部门的权限用户是不能继承的，部门的权限用来影响岗位权限。部门内的岗位权限不可超出部门权限，并且部门权限可分为通用权限（部门内岗位可自动继承）和特定权限（必须分配到具体岗位）。这样也可以实现分级的权限管理，由总管理员给部门分配权限，然后各部门管理员给本部门岗位分配权限。类似的我们也可以给职务分配权限，职务的权限将自动被关联此职务的岗位获得。>在基于角色的权限模型中，我们给角色分配权限，给用户分配角色，而在组织模型中，我们也需要给组织和岗位分配权限，给用户分配岗位，对比可发现两个模型结合的关键就在岗位和角色的关系上。处理岗位和角色的关系有合并和映射两种方法。>由于大部分的角色就是基于实际的岗位或者职务生成的，因此可以将岗位和角色合而为一，用组织模型的岗位同时表示权限模型的角色概念，直接给岗位、组织、职务分配权限。!_v_images/20191129180202.png3.1Role映射到岗位还是职务？**问题：**如下图所示的组织结构，在流程引擎中配置一个同时适用于研发1、2部请假审批流程，流程需要研发部门经理审批，如果该审批人设置成某一个部门经理的Role（表示岗位），那么流程只能用于其中这个部门。而另一个部门必须再配置一个同样的流程。流程一样而不能复用，这是不合理的。!_v_images/20191129180213.png**解决办法**方法一、将参与者设置成职务，列出该职务对应的岗位负责人，让用户选择审批人。方法二、将参与者设置成职务，通过计算请假人所在部门，通过部门在程序中自动确定审批人。所以，是否可以采用如下设计（不一定合理）：一种更灵活方式是，将Role映射到职务，在控制资源、菜单分配权限时，完全满足需求。当涉及到数据权限时（如：研发1部只能看1部的数据），可以将职务结合人员、数据的所属部门来控制权限。3.2简单数据权限如何融入其中？**问题**：用户如何只查看本部门的数据？用户如何查看跨部门的数据？**方案**：所谓简单数据权限管理是满足各个部门人员只能操作本部门的数据，只有在授权的情况下才能操作其他部门的数据。资源权限的控制方式是给资源加上标识，将此标识分配给Role，然后将Role分配给User，实现权限控制。（resource>roleuser）简单的数据权限控制亦可以借鉴这种方式，为每一条数据加上标识（部门Id），将此标识分配给Role，从而实现数据资源控制；同时，由于此标识是部门Id，直接可以通过User的部门Id来判断是否有操作数据的权限。**待解决的问题**：除了数据权限外，如何控制有效期限、可用额度、适用品种等等。4需求分析4.1RBAC要解决的问题如何对一个部门的人员**批量授权**？如何管理多个系统的角色、如何授权、如何鉴权？如何解决同一Role的用户，具有相同的功能权限，但是他们的数据操作权限不同的问题？“经理”可以查看、审批“普通员工”的工作报告，而“普通员工”只能查看、编辑自己的工作报告。如何控制？人员部门调动、职称发生变化，其权限如何自动变化？如何分级授权？如何适应信息系统和用户数量增加、信息系统功能升级、公司组织变动及岗位调整、业务权限审核人员变动等情况？如何信息留痕：所有权限申请审批、设置、变更记录需要留痕，要做到可检查、可追踪？用户申请权限如何审批？如何实现角色权限配置、用户角色配置分离管理？可参考附件《基于RBAC的用户权限管理的设计与实现》4.2GM权限管理要解决的问题角色是按组织、职务方式来管理，还是按照系统来管理？系统间的角色有共用的吗？org+role=岗位？岗位能确定到人，Role是职务，不能确定到人。为用户分配角色的权限、业务功能权限是否需要分离？开发人员以plugin方式开发、以system方式发布。5多系统的统一权限管理多系统统一权限管理需要解决的问题：建立统一的组织机构、人员、用户的管理提供统一的多系统、多终端的单点登录入口提供统一的授权管理，即各系统不提供授权管理，有统一授权平台来授权提供统一的权限校验方式支持分级授权可参考附件：《医院信息系统分级授权管理机制的研究和设计》根据自己项目的经验，有两点建议吧：1、实时跨系统校验不是一个好的方案，最好在各业务子系统做授权信息的缓存，由统一权限中心往各业务系统推送权限信息，子系统通过统一权限中心服务提供的jar包来管理缓存以及进行访问认证。这样权限系统服务响应慢或者不可用，或者升级等不会影响下游子系统的稳定运行。6待解决的问题Saas架构的权限管理如何设计？针对金融等对安全要求很高行业的权限模型如何设计？参考RBAC权限管理模型：基本模型及角色模型解析及举例www.woshipm.com/pd/440765.html统一权限管理与组织机构的结合（缩水版）blog.sina.com.cn/s/blog_6df370b70100u8zj.html多站点整合―单点登录简单方案blog.csdn.net/u011529563/article/details/12648345", "architecture/流程引擎选型.md": "国产原创snakerflowgithub.com/snakerflow/snakerflowstar451,fork329Snaker是一个基于Java的轻量级工作流引擎，适用于企业应用中常见的业务流程。本着轻量、简单、灵巧理念设计，定位于简单集成，多环境支持。轻量:snakercore.jar大小208K，代码行数约7000行，强大的扩展支持，不依赖于具体的ORM框架简单:表设计简单，流程组件简单start/end/task/custom/subprocess/decision/fork/join灵巧:暴露大量可扩展接口，支持流程设计器、流程引擎的组件模型自定义fixflowgithub.com/fixteam/fixflowstar442,fork262Fixflow是一款开源的基于BPMN2.0标准的工作流引擎,引擎底层直接支持BPMN2.0国际标准,吸纳了jBPM3、Activiti5、BonitaBPM等国际开源流程引擎的精髓,同时提供了强大的中国式流程流转处理,引擎采用微内核+插件形式设计,提供灵活的扩展模式,建模采用基于BPMN2.0标准的Eclipse设计器和基于Web的流程设计器,不仅仅为审批流程提供了解决方案,同时还为复杂业务流程编排提供了强大的支持。FixFLow本身并不具备完整的开发平台功能,它的定位是专门用于集成到现有系统的引擎。UFLOgitee.com/youseries/uflostar244,fork99UFLO2是一款纯Java流程引擎，它架构于Spring、Hibernate之上，提供诸如并行、动态并行、串行、会签等各种常见及不常见的业务流程流转功能，支持单机或集群部署；UFLO2采用全新的基于网页的流程模版设计器，打开网页即可完成流程模版的设计与制作。不是特别完善，不是标准BMPN，功能不全。JFlowgitee.com/opencc/JFlow驰骋工作流引擎研发与2003年，具有.net与java两个版本，这两个版本代码结构，数据库结构，设计思想，功能组成，操作手册，完全相同。导入导出的流程模版，表单模版两个版本完全通用。功能比较全，代码不清晰，难以嵌入到已有项目中。基于Activiti定制openwebflowgithub.com/bluejoe2008/openwebflowstar460基于Activiti的工作流引擎扩展，接管了Activiti对活动权限以及用户表的管理，并提供了催办、代办、加签（包括前加签/后加签）、自由跳转、分裂节点等功能jundworkflowgithub.com/zhijund/jundworkflowstar43基于Activiti5定制化中国式工作流系统，定制化的流程设计器，添加自定义属性。", "architecture/渐进式图片流式传输.md": "渐进式图片流式传输一、渐进式图片JPG图片支持两种编码方式：基线式（Baseline）和渐进式（Progressive）。渐进式在编码的时候，要多次扫描图片，计算开销大约是基线式的3到5倍。但是比起Google的WebP图片格式编码810倍开销还是小得很多。基线式与渐进式两者编码出来的文件大小基本相同基线式的编码方式是图片从上到下，从左到右地进行处理和编码。渐进式编码方式是先全局后局部，先轮廓再细节的编码方法。渐进式图片编码特性，可以被用来有选择性地控制传输的数据量，提高传输的成功率。除了JPEG支持渐进式编码格式，其它比如WebP、HEVC在设计上也都支持渐进式的。二、流式传输数据像流水一样在网络中传输，通信双方在数据传输进行的过程中就即时处理，而不是等全部数据接收完毕再处理。VS整体的文件传输，图片分片传输。三、图片最小传输长度对渐进式图片传输的数据有一个最低长度要求，保证收到的图片基本可用，称这个长度为图片最小传输长度（MinimalTransportSize）。发送方只要发送图片的最小传输长度，即可向用户展示发送成功，然后转到后台尽量把完整数据发送完毕。参考：微信图片优化之秘：C2C渐进式图片流式传输系统mp.weixin.qq.com/s?src=3&timestamp=1490954714&ver=1&signature=cOaIC8LeZ7x1h8*nR35Gib7vU*ibCzA8SSURam4gu0VgpoLXO6O3Y7TtzuBJp0A7tf5ZlUYC*gwf*zFeVstHRf2mNPRAdQHK*Ptg4DPadFzxSFd6*EoxKwqR9aGgL8ck9rh3Waocq3vnewF3srZmYFZ1dsUFNI11TE6uBzc0=", "architecture/王涛_金融行业中的大数据应用.md": "www.infoq.com/cn/presentations/bigdataapplicationsinfinancialindustryTOC大数据技术HadoopHadoop的13个基本框架Spark：分布式内存计算框架Spark特点新一代数据库分类K/V宽表/列存储文档图数据库SequoiaDBSequoiaDB特点用JSON统一存储非结构化/半结构化和结构化数据不依赖于Hadoop,但同时融合SQL/Hadoop/Spark擅长在线实时查询和离线统计分析支持交易事务,但不擅长OLTP简化大数据技术堆栈!_v_images/20191129174219.png典型场景1.历叱全量数据的利用2.海量非结构化数据的低成本存储3.创新应用中的数据灵活管理4.宠户实时精准营销（客户画像）", "architecture/系统性能指标.md": "说明：这里说明每秒N个请求，就是QPS。而不是请求一个html页面而附带请求的css,js,图片。因为我关心的是应用程序处理业务的能力。基本概念：**Throughput（吞吐量）**：按照常规理解网络吞吐量表示在单位时间内通过网卡数据量之和，其中即包括本机网卡发送出去的数据量也包括本机网卡接收到的数据量。一个100Mb位的双工网卡，最大发送数据的速度是12.5M字节/s，最大接收数据的速度是12.5M字节/s，可以同时收发数据。**并发用户数**：是同时执行操作的用户线程数。**响应时间**：从请求发出到收到响应花费的时间。**QPS**QueriesPerSecond每秒处理的查询数（如果是数据库，就相当于读取）**TPS**TransactionsPerSecond每秒处理的事务数如果是数据库，就相当于写入、修改**IOPS**，每秒磁盘进行的I/O操作次数例如对某个数据库测试，分开两次测QPS与TPS。QPS（读取）值总是高于TPS写、改，并且有倍率关系，因为：1、数据库对查询可能有缓存。2、机械硬盘或SSD硬盘的读就是比写快。参考：性能术语服务器端性能优化提升QPS、RT最佳线程数总结（1）QPS每秒查询率QueryPerSecond每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。术语说明：QPS=req/sec=请求数/秒【QPS计算PV和机器的方式】QPS统计方式一般使用http_load进行统计QPS=总请求数/进程总数*请求时间QPS:单个进程每秒请求服务器的成功次数单台服务器每天PV计算公式1：每天总PV=QPS*3600*6公式2：每天总PV=QPS*3600*8服务器计算服务器数量=ceil每天总PV/单台服务器每天总PV【峰值QPS和机器计算公式】原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间公式：总PV数*80%/每天秒数*20%=峰值时间每秒请求数QPS机器：峰值时间每秒QPS/单台机器的QPS=需要的机器问：每天300wPV的在单台机器上，这台机器需要多少QPS？答：3000000*0.8/86400*0.2=139QPS问：如果一台机器的QPS是58，需要几台机器来支持？答：139/58=3", "architecture/缓存技术.md": "tocORM缓存基本理念减少DB磁盘IO尽量设计细颗粒度的表尽量避免多表关联查询技巧利用表关联实现透明的对象缓存按照column拆表实现细粒度对象缓存写一致性缓存片段缓存和过期处理对象写入缓存其他缓存技巧用数据库来实现的缓存HTTP客户端缓存用缓存实现计数器功能缓存架构分类单机缓存OSCache可缓存任何对象可缓存部分jsp页面或HTTP请求Ehcache源于Hibernate进程中的缓存优缺点性能最高，代价最小适合数据量不大、并发要求不高无法扩展、缓存的数据量受限集群环境无法共享简单分布式缓存单实例的memcachedOSCache和Enhence的分布式缓存用JGroups广播，同步缓存数据使用复制方式的缓存集群必要条件缓存的数据量不大，没有超过单机的限制需要极高的读取缓存的性能缓存中的数据变更的频率不是特别大方式使用虚拟IP的方式将多个缓存实例作为一个集群使用散列方式的缓存集群必要条件需要缓存的数据量特别巨大需要极高的读取缓存的性能允许单点故障高性能高、可靠的缓存集群REST缓存实现方式通用缓存：Memcache，Redis反向代理非常适合作为URL的缓存服务器Varnish/SquidHTTP请求缓存方式缓存控制HTTP头中“Cachecontrol”字段来控制也可以通过“Expires”字段来设定过期时间条件请求与电子标签LastModifiedETagIfModifiedSince/IfNoneMatchRedis/NoSQL缓存内存模式Memcached缓存的总数据大小受限于内存的大小Redis强大的内存存储功能Redis功能、性能超越MemcachedTokyoTyrant持久化模式热点数据存入内存，非热点数据存储到磁盘NoSQL缓存的过期策略最好不使用时间过期，而是数据是否被更新过其他分类一级缓存单独的服务器，多机共享二级缓存对单WebServer进行数据共享MyBatis缓存一级缓存（localcache），即本地缓存，作用域默认为session二级缓存（secondlevelcache），作用域默认为MapperNamespace缓存侵入性", "architecture/表单及其技术研究.md": "TOCExcel转Htmlblog.csdn.net/qq_22206899/article/details/80874635首先实现office系列文件在线预览主要查到有如下解决方案:1.flash的flexpaper将文档转换为swf格式，然后使用flash在网页中浏览2.使用开源的软件openoffice+pdf2htmlEx，利用openoffice的接口先将文档转换为pdf格式，然后在使用pdf2htmlEx将文档转换为html直接在网页中显示，3.利用OpenOffice+JodConverter将word2003转换成html或者pdf文件4.自己搭建一个文档预览服务器，基于officewebapp,也就是微软的officeonline，开源的内容管理系统KodExplorer就是这么干的。5.Javapoi将html转化6.docx4j7.用第三方收费组件：PageOffice8.虚拟打印机Excel相关框架Aspose.Cells官网地址：products.aspose.com/cells，例子：github.com/asposecells/Aspose.CellsforJava这是个收费的excel处理库，看过官方文档，功能相当强大，基本可以包括了Excel的常见的功能。如果基于它写一个UI，完全可以替换excel。它还提供了一个gridweb.jar包，可以实现基于web的excel。JETTjett.sourceforge.net/index.htmlJETTJavaExcelTemplateTranslatorisaJava5.0APIthatallowsspeedycreationofExcelspreadsheetreportsusingExcelspreadsheettemplates.JETTallowsthedevelopertofollowtheMVCpatterneasily.JETTistheController,thedevelopercreatestheModel,andeitherthedeveloperoranotherpartycontrolstheExcelspreadsheettemplate,whichactsastheView.TosummarizeJETT,thedevelopersuppliesanExcelspreadsheettemplate,whichprovidesthestructure,layout,andstylingoftheresultantspreadsheet.Then,thedevelopercreatesbeansthatcontaintheactualdatatobepopulatedinthespreadsheet.Finally,thedeveloperusesanExcelTransformer,theJETTAPIentrypoint,totransformthetemplatespreadsheetintotheresultantspreadsheet,completewiththedesireddata,whichcanthenbepublished.x4janalyticgithub.com/jbaliuka/x4janalyticx4janalyticisanopensourceXLSXformattemplateengineAPIforJavaprogramminglanguage.X4JisusedastheembeddedlibraryinJavaapplicationstoimplementfullblownreportingsolutions.JXLSjxls.sourceforge.net/JxlsisasmallJavalibrarytomakegenerationofExcelreportseasy.JxlsusesaspecialmarkupinExceltemplatestodefineoutputformattinganddatalayout.报表应用将报表制作开发成一个独立的应用，用户（程序员）只需填入SQL、调整页面布局即可生成报表。使用简单，零开发成本，缺点是数据源接入受限于配置，与现有程序集成困难；报表布局设置较死板，制作灵活报表困难。适合简单的报表制作。EasyReportgithub.com/xianrendzw/EasyReportAsimpleandeasytouseWebReportSystemforjavaEasyReport是一个简单易用的Web报表工具,它的主要功能是把SQL语句查询出的行列结构转换成HTML表格Table，并支持表格的跨行RowSpan与跨列ColSpan。同时它还支持报表Excel导出、图表显示及固定表头与左边列的功能。专业的报表集成开发工具此类工具功能强大，但都需要一定的学习成本。BIRTwww.eclipse.org/birt/BusinessIntelligenceandReportingToolsBIRTAnopensourcetechnologyplatformusedtocreatedatavisualizationsandreportsthatcanbeembeddedintorichclientandwebapplications.帆软报表（收费）", "architecture/表达式及规则引擎.md": "TOCExpressionLanguageExpressionLanguage/ExpressionEngine/RuleEnginegithub.com/oldratlee/javamoderntechpractice/issues/11Java各种规则引擎www.jianshu.com/p/41ea7a43093cTop17ExpressionEvaluatorawesomeopensource.com/projects/expressionevaluatorSpringExpressionLanguageSpEL一种强大的表达式语言，支持在运行时查询和操作对象图。该语言语法类似于UnifiedEL，但提供了一些附加功能，最值得注意的是方法调用和基本字符串模板功能。SpringExpressionLanguageSpEL官方文档docs.spring.io/spring/docs/current/springframeworkreference/core.htmlexpressions说说Spring表达式语言（SpEL）中的各种表达式类型www.jianshu.com/p/5537b2c86acdAviator一个轻量级的、高性能的java表达式计算器。Aviator将表达式编译为字节码，并对其进行动态求值。github.com/killme2008/aviator/wikigithub.com/killme2008/aviatorQLExpressapowerful,lightweight,dynamiclanguagefortheJavaplatformaimedatimprovingdevelopers’productivityindifferentbusinessscenes.github.com/alibaba/QLExpressMVELMVFLEXExpressionLanguageMVELhaslargelybeeninspiredbyJavasyntax,buthassomefundamentaldifferencesaimedatmakingitmoreefficientasanexpressionlanguage,suchasoperatorsthatdirectlysupportcollection,arrayandstringmatching,aswellasregularexpressions.MVELisusedtoevaluateexpressionswrittenusingJavasyntax.mvel.documentnode.com/github.com/mvel/mvelJEXLJavaExpressionLanguagealibraryintendedtofacilitatetheimplementationofdynamicandscriptingfeaturesinapplicationsandframeworks.commons.apache.org/proper/commonsjexl/github.com/apache/commonsjexl3/5=0,默认不自动转为浮点型JUELJavaUnifiedExpressionLanguageanimplementationoftheUnifiedExpressionLanguageEL,specifiedaspartoftheJSP2.1standardJSR245,whichhasbeenintroducedinJEE5.Additionally,JUEL2.2implementstheJSP2.2maintenancereleasespecificationforfullJEE6compliance.juel.sf.net/github.com/beckchr/juelEvalExEvalExisahandyexpressionevaluatorforJava,thatallowstoevaluatesimplemathematicalandbooleanexpressions.github.com/uklimaschewski/EvalEx其它Groovy/JS/kotlinGroovy作为表达式语言，解析的性能太差。不过一旦编译生成Script对象（缓存），性能还是不错。JS作为表达式语言，解析的性能太差，且不支持在表达式中嵌入自定义Function。kotlin作为脚本语言还不成熟，问题多多。RuleEngineDroolsDroolsExpertistheruleengineandDroolsFusiondoescomplexeventprocessingCEP.www.drools.org/github.com/kiegroup/droolseasyrulesprovidestheRuleabstractiontocreateruleswithconditionsandactions,andtheRulesEngineAPIthatrunsthroughasetofrulestoevaluateconditionsandexecuteactions.github.com/jeasy/easyrules/wikigithub.com/jeasy/easyrules", "architecture/规则引擎.md": "概述规则引擎是为一些多变的业务需求提供一种配置而非硬编码的解决方案。drools参考:小明历险记：规则引擎drools教程一zhuanlan.zhihu.com/p/28528925droolsexamplesgithub.com/ityouknow/droolsexamples如：```100元以下,不加分100元500元加100分500元1000元加500分1000元以上加1000分```对应的部分规则如下：```importcom.neo.drools.entity.Orderrule\"zero\"nolooptruelockonactivetruesalience1when$s:Orderamout<=100then$s.setScore0;update$s;end```EsperEsper是用于CEP（复杂事件处理）和ESP（事件流处理）应用程序的组件。参考：Esper入门介绍及热身（一）joshpersistence.iteye.com/blog/2032397Esper入门例子（二）joshpersistence.iteye.com/blog/2033466Esper典型的应用：1、Esper可以用在股票系统、风险监控系统等等要求实时性比较高的系统中。2、业务处理管理和自动化（处理监控，业务活动监控，异常报告，经营智能化等等）3、财务（算法交易，欺诈检查，风险管理）4、网络及应用程序监控（入侵检测，SLAServiceLevelAgreement监控）5、传感器网络应用（RFID读取，生产线调度和控制，空中交通）```classApple{privateintid;privateintprice;}//监听器classAppleListenerimplementsUpdateListener{publicvoidupdateEventBeannewEvents,EventBeanoldEvents{ifnewEvents!=null{Doubleavg=DoublenewEvents0.get\"avgprice\";System.out.println\"Apple'saveragepriceis\"+avg;}}}//测试类publicclassTest{publicstaticvoidmainStringargsthrowsInterruptedException{EPServiceProviderepService=EPServiceProviderManager.getDefaultProvider;EPAdministratoradmin=epService.getEPAdministrator;Stringproduct=Apple.class.getName;Stringepl=\"selectavgpricefrom\"+product+\".win:length_batch3\";EPStatementstate=admin.createEPLepl;state.addListenernewAppleListener;EPRuntimeruntime=epService.getEPRuntime;Appleapple1=newApple;apple1.setId1;apple1.setPrice5;runtime.sendEventapple1;}}```easyruleseasyrulesgithubgithub.com/jeasy/easyrulesspringeasyrulessamplegithub.com/jonashackt/springeasyrules```java@Rulename=\"weatherrule\",description=\"ifitrainsthentakeanumbrella\"publicclassWeatherRule{@ConditionpublicbooleanitRains@Fact\"rain\"booleanrain{returnrain;}@ActionpublicvoidtakeAnUmbrella{System.out.println\"Itrains,takeanumbrella!\";}}publicclassTest{publicstaticvoidmainStringargs{//definefactsFactsfacts=newFacts;facts.put\"rain\",true;//definerulesRuleweatherRule=...Rulesrules=newRules;rules.registerweatherRule;//firerulesonknownfactsRulesEnginerulesEngine=newDefaultRulesEngine;rulesEngine.firerules,facts;}}```其他引擎URULEgithubgithub.com/youseries/uruleURULE是一款基于RETE算法的纯Java规则引擎，提供规则集、决策表、决策树、评分卡，规则流等各种规则表现工具及基于网页的可视化设计器，可快速开发出各种复杂业务规则。", "architecture/访问日志设计.md": "访问日志的用途记录用户的访问痕迹统计用户常访问的页面统计系统的高峰访问时段统计系统最常被用到的功能（可以针对这些功能做优化）实现方案基于RMDB实现每一条点击日志都记入RMDB，价值不大；日志写入频繁，RMDB写入性能不高，容易拖累业务系统；计算点击总次数，影响业务系统性能；点击次数统计准确，实时性好。基于NoSQL（redis）实现NoSQL支持的数据结构简单，做复杂的统计困难。比如：针对某人做点击统计；写入性能较好，不拖累业务系统。采用logback等记录点击日志，用异步程序分析日志文件，将分析结果写入RMDB在Linux下日志文件写入性能很高；若分析要求不高，可以用shell或简单程序实现；可以对接ELK（Elasticsearch,Logstash,Kibana），实现专业的日志分析。其它专业日志系统比如scribe,具备处理海量并发，海量数据的能力，但运维成本高。参考电影url点击次数统计功能设计greenmoon.iteye.com/blog/1633411", "architecture/面向对象编程一些方法和原则.md": "开发eatamail有感建立模型：数据对象有：SMTP服务器，邮件方法和原则：ER分析方法分块与类的设计：读取邮件的XML配置文件读取邮件模板并实例化发送邮件方法和原则：分块组合和职责单一找出每一个块提供的对外方法：读取邮件的XML配置文件读取XML解析XML文件，转换为Java对象读取邮件模板并实例化读取模板实例化模板并输出文本内容发送邮件初始化邮件配置发送邮件方法和原则：面向接口编程设计方法的实现细节采用流程图、时序图、方法注释来理清流程方法和原则：思考重于实现为每个方法建立测试用例，并逐一测试方法和原则：测试驱动开发以结果为导向编码方法和原则：由果及因，小步快跑VS由因及果，一步到位完善文档编写使用手册、README整理设计文档方法和原则：后期文档重于前期文档", "architecture\\FEBS/开发教程.md": "toc项目目录结构www.kancloud.cn/mrbird/springcloud/1265031后端项目结构如下所示：├─febsapm微服务APM模块│├─febsadmin微服务监控中心│├─prometheusgrafanaprometheusgrafanaapm相关配置，docker文件│└─skywalkingelkskywalkingelk相关配置，docker文件├─febsauth微服务认证服务器├─febscloud整个项目的父模块│├─sqlSQL脚本│├─postmanpostman脚本│└─dockercompose项目相关dockercompose文件├─febscommon通用模块│├─febscommoncore系统核心依赖包│├─febscommondatasourcestarter系统数据库自动装配starter│├─febscommondoc文档模块的核心依赖包│├─febscommondocgatewaystarter网关聚合微服务子系统api文档自动装配starter│├─febscommondocstarter微服务子系统api文档自动装配starter│├─febscommonredisstarter系统Redis自动装配starter│└─febscommonsecuritystarter微服务子系统安全配置自动装配starter├─febsgateway微服务网关├─febsserver微服务子系统│├─ebsserversystem微服务子系统系统核心模块│├─febsservertest微服务子系统demo模块│├─febsservergenerator微服务子系统代码生成模块│└─febsserverjob微服务子系统任务调度模块└─febstxmanager微服务分布式事务控制器如何添加自己的子系统www.kancloud.cn/mrbird/springcloud/1647291为了规范，建议将微服务子系统添加到febsserver层级下。```xml<parent><groupId>cc.mrbird</groupId><artifactId>febsserver</artifactId><version>2.1RELEASE</version><relativePath>../pom.xml</relativePath></parent><dependencies><dependency><groupId>cc.mrbird</groupId><artifactId>febscommoncore</artifactId><version>${febscloud.version}</version></dependency></dependencies>``````yamlfebs:cloud:security:enable:truesecurity:oauth2:resource:id:${spring.application.name}userinfouri:${febsgateway}:8301/auth/user```如何控制权限www.kancloud.cn/mrbird/springcloud/1265033后端控制后端资源权限控制使用SpringCloudSecurity权限注解控制，比如下面这个资源只有拥有\"user:add\"权限的用户可以访问：```JAVA@PostMapping@PreAuthorize\"hasAnyAuthority'user:add'\"publicvoidaddUserUseruserthrowsFebsException{this.userService.createUseruser;}```前端控制```XML<buttonvhaspermission=\"'user:add'\">新增用户</button>```项目打包www.kancloud.cn/mrbird/springcloud/1268277mvnclean和mvnpackagePostMan测试第三方登录使用指南以GitHub登录为例数据权限数据权限通常是通过部门或者组织架构来绑定的，目前系统没有组织架构，只有部门数据，所以在FEBSCloud中，数据权限通过部门ID绑定。`@DataPermissionmethods={\"selectPage\"}`注解用于控制数据权限，含义是：DataPermissionTestMapper的selectPage方法开启数据权限。开启后，数据查询前系统会在原始查询SQL中拼接xx.dept_idinxxx语句：Feign的使用Feign用于一个微服务子系统调用另一个微服务子系统的接口，本质就是http请求。但是我们的微服务都是受保护的，没有合法的令牌是无法获取到数据的，并且Fein默认并不会帮我们传递令牌。获取当前用户信息febscommoncore包下的FebsUtil工具类中。`getCurrentUser`、`getCurrentUsername`、`getCurrentUserAuthority`、`getCurrentTokenValue`全局异常控制所谓的全局异常捕获指的是系统的最外层Controller层的异常捕获。febscommoncore包中的BaseExceptionHandler类中定义了系统中几种常见的异常处理开启系统API文档目前较为流行的自动api生成框架为swagger，不过UI界面并不怎么适合国人的使用习惯，FEBSCloud集成的是Knife4J，下面演示下如何开启微服务API文档生成。starter使用介绍`febscommonsecuritystarter``febscommondocstarter``febscommonredisstarter``febscommondatasourcestarter`分布式事务演示演示前，请确保已经启动了febstxmanager、febsauth、febsgateway、febsserversystem和febsservertest。演示5种获取令牌方式OAuth2协议规范了4种获取令牌的方式：授权码模式、密码模式、客户端模式和简化模式，具体可以参考tools.ietf.org/html/rfc6749section4.1。SpringCloudOAuth2在此基础上添加了刷新令牌方式。", "architecture\\FEBS/搭建教程.md": "1.第一章基础框架搭建www.kancloud.cn/mrbird/springcloud/1263687JDK1.8SpringBoot2.1.6.RELEASESpringCloudGreenwich.SR1SpringCloudOAuth2SpringCloudSecurity1.1.架构预览!系统架构图s2.ax1x.com/2019/08/31/mxMgW8.png=1024xFEBSRegister：微服务注册中心，用于统一控制各个微服务实例的注册与发现；FEBSGateway：微服务网关，统一处理外部请求，是客户端和众多微服务连接的桥梁；FEBSAuth：微服务认证服务器，用于令牌（Token）生成和令牌校验，是整个权限系统的核心所在；FEBSServerSystem：微服务提供者（资源服务器）A，对外提供系统模块的CRUD服务；FEBSServerTest：微服务提供者（资源服务器）B。1.2.搭建微服务注册中心www.kancloud.cn/mrbird/springcloud/1263688在这一节中，我们先使用Eureka构建微服务注册中心（Eureka服务端），因为Eureka较为简单，无须启动第三方服务，只需要引入相关依赖即可。1.3.搭建认证服务器www.kancloud.cn/mrbird/springcloud/1263689借助SpringCloudOAuth和SpringCloudSecurity搭建一个统一给微服务发放访问令牌的认证服务器febsauth。1.4.搭建微服务网关www.kancloud.cn/mrbird/springcloud/1263690在微服务的架构中，服务网关就是一个介于客户端与服务端之间的中间层。在这种情况下，客户端只需要跟服务网关交互，无需调用具体的微服务接口。这样的好处在于，客户端可以降低复杂性，无需关注具体是哪个微服务在提供服务。这一节我们将使用SpringCloudZuul搭建微服务网关febsgateway。1.5.搭建资源服务器www.kancloud.cn/mrbird/springcloud/14207202.架构完善这一章主要对上一节搭建的基础框架进行完善，解决微服务权限系统常见的问题。2.1.参数配置化www.kancloud.cn/mrbird/springcloud/1263694`springbootconfigurationprocessor````java@Data@SpringBootConfiguration@PropertySourcevalue={\"classpath:febsauth.properties\"}@ConfigurationPropertiesprefix=\"febs.auth\"publicclassFebsAuthProperties{privateFebsClientsPropertiesclients={};privateintaccessTokenValiditySeconds=60*60*24;privateintrefreshTokenValiditySeconds=60*60*24*7;}``````inifebs.auth.accessTokenValiditySeconds=86400febs.auth.refreshTokenValiditySeconds=604800febs.auth.clients0.client=febsfebs.auth.clients0.secret=123456febs.auth.clients0.grantType=password,authorization_code,refresh_tokenfebs.auth.clients0.scope=all```2.2.异常处理www.kancloud.cn/mrbird/springcloud/12636952.3.Feign的使用www.kancloud.cn/mrbird/springcloud/1263696微服务之间服务的调用可以借助SpringCloudFeign来完成，SpringCloudFeign内部整合了SpringCloudRibbon和SpringCloudHystrix，所以它具有客户端负载均衡和服务容错的功能。`springcloudstarteropenfeign````java@EnableFeignClients@SpringBootApplicationpublicclassFebsServerTestApplication{......``````java@FeignClientvalue=\"FEBSServerSystem\",contextId=\"helloServiceClient\",fallbackFactory=HelloServiceFallback.classpublicinterfaceIHelloService{@GetMapping\"hello\"Stringhello@RequestParam\"name\"Stringname;}```2.4.微服务防护www.kancloud.cn/mrbird/springcloud/1263697自定义Zuul过滤器解决这个问题的大致思路是：在网关转发请求前，请求头部加入网关信息，然后在处理请求的微服务模块里定义全局拦截器，校验请求头部的网关信息，这样就能避免客户端直接访问微服务了。在自定义Zuul过滤器前，我们先来简单了解下Zuul的核心过滤器。Zuul中默认定义了4种不同生命周期的过滤器类型。PRE：PRE过滤器用于将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址，并做一些前置加工，比如请求的校验等；ROUTING：ROUTING过滤器用于将外部请求转发到具体服务实例上去；POST：POST过滤器用于将微服务的响应信息返回到客户端，这个过程种可以对返回数据进行加工处理；ERROR：上述的过程发生异常后将调用ERROR过滤器。ERROR过滤器捕获到异常后需要将异常信息返回给客户端，所以最终还是会调用POST过滤器。2.5.跨域处理www.kancloud.cn/mrbird/springcloud/1263698```java@ConfigurationpublicclassFebsGateWayCorsConfigure{@BeanpublicCorsFiltercorsFilter{finalUrlBasedCorsConfigurationSourcesource=newUrlBasedCorsConfigurationSource;finalCorsConfigurationcorsConfiguration=newCorsConfiguration;//允许cookie跨域corsConfiguration.setAllowCredentialstrue;//请求头部允许携带任何内容corsConfiguration.addAllowedHeaderCorsConfiguration.ALL;//允许任何来源corsConfiguration.addAllowedOriginCorsConfiguration.ALL;//允许任何HTTP方法corsConfiguration.addAllowedMethodCorsConfiguration.ALL;source.registerCorsConfiguration\"/**\",corsConfiguration;returnnewCorsFiltersource;}}```3.完善登录流程3.1.表结构设计www.kancloud.cn/mrbird/springcloud/1263701!用户角色权限s2.ax1x.com/2019/08/13/mpOPpR.png3.2.完善登录www.kancloud.cn/mrbird/springcloud/1263702`mybatisplusbootstarter``dynamicdatasourcespringbootstarter`MyBatisPlus多数据源依赖`mysqlconnectorjava`3.3.整合图形验证码www.kancloud.cn/mrbird/springcloud/1263703SpringSecurity本质是一长串的过滤器链，处理用户名密码登录的过滤器为`UsernamePasswordAuthenticationFilter`，要集成图形验证码校验很简单，只需要在`UsernamePasswordAuthenticationFilter`过滤器前添加图形验证码校验过滤器即可。我们通常会把验证码存储在Redis中，并设置失效时间。SpringBoot2.0后推荐使用Lettuce来代替Jedis，Lettuce基于Netty异步，拥有更好的性能。生成图形验证码可以借助GitHub的一个开源项目`github.com/whvcse/EasyCaptcha`，其提供了较为丰富的验证码配置可供选择。在febsauth的pom里引入该依赖：<dependency><groupId>com.github.whvcse</groupId><artifactId>easycaptcha</artifactId><version>1.6.2</version></dependency>在前后端不分离的架构下，我们通过浏览器传输的jsessionid来和验证码图片一一对应，但前后的分离的模式下，客户端发送的请求并没有携带jsessionid（因为不再基于Session），所以我们需要客户端在发送获取验证码请求的时候，携带一个key（比如按一定算法生成的随机字符串，模拟jsessionid）来和验证码一一对应。于是我们在create里一开始就从请求中获取key值，然后根据验证码配置文件生成验证码，并将验证码字符保存到了Redis中（RedisKey为febs.captcha.+客户端上送的key值，有效时间为配置文件定义的120秒），并将验证码图片以流的形式返回给客户端。```java@ComponentpublicclassValidateCodeFilterextendsOncePerRequestFilter{@AutowiredprivateValidateCodeServicevalidateCodeService;@OverrideprotectedvoiddoFilterInternalHttpServletRequesthttpServletRequest,HttpServletResponsehttpServletResponse,FilterChainfilterChainthrowsServletException,IOException{//校验验证码```3.4.Sentinel验证码限流www.kancloud.cn/mrbird/springcloud/1263704因为我们的验证码服务是免认证的，所以只要知道了地址就可以频繁的去获取验证码，这无形之中给服务器增加了很大的压力，甚至可能导致服务器宕机。为了解决这个问题，我们可以在网关处整合阿里巴巴开源的Sentinel流量哨兵来限制验证码的获取频率。`com.alibaba.csp:sentinelzuuladapter:1.6.3````java@ConfigurationpublicclassFebsGatewaySentinelFilter{....@PostConstructpublicvoiddoInit{initGatewayRules;}/***定义验证码请求限流，限流规则：*60秒内同一个IP，同一个key最多访问10次*/privatevoidinitGatewayRules{Set<ApiDefinition>definitions=newHashSet<>;Set<ApiPredicateItem>predicateItems=newHashSet<>;predicateItems.addnewApiPathPredicateItem.setPattern\"/auth/captcha\";ApiDefinitiondefinition=newApiDefinition\"captcha\".setPredicateItemspredicateItems;definitions.adddefinition;GatewayApiDefinitionManager.loadApiDefinitionsdefinitions;Set<GatewayFlowRule>rules=newHashSet<>;rules.addnewGatewayFlowRule\"captcha\".setResourceModeSentinelGatewayConstants.RESOURCE_MODE_CUSTOM_API_NAME.setParamItemnewGatewayParamFlowItem.setParseStrategySentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM.setFieldName\"key\".setMatchStrategySentinelGatewayConstants.PARAM_MATCH_STRATEGY_EXACT.setParseStrategySentinelGatewayConstants.PARAM_PARSE_STRATEGY_CLIENT_IP.setCount10.setIntervalSec60;GatewayRuleManager.loadRulesrules;}}```4.整合Swagger4.1.完善febsserversystemwww.kancloud.cn/mrbird/springcloud/1263707因为febsserversystem模块负责用户管理、角色管理、菜单管理、部门管理等模块的增删改查，所以这章将演示如何在febsserversystem模块里集成swagger，其他微服务系统要集成swagger照猫画虎就行了。集成MyBatisPlus配置p6spyp6spy用于在控制台中打印MyBatis执行的SQL。用户管理模块增删改查暴露服务数据校验PostMan测试4.2.接入Swaggerwww.kancloud.cn/mrbird/springcloud/1263708`io.springfox:springfoxswagger2:2.9.2``io.springfox:springfoxswaggerui:2.9.2`4.3.SwaggerOAuth2认证www.kancloud.cn/mrbird/springcloud/1263709我们在febsauth模块里配置一个新的Client，专门用于Swagger令牌发放。在febsauth模块的febsauth.properties配置文件里添加如下配置:```inifebs.auth.clients1.client=swaggerfebs.auth.clients1.secret=123456febs.auth.clients1.grantType=passwordfebs.auth.clients1.scope=test```5.整合第三方服务5.1.整合SpringBootAdminwww.kancloud.cn/mrbird/springcloud/1263712SpringBootAdmin通过`springbootstarteractuator`提供的REST接口实现了图形化的监控界面，包括应用的配置信息、Beans信息、环境属性、线程信息、JVM状况等。SpringBootAdmin分为服务端和客户端。客户端通过HTTP向服务端提供自身信息，服务端收集这些信息并以图形化界面的方式呈现。下面，SpringBootAdmin客户端简称为SBA客户端，SpringBootAdmin服务端简称为SBA服务端。整合SpringBootAdmin后，我们的系统架构如下所示:!系统架构图s2.ax1x.com/2019/08/31/mxQHHA.png=1024x`de.codecentric:springbootadminserver:2.1.6``de.codecentric:springbootadminserverui:2.1.6`5.2.SleuthZipkin链路追踪www.kancloud.cn/mrbird/springcloud/1263713一个复杂的业务流程通常会被拆分多个微服务系统来完成，微服务间通过Feign来通信。当业务流程足够复杂时，一个完整的HTTP请求调用链一般会经过多个微服务系统，要通过日志来跟踪一整个调用链变得不再那么简单。我们可以通过SpringCloudSleuth来解决这个问题。整合SpringCloudSleuth`org.springframework.cloud:springcloudstartersleuth`从日志里捞取traceId并追踪请求链路。借助zipkin实现使用图形化界面的方式追踪请求链路。整合Zipkin在整合Zipkin之前，我们需要先搭建RabbitMQ。RabbitMQ用于收集Sleuth提供的追踪信息，然后ZipkinServer从RabbitMQ里获取，这样可以提升性能。5.3.logback日志打印www.kancloud.cn/mrbird/springcloud/12637145.4.ELK日志收集www.kancloud.cn/mrbird/springcloud/1263715搭建ELK环境修改微服务日志配置我们分别在febsauth、febsgateway和febsserver模块的pom里引入`Logstash`依赖`net.logstash.logback:logstashlogbackencoder:6.1`，并增加logbackspring.xml配置：```xml<!输出到logstash的appender><appendername=\"logstash\"class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\"><destination>192.168.33.10:4560</destination><encodercharset=\"UTF8\"class=\"net.logstash.logback.encoder.LogstashEncoder\"/></appender><rootlevel=\"info\"><appenderrefref=\"logstash\"/></root>```6.前端系统介绍FEBSCloud的前端FEBSCloudWeb采用vueelementadmin，它是一款基于vue和elementui实现的后台管理系统模板。6.1.封装Axioswww.kancloud.cn/mrbird/springcloud/12637186.2.Vue导航守卫www.kancloud.cn/mrbird/springcloud/12637196.3.动态路由构建www.kancloud.cn/mrbird/springcloud/12637206.4.处理用户登录www.kancloud.cn/mrbird/springcloud/1263721!登录流程s2.ax1x.com/2019/08/28/mHF6WF.png6.5.处理令牌刷新www.kancloud.cn/mrbird/springcloud/1263722我们在febsauth定义的令牌有效时间为86400秒（即24小时），过了24小时候令牌就失效了。假如令牌即将要失效时，用户还在使用系统，那么用户的某个操作可能进行了一半时，系统突然弹出登录过期提示，非常影响用户体验。要解决上面的问题，我们可以在令牌将要失效时，判断用户是否还在使用系统，如果是的话，我们可以偷偷地通过刷新令牌来获取一个新的访问令牌，存储到浏览器内存中。这样就可以在用户无感知的情况下，“延长”访问令牌的有效时间。因为我们系统的请求都是通过6.1节封装的Axios对象来完成的，并且我们在request.js里配置了请求拦截，所以我们刷新令牌的动作也可以在请求拦截器里完成，大致步骤如下图所示：!处理令牌刷新s2.ax1x.com/2019/08/28/mH8sDP.png6.6.自定义Vue权限指令www.kancloud.cn/mrbird/springcloud/1263723`<buttonvhaspermission=\"'user:add'\">新增用户</button>`7.微服务部署7.1.微服务Docker化www.kancloud.cn/mrbird/springcloud/12637267.2.使用DockerCompose部署www.kancloud.cn/mrbird/springcloud/12637278.微服务进阶8.1.令牌存储策略www.kancloud.cn/mrbird/springcloud/1277531RedisTokenStore在第一章搭建认证服务器的时候，我们使用的是RedisTokenStore令牌存储策略。使用这种策略时，用户的access_token将存储到Redis中，退出登录后，Redis中存储的令牌也会被清除。除了这种令牌存储策略外，Spring还提供了InMemoryTokenStore、JdbcTokenStore和JwtTokenStore三种存储策略：InMemoryTokenStore该策略将令牌存储到内存中，优点就是无需依赖第三方存储，对于开发小型服务是不错的选择；缺点是认证服务器故障重启后，之前存储的令牌就丢失。JdbcTokenStore顾名思义，该策略使用数据库来存储令牌。在使用这种策略之前，我们需要先准备好库表。SpringSecurityOAuth仓库可以找到相应的脚本，只需要使用到oauth_access_token和oauth_refresh_token数据表。JwtTokenStore前面三种存储策略生成的令牌都是使用UUID生成的无意义字符串，我们也可以使用JwtTokenStore生成JWT格式令牌。在febsauth模块下认证服务器配置类FebsAuthorizationServerConfigure中配置JwtTokenStore。8.2.使用CloudGateway搭建网关www.kancloud.cn/mrbird/springcloud/1263731这一节，我们将使用SpringCloudGateway构建一个全新的微服务网关，代替之前通过SpringCloudZuul构建的微服务网关。和Zuul相比，SpringCloudGateway具有如下优势：基于Reactor模型的WebFlux构建，运行在Netty上，具有更好的性能；可拓展性高，内置了非常丰富的转发规则，除此之外，我们也可以定义自己的转发规则。对于WebFlux不熟悉的同学可以在学完本节后阅读我的博文：mrbird.cc/tags/WebFlux/。`org.springframework.cloud:springcloudstartergateway`转发规则SpringCloudGateway两大核心概念为：谓词工厂和过滤器工厂，谓词工厂用于定义转发规则，过滤器工厂用于修改请求和响应。SpringCloudGateway内置的谓词工厂和过滤器工厂可以参考：cloud.spring.io/springcloudgateway/reference/html/gatewayrequestpredicatesfactories和cloud.spring.io/springcloudgateway/reference/html/gatewayfilterfactories。```ymlspring:cloud:gateway:routes:id:FEBSAuthuri:lb://FEBSAuthpredicates:Path=/auth/**filters:StripPrefix=1id:FEBSServerSystemuri:lb://FEBSServerSystempredicates:Path=/system/**filters:StripPrefix=1id:FEBSServertesturi:lb://FEBSServerTestpredicates:Path=/test/**filters:StripPrefix=1```定义全局过滤器8.3.使用AlibabaNacos注册中心www.kancloud.cn/mrbird/springcloud/12711338.4.使用AlibabaNacos存储配置www.kancloud.cn/mrbird/springcloud/1289434SpringCloudAlibabaNacos不但可以用于搭建微服务注册中心，还可以统一管理微服务配置，类似于SpringCloudConfig。Nacos数据持久化Nacos支持使用MySQL进行数据持久化。使用Nacos管理配置增加依赖`org.springframework.cloud:springcloudstarteralibabanacosconfig````ymlspring:application:name:FEBSAuthcloud:nacos:discovery:serveraddr:${nacos.url}:8001config:serveraddr:${nacos.url}:8001group:DEFAULT_GROUPprefix:febsauthfileextension:yaml```8.5.接入Prometheus+Grafana这节的目的是搭建一个多维度监控微服务的可视化平台，包括Docker容器监控、MySQL监控、Redis监控和微服务JVM监控等，并且在必要的情况下可以发送预警邮件。这节主要用到的组件有Prometheus、Grafana、alertmanager、node_exporter、mysql_exporter、redis_exporter、cadvisor。各自作用如下所示：1.Prometheus：获取、存储监控数据，供第三方查询；2.Grafana：提供Web页面，从Prometheus获取监控数据可视化展示；3.alertmanager：定义预警规则，发送预警信息；4.node_exporter：收集微服务端点监控数据；5.mysql_exporter：收集MySQL数据库监控数据；6.redis_exporter：收集Redis监控数据；7.cadvisor：收集Docker容器监控数据。8.6.整合skywalking分布式追踪www.kancloud.cn/mrbird/springcloud/1337996Skywalking是由国人吴晟开发的一款分布式追踪软件，后面成功孵化为Apache的顶级项目。Skywalking主要包括了分布式追踪、性能指标分析、应用和服务依赖分析等功能，使用体验后个人感觉比zipkin更为直观，是替代zipkin的一个不错的选择。Skywalking的主要结构图如下所示:!s2.ax1x.com/2019/10/20/Kutat0.png=1024x从上图可以看出Skywalking主要分为四个模块：agent、collector、webappui和storage。我们可以使用Skywalkingagent探针无侵入地接入SpringCloud应用，然后通过HTTP或者GRPC将应用数据采集到collector收集器。collector中的数据存储与storage，支持MySQL、H2、Elasticsearch等存储，最终这些数据集中在webappui以图形化的方式呈现。8.7.升级到Hoxton.RELEASEwww.kancloud.cn/mrbird/springcloud/14117359.K8S集群部署9.1.集群环境准备www.kancloud.cn/mrbird/springcloud/1426915这一章节，我们的目标是通过Kubernetes（下面简称k8s，因为k和s之间有8个字符，所以俗称k8s）部署一个高可用的FEBSCloud微服务权限系统，所以在此之前你需要掌握Kubernetes的基本知识。如果您还未曾接触过Kubernetes，可以通过我的博客mrbird.cc/tags/Kubernetes/或者购买《Kubernetes权威指南第4版》书籍学习。9.2.安装第三方服务www.kancloud.cn/mrbird/springcloud/1426916这一节我们需要安装的内容较多，包括Docker、DockerCompose、MySQL、Redis、ELK等软件。9.3.Kubeadm搭建K8S1.16.2集群www.kancloud.cn/mrbird/springcloud/1426917Kubernetes从1.4版本开始后就引入了kubeadm用于简化集群搭建的过程，在Kubernetes1.13版本中，kubeadm工具进入GA阶段，可用于生产环境Kubernetes集群搭建。本节将使用Kubeadm搭建Kubernetes1.16.2集群，宿主机使用9.1里搭建的master、node1、node2、node3四台虚拟机，即一主三从的K8S集群结构。9.4.NFS服务器搭建www.kancloud.cn/mrbird/springcloud/1426918在K8S中，我们虽然可以使用volume将容器内目录挂载到宿主机目录上，但由于Pod调度的不确定性，这种数据存储方式是不牢靠的。对于有状态的应用，我们希望无论Pod被调度到哪个节点上，它们的数据总能够完整地恢复，这时候我们就不能用volume挂载了，而应该使用“网络共享存储”。9.5.搭建Docker镜像仓库Harborwww.kancloud.cn/mrbird/springcloud/1426919在本地环境下（或者公司局域网），将Docker镜像推送到DockerHub速度比较慢，推荐的做法是安装一个第三方的Docker镜像仓库，这里推荐使用Harbor。Harbor是一款开源的Docker镜像存储仓库，其扩展了DockerDistribution，在此基础上添加了我们常用的功能，比如安全认证，RBAC用户权限管理，可视化页面操作等功能。9.6.K8S构建高可用Nacoswww.kancloud.cn/mrbird/springcloud/14269209.7.K8S构建FEBSCloud服务集群www.kancloud.cn/mrbird/springcloud/14269219.8.部署前端测试www.kancloud.cn/mrbird/springcloud/142692210.分布式事务研究10.1.分布式架构事务挑战www.kancloud.cn/mrbird/springcloud/145614310.2.分布式事务解决方案www.kancloud.cn/mrbird/springcloud/145614410.3.基于消息中间件RocketMQ方案（一）www.kancloud.cn/mrbird/springcloud/145614510.4.基于消息中间件RocketMQ方案（二）www.kancloud.cn/mrbird/springcloud/145614610.5.基于TXLCN方案www.kancloud.cn/mrbird/springcloud/145614710.6.基于阿里Seata方案10.6.www.kancloud.cn/mrbird/springcloud/1456148搭建SeataServerSeata是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata将为用户提供了AT、TCC、SAGA（适合业务流程长、业务流程多的情况，所以本节不演示）和XA（截至2020年1月1日，该功能Seata还在开发中，所以也不演示）事务模式，为用户打造一站式的分布式解决方案。", "architecture\\分析设计/【架构】需求分析.md": "需求三个层次：业务需求、用户需求、软件需求，对应：业务架构、业务流程、工作细节基于SERU的面向对象需求分析：1、确定业务边界确定业务范围《前景》文档：项目背景调查、业务前景分析、业务和技术的可行性2、大卸八块（识别业务的主题域Subject）系统切分为子系统、分层划分采用组件图、包图来表示，形成系统的Highlevel的设计确定子系统间的接口（即信息交换）3、块中找流（找出主题域中的业务事件Event，即流程，和报表Report）每一个主题域相当于一个子系统按照Role确定主题域中主要的业务流程，即Event，采用活动图来描述这些业务流程活动图中节点即是关键用例找出需要输出的报表4、流中找点（对业务事件流程进行分析，找出其中的主要业务活动点，DFD）找出业务流程上的主要业务活动点，即关键用例，输出关键用例图此点是业务用例用鲁棒图（分析类图）、DFD、时序图等来分析关键用例用于确定系统的概要设计5、点的分解（精化关键业务用例，找实体）精化用例：对关键用例进行分析，分解成系统用例，输出系统用例图找实体（找出主题域、业务事件中业务实体，以及实体之间的关系）在精化用例过程中，找出系统的领域模型（ER），为数据建模作准备6、用例分析（可以采用事件流、时序图等）即用例场景分析采用事件流（文字+时序图）、用例规约来描述用例场景7、非功能需求的识别约束性需求质量需求BA的产出物：软件需求规格说明书界面原型DemoER实体关系图", "architecture\\分析设计/钱安川-敏捷需求分析和管理-用户故事方法.md": "TOC1.需求从哪里来？需求的获取产品研发－市场部门谁是产品的用户产品的目标是什么产品的竞争对手分析投资回报分析产品用户角色建模和交互设计产品界面原型6868项目开发－客户谁是项目的用户项目的业务目标项目的投资回报分析客户当前的过程客户未来的过程6868需求文档驱动的过程不堪重负敏捷需求分析和管理过程!_v_images/20191129174335.png敏捷需求管理贯串项目始终：初始阶段C识别需求，仅供估算项目规模使用，“快速启动”；发布计划阶段C高风险的需求进行可行性分析6868迭代计划阶段需求细化6868迭代实施阶段反复验证需求并确认需求被实现6868每个迭代纳入新需求，重新审视需求列表及优先级，调整计划6868项目启动阶段目标和交付物项目愿景和动机62快速产出可以开始开发的需求列表粒度粗的MasterStory62确立可视化项目原型62了解技术风险62估算项目成本62制定发布和迭代计划（发布计划是动态的）62轻量的，可视的文档项目启动阶段交付物业务流程图架构原型（技术架构、平台）界面原型（PPT等）功能分解图（故事墙）!_v_images/20191129174346.png2.需求如何表述？用户故事卡片!_v_images/20191129174356.png用户故事的3C原则Card用户故事卡片本身代表了需求的存在Conversation用户故事所代表的一段对话和交流Confirmation用户故事的确定性用户故事XYZ表述X:用户角色作为。。。Y:目标系统提供的行为或功能我希望。。。Z:实现的业务价值或目标以便于。。。角色流程RoleProcess方法!_v_images/20191129174404.png1.作为用户，我希望能够通过书名和作者名查找书籍，以便我能快速的购买我想要的书2.作为用户，我希望能够把我感兴趣的书籍加入购物车，以便我能够批量购买3.作为用户，我希望能够查看我目前购物车内的书，以便我做出购买决定INVEST原则Independent可以独立开发Negotiable可以协商Valuable有价值Estimable大小可评估Sizedappropriately合适粒度Testable可测试验证3.需求的分解!_v_images/20191129174412.pngUserStory的逐步细化!_v_images/20191129174421.png非功能性需求Accessibility可用性Archiving归档Auditability可审计性Authentication安全认证Authorization授权Localization本地化6868验收条件AcceptanceCriteria如何验收用户故事？如何确定Story已经被开发完成？如何进行估算？验收条件具体属性功能性验收条件HappyPath/SadPath方法非功能性验收条件4.需求如何管理？用户故事生命周期!_v_images/20191129174433.png迭代过程中，分析师怎么做？!_v_images/20191129174441.png可视化需求管理来自于精益生产的看板管理KanbanManagementsystem目的是为了增强管理的透明性，鼓励每个人都去发现问题和解决问题，而不是等待别人来做!_v_images/20191129174448.pngMingle中的StoryWall!_v_images/20191129174457.png5.敏捷需求分析师必读《UserStoriesApplied:ForAgileSoftwareDevelopment》byMikeCohn《金字塔原理：思考、表达和解决问题的逻辑》（麦肯锡40年经典培训教材）", "architecture\\分析设计/需求调研的内容和工作指引.md": "当你去做一个项目的软件需求时，一般需要考虑的内容包括：1系统的主要内容和界限是什么，查阅相关软件和资料书籍，了解客户的业务和专业知识（前往用户现场前准备）1.1制定总体计划和需求调研计划1.2将行程和计划通知客户，协调安排2与用户会面，提交本次调研活动的计划，达到的目标，时间安排，请用户配合（解释每个步骤的目的和用户参与的人员），并根据用户安排，适当调整计划3最好召开项目启动会议，相关业务部门和领导参与，确定双方项目组成员，确定客户方的配合人（唯一联系人）、领导（唯一协调人），介绍项目组的人员安排、总计划、需求调研计划4用户单位的组织机构是什么，哪些部门和人员岗位参与本系统的使用5使用人员对系统的目标是怎样理解的，包括一般操作人员、中层领导、决策者6画出系统需要完成的业务流程图，并认真检查和核对每条路径中是否完备，异常情况怎样处理（系统的动态特性）7依据流程图收集每个步骤需要的使用和操作的数据，确定数据的类型和范围（系统的静态特性）8画出业务实体及其关系，并估计业务实体的产生频率和数据量9评估业务流程和实体中需求变化的可能性10收集用户需要产生的单据和报表，与27步产生的结果进行检查，纠正错误、避免遗漏11收集用户对系统界面风格、版式、颜色的偏好和需求12对系统将来使用的硬件、操作系统、网络情况进行了解12.1收集系统初始化数据，或者要求客户进行收集和整理，明确期限时间13编制简单界面原型（该步骤也可放在需求分析之后完成，再次和用户进行沟通）14将业务需求与用户进行确认（采用会议讲解的方式），用户领导签字!_v_images/20191120203442.png", "architecture\\架构师大型项目实战/目录.md": "架构师大型项目实战第七套：Mysql主从复制+高可用集群+Linux+Nginx+Java+Memcached+Lvs+Redis实战PB级大型分布式大数据高并发架构实战案例网站性能调优001集群基础概念.md第七套/001集群基础概念.md", "architecture\\架构师大型项目实战\\第七套/001-集群基础概念.md": "TOC001集群基础概念网络请求!_v_images/20200604160036617_29204.png问题：什么是Prefork请求？Apache工作的三种模式：Prefork、Worker、Eventblog.mimvp.com/article/27778.html网络请求，内核进程空间，用户进程空间，网卡，磁盘IO？Linux内核空间与用户空间www.cnblogs.com/sparkdev/p/8410350.htmlLinux网络IO和磁盘IO详解www.cnblogs.com/sunsky303/p/8962628.htmlDNS负载均衡!_v_images/20200604155954082_1565.pnglinux运维学习笔记：集群系列之01：linux集群基础概念www.jianshu.com/p/a9b2d5b32a3a如何分配调度多台主机?>DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。>大多数域名注册商都支持对统一主机添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就完成了简单的负载均衡。什么是域名的A记录？域名的A记录、mx记录、ns记录怎么查看wenku.baidu.com/view/671df0c55fbfc77da269b1f0.htmlDNS负载均衡有什么缺点？1.每台主机都必须有独立外网IP2.由于使用了DNS缓存，新的DNS记录生效需要几个小时。一旦发生宕机，不能及时生效。3.本地DNS服务器会缓存已解析的域名到IP地址的映射，这会导致使用该DNS服务器的用户在一段时间内访问的是同一台Web服务器，导致Web服务器间的负载不均匀。负载均衡手段之DNS轮询www.cnblogs.com/data2value/p/6107380.html如何解决DNS负载均衡的缺点（服务器性能差异，负载不均匀，DNS缓存）？>RoundRobin:轮调：同一个客户端请求，并发的资源可能来自多台服务器。WRR:weightRoundRobin加权轮调：解决服务器的硬件、性能有所差异。考虑公平以及效率，权重weight。能者多劳。LB集群!_v_images/20200604161328677_28397.pngLinux负载均衡LVS原理技术详细讲解blog.csdn.net/chen_fly2011/article/details/54912326LVS负载均衡（LVS简介、三种工作模式、十种调度算法）blog.csdn.net/weixin_40470303/article/details/80541639MySQL数据过载怎么办？附件：从多台主机上传附件，怎么存储？NFSnfs文件共享服务器应用实战（一）blog.csdn.net/Lu_tixia/article/details/99571376nfs文件共享服务器应用实战（二）自动挂载技术blog.csdn.net/Lu_tixia/article/details/99628052nfs文件共享服务器企业实战（三）nfs高可用blog.csdn.net/Lu_tixia/article/details/99675199NFS共享存储实战www.cnblogs.com/gongjingyun123/p/11323968.html静态文件如何同步更新？rsync+inotifyinotify+rsync实现实时同步cloud.tencent.com/developer/article/1008061ftp的被动与主动模式是什么？FTP的主动模式和被动模式工作原理及抓包分析blog.csdn.net/jingzi123456789/article/details/83409572调度器过载怎么办？功能切分，比如：新浪子域名调度器宕机怎么办？Master,Slave。备用调度器如何知道主调度器宕机？心跳>standy:具备和primary配置一样，IP地址进行切换，自己服务启动。primary和standby时刻通信，发送heartbeat（心跳数）,一旦宕机，立即启动，进行切换。调度器如何知道主机是否宕机？健康检查>负载均衡可以定期向后端服务器发送Ping、尝试连接或发送请求来探测后端服务器运行的状况，这些探测称为健康检查。负载均衡通过健康检查来判断后端服务的可用性，避免后端服务异常影响前端业务，从而提高业务整体可用性。负载均衡原理与实践详解第六篇健康检查机制详解（上）blog.csdn.net/yiyuwu7069/article/details/78217985LBvsHA：处理能力vs可用性!_v_images/20200604165107019_13072.pngLB集群与HA集群的区别？>负载均衡集群着重在于提供服务并发处理能力的集群，高可用集群以提升服务在线的能力的集群。高性能集群着重用于处理一个海量任务。>LB集群具有高可用的能力，但不是高可用集群。HA集群的主机之间要进行通信，发送heartbeat，以及宕机后，快速切换服务。而LB集群的高可用能力是通过上面的调度服务器调度来实现。LBLoadBalancing集群、HAHighAvailability集群、HPHighPerformance集群blog.csdn.net/shuaishenkkk/article/details/22744979HA99%是99.9%的几倍？10倍>可用性=正常在线时间/正常在线时间+故障处理时间HA集群!_v_images/20200604164420210_17720.png在HA集群中要考虑哪些资源？>web服务器：primary：IP，webapp,页面standby：IP,webapp,页面在高可用集群中，如何充分利用standby主机资源？>web主机与mail主机互为standby。某一时刻某个资源只能被某个节点所占用。主机宕机，采用哪个standby？>定义优先级，由协调员DC来决定选择谁。主机如何通知standby自己还活着？>及时发送heartbeat，多播/组播，不能采用广播。存储!_v_images/20200604165927268_23242.pngNFS与硬盘读写文件的区别？>硬盘是块级别读取，NFS是文件级别读写。对于NFS与硬盘，两个程序同时写一个文件区别？>硬盘：无锁，错乱。NFS：有锁linux高可用集群HA原理详解www.cnblogs.com/insaneMrLi/p/10841166.htmlLB/HA高可用系列文章www.cnblogs.com/kevingrace/category/899066.html脑裂!_v_images/20200604171648321_1417.pngHA高可用集群中\"脑裂\"问题解决www.cnblogs.com/kevingrace/p/7205846.htmlDASSCSI、RAIDUltraSCSI320MbpsSAS6GbpsDASvs1000mbps/8>NAS的传输远比不上DASRAID与NFS>NFS对前端服务器而言，就是文件共享服务器。数据请求是在文件级别上完成的。RAID,是磁盘阵列，是通过主板上的总线连接到RAID上，相当于本地存储设备，数据是在块级别上交换的。当standby发现主机宕机，如何无错抢占DAS设备？DAS如何解决splitbrain脑裂问题？>由于没有及时传递heartbear信息，切换到备用的调度服务器，而主调度服务器还在写数据到DAS中，而standby也同时写同一个文件。左右就不协调了，称为splitbrain:脑裂。>解决办法：（1）电源交换机（切断主机的电源），爆头STONITHShootTheOtherNodeInTheHead（2）fencing（隔离）：拒绝某一节点访问某一资源的机制，使服务器和存储设备断开。隔离级别：1.节点级别：STONTIN。2.资源级别。当standby误以为主机宕机，抢占DAS，主机如何再抢回来？!_v_images/20200604172019789_32378.png>注意：为了防止脑裂,集群分裂，高可用集群至少有3个节点，奇数个节点，仲裁机制，少数服从多数。>补充：脑裂：本来一个大脑的两半球互相配合，变成了分裂成两个独立的大脑，都认为对方已死。在集群环境中，有这么几种可能造成\"SplitBrain\"现象：1、在集群环境中的节点间的心跳线同时断掉后，集群系统所处于的一种特殊状态。例如节点1和2组成一个集群，突然1和2间的心跳同时都断了，如果此前节点1正在运行应用，心跳都断掉后2开始去接管应用，强行加载数据，此时就是splitbrain。2、集群中节点因为处理器忙或者其他原因暂时停止响应时，其他节点可能误认为该节点“已死”。后果：节点间争夺共享磁盘（即资源）的访问权，都对共享文件系统产生读写操作，从而导致共享磁盘文件系统损坏。解决办法：使用硬盘心跳，scsireservation，以及最极端的powerfence。HP:高性能集群（HBC）!_v_images/20200604173501479_19275.png并行计算集群两个基础是什么？分布式文件系统将大大任务切割为是小任务，分别进行处理的机制。并行计算集群原理？>化整为零>合并整合。MapReduce>每台计算机只处理所有数据的一部分，且每台计算机上只存储一部分数据。每个节点既是计算节点，也是存储节点。!_v_images/20200604173728015_5214.png并行计算集群的主机兼具存储和计算，调度计算。", "architecture\\诸葛-SpringCloudAlibaba-Nacos入门/SpringCloudAlibaba-Nacos入门.md": "TOC微服务架构github.com/alibaba/springcloudalibaba/blob/master/READMEzh.md!亿级流量电商网络微服务架构_v_images/20200917161031675_7588.png=1024xNacos注册中心!基于Nginx的负载均衡_v_images/20200917161526033_6220.png增加减少机器需要频繁修改配置!Nacos服务注册中心_v_images/20200917162815662_2365.png基于Ribbon算法的负载均衡!完整的微服务架构_v_images/20200917164823949_25307.png=1200xFeign：通过动态代理，实现对远程服务的调用。P6Sentinel限流熔断降级Sentinel切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。Sentinel教程Sentinel介绍QuickStartgithub.com/alibaba/Sentinel/wiki/介绍【Sentinel（一）】Sentinel介绍与使用blog.csdn.net/noaman_wgs/article/details/103328793%0Ablog.csdn.net/noaman_wgs/article/details/103328793Sentinel实战控制台篇www.jianshu.com/p/c47dfd25eeee%0Awww.jianshu.com/p/c47dfd25eeeeSentinel教程gitee.com/all_4_you/sentineltutorial%0Agitee.com/all_4_you/sentineltutorialgithub.com/alibaba/Sentinel/tree/master/sentineldemo!Sentinel主要特性imgblog.csdnimg.cn/20191130203727708.png?xossprocess=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=,size_16,color_FFFFFF,t_70=800xSentinel与Hystrix的区别关于Sentinel与Hystrix的区别见：技术选型：SentinelvsHystrixyq.aliyun.com/articles/633786/总体来说：Hystrix常用的线程池隔离会造成线程上下切换的overhead比较大；Hystrix使用的信号量隔离对某个资源调用的并发数进行控制，效果不错，但是无法对慢调用进行自动降级；Sentinel通过并发线程数的流量控制提供信号量隔离的功能；此外，Sentinel支持的熔断降级维度更多，可对多种指标进行流控、熔断，且提供了实时监控和控制面板，功能更为强大。SpringCloudAlibaba：Sentinel实现熔断与限流SpringCloudAlibaba：Sentinel实现熔断与限流juejin.im/post/6844903999876022279%0Ajuejin.im/post/6844903999876022279与Feign结合使用引入依赖`springcloudstarteralibabasentinel`在application.yml中打开Sentinel对Feign的支持：`feign.sentinel.enabled:true`在应用启动类上添加@EnableFeignClients启动Feign的功能；定义对nacosuserservice服务的调用```java@FeignClientvalue=\"nacosuserservice\",fallback=UserFallbackService.classpublicinterfaceUserService{@PostMapping\"/user/create\"CommonResultcreate@RequestBodyUseruser;}```创建UserFallbackService类实现UserService接口，用于处理服务降级逻辑：```java@ComponentpublicclassUserFallbackServiceimplementsUserService{@OverridepublicCommonResultcreateUseruser{UserdefaultUser=newUser1L,\"defaultUser\",\"123456\";returnnewCommonResult<>defaultUser,\"服务降级返回\",200;}}```通过Feign调用nacosuserservice服务中的接口：```java@RestController@RequestMapping\"/user\"publicclassUserFeignController{@AutowiredprivateUserServiceuserService;@PostMapping\"/create\"publicCommonResultcreate@RequestBodyUseruser{returnuserService.createuser;}```调用如下接口会发生服务降级，返回服务降级处理信息：localhost:8401/user/4```json{\"data\":{\"id\":1,\"username\":\"defaultUser\",\"password\":\"123456\"},\"message\":\"服务降级返回\",\"code\":200}``````java@TransactionalpublicStringcreateOrderLongproductId，LonguserId，IntegerstockCount，IntegercreditCount{System.out.println\"创建订单成功\";//T0D0stockService.deductStockproductId，stockCount;creditService.addCredituserId，creditCount;//DEBUG:停掉积分系统，不能报错wmsService.deliveryuserId，productId;return\"success\";}```Seata分布式事务seata.io/zhcn/@GlobalTransactionalSeataAT模式整体机制：两阶段提交协议的演变：一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。二阶段：提交异步化，非常快速地完成。回滚通过一阶段的回滚日志进行反向补偿。对数据一致性的及时性要求不高的业务场景，尽量不适用分布式事务，因为Seata底层是加锁，降低了系统性能。电商业务中台整体微服务架构www.processon.com/view/link/5e69e768e4b07fc7a6841488!电商业务中台整体微服务架构_v_images/20200917182324982_14617.png=1200xGateway的作用SpringCloudGateway：路由（服务转发）限流安全认证（对请求统一校验权限）!Gateway配置_v_images/20200917174512999_3323.png分布式调用链路追踪Pinpoint微服务自动化监控Prometheus&Grafana", "SkillsMap/JavaEE.md": "Spring【专题】SpringBoot基础教程blog.didispace.com/SpringBoot基础教程/【深度】震精！SpringBoot内存泄露，排查竟这么难！mp.weixin.qq.com/s/UgUXeWBUy67UsZt18s3mdQSpringSecurity【官方】SpringSecurity中文文档www.springcloud.cc/springsecurity.htmlMyBatisMyBatisPlus入门视频课程www.imooc.com/learn/1130MyBatisPlus开发指南mp.baomidou.com/guide/mybatisplus的使用入门简书www.jianshu.com/p/ceb1df475021常见问题|MyBatisPlusjobob.gitee.io/mp3doc/faq/如何使用：map下划线自动转驼峰mybatis&ndash;MyBatis3|动态SQLwww.mybatis.org/mybatis3/zh/dynamicsql.htmlMybatisPlus学习笔记简书www.jianshu.com/p/5df97ea42978MyBatis传入多个参数的问题mingyue1818博客园www.cnblogs.com/mingyue1818/p/3714162.html【深度】Mybatis自定义拦截器与插件开发mp.weixin.qq.com/s/8zAvIsjZNgG1tH4FN6UQSAbaomidou/mybatisplussamples:MyBatisPlusSamplesgithub.com/baomidou/mybatisplussamplesmybatisjava.sql.SQLException:ORA00907:缺失右括号jackpk的专栏CSDN博客blog.csdn.net/jackpk/article/details/49894541Crown:Crown以SpringBoot2为基础，打造一个快速开发的Web应用脚手架。文档地址：gitee.com/cancerGit/Crown", "SkillsMap/Java语言.md": "Java语言Java新功能：github.com/gjhuai/java8tutorialJava设计模式：github.com/gjhuai/javadesignpatterns【练习】70k星iluwatar/javadesignpatternsgithub.com/iluwatar/javadesignpatternsgithub.com/gjhuai/javasamplesgithub.com/eugenp/tutorials.git阅读《深入理解Java虚拟机*JVM高级特性与最佳实践*第3版》Groovy_Linksgithub.com/virtualdogbert/Groovy_LinksGroovy的SQL模块www.jianshu.com/p/a0e301f79f9bJava8简明教程黄小非blog.csdn.net/jiankunking/article/details/51479024Java8简明教程飞龙blog.didispace.com/books/java8tutorial/Java8Streamsmapexampleswww.mkyong.com/java8/java8streamsmapexamples/Java8CConvertListtoMapwww.mkyong.com/java8/java8convertlisttomap/java8的lambda中的map相关操作blog.csdn.net/wabiaozia/article/details/84262195【深度】全网把Map中的hash分析的最透彻的文章，别无二家blog.csdn.net/hollis_chuang/article/details/80248617【深度】21张图带你领略集合的线程不安全mp.weixin.qq.com/s/IvSGGcUXq3z7b9yyYHUKvA【深度】我工作三年了，该懂并发了（干货）mp.weixin.qq.com/s/Ov_QnfM4QSiFLL1HBxdEsgJVM【入门】这几款JVM故障诊断处理工具你还不会mp.weixin.qq.com/s/t7G1tSrNJ603nIpgzMY2uw【深度】记一次线上商城系统Tomcat、JVM高并发的优化mp.weixin.qq.com/s/Bp4TB1aoDmJE5jqHIP22xg【深度】快速定位生产故障问题JVM进程CPU占用率高于100blog.csdn.net/flysqrlboy/article/details/79314521【深度】史上最强Tomcat8性能优化blog.csdn.net/ThinkWon/article/details/102744033【深度】Tomcat架构原理解析到架构设计借鉴mp.weixin.qq.com/s/ocjTeevXHi1zLtMz3rMBeQ【原理】深入理解JVM垃圾收集机制JDK1.8cloud.tencent.com/developer/article/1069187【原理】打工人，从JMM透析volatile与synchronized原理blog.csdn.net/javachengzi/article/details/115303495【原理】JVM之内存模型zhuanlan.zhihu.com/p/44296601【原理】JVM之类加载机制zhuanlan.zhihu.com/p/44340596【原理】JVM之代码优化zhuanlan.zhihu.com/p/44432381【原理】JVM之线程并发zhuanlan.zhihu.com/p/44517264【原理】JVM与操作系统zhuanlan.zhihu.com/p/44401058【原理】volatile非线程安全解析blog.csdn.net/wsh596823919/article/details/82698357【原理】骚操作：不重启JVM，如何替换掉已经加载的类？mp.weixin.qq.com/s/GCJ5vUsnUSb5VTBoz0zSFwJavaJetty类加载问题处理hadix的专栏博客频道CSDN.NETblog.csdn.net/hadixlin/article/details/40426455JVM之类的加载机制Gavin博客频道CSDN.NETblog.csdn.net/gavin_john/article/details/61208054Javatip:Howtoreadfilesquickly|NadeauSoftwarenadeausoftware.com/articles/2008/02/java_tip_how_read_files_quicklyFileChannelwithByteBufferandbytegetsJavaGarbageCollectionBasicswww.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.htmlt5nginx+tomcat7（8）集群，负载均衡和session共享CSDN博客blog.csdn.net/remote_roamer/article/details/51133790一些简单的编程练习题文章伯乐在线blog.jobbole.com/53039/blog/event.mdatmaster&middot;jasonGeng88/bloggithub.com/jasonGeng88/blog/blob/master/201706/event.mdjava基于事件驱动的单线程异步框架为程序员服务outofmemory.cn/codesnippet/3620/javawitheventdrivesinglexianchengyibuskeletonQuartz任务调度3存储与持久化操作配置详细解析blog.csdn.net/qwe6112071/article/details/50989192SpringMVC更灵活的控制json返回（自定义过滤字段）diamondfsd.com/article/ae89cf4ef6794cc09882f02e0240866eCustomErrorMessageHandlingforRESTAPI|Baeldungwww.baeldung.com/globalerrorhandlerinaspringrestapi【每日一博】基于Groovy实现SpringBean的动态加载推酷www.tuicool.com/articles/JNFbim前后端分离实践有感边城客栈学海无涯51CTO博客blog.51cto.com/jamesfancy/2058830奇偶校验的概念haige_666的博客CSDN博客blog.csdn.net/haige_666/article/details/81022302SpringCloudprojects.spring.io/springcloud/springcloud.htmlDevelopersCustomRequestMappingHandlerMappingwww.bountysource.com/issues/43045647customrequestmappinghandlermapping基于Groovy实现SpringBean的动态加载CSDN博客blog.csdn.net/luxianping/article/details/52144782groovy编写spring的controller三支持annotation快马扬鞭须努力！ITeye博客sillycat.iteye.com/blog/562780SpringMVC源码总结（二）mvc:annotationdriven以及@Controller和@RequestMapping的那些事乒乓狂魔源码研究群QQ345731741已搬往开源中国ITeye博客lgbolgger.iteye.com/blog/2105108ConfigurethehandlermappingpriorityinSpringMVCwww.mkyong.com/springmvc/configurethehandlermappingpriorityinspringmvc/GuidetoSpringHandlerMappings|Baeldungwww.baeldung.com/springhandlermappingsTypesofSpringHandlerAdapters|Baeldungwww.baeldung.com/springmvchandleradaptersSpringBootBucket1.0.0发布，SprintBoot全家桶开源中国社区www.oschina.net/news/93900/springbootbucket10?from=20180311面试必备：30个Java集合面试问题及答案推酷www.tuicool.com/articles/YbMbYbrxuminwlt/j360idgen:ID生成服务器,多种高性能ID生成策略github.com/xuminwlt/j360idgenJava算法生成全局唯一的IdIdGenCSDN博客blog.csdn.net/high2011/article/details/79192761【JAVA】系统唯一ID生成方案讨论CSDN博客blog.csdn.net/simonchi/article/details/56276878Spring3.1.0实现原理分析一.类型转换roberts939299的专栏CSDN博客blog.csdn.net/roberts939299/article/details/69666281Spring，为内部方法新起一个事务，此处应有坑。等你归去来博客园www.cnblogs.com/yougewe/p/7466677.html手写一个简化版Tomcat布衣小工博客园www.cnblogs.com/itbuyixiaogong/p/9067116.html当Java遇到Jade&mdash;票牛PC版前后端分离的实践演道网|演道网www.go2live.cn/dev/%E5%BD%93java%E9%81%87%E5%88%B0jade%E7%A5%A8%E7%89%9Bpc%E7%89%88%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%BC%94%E9%81%93%E7%BD%91.html狗屎一样的代码！快，重构我！mp.weixin.qq.com/s/4vLU0T5xkeVHNfoT2qSV9Q?client=tim&ADUIN=15756953&ADSESSION=1553564018&ADTAG=CLIENT.QQ.5603_.0&ADPUBNO=268828.6SpringBoot集成SpringSecurity简书www.jianshu.com/p/08cc28921fd0spring动态创建bean开源中国社区www.oschina.net/code/snippet_1387007_48362xiaoweizha/springbootebean:springbootebeanmysql配置整合github.com/xiaoweizha/springbootebeanspringmvcFreemarkernotloadingremotetemplateStackOverflowstackoverflow.com/questions/35171306/freemarkernotloadingremotetemplateFreeMarker缓存处理小小默：进无止境CSDN博客blog.csdn.net/J080624/article/details/78648845SerializationandClassloaders|Reflectionsrsankarx.wordpress.com/2012/06/08/javaserializationclassloaders/SpringBoot分离打包踩坑无法加载classClassNotFoundExcep...简书www.jianshu.com/p/32d38a7fd20aSpringdataredis:serializer实例深入一点,你会更加快乐ITeye博客shiftaltctrl.iteye.com/blog/1887370tomcat的类加载器初步认识简书www.jianshu.com/p/9f1df03b0f2bmonkeyk/oauth2shiroredis:oauth2shiro与Redis的整合,更符合实际项目需要github.com/monkeyk/oauth2shiroredisdaijiejay/daijieexample:基于springcloud系列整合的分布式项目的例子，监控管理、配置中心、注册中心、分布式锁、分布式事务、多数据源、工作流、单点登录、oauth2授权、接口文档、路由跳转、第三方集成等等github.com/daijiejay/daijieexampleshiro集成OAuth2学习体会香菇猫的博客CSDN博客blog.csdn.net/u013627689/article/details/78058152ormHowtousedynamicSQLqueryinMyBatiswithannotationhowtouseselectProvider?StackOverflowstackoverflow.com/questions/6685655/howtousedynamicsqlqueryinmybatiswithannotationhowtouseselectprovide并发【书籍】Java7并发编程指南中文版ifeve.com/java7concurrencycookbook/【深度】Java并发之AQS详解www.cnblogs.com/waterystone/p/4920797.htmlThreadLocal全攻略：使用实战，源码分析，内存泄露分析blog.csdn.net/wo541075754/article/details/116081575常用工具库modelMapper入门及使用解析www.jianshu.com/p/d97f9ea2d3caCGLIBBeanCopier和BeanMap等实现grefr.iteye.com/blog/2053748", "SkillsMap/ProductsMap.md": "电商50Star的mall项目是一套电商系统github.com/macrozheng/mall芋道mall商城，基于微服务的思想，构建在B2C电商场景下的项目实战。github.com/YunaiV/onemall开源项目kkFileView文档在线预览github.com/kekingcn/kkFileView2016年度开源中国新增开源软件排行榜TOP100www.oschina.net/news/80846/2016oscnewopensourcesoftwaretop1002016年度码云热门项目排行榜TOP50www.oschina.net/news/80909/2016oschinagittop50围观!2018开年1k+star及码云GVP项目是如何炼成的www.oschina.net/news/92981/giteejanuarymostpopulargvp?from=20180204SpringBoot扩展开源软件SpringBoot扩展码云Gitee.comgitee.com/explore/springbootexthsweb后台管理基础框架github.com/hsweb/hswebframework表单JXLSjxls.sourceforge.net/getting_started.htmlalibaba/easyexcel:快速、简单避免OOM的java处理Excel工具github.com/alibaba/easyexcelwengwh/plumdowork:工作流，表单，报表结合的多模块系统github.com/wengwh/plumdoworkjbaliuka/x4janalytic:ExcelreportinglibraryforJAVAgithub.com/jbaliuka/x4janalyticasfRevision1784855:/poi/trunk/src/examples/src/org/apache/poi/ss/examples/htmlsvn.apache.org/repos/asf/poi/trunk/src/examples/src/org/apache/poi/ss/examples/html/BasZhang/FormulaGen:excel公式转java类github.com/BasZhang/FormulaGenexcel模板文件，填充数据，生成新的excel文件git.oschina.net/winsonone/excelsouthwind0922.github.io/formDesign/demo/index.htmlsouthwind0922.github.io/formDesign/demo/index.htmlNoForm一个更好的表单解决方案知乎zhuanlan.zhihu.com/p/44120143GitHubalibaba/nopage:EasytomakeCRUDforeveryonegithub.com/alibaba/nopage表单设计器dev.snhb.group:9988/formmarker//FineReport|beerwww.hexianwei.com/2019/01/06/FineReport10.0/用户界面慧都网www.evget.com/category/20COMP35420144/spreadsheet:SpreadsheetApplicationgithub.com/COMP35420144/spreadsheetlittleorca/ferriswheel:Afantasticspreadsheetframework!github.com/littleorca/ferriswheelkeikai/keikaitutorial:Atutorialofawebspreadsheetcomponent,keikaigithub.com/keikai/keikaitutorialKeikaikeikai.io/asharapov/reports:GeneratesreportsinExcelgithub.com/asharapov/reports史上最全的BIRT报表实例大全birtbird博客园www.cnblogs.com/birtbird/archive/2013/01/10/2855480.htmlExcelReport标签韩兆新博客园www.cnblogs.com/hanzhaoxin/tag/ExcelReport/流程引擎fixteam/fixflow:做中国最好的开源业务流程引擎【QQ群:152654373】github.com/fixteam/fixflowFoxBPM/FoxBPM:FoxBPM开源BPM、流程引擎产品fixflow6.0github.com/FoxBPM/FoxBPM济南驰骋信息技术有限公司/JFlow码云开源中国gitee.com/opencc/JFlow/tree/masterHome&middot;killme2008/aviatorWikigithub.com/killme2008/aviator/wiki基于Groovy的规则脚本引擎实战推酷www.tuicool.com/articles/QJfQbqyFlowable引擎使用统一权限管理SHARE&amp;TOPCSDN博客blog.csdn.net/sharetop/article/details/73920306Guns:Guns基于SpringBoot2，致力于做更简洁的后台管理系统，完美整合springmvc+shiro+mybatisplus+beetl!Guns项目代码简洁，注释丰富，上手容易，同时Guns包含许多基础模块用户管理，角色管理，部门管理，字典管理等10个模块，可以直接作为一个后台管理系统的脚手架!码云Gitee.comgitee.com/stylefeng/guns/tree/master/activitiflowable开源工作流引擎项目整合开发实施实践总结落寞的流月城博客园www.cnblogs.com/aschs/p/9236269.htmlagilebpmbasic:【流程管理】【智慧协同】【移动办公】【SpringBoot2快速开发平台】企业级流程解决方案，前后端分离，模块化，超低耦合。基于activiti5.22，零java代码即可做到复杂业务的流程实gitee.com/agilebpm/agilebpmbasicdoc.agilebpm.cndoc.agilebpm.cn/工作流activity视频教程+redis视频教程百度网盘分享地址愿我如星君如月...夜夜流光相皎洁...CSDN博客blog.csdn.net/jiangyu1013/article/details/78345683Flowable第二期_腾讯课堂ke.qq.com/course/308748扩展Activiti流程定义文件，实现自定义节点属性hxlzpnyist的个人空间开源中国my.oschina.net/hxlzpnyist/blog/164708Activiti任务节点属性扩展&ndash;分享牛www.shareniu.com/article/54.htm扩展Activiti工作流任务和属性简书www.jianshu.com/p/68c0034f8e56flowablemodler为任务节点增加自定义属性&ndash;分享牛www.shareniu.com/article/196.htmbluejoe2008/openwebflow:基于Activiti的工作流引擎扩展，接管了Activiti对活动权限以及用户表的管理，并提供了催办、代办、加签（包括前加签/后加签）、自由跳转、分裂节点等功能github.com/bluejoe2008/openwebflow分享牛www.shareniu.com/?tdsourcetag=s_pctim_aiomsgJSAAS企业级应用敏捷开发平台&ndash;广州红迅软件有限公司www.redxun.cn/?page_id=981SSOa466350665/smart:Java单点登录权限系统，权限按钮级、修改实时生效、支持分布式github.com/a466350665/smartdynamind/springbootsecurityoauth2minimal:MinimalimplementationofAuthorizationServer,ResourceServerandOAuth2ClientinSpringBootwithSpringSecurityandJWTgithub.com/dynamind/springbootsecurityoauth2minimal供学习yoichiro/oauth2server:ThisprojectisanimplementationofOAuth2.0writteninJava.github.com/yoichiro/oauth2servercoderhuang/ssoshirocas:spring下使用shiro+cas配置单点登录github.com/coderhuang/ssoshirocashellokoding/hellossojwtauth:SingleSignOnSSOExamplewithJSONWebTokenJWT,SpringBootgithub.com/hellokoding/hellossojwtauth基于CAS的单点登录SSO5:基于Springboot实现CAS客户端的前后端分离推酷www.tuicool.com/articles/Yfyy6bq登录对比：cas（单点登录）；oauth2（授权）；单一登录的区别xyz啊哈CSDN博客blog.csdn.net/qaaaaa111/article/details/84912644轻松搭建CAS5.x系列6在CASServer上增加OAuth2.0协议好用的CASCSDN博客blog.csdn.net/weixin_39206782/article/details/81160729CAS5.2x单点登录一&mdash;&mdash;搭建cas服务器java线程池CSDN博客blog.csdn.net/u013825231/article/details/79132399轻松搭建CAS5.x系列文章好用的CASCSDN博客blog.csdn.net/weixin_39206782/article/details/80869410cas5.3.2单点登录CasServer开启Oauth2.0协议二十这个名字想了很久CSDN博客blog.csdn.net/qq_34021712/article/details/82290876sso单点登录系统（解决session共享）Persistentence的博客CSDN博客blog.csdn.net/Persistentence/article/details/77170394Springboot整合Shiro：集成Kaptcha验证码简书www.jianshu.com/p/ad0bc0508abdRedis+Shiro+Springdataredis，共享Session小LUA博客园www.cnblogs.com/LUA123/p/7728319.html讲真，别再使用JWT了！简书www.jianshu.com/p/af8360b83a9f使用JWT的OAuth2的SSO分析沧海一滴博客园www.cnblogs.com/softidea/p/6854227.htmlqq53182347/liughparent:SpringBoot+JWT+Shiro+MybatisPlus实现Restful快速开发后端脚手架github.com/qq53182347/liughparentHeeexy/SpringBootShiroVue:提供一套基于SpringBootShiroVue的权限管理思路.前后端都加以控制,做到按钮/接口级别的权限github.com/Heeexy/SpringBootShiroVueHazelcastSupportinApacheShiroStormpathUserIdentityAPIstormpath.com/blog/hazelcastsupportapacheshiroOAuthscribejava/scribejava:SimpleOAuthlibraryforJavagithub.com/scribejava/scribejavaOAuth2.0之OLTU实现举例简书www.jianshu.com/p/6573a9f066dc第十七章OAuth2集成――《跟我学Shiro》《亿级流量网站架构核心技术》~ITeye博客jinnianshilongnian.iteye.com/blog/2038646OAuth2.0基本原理及应用zhangwenxatu的博客CSDN博客blog.csdn.net/zhangwenxatu/article/details/52506732OAuth2基本概念和运作流程莫林SegmentFault思否segmentfault.com/a/1190000013467122?utm_source=tagnewestApacheOltu实现OAuth2.0服务端【授权码模式AuthorizationCode】花儿笑弯了腰博客园www.cnblogs.com/Irving/p/4134752.htmlmonkeyk/oauth2shiro:IntegrateOAuth2oltuandShirogithub.com/monkeyk/oauth2shiromaking/oauth2ssodemo:SimpleOAuth2SSODemowithSpringBoot+SpringSecurityOAuth2github.com/making/oauth2ssodemodsyer/sparklrboot:DemoOAuth2providerwithSpringBootgithub.com/dsyer/sparklrbootspringcloudsamples/authservergithub.com/springcloudsamples/authserverrajithd/springbootoauth2:SpringBootOauth2withH2databasegithub.com/rajithd/springbootoauth2monkeyk/oauth2shiroat1.0github.com/monkeyk/oauth2shiro/tree/1.0基于Oauth2的api接口开发（一）ifnotmeOSCHINAmy.oschina.net/guoshuyun/blog/743017RFC6749TheOAuth2.0AuthorizationFrameworktools.ietf.org/html/rfc6749section1.3.2权限【权限管理】角色访问控制RBAC模式及其思想heroShane的个人页面my.oschina.net/heroShane/blog/1961457.2.继承型角色树的实现jibu.qiniudn.com/jibudoc/ch07s02.htmlfghierarchyrole产品|权限设计=功能权限+数据权限简书www.jianshu.com/p/0ab125cf8258如何在应用系统中实现数据权限的控制功能伍华聪博客园www.cnblogs.com/wuhuacong/p/3664204.html权限角色和岗位有什么区别？博客频道CSDN.NETblog.csdn.net/superdog007/article/details/19898821【ITOO高校云平台】&mdash;&mdash;浅析权限系统中角色与职位博客频道CSDN.NETblog.csdn.net/u010164936/article/details/47358737基于岗位抽象的角色权限控制模型设计与实现豆丁网www.docin.com/p994504319.html规则引擎QL语言express_wind的专栏博客频道CSDN.NETblog.csdn.net/express_wind/article/category/1081737小明历险记：规则引擎drools教程一zhuanlan.zhihu.com/p/28528925QLExpress/Taocodecode.taobao.org/p/QLExpress/src/indexTaocodecode.taobao.org/p/QLExpress/wiki/index/MQMPush开源实时消息推送系统mpush,push,tcp,netty,消息推送,信息推送,Android推送,AndroidPush,IOSPush,物联网推送,免费,开源,安全,加密,集群mpusher.github.io/rushmore/zbus码云开源中国git.oschina.net/rushmore/zbusProxyadamfisk/LittleProxy:HighperformanceHTTPproxyoriginallywrittenbyyourfriendsatLanternandnowmaintainedbyastellargroupofvolunteeropensourceprogrammers.github.com/adamfisk/LittleProxydddpaul/ratpackproxy:SimpliestHTTPreverseproxyonJava:github.com/dddpaul/ratpackproxyvietj/vertxhttpproxy:AdynamichttpproxyontopofVert.xgithub.com/vietj/vertxhttpproxyGitHubmitre/HTTPProxyServlet:Smiley'sHTTPProxyimplementedasaJavaservletgithub.com/mitre/HTTPProxyServletGitHubahabra/reverseproxy:ReverseProxyserverwhichcanbedeployedasaJavawebappgithub.com/ahabra/reverseproxyGreatGarlic/NettyReverseProxy:不同于Nginx的基于Netty和Spring的反向代理中间件github.com/GreatGarlic/NettyReverseProxyspinn3r/noxy:AHTTPproxybasedonnettyandlittleproxygithub.com/spinn3r/noxyravindraranwala/NettyReverseProxy:NettyReverseProxywhichsendsClientrequeststoaspecifiedBackendservicegithub.com/ravindraranwala/NettyReverseProxy/Web打印GitHubSubLuLu/thermal_printer:Java实现网络小票打印机自定义无驱打印github.com/SubLuLu/thermal_printerGitHubLehmanHe/A4print:一个在线云打印平台（android部分）含订单管理、百度地图、二维码等等github.com/LehmanHe/A4printGitHubnicklv/printvue2iviewadmin:基于vue2，Iview2的web在线打印管理系统github.com/nicklv/printvue2iviewadminLehmanHe/A4print:一个在线云打印平台（android部分）含订单管理、百度地图、二维码等等github.com/LehmanHe/A4print", "SkillsMap/SkillsMap-概述.md": "SkillsMap记录原则自己写文档不如去背文档。网上的资料文档太多，自己去再写一遍完全是浪费时间，不如花时间去记住这些知识内容。在SkillsMap中只用记录文档的链接地址。找到最精炼的总结笔记，并定期复习。资料分类：【入门】、【总结】、【深度】、【全面】、【原理】、【例子】、【官方】入门可以用视频，总结一定用文档。如何学习新技术？1.快速了解：看视频，入门blog，专题blog。2.解读代码：去搞清楚每一行代码，并笔记记录。代码选择：github上的codetutrial库最佳，零散代码亦可。不是为了保留代码，是为了记住、理解代码。codetutorial库可长期维护，温故知新。3.系统学习：看书，看官方文档，做笔记。在掌握技术的用法后，看一本书（不要太多的书）系统的梳理知识点。4.总结笔记：可快速复习。CTO职责1.**定战略（制定技术战略）**：结合业务发展需求和现状，制定技术发展战略、对系统架构发展进行规划、组织制定和实施重大技术决策和方案（人工智能、数据中台等）；2.**搭班子（团队建设）**：定岗位明职责、制定人才发展晋升通道、按职位制定技术学习方案、招聘、培养培训3.**带队伍（执行力）**：整体规划、分层细化、组织人力团队、定职责、监督与指导、工作评价三评审：需求评审、计划评审、代码评审4.**制定研发流程**：主导制定并持续优化研发工作流程和规范，保证高效率高质量的技术产出，促进技术成果的沉淀共享，确保技术成果的有效性和持续性；5.**制定研发技术路线**：制定或评审技术架构和数据库设计；优化现有技术框架；负责部门软件构件库的搭建、第三方控件的选型；6.**保障业务**：最大程度支撑部门产品的技术实现和稳定运行，力求技术稳定性和先进性为部门发展提供动力，容量规划预备业务的快速增长；完成各项技术工作相关数据统计分析报告，并据此对部门发展提出合理化建议；7.**新技术研究**：研究部门战略发展相关最新产品和技术的发展方向，调研与产品相符的最新技术，并在系统中使用以提升产品体验。职位要求：2、具备良好的基本功，熟练使用基本的数据结构和算法，深入理解多线程、socket等相关技术；3、熟练掌握Spring等主流的开发框架，深入理解框架实现原理及特性；4、具备良好的编码习惯，结构清晰，命名规范，逻辑性强，代码冗余率低；5、熟悉Java的高级特性，深入理解各种设计模式和应用场景；6、有大规模分布式系统的开发和高可用相关的实践经验，具备设计复杂系统的能力；7、熟练掌握Mongodb数据库，具备Mongodb索引优化、查询优化、分库分表优化、数据库备份还原应用的能力；8、熟练掌握MySql数据库，具备MySql索引优化、查询优化、分库分表优化、数据库备份还原应用的能力；9、熟练掌握一种以上非关系型数据库，理解其使用场景及限制，如：Redis、Memcached等；10、熟悉分布式系统，熟练掌握一种以上服务框架和消息中间件，如：kafka，了解其实现原理；11、熟悉负载均衡和HA的基本原理，熟练掌握一种以上的HA框架，如：ZooKeeper、KeepAlived、LVS、DNAT、SNAT等；12、熟悉前端开发基本原理，熟练掌握一种以上的web框架，如：React、Vue、Angulard；13、对BIM、GIS有相关开发经验者优先；", "SkillsMap/SpringCloud微服务.md": "TOC微服务架构【专题】微服务架构专题blog.didispace.com/microserivcesarch/【专题】SpringCloud从入门到精通blog.didispace.com/springcloudlearning/现成框架github.com/gjhuai/FEBSCloudSpringCloud学习教程juejin.cn/column/6962024277382004773对应源码：github.com/macrozheng/springcloudlearning.gitwww.cnblogs.com/fanshuyao/category/1941706.htmldocs.springcloud.cn/Ribbon主要功能：提供客户端进程内负载均衡。【官方】Ribbon官方源码github.com/Netflix/ribbon【例子】Ribbon例子gitee.com/gjhuai/springcloudstudy/tree/master/ribbonexamplesOpenFeign【例子】Feign简单的Client访问http请求例子gitee.com/gjhuai/springcloudstudy/tree/master/feignclientsample【例子】详细讲解OpenFeign的使用姿势！developer.aliyun.com/article/775626代码地址：OpenFeign例子github.com/yehongzhi/example需要启动`nacos`注册中心。程序分为`provider`和`consumer`【官方】Feign官方源码github.com/OpenFeign/feign里面两个使用例子：`examplegithub`和`examplewikipedia`Hystrixnacos【例子】nacos官方例子github.com/alibaba/nacos/tree/develop/example/src/main/java/com/alibaba/nacos/example【例子】nacos使用例子github.com/nacosgroup/nacosexamples【入门】Nacos视频教程（无废话版）www.bilibili.com/video/BV1WZ4y1w7ww【官方】Nacos官方文档nacos.io/zhcn/docs/whatisnacos.html【原理】Nacos原理blog.csdn.net/qq_45122010/article/details/104079392【原理】Nacos注册中心的设计原理详解www.infoq.cn/article/B*6vyMIKao9vAKIsJYpE【原理】微服务：注册中心ZooKeeper、Eureka、Consul、Nacos对比blog.csdn.net/fly910905/article/details/100023415【全面】nacos实战（史上最全）www.cnblogs.com/crazymakercircle/p/14231815.htmlRPCdubbo阿狸_桃子博客频道CSDN.NETblog.csdn.net/liwf_/article/category/2425075【dubbo学习】5.dubboadmin管理控制台启动ITeye技术网站orangesdk.iteye.com/blog/2207614UserGuidezhDubboalibaba.github.io/dubbodocstatic/User+Guidezh.htm毫秒服务引擎msechaomiao.qq.com/wosyingjun/HRPC:AlightweighthighperformanceRPCframeworkbaseonNettyandZookeepergithub.com/wosyingjun/HRPCweibocom/motan:AremoteprocedurecallRPCframeworkforrapiddevelopmentofhighperformancedistributedservices.github.com/weibocom/motanqiangzigege/MyThrift码云开源中国git.oschina.net/qiangzigege/MyThriftgjhuai/rpc码云开源中国git.oschina.net/gjhuai/rpc", "SkillsMap/分布式事务.md": "分布式事务【课程】从0到1实现分布式事务认识分布式事务blog.csdn.net/woaixinxin123/article/details/103709926视频：www.bilibili.com/video/av80626430/【课程】【黑马】分布式事务解决方案专题www.bilibili.com/video/BV1FJ411A7mV/【入门】分布式事务，这一篇就够了xiaomiinfo.github.io/2020/01/02/distributedtransaction/【深度】1.4w字，25张图让你彻底掌握分布式事务原理blog.csdn.net/weixin_41385912/article/details/109396670【深度】对比5种分布式事务方案，还是宠幸了阿里的Seata（原理+实战）blog.csdn.net/hollis_chuang/article/details/112386366txlcn从0到1实现分布式事务认识分布式事务blog.csdn.net/woaixinxin123/article/details/103709926视频：www.bilibili.com/video/av80626430/分布式事务从0到1了解TXLCN原理blog.csdn.net/woaixinxin123/article/details/103710053视频一：www.bilibili.com/video/av80676649视频二：www.bilibili.com/video/av80676836", "SkillsMap/前端.md": "TOC准备使用云笔记或Markdown记录在查询资料中遇到各种问题和答案。熟练使用VSCode，安装必需的各种插件。VSCode配置Vue开发环境Vetur+ESLint+Prettierblog.zuiyu1818.cn/posts/VScode_Vue.html看视频做练习时，所有的练习必须是自己手敲、调试过的，不能偷懒。看视频练习，建议使用Win键+Left/Rigth键将屏幕分成两个部分，左边看视频，右边敲代码。HTML/CSS实战1.观看视频Web前端最通俗易懂html+css合集9天速成www.bilibili.com/video/BV1bK4y1P7R9听懂此教程，需要对html/css有简单了解。此教程重在实操。2.完成上面视频中的例子作品。3.html&css初学者教程200+小项目www.bilibili.com/video/BV1XV411n7Qx参考视频完成例子，例子很多，完成越多越好。源码地址：`github.com/SCUTBrothers/HtmlCSSTutorialForBeginnersLearningMaterialsofYoutubeVideo`尽管有源码，还是自己一点一点敲出来、调试通过更有意义，别人源码可以作为参考。4.可选：github.com/zxuqian/htmlcssexamplesJavaScript学习1.观看视频JavaScript最新教程通俗易懂www.bilibili.com/video/BV1JJ41177di。内容包括JavaScript语法、JSON、DOM、jQuery。2.完成上面视频的所有的例子。3.阅读完《JavaScript语言精粹:修订版192.168.31.200/books/%E5%89%8D%E7%AB%AF/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9.pdf》不习惯电子版，可以自己购买纸质版。4.进阶练习。参考视频教程36个js网页特效教程www.bilibili.com/video/BV11E411K7TV，完成视频中的例子。5.【练习】JavaScript的学习代码总结github.com/csxiaoyaojianxian/JavaScriptStudyEasyUI/LayUI学习1.从EasyUI官网jeasyui.com/download/index.php下载jQuery版本的easyui，完成demo中以下列表中所有例子：ComboBoxDataGridLayoutPanel2.完成LayUI官方文档www.layui.com/doc/中练习，可参考Layui在线示例www.layui.com/demo/，练习内容如下：布局www.layui.com/doc/element/layout.html导航www.layui.com/doc/element/nav.html选项卡www.layui.com/doc/element/tab.html面板www.layui.com/doc/element/panel.html弹出层www.layui.com/doc/modules/layer.html数据表格www.layui.com/doc/modules/table.htmlTypeScript学习【入门】观看视频B站讲的最好的Vue3+TS从入门到精通www.bilibili.com/video/BV1CK411u75G的P1~P36，后面的是Vue3内容。【练习】参考源码：github.com/qinting513/Vue3TS_TodoList.git可选：阅读《TypeScript编程》Vue学习【入门】Vue3+TS快速上手24kcs.github.io/vue3_study/【入门】Vue2:观看视频4个小时带你快速入门Vuewww.bilibili.com/video/BV12J411m7MG【练习】参考源码：github.com/ZzZzzzxc/vueneteasecloudmusic【入门】观看视频B站讲的最好的Vue3+TS从入门到精通www.bilibili.com/video/BV1CK411u75GP37~P53。【练习】参考源码：github.com/qinting513/Vue3TS_TodoList.git【官方】阅读完Vue官方文档v3.cn.vuejs.org/guide/。【总结】Vue学习笔记：Vue入门学习mrbird.cc/VueLearnNote.htmlAngular1.观看视频Angular零基础入门教程www.bilibili.com/video/BV1M44y1k7JKFlutter/Dart学习1.Dart学习：阅读Dart语言基础入门篇zhuanlan.zhihu.com/p/101332443`Dart`与`Java`、`TypeScript`、`C`等语言惊人的相似，阅读上面的入门文章即可编程。如果没有面向对象编程基础，可观看视频DartFlutter2入门实战视频教程2021年更新www.bilibili.com/video/BV1S4411E7LYP1~P142.完成github.com/AweiLoveAndroid/Flutterlearning中Dart相关例子代码练习。3.Flutter学习：技术胖的Flutter学习路线jspang.com/detailed?id=58，这个视频是配blog笔记的，便于复习和查找。视频地址：Flutter基础视频教程www.bilibili.com/video/BV15t411U7yf其他可选：观看视频DartFlutter2入门实战视频教程2021年更新www.bilibili.com/video/BV1S4411E7LYP15~4.完成github.com/AweiLoveAndroid/Flutterlearning中Flutter相关例子代码练习。5.阅读Flutter实战book.flutterchina.club/。【入门】Flutter基础系列之入门一www.cnblogs.com/LeeGof/p/10493238.html【入门】Flutter基础系列之混合开发二www.cnblogs.com/LeeGof/p/10925672.html开源项目【项目】awesomeflutter:Flutterlibraries,tools,tutorials,articlesgithub.com/Solido/awesomeflutter【项目】flutter常用140+组件的demogithub.com/alibaba/fluttergoUIgoteam/JQueryEasyUI1.5.xOfInsdepTheme码云Gitee.comgitee.com/xiahuibin/JQueryEasyUI1.5.xOfInsdepThemeloafer/jQuery.easyuiextend:jqueryeasyuiextensiongithub.com/loafer/jQuery.easyuiextend组件|Elementelementcn.eleme.io//zhCN/component/tableGitHubElemeFE/element:AVue.js2.0UIToolkitforWebgithub.com/ElemeFE/elementvueelementadminpanjiachen.github.io/vueelementadmin//dashboard鱼蛋儿/elementadmin码云Gitee.comgitee.com/yupeng957/elementadminlayui经典模块化前端框架www.layui.com/Bilibili/flv.js:HTML5FLVPlayergithub.com/Bilibili/flv.jsWeexweexproject.io/SVGSVG教程|菜鸟教程www.runoob.com/svg/svgtutorial.htmlXML问题:使用SVG编程www.ibm.com/developerworks/cn/xml/xmatters40/InteractiveSVGComponents|Peter'sWebsitewww.petercollingridge.co.uk/interactivesvgcomponentschokcoco/SVG:SVG奇思妙想github.com/chokcoco/SVGkbwood/svg:jQuerySVGplugingithub.com/kbwood/svggilbarbara/logos:AhugecollectionofSVGlogosgithub.com/gilbarbara/logoscolebemis/feather:Simplybeautifulopensourceiconsgithub.com/colebemis/feathersvgdotjs/svg.js:ThelightweightlibraryformanipulatingandanimatingSVGgithub.com/svgdotjs/svg.jsadobewebplatform/Snap.svg:TheJavaScriptlibraryformodernSVGgraphics.github.com/adobewebplatform/Snap.svgaptana/studio3rcp:ThisrepositorycontainstheRCPcodeforAptanaStudio3.Thisisthewrapper/packagingtomakeusanEclipsebasedstandaloneproduct.github.com/aptana/studio3rcpGeertjanWielenga/HTMLWYSIWYGgithub.com/GeertjanWielenga/HTMLWYSIWYGbatik详解yydcj的专栏CSDN博客blog.csdn.net/yydcj/article/details/8489419基于EMS图形子系统二进制与SVG图形文件同步转换的设计与实现_电工电气_中国百科网www.chinabaike.com/t/9642/2014/0414/2062213.html", "SkillsMap/区块链.md": "区块链区块链学习路上的一些资料作为参考github.com/cancerts/studyblockchainreferrenceSolidity官方文档中文版wiki.jikexueyuan.com/project/solidityzh/以太坊官网文档中文版wiki.jikexueyuan.com/project/ethereum/汪晓明对区块链、以太坊的思考wangxiaoming.com/blog/archives/北京大学肖臻老师《区块链技术与应用》公开课www.bilibili.com/video/av37065233/区块链技术与应用视频笔记（14）blog.csdn.net/volunteer1024/article/details/95016814区块链技术与应用视频笔记（59）blog.csdn.net/volunteer1024/article/details/98221582第10讲BTC分叉blog.csdn.net/volunteer1024/article/details/100558255第11讲课堂问答blog.csdn.net/volunteer1024/article/details/100558276第1416讲ETH以太坊概述、账户、状态树blog.csdn.net/volunteer1024/article/details/100564872视频课程区块链技术核心概念与原理讲解www.imooc.com/learn/988java从零开始开发区块链技术www.bilibili.com/video/av43326226/区块链技术从入门到精通www.bilibili.com/video/av31859009", "SkillsMap/工具.md": "TOC工具使用Eclipse远程调试（远程服务器端监听www.cnblogs.com/jianliangWu/p/7110681.html阿里巴巴程序员常用的15款开发者工具www.infoq.cn/article/1jV*BDxGwld6CWDVIt48非常全的VsCode快捷键blog.csdn.net/p358278505/article/details/74221214eclipse使用jetty:run命令调试blog.csdn.net/huaieli1/article/details/79494871nginx配置locationrootbw_0927博客园www.cnblogs.com/my_life/articles/7070805.htmlDocker学习笔记2Docker常用命令CSDN博客blog.csdn.net/we_shell/article/details/38368137xpath的学习www.cnblogs.com/xxyBlogs/p/4244073.html工具：chrome插件xpathhelper", "SkillsMap/数据库.md": "TOCMySQL阅读《高性能MySQL第3版》【官方】MyCat官方文档github.com/MyCATApache/MycatServer/wiki【全面】Mycat2权威指南www.yuque.com/books/share/6606b3b63365418794c4e51116894695【全面】MySQL数据库集群方案汇总www.yuque.com/zerodai/yqzdgs/mnkzn3包括后端各种技术：数据库中间件，MySQL，Oracle，MongoDB，Redis，SQLServer，RabbitMQ，【入门】多图文，详细介绍mysql各个集群方案www.cnblogs.com/lgx211/p/12456859.html【项目】阿里巴巴MySQLbinlog增量订阅&消费组件Canalgithub.com/alibaba/canal【项目】DistributedDatabaseEcospheregithub.com/apache/shardingsphere【入门】ShardingJDBC使用入门和基本配置www.cnblogs.com/yixinjishu/p/10876071.html【深度】MySQL高可用架构对比，MMM与MHA以及MGRblog.csdn.net/William0318/article/details/106855431【深度】MySQL+MGR单主模式和多主模式的集群环境部署手册Centos7.5www.cnblogs.com/kevingrace/p/10470226.html【深度】悄悄告诉你MySQLMGR到底牛在哪?blog.csdn.net/weixin_27146053/article/details/113592833【深度】MySQL5.7基于组复制MySQLGroupReplication运维小结www.cnblogs.com/kevingrace/p/10260685.html【深度】MySQLReplication主从复制全方位解决方案www.cnblogs.com/clsn/p/8150036.html【深度】常见索引介绍www.cnblogs.com/yunnick/p/11165838.html【深度】方案虽好，成本先行：数据库Sharding+Proxy实践解析dbaplus.cn/news1118541.html【深度】懵了！女朋友突然问我MVCC实现原理www.cnblogs.com/fkaka/p/14620957.html【入门】必须了解的MySQL三大日志：binlog、redolog和undologmp.weixin.qq.com/s/JPgROEQIQRuRNwAT_19cVAMongoDB【入门】MongoDB是什么?能干嘛？zhuanlan.zhihu.com/p/59753955【入门】MongoDB教程：1天玩转MongoDB数据库c.biancheng.net/mongodb/【书籍】阅读《Mongodb权威指南（中文第二版）》Redis【入门】Redis【入门】就这一篇!www.wmyskxz.com/2018/05/31/redisrumenjiuzheyipian/【入门】Redis的8大数据类型blog.csdn.net/zhuzj12345/article/details/111245513【入门】redis八种基本数据类型及其应用blog.csdn.net/xiewenfeng520/article/details/104063062【全面】Redis知识体系详解www.pdai.tech/md/db/nosqlredis/dbredisoverview.html【书籍】阅读《Redis开发与运维付磊》【深度】Redis专题：了解Redis集群，这篇就够了mp.weixin.qq.com/s/ovkWr58oRP_zumdis4TxeQ【深度】Redis缓存失效策略思考mp.weixin.qq.com/s/8R2nn3cbwSO7n6fZ9SXTw【深度】Redis9――史上最强【集群】入门实践教程www.cnblogs.com/wmyskxz/p/12511834.html【深度】Redis8――发布/订阅与Streamzhuanlan.zhihu.com/p/113370863【深度】Redis7――持久化【一文了解】www.cnblogs.com/wmyskxz/p/12487505.html【深度】Redis6――GeoHash查找附近的人www.cnblogs.com/wmyskxz/p/12466945.html【深度】Redis5――亿级数据过滤和布隆过滤器blog.csdn.net/WantFlyDaCheng/article/details/104832358【深度】Redis5――亿级数据过滤和布隆过滤器blog.csdn.net/WantFlyDaCheng/article/details/104832358【深度】Redis3――分布式锁深入探究blog.csdn.net/weixin_43893935/article/details/104652792【深度】Redis2――跳跃表www.wmyskxz.com/2020/02/29/redis2tiaoyuebiao/【深度】Redis1――5种基本数据结构www.wmyskxz.com/2020/02/28/redis15chongjibenshujujiegou/OracleOracle用户，权限，角色以及登录管理【不错小结】haiross的专栏CSDN博客blog.csdn.net/haiross/article/details/25777335Oracle建立表空间和用户冷雨夜的专栏CSDN博客blog.csdn.net/starnight_cbj/article/details/6792364Centos6/7下静默安装oracle10g一路追寻的博客CSDN博客blog.csdn.net/u013938484/article/details/51175501cenos6.8安装oracle10g_百度文库wenku.baidu.com/view/2d79c159284ac850ac0242b2.htmlCentOS6.332位静默安装Oracle10gr2详细教程_百度文库wenku.baidu.com/view/210a0659a98271fe910ef937.htmlOracle起步创建临时表空间/表空间/创建用户/授权MuaRine博客园www.cnblogs.com/xmaomao/p/3273102.htmlCentOSminimal搭建基本的Linux学习环境简书www.jianshu.com/p/bdd29c1e1dd9Centos7学习之添加用户王吉军全栈工程师CSDN博客blog.csdn.net/johnnycode/article/details/40655857Linux下挂载新硬盘方法知秋一叶CSDN博客blog.csdn.net/zqixiao_09/article/details/51417432centos7配置静态ip薛定谔的猫！博客园www.cnblogs.com/zhangXingSheng/p/6580718.htmlOracle11g删除生命不止，战斗不息！51CTO技术博客soulful.blog.51cto.com/468033/378995使用Phabricator做为CodeReview工具简书www.jianshu.com/p/b1a75a14638cCodereviewPhabricatorUseguideintroduce简书www.jianshu.com/p/d9957c1d2339SpringMVC更灵活的控制json返回（自定义过滤字段）diamondfsd.com/article/ae89cf4ef6794cc09882f02e0240866eHTML&amp;CSS设计与构建网站豆瓣book.douban.com/subject/21338365/JavaScript&amp;jQuery交互式Web前端开发豆瓣book.douban.com/subject/26433805/TopJUI前端框架最懂后端程序员的极速Web开发框架www.topjui.com/功能演示Lodop打印控件官方网站www.lodop.net/LodopDemo.html监视oracle执行的SQL语句CSDN博客blog.csdn.net/zaneabc/article/details/51924309Linux下完全删除Oracle麦地坞51CTO技术博客yunlongzheng.blog.51cto.com/788996/768269Oracle占用cpu过高的处理办法FenggFocusOracleCSDN博客blog.csdn.net/fffygapl/article/details/7718266Oracle之物化视图Ronger博客园www.cnblogs.com/Ronger/archive/2012/03/28/2420962.htmlOracle10gforlinuxX86的SILENT安装oracle,data,root,enterprice64,HOMEwww.bijishequ.com/detail/291324?p=55oracle10g在linux上的静默安装为程序员服务ju.outofmemory.cn/entry/251840数据库数据库分库分表sharding系列三关于使用框架还是自主开发以及sharding实现层面的考量blog.csdn.net/bluishglc/article/details/7766508Oracle怎么获取某个表变化的数据CSDN论坛bbs.csdn.net/topics/392312617Oracle表变化趋势追踪记录原创czmmiao.iteye.com/blog/1327665zhoubihui/redo_log_calculate_analysis:oracle_redo_calculate_analysis,Oracle数据库复制github.com/zhoubihui/redo_log_calculate_analysisstuxuhai/HData:一个支持多数据源的ETL数据导入/导出工具github.com/stuxuhai/HDatatheseusyang/geode码云开源中国git.oschina.net/theseusyang/geode大数据计算服务ODPS_大数据分析挖掘_分布式运算阿里云www.aliyun.com/product/odpsSQLPerformanceTuning:QueryOptimization101DZoneDatabasedzone.com/articles/sqlhandbookandbestpracticesperformancetuning?utm_source=Weekly%20Digest&utm_medium=email&utm_content=database&utm_campaign=wd%2020160217alibaba/DataX:DataX是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括MySQL、Oracle、HDFS、Hive、OceanBase、HBase、OTS、ODPS等各种异构数据源之间高效的数据同步功能。github.com/alibaba/DataX常见问题&middot;alibaba/druidWikigithub.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98arthurblake/log4jdbc:log4jdbcisaJavaJDBCdriverthatcanlogSQLand/orJDBCcallsandoptionallySQLtiminginformationforotherJDBCdriversusingtheSimpleLoggingFacadeForJavaSLF4Jgithub.com/arthurblake/log4jdbc数据库Sharding的基本思想和切分策略Laurence的技术博客博客频道CSDN.NETblog.csdn.net/bluishglc/article/details/6161475产品表与分类表数据库设计_百度文库wenku.baidu.com/link?url=LAA5APO4vPnb6riguW_qzNBGFCVbku3ThaSdTEAI_ZuEp8oY1aax2ZFYRjfA964Hsfn8rEJG9FF6hGKvk9g6fA91quVficiX4Y1oQoh2y中小型商城系统中的分类/产品属性/扩展属性的数据库设计菩提树下的杨过博客园www.cnblogs.com/yjmyzz/archive/2010/06/27/1766012.html电子商务ecommerce随笔分类活雷锋博客园www.cnblogs.com/mmmjiang13/category/288925.html非小型电子商务系统设计经验分享活雷锋博客园www.cnblogs.com/mmmjiang13/archive/2012/07/05/2575538.html29条消息大数据在电力行业的应用前景有哪些？知乎www.zhihu.com/question/23241126京东11.11|运筹帷幄于千里之外，大数据构建京东智慧物流系统|36大数据www.36dsj.com/archives/68545从0到1构建数据生态系列之二：拓荒|36大数据www.36dsj.com/archives/69704百度网盘sp***ra的分享pan.baidu.com/share/home?uk=2902511137category/type=0", "SkillsMap/架构.md": "分析设计用Axure写产品需求文档实例www.axure.com.cn/2966AxureShop原型演示demo.axureshop.com/?url=cloud.axureshop.com/pvpap1&buyurl=www.axureshop.com/a/1176518.html常用的软件需求说明书模板zhuanlan.zhihu.com/p/8503721110.软件需求最佳实践笔记|需求描述zhuanlan.zhihu.com/p/81875474架构实战：架构设计文档模板juejin.cn/post/6844903863619698696", "SkillsMap/编程语言.md": "编程基础一口气搞懂「链表」，就靠这20+张图了mp.weixin.qq.com/s/HWu2eOHEPGi44jgi4VRoXgPythongithub.com/gjhuai/fanxiangce廖雪峰的Python教程www.liaoxuefeng.com/wiki/1016959663602400Python3教程www.runoob.com/python3/python3tutorial.html用Python做科学计算&mdash;用Python做科学计算old.sebug.net/paper/books/scipydoc/index.htmlPython框架Flask项目实战教程jamesben博客园www.cnblogs.com/jsben/p/4909964.htmlPython自动化测试selenium爬虫被检测到该如何破？知乎www.zhihu.com/question/50738719SeleniumwithPythondocumentationseleniumpython.readthedocs.io/如何突破网站对selenium的屏蔽_鲲鹏Web数据抓取www.sitedigger.com/html/articles/20180821/653.htmlpython爬虫selenium抓取今日头条（ajax异步加载）www.cnblogs.com/hellangels333/p/8762112.htmlSeleniumPython中文文档2documentationseleniumpythonzh.readthedocs.io/en/latest/locatingelements.htmlweb自动化测试（python3）许西城的博客（记录点滴）许西城CSDN博客blog.csdn.net/CCGGAAG/column/info/16881Golang【入门】Go语言简明教程studygolang.com/articles/13958【书籍】Go语言高级编程AdvancedGoProgrammingchai2010.cn/advancedgoprogrammingbook/【练习】golang教程学习笔记github.com/gjhuai/golangStudy【项目】gozero微服务框架github.com/taltech/gozero/blob/master/readmecn.md【项目】Go数据中台系统github.com/jackluo2012/datacenter说明：我用gozero一周实现了一个中台系统xie.infoq.cn/article/5adaa270170ad23e8108ea4b8【书籍】《Go程序设计语言》【练习】Go语言圣经《Go程序设计语言》习题汇总segmentfault.com/a/1190000021285503【深度】Go程序内存泄露问题快速定位zhuanlan.zhihu.com/p/368567370【深度】如何写出优雅的Go语言代码draveness.me/golang101/【练习】Go学习、Go进阶、Go实用工具类、Gokit，GoMicro微服务实践、Go推送hub.fastgit.org/hwholiday/learning_tools", "SkillsMap/运维.md": "Zookeeper【入门】Zookeeper入门看这篇就够了blog.csdn.net/java_66666/article/details/81015302【深度】说得太好了！阿里巴巴为什么不用ZooKeeper做服务发现？blog.csdn.net/zl1zl2zl3/article/details/105207165MinIO【入门】开源分布式对象存储MinIOzhuanlan.zhihu.com/p/103803549", "backend/Consul学习.md": "Consul原理和使用简介Consul原理和使用简介blog.coding.net/blog/introconsulConsul是什么Consul是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件，由HashiCorp公司用Go语言开发，基于MozillaPublicLicense2.0的协议进行开源。Consul支持健康检查,并允许HTTP和DNS协议调用API存储键值对。命令行超级好用的虚拟机管理软件vgrant也是HashiCorp公司开发的产品。一致性协议采用Raft算法，用来保证服务的高可用。使用GOSSIP协议管理成员和广播消息，并且支持ACL访问控制。功能特点服务发现：Consul的客户端可以提供的服务，如api或mysql,其他的客户端可以使用Consul发现一个特定服务的提供者。使用DNS或HTTP，应用程序可以很容易地找到他们所依赖的服务。健康检查：Consul客户端可以提供任何数量的健康检查,无论是与给定的服务“Web服务器返回200OK”,还是和本地节点相关联\"内存利用率低于90%\"。这些信息可以由操作员监控集群健康,它用于由服务发现组件将通信路由远离不健康的主机。键/值存储：应用程序可以使用Consul的分层键/值存储任意数量的目标,包括动态配置,特征衰弱,leader选举,等等。简单的HTTPAPI使得它易于使用。多数据中心：Consul支持多个数据中心,这意味着Consul的用户不用担心构建额外的抽象层增加到多个区域。Consul的优势使用Raft算法来保证一致性，比复杂的Paxos算法更直接。相比较而言,zookeeper采用的是Paxos，而etcd使用的则是Raft。支持多数据中心，内外网的服务采用不同的端口进行监听。多数据中心集群可以避免单数据中心的单点故障，而其部署则需要考虑网络延迟、分片等情况等。zookeeper和etcd均不提供多数据中心功能的支持。支持健康检查。etcd不提供此功能。支持http和dns协议接口。zookeeper的集成较为复杂，etcd只支持http协议。官方提供web管理界面，etcd无此功能。Consul的角色client:客户端，无状态，将HTTP和DNS接口请求转发给局域网内的服务端集群。server:服务端，保存配置信息，高可用集群，在局域网内与本地客户端通讯，通过广域网与其他数据中心通讯。每个数据中心的server数量推荐为3个或是5个。Consul架构Consul架构devopsh.com/726.htmlAgent代理是长时间运行的守护进程在每个Consul集群的成员。它是由Consul代理运行。代理能够在客户机或服务器上运行模式。由于所有节点都必须运行一个代理,它是简单的参考节点作为一个客户端或服务器,但还有其他代理的实例。所有代理可以运行DNS或HTTP接口,并负责运行检查和保持服务同步。Client客户端是转发所有的RPC到服务器的代理。客户端是相对无状态的。客户端执行的唯一背景活动是正在LAN八卦池gossippool的一部分。这具有最小资源开销，仅消耗少量的网络带宽。Server服务器是一套扩展的职责包括参与Raft仲裁，维护集群状态，响应RPC查询，WAN八卦gossip到其他数据中心，并转发查询的主导者或远程数据中心的代理人。Datacenter数据中心似乎是显而易见的，但也有微妙的细节，如EC2多个可用区。我们定义了一个数据中心是一个联网环境是私有的，低延迟和高带宽。这不包括通信，将穿越公共互联网。Consensus当我们的文档中使用，我们使用的共识，意味着在交易的订货经选举产生的领导人达成协议以及协议。由于这些事务应用到FSM，我们隐含地包括一个复制的状态机的一致性。共识进行了更详细的描述维基百科，和我们的实施进行说明此处。GossipConsul是建立在之上Sref，它提供了一个完整的gossipprotocol是用于多种用途。Sref实行会员制，故障检测和事件广播机制。我们使用这些描述更多的gossipdocumentation。这足以知道，gossip涉及随机节点到节点通信，主要是通过UDP。LANGossip指LAN八卦池ReferstotheLANgossippool,它包含了所有位于同一局域网络或数据中心上的节点。WANGossip指WAN八卦池ReferstotheWANgossippool，其中只包含服务器。这些服务器主要位于不同的数据中心，并且通常通信通过互联网或广域网。RPC远程过程调用。这是一个请求/响应机制，允许一个客户端，使一服务器的请求。!_v_images/20191129172555.png如何用Consul打造弹性可扩展的PaaS平台如何用Consul打造弹性可扩展的PaaS平台os.51cto.com/art/201601/504856.htmConsul和ZooKeeper的区别Consul和ZooKeeper的区别dockone.io/article/300服务发现：ZookeepervsetcdvsConsulit.dataguru.cn/article81311.html", "backend/Docker使用指南.md": "Docker容器进入的4种方式www.cnblogs.com/xhyan/p/6593075.html1.查看docker信息（version、info）```shell查看docker版本$dockerversion显示docker系统的信息$dockerinfo```2.对image的操作（search、pull、images、rmi、history）```shell检索image$dockersearchimage_name下载image$dockerpullimage_name列出镜像列表;a,all=falseShowallimages;notrunc=falseDon'ttruncateoutput;q,quiet=falseOnlyshownumericIDs$dockerimages删除一个或者多个镜像;f,force=falseForce;noprune=falseDonotdeleteuntaggedparents$dockerrmiimage_name显示一个镜像的历史;notrunc=falseDon'ttruncateoutput;q,quiet=falseOnlyshownumericIDs$dockerhistoryimage_name```3.启动容器（run）docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。```shell在容器中运行\"echo\"命令，输出\"helloword\"$dockerrunimage_nameecho\"helloword\"交互式进入容器中$dockerrunitv/root/software/:/mnt/software/image_name/bin/bashi：表示以“交互模式”运行容器；t：表示容器启动后会进入其命令行；v：表示需要将本地哪个目录挂载到容器中，格式：v<宿主机目录>:<容器目录>；在容器中安装新的程序$dockerrunimage_nameaptgetinstallyapp_nameNote：在执行aptget命令的时候，要带上y参数。如果不指定y参数的话，aptget命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。aptget命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。$dockerrundp22p58080:8080learn/tutorial/usr/sbin/sshdDd：表示以“守护模式”执行命令或脚本，此时Tomcat控制台不会出现在输出终端上。p：表示宿主机与容器的端口映射，此时将容器内部的8080端口映射为宿主机的58080端口。name：表示容器名称，用一个有意义的名称命名即可。```4.查看容器（ps）```shell列出当前所有正在运行的container$dockerps列出所有的container$dockerpsa列出最近一次启动的container$dockerpsl在docker容器内查看ip$ipaddrshoweth0$iproute```5.保存对容器的修改（commit）当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。```shell保存对容器的修改;a,author=\"\"Author;m,message=\"\"Commitmessage$dockercommitIDnew_image_nameNote：image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。```6.对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）```shell删除所有容器$dockerrm`dockerpsaq`删除单个容器;f,force=false;l,link=falseRemovethespecifiedlinkandnottheunderlyingcontainer;v,volumes=falseRemovethevolumesassociatedtothecontainer$dockerrmName/ID停止、启动、杀死一个容器$dockerstopName/ID$dockerstartName/ID$dockerkillName/ID从一个容器中取日志;f,follow=falseFollowlogoutput;t,timestamps=falseShowtimestamps$dockerlogsName/ID列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A增加的，D删除的，C被改变的$dockerdiffName/ID显示一个运行的容器里面的进程信息$dockertopName/ID从容器里面拷贝文件/目录到本地一个路径$dockercpName:/container_pathto_path$dockercpID:/container_pathto_path重启一个正在运行的容器;t,time=10Numberofsecondstotrytostopforbeforekillingthecontainer,Default=10$dockerrestartName/ID进入一个已经在运行的容器$dockerexecit775c7c9ee1e1/bin/bashattachAttachlocalstandardinput,output,anderrorstreamstoarunningcontainer.这是一个过时的命令，不建议使用$dockerattachID```7.保存和加载镜像（save、load）当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。```shell保存镜像到一个tar包;o,output=\"\"Writetoanfile$dockersaveimage_nameofile_path加载一个tar包格式的镜像;i,input=\"\"Readfromatararchivefile$dockerloadifile_path机器a$dockersaveimage_name>/home/save.tar使用scp将save.tar拷到机器b上，然后：$dockerload</home/save.tar```8、登录registryserver（login）```shell登陆registryserver;e,email=\"\"Email;p,password=\"\"Password;u,username=\"\"Username$dockerlogin```9.发布image（push）```shell发布docker镜像$dockerpushnew_image_name```10.根据Dockerfile构建出一个容器```shellbuildnocache=falseDonotusecachewhenbuildingtheimageq,quiet=falseSuppresstheverboseoutputgeneratedbythecontainersrm=trueRemoveintermediatecontainersafterasuccessfulbuildt,tag=\"\"Repositorynameandoptionallyatagtobeappliedtotheresultingimageincaseofsuccess$dockerbuildtimage_nameDockerfile_path```使容器自启动`dockerupdaterestart=always81bcb97c4f5e`参数详解docker命令参数详解dockeruseageofdockerD默认false允许调试模式debugmodeH默认是unix:///var/run/docker.socktcp://host:port来绑定或者unix:///path/to/socket来使用二进制文件的时候，当主机iphost=0.0.0.0,端口port=4243或者path=/var/run/docker.sock是缺省值，做为默认值来使用apienablecors默认flase允许CORSheader远程apib默认是空，附加在已存在的网桥上，如果是用'none'参数，就禁用了容器的网络bip默认是空，使用提供的CIDR（ClasslessInterDomainRouting无类型域间选路）标记地址动态创建网桥dcoker0,和b参数冲突d默认false允许进程模式daemonmodedns默认是空，使docker使用指定的DNS服务器g默认是\"/var/lib/docker\":作为docker使用的根路径icc默认true，允许intercontainer来通信ip默认\"0.0.0.0\"：绑定容器端口的默认Ip地址iptables默认true禁用docker添加iptables规则mtu默认1500:设置容器网络传输的最大单元mtup默认是/var/run/docker.pid进程pid使用的文件路径r默认是true重启之前运行的容器s默认是空，这个是docker运行是使用一个指定的存储驱动器v默认false打印版本信息和退出dockerrun命令详解Usage:dockerrunOPTIONSIMAGE:TAGCOMMANDARG...Runacommandinanewcontainera=map:附加标准输入、输出或者错误输出c=0:共享CPU格式（相对重要）cidfile=\"\":将容器的ID标识写入文件d=false:分离模式，在后台运行容器，并且打印出容器IDe=:设置环境变量h=\"\":容器的主机名称i=false:保持输入流开放即使没有附加输入流privileged=false:给容器扩展的权限m=\"\":内存限制格式:<number><optionalunit>,unit单位=b,k,morgn=true:允许镜像使用网络p=:匹配镜像内的网络端口号rm=false:当容器退出时自动删除容器不能跟d一起使用t=false:分配一个伪造的终端输入u=\"\":用户名或者IDdns=:自定义容器的DNS服务器v=:创建一个挂载绑定：hostdir:containerdir:rw|ro.如果容器目录丢失，docker会创建一个新的卷volumesfrom=\"\":挂载容器所有的卷entrypoint=\"\":覆盖镜像设置默认的入口点w=\"\":工作目录内的容器lxcconf=:添加自定义lxcconf=\"lxc.cgroup.cpuset.cpus=0,1\"sigproxy=true:代理接收所有进程信号eveninnonttymodeexpose=:让你主机没有开放的端口link=\"\":连接到另一个容器name:aliasname=\"\":分配容器的名称，如果没有指定就会随机生成一个P=false:Publishallexposedportstothehostinterfaces公布所有显示的端口主机接口参考docker详细的基础用法www.linuxeye.com/Linux/2019.html", "backend/GeoServer使用.md": "TOCGeoServer之发布Geotiff存在的问题首次使用geoserver发布geotiff时，在导入geotiff会遇到这样的问题：```Couldnotlistlayersforthisstore,anerroroccurredretrievingthem:Failedtocreatereaderfromfile://F:\\tif\\11.tifandhintsHints:REPOSITORY=org.geoserver.catalog.CatalogRepository@11d3c487EXECUTOR_SERVICE=java.util.concurrent.ThreadPoolExecutor....```出现这种情况时因为所选的TIFF的头文件有问题或者geoserver无法识别投影坐标系。解决方法：通过gdal_translate（提前安装了gdal）重写TIFF文件CMD命令行输入：`gdal_translateofGTiffscale输入文件路径输出文件路径`或：`gdal\\apps\\gdal_translate.exea_srsEPSG:900913mapguangdong_Level_3.tifgd032.tif`官方链接：gdal.org/1.11/gdal_translate.html瓦片地图的存储", "backend/Hadoop学习.md": "Hadoop管理员的十个最佳实践1.选择ClouderaCDH部署你的Cluster动机2.Hadoop集群配置与管理3.开启SecondaryNameNode4.使用Ganglia和Nagios监控你的集群5.设置好内存至关重要6.管理员玩转MapReduce7.NameNodeHA8.使用firewall阻止坏人进入9.开启垃圾箱trash功能10.去社区寻找帮助!_v_images/20191129172125.png", "backend/Kettle学习.md": "参考：kettle入门HelloWorld教程blog.csdn.net/neweastsun/article/details/38728757简单的把csv文件转换成xml文件的HelloWorld程序kettleHelloWorld教程重构blog.csdn.net/neweastsun/article/details/38845795还是转换csv为xml，不过加入了文件名动态传入、文件是否存在判断、错误处理；演示了job、transformation怎样协作工作kettle教程其实就你的kettle文件夹下，docs文件夹下包含了所有的文档，samples文件夹下包含了一些示例。docs里面最主要的是SpoonversionUserGuide.zip，里面记录了kettle的技术性文档，包括支持的操作系统，数据库平台，文本格式，图形化的界面，其中最重要的是所有的转换对象TransformationCoreObjects和Job对象JobCoreObjects的解释，包括截图和每一个参数的解释。www.cnblogs.com/limengqiang/archive/2013/01/16/KettleApply2.htmlwww.cnblogs.com/limengqiang/archive/2013/01/17/KettleApply3.html", "backend/Memcached学习.md": "特点使用简单的基于文本行的协议基于libevent的事件处理libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能封装成统一的接口。内置内存存储方式memcached不互相通信的分布式原理hash算法生成hashKey二级列散维护Data两个核心组件服务端MS客户端MCJAVAMemCache史无前例的详细讲解！看完包精通MEMCACHE！blog.csdn.net/hjm4702192/article/details/7894080分布式缓存Memcachedblog.sina.com.cn/s/blog_493a845501013ei0.html淘宝开放平台缓存设计getpocket.com/a/read/169855716!_v_images/20191129172107.png", "backend/Nginx反向代理.md": "Location指令URI匹配规则Nginx的location规则：优先级和路径替换blog.csdn.net/tzy233/article/details/79780444规则proxy_pass的目标地址，默认不带/，表示只代理域名，url和querystring部分不会变（把请求的path拼接到proxy_pass目标域名之后作为代理的URL）如果在目标地址后增加/，则表示把path中location匹配成功的部分剪切掉之后再拼接到proxy_pass目标地址比如请求/a/b.html```htmllocation/a{proxy_passserver;}location/a{proxy_passserver/;}```如上两个匹配成功后，实际代理的目标url分别是server/a/b.html把/a/b.html拼接到server之后server/b.html把/a/b.html的/a去掉之后，拼接到server/之后反向代理VS正向代理!_v_images/20191129175620.png!_v_images/20191129175628.png正向代理中，proxy和client同属一个LAN；它是代理客户端，为客户端收发请求，使真实客户端对服务器不可见。其是**从内到外**。反向代理中，proxy和server同属一个LAN；它是代理v服务器，为服务器收发请求，使真实服务器对客户端不可见。\"反向\"这个词在这儿的意思其实是指方向相反，即代理把来自外网client的请求forward到内网server，**从外到内**。因为服务对象和自身角色不同，所以刚好是相反的。反向代理两种用途1、作内容服务器的替身!_v_images/20191129175636.png2、作为内容服务器的负载均衡器可以在一个组织内使用多个代理服务器来平衡各Web服务器间的网络负载。在此模型中，可以利用代理服务器的高速缓存特性，创建一个用于负载平衡的服务器池。此时，代理服务器可以位于防火墙的任意一侧。如果Web服务器每天都会接收大量的请求，则可以使用代理服务器分担Web服务器的负载并提高网络访问效率。对于客户机发往真正服务器的请求，代理服务器起着中间调停者的作用。代理服务器会将所请求的文档存入高速缓存。如果有不止一个代理服务器，DNS可以采用“循环复用法”选择其IP地址，随机地为请求选择路由。客户机每次都使用同一个URL，但请求所采取的路由每次都可能经过不同的代理服务器。!_v_images/20191129175645.png", "backend/zookeeper学习.md": "Zookeeper初体验之――伪分布式安装www.cnblogs.com/haippy/archive/2012/07/19/2599989.htmlZookeeper初体验之――JAVAAPI初探www.cnblogs.com/haippy/archive/2012/07/19/2600032.htmlHelloWorldZookeeper初体验之――JAVA实例www.cnblogs.com/haippy/archive/2012/07/20/2600077.htmlApacheZookeeper官网的例子，有点晦涩Zookeeper进阶之――典型应用场景（一）www.cnblogs.com/haippy/archive/2012/07/23/2603583.htmlZookeeper进阶之――典型应用场景（二）www.cnblogs.com/haippy/archive/2012/07/23/2604556.htmlZookeeper进阶之――Zookeeper编程示例（如何使用Zookeeper实现屏障Barriers和队列Queues）www.cnblogs.com/haippy/archive/2012/07/26/2609769.html英文的Zookeeper开发常见问题分析tech.uc.cn/?p=1189分布式服务框架Zookeeper管理分布式环境中的数据www.ibm.com/developerworks/cn/opensource/oscnzookeeper/系列OSChinaZookeeper系列_Indexmy.oschina.net/xianggao/blog/538867【Zookeeper系列二】ZooKeeper典型应用场景实践my.oschina.net/xianggao/blog/531613使用RMI+ZooKeeper实现远程调用框架my.oschina.net/huangyong/blog/345164?fromerr=5OjN02heZOOKEEPER解惑www.cnblogs.com/gpcuster/archive/2010/12/29/1921213.html", "backend/Zuul学习.md": "Netflix学习笔记：Zuullxlong.iteye.com/blog/2267985从ZuulSimpleWebapp入手github.com/Netflix/zuul/wiki/zuulsimplewebapp例子github.com/flindby/springoauth2zuulSpringBoot+Oauth2+Zuul", "backend\\Linux/03-Linux学习.md": "TOC常用命令Linux统计文件夹下文件个数及目录个数1.统计文件夹下文件的个数`lsl|grep\"^\"|wcl`2.统计文件夹下目录的个数`lsl|grep\"^d\"|wcl`3.统计文件夹下文件个数，包括子文件`lslR|grep\"^\"|wcl`4.统计文件夹下目录个数，包括子目录`lslR|grep\"^d\"|wcl`wc命令：WordCount功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。wclcwc统计字节数l统计行数m统计字符数，此标志不能与c标志一起使用w统计字数。一个字定义为由空白、跳格或换行字符分隔的字符串使用ps/awk杀死进程```shell!/bin/bashGrabsandkillaprocessfromthepidlistthathasthewordmyapp67pid=`psaux|grepmyapp|awk'{print$2}'`kill9$pid```查看程序端口占用情况netstatanp|grepportno即：netstatCapn|grep8080其中最后一栏是*PID/Programname*查看linux磁盘空间容量查看磁盘使用情况dflh查看目录的磁盘占用情况dush*|sorthcrontabUbuntu查看crontab运行日志修改rsyslog文件，将/etc/rsyslog.d/50default.conf文件中的cron.*前的删掉；重启rsyslog服务servicersyslogrestart；重启cron服务servicecronrestartssh证书登录1.在windows下，创建`~\\.ssh`目录；2.在`~\\.ssh`下，执行`sshkeygentrsa`，生成私钥`id_rsa`,公钥`id_rsa.pub`;3.将公钥`id_rsa.pub`拷贝到linux的`~/.ssh`目录下，改名为`authorized_keys`；4.修改ssh配置是否开启证书登录:`vi/etc/ssh/sshd_config````shellRSAAuthenticationyes是否允许用户自行使用成对的密钥系统进行登入行为version2PubkeyAuthenticationyes是否允许用户自行使用成对的密钥系统进行登入行为AuthorizedKeysFile公钥数据路径用户目录下.ssh/authorized_keys```修改完成后，`sudosystemctlrestartsshd`重启ssh服务；5.登录服务器:`sshi~\\.ssh\\id_rsagjh@10.19.12.12`linux下ssh客户端以及sftp文件传送的一般用法linux下ssh客户端以及sftp文件传送的一般用法以前在windows上，我要用ssh连接服务器，我一般都用putty。这段时间一直在linux上工作，由于linux上一般都自带ssh客户端，也就是ssh命令了，此外还有一个命令sftp，用来安全的传送文件，今天为了管理linux服务器，用到了linux下的这两个命令行工具，现就其最常用的用法描述如下：假定服务器ip为61.145.34.33，ssh服务的端口号为9186，服务器上有个用户为sshuser；用ssh登录服务器的命令为：>sshlsshuser61.145.34.33p9186回车后，如果是第一次登录，会提示你一条认证信息，你键入yes即可，接着输入服务器sshuser的密码登录即可；用sftp登录服务器的命令为：>sftpoPort=9186sshuser@61.145.34.33回车后，输入服务器sshuser的密码登录，然后会显示一个sftp>的环境，这个时候，键入help你会看到所有命令的帮助，跟ftp命令行工具非常类似，比如get,put等等。至于这两个命令行的其他用法，可参看其联机手册...修改home下的中文目录为英文目录在终端下输入命令：exportLANG=en_USxdguserdirsgtkupdate这个时候会弹出一个配置界面，提示是否将中文目录切换为英文目录。选中不再提示，确定。系统会删除没有内容的中文目录，而有内容的目录会保持。并创建8个相应的英文目录如下：“Desktop”、“Download”、“Templates”、“Public”、“Documents”、“Music”、“Pictures”、“Videos”。此时，您在“位置”里看到的常用中文目录已经变成英文目录。只需要将原中文目录的内容拷贝到相应英文目录，并删除中文目录即可。接下来再执行exportLANG=zh_CN.UTF8以显示中文。OK，行了，三个命令就行。可就为一次改变要记三个命令，也麻烦。能不能不记啦。当然可以，那您注销，然后在登录界面选择语言种类为“Englishunitedstates”，进入系统后你就发现整个系统都变成English了，同时还会弹出一个对话框提示是否切换用户目录，选择“Updatenames”，确认并再注销，在登录界面选择“汉语”，进入系统后事个系统又变成了Chinese了，同样会弹出同一个对话框，选择\"Keepoldnames\"。OK，大功告成，一个命令都不需要记，就可完成您想要的结果。分区方案/boot200MLinux的内核及引导系统程序所需要的文件，比如vmlinuzinitrd.img文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；启动撞在文件存放位置，如kernels，initrd，grub。/100G用于存储系统文件/home200G用户工作目录；个人配置文件，如个人环境变量等；所有账号分配一个工作目录。swap是内存的两倍find```shellfind.name.gradleexecrmrf{}\\;find.typefexeclsl{}\\;```linux解压缩命令tarc:建立压缩档案x：解压t：查看内容r：向压缩归档文件末尾追加文件u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。z：有gzip属性的j：有bz2属性的Z：有compress属性的v：显示所有过程O：将文件解开到标准输出下面的参数f是必须的f:使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。压缩tarCcvfjpg.tar*.jpg//将目录里所有jpg文件打包成tar.jpgtarCczfjpg.tar.gz*.jpg//将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztarCcjfjpg.tar.bz2*.jpg//将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tarCcZfjpg.tar.Z*.jpg//将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrarajpg.rar*.jpg//rar格式的压缩，需要先下载rarforlinuxzipjpg.zip*.jpg//zip格式的压缩，需要先下载zipforlinux解压1、*.tar用tarCxvf解压2、*.gz用gzipd或者gunzip解压3、*.tar.gz和*.tgz用tarCxzf解压4、*.bz2用bzip2d或者用bunzip2解压5、*.tar.bz2用tarCxjf解压6、*.Z用uncompress解压7、*.tar.Z用tarCxZf解压8、*.rar用unrare解压9、*.zip用unzip解压nohup命令该命令的一般形式为：`nohupcommand&`如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：`nohupcommand>myout.file2>&1&`在上面的例子中，输出被重定向到myout.file文件中。使用jobs查看任务。使用fg%n关闭。添加sudoer1）进入超级用户模式。也就是输入\"su\",系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root用）2）添加文件的写权限。也就是输入命令\"chmodu+w/etc/sudoers\"。3）编辑/etc/sudoers文件。也就是输入命令\"vim/etc/sudoers\",输入\"i\"进入编辑模式，找到这一行：\"rootALL=ALLALL\"在起下面添加\"xxxALL=ALLALL\"这里的xxx是你的用户名，然后保存（就是先按一下Esc键，然后输入\":wq\"）退出。4）撤销文件的写权限。也就是输入命令\"chmoduw/etc/sudoers\"。Linux的文件权限与目录配置**使用者与群组**!_v_images/20191118210432.png帐号>/etc/passwd密码>/etc/shadowgroup>/etc/group**文件属性**!_v_images/20191118210454.png系统默认语系>/etc/sysconfig/i18n`改变文件属怅不权限`chgrp：改变所属群组>chgrpgroupnamefilenamechown：改变拥有者>chownR账号名称filename/dir;chownR账号名称:组名filename/dirchmod：改变权限,SUID,SGID,SBIT等r:4w:2x:1```shellchmod777.bashrcchmodu/g/o/a+//=rwxfilename/dirchmodu=rwx,go=rx.bashrc```将权限去掉而保留已存在的权限？如：要拿掉全部人的可执行权限`chmodax.bashrc`!_v_images/20191118210639.png**Linux更改文件拥有者|chown命令用法**www.isstudy.com/linux/4123.htmlchownR账户名称：用户组名称、文件或目录参数：R：进行递归的持续更改，即将同子目录下的所有文件、目录都更新问这个用户组。通常用在更改某一目录的情况。范例：```shellroot@linux~chownbininstall.logroot@linux~lsClrwrr1binusers24343Jun2308:33install.logroot@linux~chownroot:rootinstall.logroot@linux~lslrwrr1rootroot24343Jun2308:33install.log```", "backend\\Linux/CentOS7下安装docker.md": "TOC安装docker参考：Centos7上安装dockerwww.cnblogs.com/yufeng218/p/8370670.htmlInstallDockerCEforGentOSdocs.docker.com/install/linux/dockerce/centos/installdockerceDocker学习笔记2Docker常用命令blog.csdn.net/we_shell/article/details/383681371、安装需要的软件包，yumutil提供yumconfigmanager功能，另外两个是devicemapper驱动依赖的```shell$sudoyuminstallyyumutilsdevicemapperpersistentdatalvm2```2、设置yum源```shell$sudoyumconfigmanageraddrepodownload.docker.com/linux/centos/dockerce.repo```3、可以查看所有仓库中所有docker版本，并选择特定版本安装```shell$yumlistdockerceshowduplicates|sortr```4、安装docker```shell$sudoyuminstalldockerce由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0$sudoyuminstall<FQPN>例如：sudoyuminstalldockerce17.12.0.ce```5、启动并加入开机启动```shell$sudosystemctlstartdocker$sudosystemctlenabledocker```6、验证安装是否成功有client和service两部分表示docker安装启动都成功了```shell$dockerversion```docker容器网络无法访问docker网络原理：Docker学习笔记4――Docker网络配置blog.csdn.net/qq_37423198/article/details/78682404采用默认的网桥模式网络。需要修改宿主机配置：在/etc/sysctl.conf文件中加入以下两行```shellnet.ipv6.conf.all.disable_ipv6=1停止ipv6net.ipv4.ip_forward=1docker网络转发```重启网络：servicenetworkrestart改变docker的image存放目录steps:1.mkdir/data/docker（你想要docker存放image的目录）2.systemctlstopdocker3.vi/usr/lib/systemd/system/docker.service4.添加g/data/docker```shellUnit...Service...ExecStart=/usr/bin/dockerdaemong/data/docker...Install...```5.cpR/var/lib/docker/*/data/docker/6.systemctldaemonreload7.systemctlstartdocker安装oraclexe镜像参考：macos下使用Docker安装oraclexe11g数据库blog.csdn.net/xp541130126/article/details/70138904可以在hub.docker.com搜索自己需要的image。```shell搜索包括oracle的image，选择镜像：alexeiled/dockeroraclexe11gdockersearchoracle下载镜像dockerpullalexeiled/dockeroraclexe11g启动镜像为一个容器，并命名为oracledockerrunh\"oracle\"name\"oracle\"dp49160:22p49161:1521p49162:8080alexeiled/dockeroraclexe11g映射端口时，指定了ip，那么宿主机采用ipv4，否则采用ipv6，为了减少麻烦，最好指定ip，ip不要设成127.0.0.1，否则外网无法访问dockerrunh\"oracle_xe_1\"name\"oracle_xe_1\"dp192.168.31.200:49150:22p192.168.31.200:49151:1521p192.168.31.200:49152:8080alexeiled/dockeroraclexe11g```oracleexpress版本是免费的开发版，它的主要限制是数据库的大小最大1G，和一些性能的限制。此镜像的oracle数据库连接信息hostname:宿主机IPport:49161sid:xeusername:system/oracleusername:sys/oracleubuntu的帐户：root/admin进入docker容器```shelldockerexecit<CONTAINER><COMMAND>dockerexecit0deb75d61474/bin/bash```参考：Docker容器进入的4种方式www.cnblogs.com/xhyan/p/6593075.html安装oracle企业版镜像wget下载oracle安装文件登录oracle官网，得到下载链接，类似：download.oracle.com/otn/linux/oracle11g/R2/linux.x64_11gR2_database_1of2.zip?AuthParam=1528547837_6e9ab74583f4c5b6b8bc7256af0436be用下面命令下载即可```shellwgetlimitrate=2M\"download.oracle.com/otn/linux/oracle11g/R2/linux.x64_11gR2_database_1of2.zip?AuthParam=1528547837_6e9ab74583f4c5b6b8bc7256af0436be\"```", "backend\\Linux/CentOS7下安装jdk和groovy.md": "TOC删除原有的OpenJDK的JREcentos7自带只有OpenJDK的JRE，没有JDK。JRE和JDK默认被安装在`/usr/lib/jvm`目录下1.查看系统是否安装过java`root@localhosthomeyumlistinstalled|grepjava`2.如果有旧版本的java，可以用如下方法卸载java`root@localhosthomeyumyremovejava1.8.0openjdk*`3.查看java软件包列表`root@localhosthomeyumylistjava*`安装OpenJDK这部分可选。（由于Oracle的OpenJDK在6个月后，会被强制要求升级到JDK11，所以不推荐安装）4.下载安装java1.8的所有软件包，中途需要输入y来确认下载。`root@localhosthomeyuminstalljava1.8.0openjdk*`5.安装成功，输入如下命令检查是否安装成功，如果返回正确的版本号则表示安装成功。`root@localhosthomejavaversion`安装AmazonCorrettoJDK8CorrettoJDK官方安装说明docs.aws.amazon.com/zh_cn/corretto/latest/corretto8ug/genericlinuxinstall.htmlCorrettoJDK是OpenJDK的分支，更新比较及时，推荐使用。要将CorrettoRPM存储库与yum软件包管理器（例如AmazonLinuxAMI）一起使用，请导入Corretto公有密钥，然后将存储库添加到系统列表中。对于大多数系统，您必须运行以下命令：```shellsudorpmimportyum.corretto.aws/corretto.keysudocurlLo/etc/yum.repos.d/corretto.repoyum.corretto.aws/corretto.repo```添加存储库后，您可以运行以下命令来安装Corretto8：`sudoyuminstallyjava1.8.0amazoncorrettodevel`验证安装`javaversion`安装GroovySimplyopenanewterminalandenter:`curlsget.sdkman.io|bash`Openanewterminalortypethecommand:`source\"$HOME/.sdkman/bin/sdkmaninit.sh\"`TheninstallthelateststableGroovy:`sdkinstallgroovy`Afterinstallationiscompleteandyou’vemadeityourdefaultversion,testitwith:$groovyv", "backend\\Linux/CentOS7升级Python2.x到3.x，安装pip.md": "TOC下载并安装```shellyuminstallgccgccc++y此命令非必需，缺少gcc时执行下载python3wgetwww.python.org/downloads/release/python372/tarxvfPython3.7.2.tar.xzcdPython3.7.2/编译./configuremakemakeinstall```设置3.X为默认版本验证此时默认版本```shell$pythonV一个是旧版本，一个是新版本Python2.7.5$python3V新版本Python3.7.2$lsal/usr/bin|greppython...lrwxrwxrwx.1rootroot7May262017python>python2在/usr/bin下面。可以看到python链接的是python2.7```切换默认版本```shell将原来python的软链接重命名mv/usr/bin/python2.7/usr/bin/python2将python链接至python3lns/usr/local/bin/python3/usr/bin/python```修改一些系统工具yum、firewallcmd等工具都是基于python2.7开发的，升级python3后，都不能使用了，需要将文件头!/usr/bin/python改为!/usr/bin/python2.7。需要修改文件：/usr/bin/yum/usr/libexec/urlgrabberextdown/usr/bin/firewallcmd...安装pip从Python2版本>=2.7.9或Python3版本>=3.4开始，官网的安装包中已经自带了pip，在安装时用户可以直接选择安装。或者如果使用由`virtualenv`或者`pyvenv`创建的VirtualEnvironment，那么pip也是被默认安装的。如果没有在安装的时候，选择上安装pip，那么也可以从本地安装。例如，直接使用`getpip.py`进行安装。首先从官网下载`getpip.py`，然后直接运行`pythongetpip.py`即可。参考：Centos7Python3以及pip3安装flintx.me/2017/12/15/Centos%207%20Python3%20%E4%BB%A5%E5%8F%8A%20pip3%20%E5%AE%89%E8%A3%85/安装pip2```python首先安装epel扩展源$sudoyumyinstallepelrelease安装pythonpip$sudoyumyinstallpythonpip清除cache$sudoyumcleanall测试（任意目录下）$pipVpip8.1.2from/usr/lib/python2.7/sitepackagespython2.7```手动安装pip3```python下载源代码$wgetnocheckcertificategithub.com/pypa/pip/archive/19.0.3.tar.gz解压文件$tarzvxf19.0.3.tar.gz$cdpip19.0.3使用Python3安装$python3setup.pyinstall配置软链接$sudolns/usr/local/bin/pip/usr/bin/pip3测试（任意目录下）$pip3Vpip9.0.1from/usr/local/lib/python3.6/sitepackagespython3.6```安装ssl模块参考：centos6编译安装python3.7www.aikaiyuan.com/12064.htmlCentOS等linux下python需要通过源码编译安装，默认情况下未安装ssl，需要先安装openssl，而且必须是源码编译安装，因为python编译安装时，需要编译ssl代码。源码安装openssl```shellwgetwww.openssl.org/source/openssl1.0.2o.tar.gz可以下载最新版本cdopenssl1.0.2o./configprefix=/usr/local/opensslopenssldir=/usr/local/opensslmakemakeinstall```下载python3.7```shellwgetwww.python.org/ftp/python/3.7.0/Python3.7.0.tgzcdPython3.7.0```修改ssl路径`vimModules/Setup.dist`>SSL=/usr/local/openssl>_ssl_ssl.c\\>DUSE_SSLI$SSL/includeI$SSL/include/openssl\\>L$SSL/liblssllcrypto重新编译安装```shell./configureenableoptimizationswithopenssl=/usr/local/opensslmakemakeinstall```", "backend\\Linux/CentOS7安装MongoDB-3.6.md": "TOC配置yum源`vim/etc/yum.repos.d/mongodborg3.6.repo````shellmongodborg3.6name=MongoDBRepositorybaseurl=repo.mongodb.org/yum/redhat/$releasever/mongodborg/3.6/x86_64/gpgcheck=1enabled=1gpgkey=www.mongodb.org/static/pgp/server3.6.asc```安装与配置yum安装`yumyinstallmongodborg`查看mongodb的位置`whereismongod`创建数据目录与日志目录，并授权`mkdirp/data/mongodb/data/data/mongodb/logs`一般分配到独立的大分区`chownmongod.mongod/data/mongodb/data/data/mongodb/logsR`默认是使用mongod执行的，所以需要修改一下目录权限修改配置`vim/etc/mongod.conf````shellwheretowriteloggingdata.systemLog:destination:filelogAppend:truepath:/data/mongodb/logs/mongod.log修改日志文件位置Whereandhowtostoredata.storage:dbPath:/data/mongodb/data修改数据文件存放位置journal:enabled:true......networkinterfacesnet:port:27017bindIp:0.0.0.0修改监听所有IP的端口```启动MongoDB启动mongodb：`systemctlstartmongod.service`停止mongodb：`systemctlstopmongod.service`查到mongodb的状态：`systemctlstatusmongod.service`设置为自启动`systemctlenablemongod.service`防火墙设置开放端口`firewallcmdzone=publicpermanentaddport=27017/tcp`重启防火墙`firewallcmdreload`查看端口是否开放`firewallcmdzone=publiclistports`用户管理（未试验）创建验证用户`db.createUser{user:\"root\",pwd:\"rootpassword\",roles:{role:\"root\",db:\"admin\"}}`修改配置文件，添加上验证```shellsecurity:authorization:enabled```重启mongd服务：`systemctlrestartmongod.service`登录验证`mongourootprootpasswordauthenticationDatabaseadmin`可视化工具NoSQLManagerforMongoDB:dev.snhb.group:82/soft/dev/NoSQLManagerforMongoDB.zip", "backend\\Linux/CentOS7安装MySQL5.7.md": "TOC参考：CentOS7安装MySQLwww.cnblogs.com/bigbrotherer/p/7241845.html删除MariaDB怎么操作在CentOS中默认安装有MariaDB，不想用接卸载了。首先、查询所安装的MariaDB组件：```shellroot@localhostlogsrpmqa|grepMaria*MariaDBserver5.5.491.el7.centos.x86_64MariaDBcommon5.5.491.el7.centos.x86_64MariaDBclient5.5.491.el7.centos.x86_64```卸载数据库：```shellroot@localhostlogsyumyremovemari*```删除数据库文件：```shellroot@localhostlogsrmrf/var/lib/mysql/*```再查看一下还有没有残留，如果有，再删除```shellroot@localhostlogsrpmqa|grepMaria*```CentOS7安装MySQL在CentOS中默认安装有MariaDB，这个是MySQL的分支，但为了需要，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。1、下载并安装MySQL官方的YumRepository>`root@localhost~wgeticdev.mysql.com/get/mysql57communityreleaseel710.noarch.rpm`使用上面的命令就直接下载了安装用的YumRepository，大概25KB的样子，然后就可以直接yum安装了。>`root@localhost~yumyinstallmysql57communityreleaseel710.noarch.rpm`之后就开始安装MySQL服务器。>`root@localhost~yumyinstallmysqlcommunityserver`这步可能会花些时间，安装完成后就会覆盖掉之前的mariadb。至此MySQL就安装完成了，然后是对MySQL的一些设置。2、MySQL数据库设置首先启动MySQL>`root@localhost~systemctlstartmysqld.service`查看MySQL运行状态，运行状态如图：>`root@localhost~systemctlstatusmysqld.service`此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码：>`root@localhost~grep\"password\"/var/log/mysqld.log`>Atemporarypasswordisgeneratedforminer@localhost:Vaj4edh+G2j6如下命令进入数据库：>`root@localhost~mysqlurootp`输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：>`mysql>ALTERUSER'root'@'localhost'IDENTIFIEDBY'newpassword';`这里有个问题，新密码设置的时候如果设置的过于简单会报错：>ERROR1819HY000:Yourpassworddoesnotsatisfythecurrentpolicyrequirements但此时还有一个问题，就是因为安装了YumRepository，以后每次yum操作都会自动更新，需要把这个卸载掉：>`root@localhost~yumyremovemysql57communityreleaseel710.noarch`此时才算真的完成了。MySQL赋给用户权限命令格式：>`mysql>grant权限1,权限2,…权限non数据库名称.表名称to用户名@用户地址identifiedby'连接口令';`>权限1,权限2,…权限n代表`select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file`等14个权限。>当权限1,权限2,…权限n被`allprivileges`或者`all`代替，表示赋予用户全部权限。>当`数据库名称.表名`称被`*.*`代替，表示赋予用户操作服务器上所有数据库所有表的权限。>用户地址可以是`localhost`，也可以是ip地址、机器名字、域名。也可以用`'%'`表示从任何地址连接。>`'连接口令'`不能为空，否则创建失败。```shell给来自10.163.225.87的用户joe分配可对数据库vtdc的employee表进行select,insert,update,delete,create,drop等操作的权限，并设定口令为123。mysql>grantselect,insert,update,delete,create,droponvtdc.employeetojoe@10.163.225.87identifiedby'123';给来自10.163.225.87的用户joe分配可对数据库vtdc所有表进行所有操作的权限，并设定口令为123。mysql>grantallprivilegesonvtdc.*tojoe@10.163.225.87identifiedby'123';给来自10.163.225.87的用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123。mysql>grantallprivilegeson*.*tojoe@10.163.225.87identifiedby'123';给本机用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123。mysql>grantallprivilegeson*.*tojoe@localhostidentifiedby'123';```", "backend\\Linux/centos7安装Oracle10g.md": "安装目录2T的硬盘挂载到/data，且已配置启动挂载，参见/etc/fstabjdk安装在/usr/java目录gradle安装在/opt/programs/gradle，设置了GRADLE_USER_HOME=/opt/repo/gradle错误:ORA27125:unabletocreatesharedmemorysegment临时解决方法：```root@zhifei~idoracleuid=1001oraclegid=1001oinstall组=1001oinstall,1002dbaroot@zhifei~more/proc/sys/vm/hugetlb_shm_group0root@zhifei~echo1002>/proc/sys/vm/hugetlb_shm_group```终极解决方法```shellroot@zhifei~idoracleuid=1001oraclegid=1001oinstall组=1001oinstall,1002dbaroot@zhifei~vi/etc/sysctl.conf加入如下的内容，其中1002为dba组号，需要根据你实际的情况进行改变。vm.hugetlb_shm_group=1002root@zhifei~sysctlp```启动Oracle启动Oracle，最少需要启动oracle实例、oracle监听。参考下面命令：```shell$suCoracle接着输入：$sqlplus\"/assysdba\"接着请输入SQL>startup就可以正常的启动数据库了。另外停止数据库的指令如下：SQL>shutdownimmediate检查OracleDB监听器是否正常，回到终端机模式，输入：$lsnrctlstatus检查看看监听器是否有启动。如果没有启动，可以输入：$lsnrctlstart```另一种方式是运行以下命令（shell在/home/oracle/orastart）：```shell启动实例/data/oracle/10g/bin/dbstart启动监听/data/oracle/10g/bin/lsnrctlstart```参考：CentOSOracle服务启动&停止脚本与开机自启动77jiayuan.blog.51cto.com/386386/1569408Oracle11gR2卸载1.关掉oracleserver和backgroundprocessespsef|grepora关掉数据库shutdownimmediate2.关掉监听lsnrctlstatus如果开启的话就执行lsnrctlstop关掉3.把$ORACLE_HOME下面的文件删掉用dbca图形界面把数据库删掉4.把/usr/local/bin下的三个文件夹dbhomeoraenvcoraenv删掉rmfdbhomermforaenvrmfcoraenv5.把/etc下面的oratab和orainst.loc删掉rmforatabrmforainst.loc6.把/opt下面ORCLfmap删掉rmfRORCLfmap7.oracle@RedHat~$env|grepORAORACLE_SID=ora10gORACLE_BASE=/u01/app/oracleORACLE_HOME=/u01/app/oralce/product/10.2.0/db_1把上面的目录下的文件全部删掉rmfR/u018.把oracle用户和oinstall和dba删掉必须先删oracle用户userdelroraclegroupdeloinstallgroupdeldba", "backend\\Linux/CentOS安装.md": "TOC安装nginxyumyinstallnginxNginx开启目录浏览配置文件只需要将下面几行配置文件加入nginx配置的server段或location段内：```shellautoindexon;开启目录浏览autoindex_exact_sizeoff;默认为on，以bytes为单位显示文件大小；切换为off后，以可读的方式显示文件大小，单位为KB、MB或者GB。autoindex_localtimeon;默认为off，以GMT时间作为显示的文件时间；切换为on后，以服务器的文件时间作为显示的文件时间。charsetutf8,gbk;设置编码```在VirtualBox中安装CentOSNAT网络不能访问在【全局设定】>【网络】下添加一个NAT网络（原来没有）。安装Virtualbox增强1.挂载VBoxGuestAdditions.iso到光驱2.安装相关依赖包yuminstallybzip2gccgccdevelgccc++gccc++develmakekernelheaderskerneldevel3.挂载并安装```shellmkdir/mnt/cdrommounttautor/dev/cdrom/mnt/cdromcd/mnt/cdromexportMAKE='/usr/bin/gmakei'./VBoxLinuxAdditions.run```**安装增强各种失败**参考：www.jianshu.com/p/863bea519106多个kernel版本不一致错误由于kernel版本不一致造成。反复查看kernel版本，更新版本，事内核相关包版本一致，命令如下：```shellrpmqa|grepkernel|sotyuminstallkernel（或其他包）yumupdatekernel（或其他包）```如果还不行，查看/usr/src/kernels/目录下kernel版本，使用export命令直接指定KERN_DIR:```shellexportKERN_DIR=/usr/src/kernels/2.6.2.6.18371.9.1.0.1.el5x86_64/Toavoidthe‘BuildingtheOpenGLsupportmodulefailed’error,trythiscommand:exportMAKE=’/usr/bin/gmakeCi’```挂载共享文件夹手动挂载在virtualbox中添加完共享文件夹后，记住共享名称，重新进入虚拟CentOS，默认情况下，共享文件夹映射到/media/sf_xxxx。在命令行终端下输入：```shellsudomkdir/mnt/sharesudomounttvboxsfwinshare/mnt/share```如果提示/sbin/mount.vboxsf:mountingfailedwiththeerror:Nosuchdevice可能是没有载入内核模块vboxfs，先查看下：lsmod|grepvboxsf如果没有结果返回，说明vboxsf没有载入，执行sudomodprobevboxsf启动时自动挂载。好像不能成功，参考：CentOS7VirtualBox开机自动挂载共享文件夹segmentfault.com/q/1010000005600781在文件~/.bashrc中追加如下命令mounttvboxsfwinshare/mnt/share/", "backend\\Linux/CentOS常用命令.md": "TOCCentOS7查看硬盘情况lsblk查看分区和磁盘dfh查看空间使用情况fdiskl分区工具查看分区信息cfdisk/dev/sda查看分区blkid查看硬盘label（别名）CentOS7自启动设置参考：CentOS7.x设置自定义开机启动,添加自定义系统服务blog.csdn.net/looksun/article/details/50668492CentOS7自启服务分为两种：系统（system）和用户（user），目录分别为：/usr/lib/systemd/system和/usr/lib/systemd/user。服务文件以.service结尾，常用命令如下：```shell启动nginx服务systemctlstartnginx.service设置开机自启动（service文件在/etc/systemd/system/下创建，enbale后，在/etc/systemd/system/建立链接文件）systemctlenablenginx.serviceroot@zhifei~systemctlenablejiraCreatedsymlinkfrom/etc/systemd/system/multiuser.target.wants/jira.serviceto/etc/systemd/system/jira.service.停止开机自启动systemctldisablenginx.service查看服务当前状态systemctlstatusnginx.service重新启动服务systemctlrestartnginx.service查看所有已启动的服务systemctllistunitstype=service```CentOS7防火墙及端口设置防火墙服务默认使用的是firewalld，而不是iptables。启动/停止iptables或firewalld使用：systemctlenable/start/stopiptables/firewalld参考：禁用firewalld&开启iptables&systemctl使用简介blog.csdn.net/qq_34409701/article/details/52777197CentOS7使用firewalld打开关闭防火墙与端口www.cnblogs.com/moxiaoan/p/5683743.html使用firewalld时，开放端口设置如下：```shell启动：systemctlstartfirewalld查看状态：systemctlstatusfirewalld停止：systemctlstopfirewalld禁用：systemctldisablefirewalldfirewallcmdzone=publicpermanentaddport=80/tcp命令含义：zone作用域permanent永久生效，没有此参数重启后失效addport=80/tcp添加端口，格式为：端口/通讯协议查看所有打开的端口：firewallcmdzone=publiclistports查看firewallcmdzone=publicqueryport=80/tcp删除firewallcmdzone=publicremoveport=80/tcppermanent重启防火墙firewallcmdreload```Centos7网络配置centos7取消了ifconfig命令，使用ipaddr命令查看IP地址修改文件：/etc/sysconfig/networkscripts/ifcfgenp2s0```shellTYPE=\"Ethernet\"BOOTPROTO=\"static\"DEFROUTE=\"yes\"IPV4_FAILURE_FATAL=\"no\"IPV6INIT=\"yes\"IPV6_AUTOCONF=\"yes\"IPV6_DEFROUTE=\"yes\"IPV6_FAILURE_FATAL=\"no\"IPV6_ADDR_GEN_MODE=\"stableprivacy\"NAME=\"enp2s0\"UUID=\"1b2b9785959a4c35a2a804ab32ef2855\"DEVICE=\"enp2s0\"ONBOOT=\"yes\"PEERDNS=\"yes\"PEERROUTES=\"yes\"IPV6_PEERDNS=\"yes\"IPV6_PEERROUTES=\"yes\"IPV6_PRIVACY=\"no\"IPADDR=192.168.31.200GATEWAY=192.168.31.1NETMASK=255.255.255.0NM_CONTROLLED=noDNS1=192.168.31.1ZONE=public```CentOS的SSH安装www.cnblogs.com/kaid/p/7985568.html1.检查是否安装SSH服务端软件包：rpmqa|grepopenssh若显示结果中包括opensshserver*.则已安装，直接启动2.安装缺失的软件sudoyuminstallopenssh*3.注册、启动sshd服务systemctlenablesshdsystemctlstartsshd或者servicesshdstart4.开启防火墙的22端口：具体防火墙使用可以参见：www.cnblogs.com/moxiaoan/p/5683743.htmlfirewallcmdzone=publicaddport=22/tcppermanentservicefirewalldrestart5.测试：本机测试：sshusername@localhost测试，（但必须要先安装linux的ssh客户端软件包）CentOS修改系统环境变量方法一：在/etc/profile文件中添加变量【对所有用户生效（永久的）】用VI在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。root@CentOS~vi/etc/profile在文件末尾加上如下两行代码PATH=/usr/local/webserver/php/bin:$PATHexportPATH要是刚才的修改马上生效，需要执行以下代码root@CentOS~source/etc/profile这时再查看系统环境变量，就能看见刚才加的东西已经生效了方法二：在用户目录下的.bash_profile文件中增加变量【对单一用户生效（永久的）】用VI在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。具体操作和方法1一样，这里就不在列举代码了。方法三：直接运行export命令定义变量【只对当前shell（BASH）有效（临时的）】在shell的命令行下直接使用export变量名=变量值定义变量，该变量只在当前的shell（BASH）或其子shell（BASH）下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。例如exportPATH=/usr/local/webserver/php/bin:$PATHyum&rpm安装```shellrpmiexample.rpm安装example.rpm包；rpmivexample.rpm安装example.rpm包并在安装过程中显示正在安装的文件信息；rpmivhexample.rpm安装example.rpm包并在安装过程中显示正在安装的文件信息及安装进度；```yum安装路径查询```shellrpmqa|grepxxx查询要找的软件名称rpmql软件名称显示软件的安装路径```卸载软件```shellrpmenodeps要卸载的软件包rpmenodepsjava1.6.0openjdk1.6.0.01.66.1.13.0.el6.i686```centos7yum404错误```shellyumcleanallrpmrebuilddbyumupdate```忘记密码www.linuxidc.com/Linux/201801/150211.htm升级内核查看内核版本unamer通过yum升级内核yuminstallykernel删除多余的kernel```shell查看系统中全部的内核RPM包:rpmqa|grepkernelerlangkernel18.3.31.el7.x86_64kerneldevel3.10.0123.el7.x86_64abrtaddonkerneloops2.1.1136.el7.centos.x86_64kernel3.10.0327.28.3.el7.x86_64kernel3.10.0123.el7.x86_64删除旧内核的RPM包yumremovexxxx重启系统reboot```通过源码升级内核比较复杂，不作介绍重启系统一定不要忘记，否则不生效。", "backend\\Linux/Fedora使用记录.md": "Add国内yum源```shellcd/etc/yum.repos.dwgetmirrors.163.com/.help/fedora163.repowgetmirrors.163.com/.help/fedoraupdates163.repoyummakecache```增加FZUG源一、安装FZUG源FZUG源安装指南github.com/FZUG/repo/wiki/%E6%B7%BB%E5%8A%A0FZUG%E6%BA%90`dnfinstallmirrors.tuna.tsinghua.edu.cn/fzug/free/30/x86_64/fzugrelease300.1.noarch.rpm`Fedora31用户，暂时可用以上链接。虽然版本叫30,但是在31的系统上是能够正确选择Fedora31的仓库的。二、Fedora安装rpmfusion源方法1、下载两个文件：　　1）download1.rpmfusion.org/free/fedora/rpmfusionfreereleasestable.noarch.rpm　　2）download1.rpmfusion.org/nonfree/fedora/rpmfusionnonfreereleasestable.noarch.rpm2、安装这两个文件```shellyuminstallrpmfusionfreereleasestable.noarch.rpmyuminstallrpmfusionnonfreereleasestable.noarch.rpm```3、生成缓存:yummakecache安装JDK打开dnfdragora，搜索JDK，安装java1.8.0openjdkdevel即可安装AmazonCorrettoJDKdocs.aws.amazon.com/corretto/latest/corretto8ug/downloadslist.htmlsudoyuminstallyjava1.8.0amazoncorretto*.rpmFedora27安装输入法安装fcitx```shellsudodnfinstallfcitxfcitxlibpinyinfcitxqt4kcmfcitxdnfinstallfcitxconfigtool```安装好以后，运行fcitx，再运行fcitxconfigtool。在配置选项里加入输入法。如果系统语言为英文，记得勾选掉下面的“OnlyShowCurrentLanguage”选项。然后点击应用。运行一下命令来切换系统默认输入法至fcitx：`imsettingsswitchfcitx`此处会有报错，请忽略，然后重启电脑。安装完成。修改home下的中文目录为英文目录安装`xdguserdirsgtk``yuminstallyxdguserdirsgtk`切换英文Lang打开终端，在终端下输入命令：```shellexportLANG=en_USxdguserdirsgtkupdate```这个时候会弹出一个配置界面，提示是否将中文目录切换为英文目录。选中不再提示，确定。系统会删除没有内容的中文目录，而有内容的目录会保持。并创建8个相应的英文目录。此时，您在“位置”里看到的常用中文目录已经变成英文目录。只需要将原中文目录的内容拷贝到相应英文目录，并删除中文目录即可。恢复中文Lang`exportLANG=zh_CN.UTF8`删除多余内核删除旧内核```shell$rpmqa|grepkernel$yumremovekernelcore4.18.0kerneldevel4.18.0kerneltoolslibs4.18.0kernelheaders4.18.0```安装wechat使用FZUG源，打开dnfdragora，搜索wechat，安装即可安装wps下载wps：linux.wps.cn/安装：`yuminstallwpsoffice11.1.0.96621.x86_64.rpm`安装qq下载：im.qq.com/linuxqq/download.html```shellsudoyuminstallgtk2.x86_64centossudorpmivhlinuxqq_1.0.1b1100_mips64el.rpm```FTP客户端FileZilla在dnfdragora中安装SSH客户端EasySSH方法11、下载easyssh*.rpm版本download.copr.fedorainfracloud.org/results/deadmozay/easyssh/fedora32x86_64/00865362easyssh/2、安装：`yuminstallyeasyssh*.rpm`方法2```shellcd/etc/yum.repo.d/wgetcopr.fedorainfracloud.org/coprs/deadmozay/easyssh/repo/fedora32/deadmozayeasysshfedora32.repoyuminstallyeasyssh```openbox分屏lxqt默认使用openbox窗口管理器。openbox可以通过配置keybind实现分屏。askubuntu.com/questions/1182097/lubuntu19102004howtotilewindowsthewindowtilingsectionismissingwww.allartsoftworks.com/it/articles/howtoresizesplitwindowslxdelubuntuopenboxhowtoresizewindowswithhotkeysunderlubuntulxde/编辑`~/.config/openbox/lxqtrc.xml`，加入以下内容。```xml<!Lubuntuspecific.Keybindingsforwindowtiling><!HalfLeftScreen><keybindkey=\"CWLeft\"><actionname=\"UnmaximizeFull\"/><actionname=\"MoveResizeTo\"><x>0</x><y>0</y><height>100%</height><width>50%</width></action></keybind><!HalfRightScreen><keybindkey=\"CWRight\"><actionname=\"UnmaximizeFull\"/><actionname=\"MoveResizeTo\"><x>0</x><y>0</y><height>100%</height><width>50%</width></action></keybind><!HalfUpperScreen><keybindkey=\"CWUp\"><actionname=\"UnmaximizeFull\"/><actionname=\"MoveResizeTo\"><x>0</x><y>0</y><width>100%</width><height>50%</height></action></keybind><!HalfLowerScreen><keybindkey=\"CWDown\"><actionname=\"UnmaximizeFull\"/><actionname=\"MoveResizeTo\"><x>0</x><y>0</y><width>100%</width><height>50%</height></action></keybind>```配置完后，在终端执行`openboxreconfigure`是配置生效。IDEA显示RunDashboard窗口在Settings>Plugins中增加SpringBoot支持在.idea下的workspace.xml中，找到`<componentname=\"RunDashboard\">`，加入：```shell<optionname=\"configurationTypes\"><set><optionvalue=\"SpringBootApplicationConfigurationType\"/></set></option>```重新打开项目，在View>ToolsWindows下，可以看到`RunDashboard`，运行SpringBoot程序就可以看到这个窗口了。yuminstallredis安装`yuminstallredis`启动`serviceredisstart`或`systemctlstartredis`查看redis安装时创建的文件`rpmqa|grepredis``rpmqlredis`查看redis版本：`rediscliversion`设置为开机自动启动`chkconfigredison`或`systemctlenableredis.service`开启Redis远程登录连接redis默认只能localhost访问，所以需要开启远程登录。解决方法如下：在redis的配置文件/etc/redis.conf中将bind127.0.0.1改成了bind0.0.0.0然后要配置防火墙开放端口6379连接redis```shellgjh@localhostnacos$rediscli127.0.0.1:6379>setkey1\"helloworld\"OK127.0.0.1:6379>getkey1\"helloworld\"127.0.0.1:6379>delkey1integer1127.0.0.1:6379>getkey1nil```yum用法查询使用yumsearch<term>more_terms命令，能够在已启用的软件包仓库中，对所有软件包的名称、描述和概述中进行搜索，最后，yum会以显示符合合条件的搜索结果列表。yumlist以及相关的一些命令则能够为你提供有关软件包、软件包集和软件仓库的信息。所有的yumlist命令都能够使用glob表达式作为参数，对输出结果进行过滤。在glob表达式中，你可以使用*代表任何数量个字符，使用?代表任何一个字符。通过后面的示例，你可以对glob表达式有些简单的认识。yumlist<glob_expr>more_glob_exprs──列出所有符合glob表达式的软件包yumlistall──列出所有已安装的和可用的软件包yumlistinstalled──列出所有已经安装在系统中的软件包。输出结果的最右边一列是取得该软件包的软件仓库。标识为installed的软件包则说明它是做为系统基本组件而预安装的。yumlistavailable──列出所有启用的软件仓库中可用的软件包yumgrouplist──列出所有软件包组yumrepolist──列出所有启用的软件仓库的ID，名称及其包含的软件包的数量yuminfo<package_name>more_names命令可查看一个或多个软件包的信息此处同样可以应用glob表达式。install&uninstallyuminstallsoftwarename安装yumremovesoftwarename卸载软件yumreinstallsoftwarename重新安装yumcleanall清空yum缓存升级yumcheckupdate:可以了解系统中哪些已安装的包当前有更新yumupdate：升级所有包同时也升级软件和系统内核yumupgrade：只升级所有包，不升级软件和系统内核yumhistory查看系统软件改变历史yum使用upgrade选项，等价于打开obsoletes配置的yumupdate。而默认中/etc/yum.conf配置文件obsoletes是打开的，因此这两个指令选项是等价的。这是一个yum缓存配置文件的示例，obsoletes定义了更新时处理软件包的取代关系，简单来讲，1表示更新旧的rpm包的同时会删除旧包，0表示更新的时候不会删除旧包，因此，yumupdate和yumupgrade的功能都是一样的，都是将需要更新的package更新到源中的最新版。唯一不同的是，yumupgrade会删除旧版本的package，而yumupdate则会保留obsoletes=0。生产环境中建议使用yumupdate，防止因为替换，导致旧的软件包依赖出现问题。npm错误`使用npmstart影响项目出现Error:ENOSPC:Systemlimitfornumberoffilewatchersreached,watch`原来在fedorac，entos，ubuntu等系统中，由于gulpserve跟踪项目的文件数有限制，必须要设置一下，解除设置才可以继续跟踪。还有可能是因为gulp的watch需要监听很多文件的改动，但是fedora，ubuntu系统的文件句柄其实是有限制的，因此可以使用下面的命令解除`echofs.inotify.max_user_watches=524288|sudoteea/etc/sysctl.conf&&sudosysctlp`挂载VMWare的共享目录www.cnblogs.com/skyheaving/p/12286513.html打开`/etc/fuse.conf`的`user_allow_other`注释在`/etc/fstab`文件中，添加`.host:/D/home/gjh/ddfuse.vmhgfsfuseallow_other,max_write=61440,defaults00`PS:`max_write=61440`的作用是防止不能写入稍大文件。立即生效：`mounta`卸载`umount/mnt/hgfs`安装sublime按照官网的指导安装。www.sublimetext.com/docs/3/linux_repositories.htmldnf```shellInstalltheGPGkey:sudorpmvimportdownload.sublimetext.com/sublimehqrpmpub.gpgSelecttheStablechanneltouse:sudodnfconfigmanageraddrepodownload.sublimetext.com/rpm/stable/x86_64/sublimetext.repoUpdatednfandinstallSublimeTextsudodnfinstallsublimetext```破解sublimetextBuild3211最详细的安装方法www.codenong.com/js65a10209118f/保存git账号密码1.在~/下，touch创建文件.gitcredentials,用vim编辑此文件，输入内容格式：touch.gitcredentialsvim.gitcredentials在里面按“i”然后输入：{username}:{password}@github.com比如account:password@github.com2.在终端下执行gitconfigglobalcredential.helperstore3.可以看到~/.gitconfig文件，会多了一项：credentialhelper=storeFedora使用PCManFM无法启动xterm：`sudolns/usr/bin/lxterminal/usr/bin/xterm`maven私服不能下载snapshots依赖```xml<profiles><profile><!根据仓库id激活下面的配置><id>xxnexus</id><activation><activeByDefault>true</activeByDefault></activation><repositories><repository><id>xxnexus</id><!私服地址><url>xx.xx.xx.xx:8081/repository/xx_group/</url><releases><enabled>true</enabled></releases><snapshots><enabled>true</enabled></snapshots></repository></repositories></profile></profiles>```开始菜单修改注意几个目录和文件。`/usr/share/applications/`下的`.desktop`文件和`mimeinfo.cache`文件`~/.local/share/applications/`下的`.desktop`文件和`mimeinfo.cache`文・件`/etc/gnome/defaults.list`和`~/.local/share/applications/default.list`文件保存的是文件的打开方式。find的用法实例将目前目录及其子目录下所有延伸档名是c的文件列出来。`find.name\"*.c\"`将目前目录其其下子目录中所有一般文件列出`find.typef`将目前目录及其子目录下所有最近20天内更新过的文件列出・`find.ctime20`查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：`find/var/logtypefmtime+7okrm{}\\;`查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件：`find.typefperm644execlsl{}\\;`为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径：`find/typefsize0execlsl{}\\;`", "backend\\Linux/lubuntu版本：Desktop与Alternate区别.md": "大概的概括是：desktop是livecd+图形安装cd，server是服务器版，alternate是文本安装模式的。Desktop版本：其实desktop是LiveCD的名字，也就是刻录在光盘上运行的Linux，是一套已经装好的系统。把它烧录到光盘上放进光驱就可以直接运行这套完整的linux。当然你也可以在运行之后把它“安装”到硬盘上，而这样的安装更像是一种拷贝或者还原，类似ghost。LiveCD可以免安装体验也可以用于网络诊断比较方便。LiveCD可以用于在windows引导不了时做一些工作，相当于一个移动的操作系统。LiveCD还可以用于备份系统还可以用于安装gentoolfs等发行版。LiveCD还有一个最主要的工作是恢复引导分区。Thedefault\"Desktop\"installerrequires384800MBofRAMdependingonyourselectedoptions.Ifyouhaveanyproblems,orifyou'recomfortableusingakeyboardinterface,trythealternateinstallertoinstalloncomputerswithlessRAMoraharddisksmallerthan4.3GB.Alternate版本：alternate是标准的安装CD，包含了一些桌面程序，可以用高级安装模式安装，在安装时可以划分分区。也可以当作Server来用，不过一些Server程序要自己通过网络来安装Alternate安装过程会有高级分区以及grub安装选项,Desktop没有.alternate既能安装desktop也能安装server。*创建预配置OEM系统；*设置自动布置；*在无网络链接情况下从旧系统升级；*LVM和/或RAID分区；*在小于256MB内存的系统上安装（但是注意相应地低内存系统可能无法运行完整的桌面环境）。AlternateISOsareforlowRAMPCsandthosethatcanonlybootfromCD.Computerswithlessthan400MBofRAMareconsideredlowRAMcomputers.Server版本：server版本就不多介绍了，主要用于服务器的搭建，自带没有桌面环境，不建议新手安装。以上就是他们之间的区别，按照你的需求来选择吧！最后如果安装软磁盘阵列请您选择Alternate版本或者Server版本。", "backend\\Linux/VIM使用记录.md": "★命令模式移动光标h或向左方向键←→光标向左移动一个字元j或向下方向I↓→光标向下移动一个字元k或向上方向I↑→光标向上移动一个字元l或向右方向I→→光标向右移动一个字元Ctrl+f→屏幕『向下』移动一页，相当于PageDown按键Ctrl+b→屏幕『向上』移动一页，相当于PageUp按键n<space>→n表示『数字』。按下数字后再按空白I，光标会向右移动这一行的n个字元0→数字『0』：移动到这一行的最前面字元处$→移动到这一行的最后面字元处G→移动到这个文件的最后一行nG→n为数字。移动到这个文件的第n行可配合:setnugg→移动到这个文件的第一行，相当于1Gn<Enter>→n为数字。光标向下移动n行查找与替换/word→向光标之下查找一个名称为word的字符串。如想查找eric4ever字符串，输入/eric4ever即可?word→向光标之上查找一个名称为word的字符串n→『重复前一个查找的动作』N→与n刚好相反，为『反向』进行前一个查找动作:n1,n2s/word1/word2/g→n1与n2均为数字。在第n1与n2行之间查找word1字符串，并将该字符串替换为word2。如：在1到9行之间查找eric4ever并替换为ERIC4EVER则：『:1,9s/eric4ever/ERIC4EVER/g』:1,$s/word1/word2/g→从第一行到最后一行查找word1字符串，并将该字符串替换为word2:1,$s/word1/word2/gc→从第一行到最后一行查找word1字符串，并将该字符窗替换为word2，替换前显示提示对话框是否确认替换删除、复制与粘贴x,X→在一行字当中，x为向后h除一个字元相当于del按键，X为向前h除一个字元相当于backspace按键dd→h除光标所在的那一整列ndd→n为数字。h除光标所在的向下n列yy→复制光标所在的那一行nyy→n为数字。复制光标所在的向下n列p,P→p为将已复制的内容粘贴在光标下一行上，P则为粘贴在光标的上一行u→还原前一个动作Ctrl+r→重做上一个动作.→小数点，意思是重复前一个动作★编辑模式i,I→插入：在目前的光标所在处插入输入的文字，已存在的文字会向后退；其中，i为『从目前光标所在处插入』，I为『在目前所在行的第一非空白字元处开始插入』a,A→a为『从目前光标所在的下一个字元处开始插入』，A为『从光标所在行的最后一个字元处开始插入』o,O→o为『在目前光标所在的下一行处插入新的一行』，O为『在目前光标所在处的上一行插入新的一行』r,R→r为『取代光标所在的那一个字元』，R为『一直取代光标所在的文字，直到按下ESC为止』Esc→退出编辑模式，回到一般模式中★末行指令模式:w→将编辑的文件写入到硬盘上:q→退出vi:wq→保存后退出，若为:wq!则为强制保存为退出:setnu→显示行号:setnonu→取消显示行号!_v_images/20191118204553.png1、正则表达式查找freetravel.blog.sohu.com/106769983.html1继续查找。n,3n,N2向上搜索。?3\\c忽略大小写，而\\C对大小写敏感。4查找当前词。*向下，向上5特殊字符。.*^%/?~$加反斜杠\\。而\\e表示<esc>；\\t表示<tab>；\\r表示<cr>；\\b表示<bs>。6匹配换行或空格。\\n换行；\\s空白，注意是空白不是空格。\\_s匹配换行或者空格；\\_a表示匹配换行或者一个字母。7限定词首或者词尾。\\<以指定字符串开始的单词<，\\>以指定字符串结尾的单词8行首和行尾。输入/^string查找以string开始的行，输入/string$则查找以string结束的行。这个模式不会忽略前导或者后置的空格。9可重复的字符。*重复多次或者0次，如：/be*或be\\*。\\+重复至少一次到无数次。\\=重复0次或者一次。\\{n,m}重复n到m次。10匹配列表中的一个。\\|分割的列表。如：/one\\|two\\|three，　　/end\\if\\|while\\|for\\将会查找endif，endwhile以及endfor。11特殊的字符集合。\\d代替09；\\D代替非数字^09；\\s表示空白字符代替<Tab>和<Space>；\\S表示非空白字符代替^；\\l表示小写字母代替az；\\L表示非小写字母代替^az；\\u表示大写字母代替AZ；\\U表示非大写字母代替^AZ。12搜索并替换。简单形式是:s/from/to/；:%s/from/to/就是在全文查找from并替换为to；:1,50s/from/to/表示在第1行和第50行之间（包括1和50行）进行搜索和替换。13替换的确认方式。默认是无须确认；g表示直接替换无须进行确认；c表示在进行替换前需要用户进行确认。这时你可以选择y/n/a/q/1/^E/^Y）:y表示同意当前替换；n表示不同意当前替换；a表示替换当前和后面的并且不再确认；q表示立即结束替换操作；1表示把当前的替换后结束替换操作；^E向上滚屏^Y向下滚屏，用来帮助查看前后内容以决定进行操作。14查找历史。上下键2、按目录查找字符串使用vimgrepwww.nerdlinux.com/post/43/blog.csdn.net/unbutun/article/details/6591257blog.csdn.net/qilihechuncai/article/details/85873893、查看/转换文件编码blog.csdn.net/dengxu11/article/details/6763765:setfenc=gbk然后保存文件即可转换编码sosowo.org/archives/604、列模式c+q进入列模式blog.csdn.net/hywhy/article/details/58624565、文件比较bbs.ednchina.com/BLOG_ARTICLE_222557.HTM6、多Tab:tabnew7、outlinectags+taglist8、FileExplorerwww.cnblogs.com/ifys/archive/2010/10/24/1860610.html前面四部分。ctags+taglist+bufexplorer+winmanagerNERDTree", "backend\\Linux/WSL2.md": "TOCadamtheautomator.com/windowssubsystemforlinux/安装CentOSWSL下载安装下载地址：github.com/wsldlpg/CentWSL/releases安装XFCE1.先安装epelrelease（centos的软件包yum源）`yumyinstallepelrelease`2.如果你的CENTOS是最小化安装的那默认都是不带XWINDOWS的，所以在安装这些桌面之前得先安装一下XWINDOWS，这个控制功能。```yumupgradeyumygroupinstall\"XWindowSystem\"```3.安装Xfce桌面环境`yumygroupinstallinstall\"Xfce\"`4.增加中文字体先安装字体管理工具：`yumyinstallxorgx11fontutils`将字体复制到`/usr/share/fonts/chinese/`目录下5.安装输入法选择fcitx输入法架构，不选择ibus安装fcitx:`yumyinstallfcitxfcitxpinyinfcitxconfigtool`修改locale：修改`/etc/locale.conf`内容`LANG=zh_CN.utf8`参考：blog.csdn.net/lemontree1945/article/details/80088986增加环境变量参考：blog.csdn.net/qq_27785239/article/details/105874669```exportXIM=\"fcitx\"exportXIM_PROGRAM=\"fcitx\"exportXMODIFIERS=\"@im=fcitx\"exportGTK_IM_MODULE=\"fcitx\"exportQT_IM_MODULE=\"fcitx\"```重启，在菜单Settings>FcitxConfiguration里面配置（或者右上角键盘图标上配置）Addthesevariablesin`~/.bashrc`file:```iniexportDISPLAY=$cat/etc/resolv.conf|grepnameserver|awk'{print$2;exit;}':0.0exportLIBGL_ALWAYS_INDIRECT=1```Steps:Updateandupgrade:`dnfupgrade`InstallXFCEgrouppacakge:`dnfgroupinstall\"XfceDesktop\"`StartXFCE:startxfce4orxfce4session增加菜单项进入目录`/usr/share/applications`，复制一个菜单项修改idea中fcitx无法输入中文1.修改`/etc/locale.conf`内容`LANG=zh_CN.utf8`参考：blog.csdn.net/lemontree1945/article/details/800889862.增加环境变量```exportXIM=\"fcitx\"exportXIM_PROGRAM=\"fcitx\"exportXMODIFIERS=\"@im=fcitx\"exportGTK_IM_MODULE=\"fcitx\"exportQT_IM_MODULE=\"fcitx\"```参考：blog.csdn.net/qq_27785239/article/details/105874669idea打不开markdown文件错误信息如下：```JCEFBrowsercomponentfailedtostartMissingnativelibraries:libXss.so.1```修复：`yuminstalllibXScrnSaver`安装sublime1.下载Linux安装包:download.sublimetext.com/sublime_text_3_build_3211_x64.tar.bz22.解压:`tarxvfsublime_text_3_build_3211_x64.tar.bz2`3.创建链接:`lns/opt/sublime_text_3/sublime_text/usr/bin/sublime_text`4.创建菜单项:`cp/opt/sublime_text_3/sublime_text.desktop/usr/share/applications/`5.修改文件路径：`sudovi/usr/share/applications/sublime_text.desktop`6.禁止更新提示：Preferences=>Settings>settingsuser=>添加`\"update_check\":false`7.破解及使用指南：www.codenong.com/js65a10209118f/安装FedoraWSL下载安装下载地址：github.com/WhitewaterFoundry/FedoraRemixforWSL/releases安装XFCE参考：github.com/Biswa96/WSLInstall/blob/master/docs/Install_Desktop_Environments.mdAddthesevariablesin`~/.bashrc`file:```iniexportDISPLAY=$cat/etc/resolv.conf|grepnameserver|awk'{print$2;exit;}':0.0exportLIBGL_ALWAYS_INDIRECT=1```Steps:Updateandupgrade:`dnfupgrade`InstallXFCEgrouppacakge:`dnfgroupinstall\"XfceDesktop\"`StartXFCE:startxfce4orxfce4sessionyumvsdnfblog.csdn.net/sfakh/article/details/109273318安装Ubuntuwsl参考：medium.com/@japheth.yates/thecompletewsl2guisetup2582828f4577CentOS7下安装Golangwww.cnblogs.com/zhzhlong/p/12695301.html安装文档：golang.google.cn/doc/install1.下载：golang.google.cn/dl/2.解压：解压压缩包到/usr/local目录`tarC/usr/localxzfgo1.13.linuxamd64.tar.gz`3.配置环境变量`vi/etc/profile````最后一行添加exportGOROOT=/usr/lib/golangexportPATH=$PATH:$GOROOT/bin````source/etc/profile`查看版本`goversion`4.设置代理命令行执行：```goenvwGO111MODULE=autogoenvwGOPROXY=goproxy.io,direct```原理参考：cloud.tencent.com/developer/article/15937345.设置GOPATHGOPATH的默认值blog.csdn.net/weixin_33938733/article/details/88009373`source/etc/profile````exportGOPATH=/opt/gopathexportPATH=$PATH:$GOPATH/bin```", "database/05_MySQL高可用.md": "TOC参考资料必须了解的MySQL三大日志：binlog、redolog和undologmp.weixin.qq.com/s/JPgROEQIQRuRNwAT_19cVA日志是mysql数据库的重要组成部分，记录着数据库运行期间各种状态信息。mysql日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注的是二进制日志binlog和事务日志包括redolog和undolog，本文接下来会详细介绍这三种日志。美团数据库高可用架构的演进与设想tech.meituan.com/2017/06/29/databaseavailabilityarchitecture.htmlMMM、MHA、MHA+Zebra架构等多图文，详细介绍mysql各个集群方案www.cnblogs.com/lgx211/p/12456859.html介绍优劣：一，mysql原厂出品（1，MySQLReplication、2，MySQLFabirc、3，MySQLCluster）；二，mysql第三方优化（4，MMM、5，MHA、6，GaleraCluster）三，依托硬件配合（7，heartbeat+SAN、8，heartbeat+DRDB）四，其它（9，Zookeeper+proxy、10，Paxos）高性能、高可用、可扩展的MySQL集群如何组建？www.zhihu.com/question/21307639组建MySQL集群的几种方案LVS+Keepalived+MySQL（有脑裂问题？但似乎很多人推荐这个）DRBD+Heartbeat+MySQL（有一台机器空余？Heartbeat切换时间较长？有脑裂问题？）MySQLProxy（不够成熟与稳定？使用了Lua？是不是用了他做分表则可以不用更改客户端逻辑？）MySQLCluster（社区版不支持INNODB引擎？商用案例不足？）MySQL+MHA（如果配上异步复制，似乎是不错的选择，又和问题？）MySQL+MMM（似乎反映有很多问题，未实践过，谁能给个说法）回答：不管哪种方案都是有其场景限制或说规模限制，以及优缺点的。1.首先反对大家做读写分离，关于这方面的原因解释太多次数（增加技术复杂度、可能导致读到落后的数据等），只说一点：99.8%的业务场景没有必要做读写分离，只要做好数据库设计优化和配置合适正确的主机即可。2.Keepalived+MySQL确实有脑裂的问题，还无法做到准确判断mysqld是否HANG的情况；3.DRBD+Heartbeat+MySQL同样有脑裂的问题，还无法做到准确判断mysqld是否HANG的情况，且DRDB是不需要的，增加反而会出问题；3.MySQLProxy不错的项目，可惜官方半途夭折了，不建议用，无法高可用，是一个写分离；4.MySQLCluster社区版本不支持NDB是错误的言论，商用案例确实不多，主要是跟其业务场景要求有关系、这几年发展有点乱不过现在已经上正规了、对网络要求高；5.MySQL+MHA可以解决脑裂的问题，需要的IP多，小集群是可以的，但是管理大的就麻烦，其次MySQL+MMM的话且坑很多，有MHA就没必要采用MMM建议：1.若是双主复制的模式，不用做数据拆分，那么就可以选择MHA或Keepalive或heartbeat2.若是双主复制，还做了数据的拆分，则可以考虑采用Cobar；3.若是双主复制+Slave，还做了数据的拆分，需要读写分类，可以考虑Amoeba；MySQL数据库集群方案汇总www.yuque.com/zerodai/yqzdgs/mnkzn3悄悄告诉你MySQLMGR到底牛在哪database.51cto.com/art/202004/615706.htmMySQL+MGR单主模式和多主模式的集群环境部署手册Centos7.5www.cnblogs.com/kevingrace/p/10470226.htmlMySQL高可用架构对比，MMM与MHA以及MGRblog.csdn.net/William0318/article/details/106855431MyCatmycat的三大功能：分表、读写分离、主从切换分表mycat分表的实现：首先在mycat的scheme.xml中配置逻辑表，并且在配置中说明此表在哪几个物理库上。此逻辑表的名字与真实数据库中的名字一致！然后需要配置分片规则，即按照什么逻辑分库！读写分离MyCat基本元素1.`逻辑库`：对后端多个物理数据库的映射，逻辑库中不保存数据。2.`逻辑表`：逻辑库中的表，映射后端多个物理数据库中的表，也不保存数据逻辑表分类1.`分片表`：进行了水平切分的表，表结构相同，可存储在不同库中，所有分片表的集合才是一张完整的表。2.`非分片表`：垂直切分的表，一个数据库中就保存了一张完整的表3.`全局表`：所有分片数据库中都存在的表4.`ER关系表`：mycat独有，子表依赖父表，保证在同一个数据库中配置文件1.`/usr/local/mycat/conf/server.xml`定义用户以及系统相关变量，如端口等。其中用户信息是前端应用程序连接mycat的用户信息。2.`/usr/local/mycat/conf/schema.xml`定义逻辑库，表、分片节点等内容。3.`/usr/local/mycat/conf/rule.xml`中定义分片规则。", "database/MongoDB.md": "官方文档：docs.mongodb.com/manual/特性文档数据库，使用BSON结构。没有schema限制，更灵活，存储速度更加快。即时查询能力保留了关系型数据库即时查询的能力，保留了索引（底层是基于Btree）的能力。易伸缩易伸缩是指对数据集进行分片，将存储压力分摊给多台服务器。自动故障转移自动故障转移是副本集的概念，MongoDB能检测主节点是否存活，当失活时能自动提升从节点为主节点，达到故障转移。速度fireandforget驱动，即通过驱动调用写入时，可以立即得到返回得到成功的结果（即使是报错），这样让写入的速度更加快，当然会有一定的不安全性，完全依赖网络。Journaling日志，持久性：像mysql的binlog日志，当需要插入的时候会先往日志里面写入记录，再完成实际的数据操作，这样如果出现停电，进程突然中断的情况，可以保障数据不会错误，可以通过修复功能读取Journaling日志进行修复。vsRedisRedis八大数据结构string,list,set,hash,zset,geospatial,hyperloglog,bitmaps数据淘汰算法10wQPS无法统计Mongo提供聚合函数Mongodb也可设置数据过期时间用途分布式日志收集ELK复杂，耗内存ES最多支持32G电子产品传感器40亿个地理地图数据爬虫Schema经常变动大数据3V海量Volume多样Variety实时VelocityC/S服务模型mongod服务端缺少内存配置，由OS管理内存mongos路由实现分片功能mongo客户端jsshell类似sql命令行工具mongodump和mongorestore，备份和恢复mongoexport和mongoimport，用来导入导出JSON、CSV和TSV数据mongosniff，网络嗅探工具，用来观察发送到数据库的操作。基本就是把网络上传输的BSON转换为易于人们阅读的shell语句。操作入门＿id读作“ObjectId”，它是由时间、机器码、进程pid和自增计数器构成的，始终递增，但绝不重复。聚合查询聚合功能可以把数据像放入传送带一样，先把原始数据按照一定的规则进行筛选处理，然后通过多个不同的数据处理阶段来处理数据，最终输出个汇总的结果。aggregate优化和安全建议MongoDB会自动监控，如果发现一个游标在10分钟内没有进行任何的数据库操作，就会把它关掉。Java开发官方驱动文档：mongodb.github.io/mongojavadriver/4.2GettingStartedwww.mongodb.com/blog/post/gettingstartedwithmongodbandjavapartiwww.mongodb.com/blog/post/gettingstartedwithmongodbandjavapartiimongojavadrivermongodbdrivercore是核心库mongodbdriversync是非异步的同步版本，包含了一般MongoCollection的接口mongodbdriverlegacy兼容旧版本APImongodbdriver=mongodbdriversync+mongodbdriverlegacymongojavadriver=mongodbdriver+mongodbdrivercore+bsonMorphiaMorphiaisareallylightweightODMObjectDocumentMapper,soit’ssimilartoORMslikeHibernate.SpringDataMongoDBAnotherfrequentlyusedODMMongoJack直接将JSON映射成Mongo对象。不再需要将JSON转换成Java对象，再转为Mongo对象。JongoanotherJacksonbasedODM,butprovidesaninterestingextraintheformofsupportingqueriesthewayyou’dwritethemintheshell.Golang开发GettingStarted：www.mongodb.com/blog/post/quickstartgolangmongodbstartingandsetupMongoDB集群1、MasterSlaver是一种主从副本的模式，目前已经不推荐使用。一个主节点（Primary）和一个或多个从节点（Secondary）可用于备份、故障恢复、读扩展等只能有一个主节点，主节点提供所有的增、删、查、改服务，从节点不提供任何服务，但是可以通过设置使从节点提供查询服务。每个从节点要知道主节点的地址，主节点记录在其上的所有操作，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。当主节点出现故障时，只能人工介入，指定新的主节点，从节点不会自动升级为主节点。同时，在这段时间内，该集群架构只能处于只读状态。2、ReplicaSet模式是一种互为主从的关系。ReplicaSet将数据复制多份保存，不同服务器保存同一份数据，在出现故障时自动切换，实现故障转移，在实际生产中非常实用。也是一主多从，区别是：当集群中主节点发生故障时，副本集可以自动投票，选举出新的主节点，并引导其余的从节点连接新的主节点。自带故障转移功能的主从复制。只能有一个主节点。主节点负责数据的写入和更新，并在更新数据的同时，将操作信息写入名为oplog的日志文件当中。从节点会定时轮询读取oplog日志，根据日志内容同步更新自身的数据，保持与主节点一致。在副本集中还有一个额外的仲裁节点（不需要使用专用的硬件设备），负责在主节点发生故障时，参与选举新节点作为主节点。副本集中的各节点会通过心跳信息来检测各自的健康状况，当主节点出现故障时，并选举其中一个作为新的主节点。为了保证选举票数不同，副本集的节点数保持为奇数。3、Sharding模式适合处理大量数据，它将数据分开存储，不同服务器保存不同的数据，所有服务器数据的总和即为整个数据集。分片是指将数据拆分并分散存放在不同机器上的过程。MongoDB支持自动分片，可以使数据库架构对应用程序不可见。需要三个重要的组件，分别是分片服务器（ShardServer）、配置服务器（ConfigServer）和路由服务器（RouteServer）。需要三个重要的组件，分别是分片服务器（ShardServer）、配置服务器（ConfigServer）和路由服务器（RouteServer）。ShardServer是一个mongod数据库实例，在实际生产中，一个ShardServer可由几台机器组成一个副本集来承担，防止因主节点单点故障导致整个系统崩溃。ConfigServer是独立的一个mongod进程，保存集群和分片的元数据。RouteServer是独立的一个mongos进程，在集群中可作为路由使用，客户端由此接入，让整个集群看起来像是一个单一的数据库，提供客户端应用程序和分片集群之间的接口。它将客户端的请求路由给每个ShardServer，在各ShardServer返回结果后进行聚合并返回客户端。Sharding模式追求的是高性能，而且是三种集群中最复杂的。在实际生产环境中，通常将ReplicaSet和Sharding两种技术结合使用。", "database/MongoDB例子解读.md": "ReadPreference读偏好**MongoDB有5种ReadPreference模式：**primary主节点，默认模式，读操作只在主节点，如果主节点不可用，报错或者抛出异常。primaryPreferred首选主节点，大多情况下读操作在主节点，如果主节点不可用，如故障转移，读操作在从节点。secondary从节点，读操作只在从节点，如果从节点不可用，报错或者抛出异常。secondaryPreferred首选从节点，大多情况下读操作在从节点，特殊情况（如单主节点架构）读操作在主节点。nearest最邻近节点，读操作在最邻近的成员，可能是主节点或者从节点。MongoDB应答机制w:该选项要求确认操作已经传播到指定数量的mongod实例或指定标签的mongod实例w:1应答式写入w:0非应答式写入w:>1用于副本集环境写入节点数j:该选项要求确认写操作已经写入journal日志之后应答客户端需要开启journal功能wtimeout:该选项指定一个时间限制,以防止写操作无限制被阻塞导致无法应答给客户端readConcern原理解析readConcern决定到某个读取数据时，能读到什么样的数据。local能读取任意数据，这个是默认设置majority只能读取到『成功写入到大多数节点的数据』readConcern的初衷在于解决『脏读』的问题gocontext之WithTimeout的使用1.context包的WithTimeout函数接受一个Context和超时时间作为参数，返回其子Context和取消函数cancel2.新创建协程中传入子Context做参数，且需监控子Context的Done通道，若收到消息，则退出3.需要新协程结束时，在外面调用cancel函数，即会往子Context的Done通道发送消息4.若不调用cancel函数，到了原先创建Context时的超时时间，它也会自动调用cancel函数，即会往子Context的Done通道发送消息Golang的Tag语法通过Tag来增强结构体的定义，Tag会带上一些meta信息。Tag在运行时可以通过reflection包来读取。Tags可以由键值对来组成，通过空格符来分割键值66，可以通过反射的Lookup或者Get来获取键值对的值。Tag最常用的大概就是在marshaling。", "database/MySQL常用.md": "TOC常用操作用户管理创建用户>`CREATEUSER'username'@'host'IDENTIFIEDBY'password';`>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%>`CREATEUSER'pig'@'%'IDENTIFIEDBY'123456';`更改用户密码```sql改密码SETPASSWORDFOR'username'@'host'=PASSWORD'newpassword';如果是当前登陆用户用:SETPASSWORD=PASSWORD\"newpassword\";例子:SETPASSWORDFOR'pig'@'%'=PASSWORD\"123456\";```授权```sqlGRANTSELECT,INSERTONtest.userTO'pig'@'%';GRANTALLON*.*TO'pig'@'%';用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:GRANTprivilegesONdatabasename.tablenameTO'username'@'host'WITHGRANTOPTION;```撤销用户权限```sql说明:privilege,databasename,tablename：同授权部分,不能超越。REVOKEprivilegeONdatabasename.tablenameFROM'username'@'host';例子:REVOKESELECTON*.*FROM'pig'@'%';```删除用户`DROPUSER'username'@'host';`用户授权命令格式：>`mysql>grant权限1,权限2,…权限non数据库名称.表名称to用户名@用户地址identifiedby'连接口令';`>权限1,权限2,…权限n代表`select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file`等14个权限。>当权限1,权限2,…权限n被`allprivileges`或者`all`代替，表示赋予用户全部权限。>当`数据库名称.表名`称被`*.*`代替，表示赋予用户操作服务器上所有数据库所有表的权限。>用户地址可以是`localhost`，也可以是ip地址、机器名字、域名。也可以用`'%'`表示从任何地址连接。>`'连接口令'`不能为空，否则创建失败。```shell给来自10.163.225.87的用户joe分配可对数据库vtdc的employee表进行select,insert,update,delete,create,drop等操作的权限，并设定口令为123。mysql>grantselect,insert,update,delete,create,droponvtdc.employeetojoe@10.163.225.87identifiedby'123';给来自10.163.225.87的用户joe分配可对数据库vtdc所有表进行所有操作的权限，并设定口令为123。mysql>grantallprivilegesonvtdc.*tojoe@10.163.225.87identifiedby'123';给来自10.163.225.87的用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123。mysql>grantallprivilegeson*.*tojoe@10.163.225.87identifiedby'123';给本机用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123。mysql>grantallprivilegeson*.*tojoe@localhostidentifiedby'123';```Database/Table操作创建数据库```mysqlCREATEDATABASE`mydb`CHARACTERSETutf8COLLATEutf8_general_ci;showdatabases;usewifidb```MySQL在Linux下的表名如何不区分大小写>在CentOS7下，在`/etc/my.cnf`文件中`mysqld`的后面加`lower_case_table_names=1`。0,区分大小写;1,不区分。>然后重启mysql：`systemctlreloadmysqld`执行sql文件：```shellmysqluuserp输入密码usetestdbsource/home/gjh/t.sql```查看mysql版本的四种方法```shellshengting@login~$`mysqlV`mysql>status;mysql>`selectversion;````查看表字段：```sqldesctableName;showfieldsfromtableName;showcolumnsfromtableName;```运维导入导出导出导出数据库：`mysqldumpu用户名p数据库名>导出的文件名`，如我输入的命令行:`mysqldumpurootpnews>news.sql`输入后会让你输入进入MySQL的密码（如果导出单张表的话在数据库名后面输入表名即可）导入1、进入MySQL：`mysqlu用户名p`，如我输入的命令行:`mysqlurootp`输入同样后会让你输入MySQL的密码2、新建你要建的数据库，这时是空数据库，如新建一个名为news的目标数据库：`CREATEDATABASEIFNOTEXISTSyourdbnameDEFAULTCHARSETutf8COLLATEutf8_general_ci;`3、输入：`mysql>use目标数据库名`，如我输入的命令行:`mysql>usenews;`4、导入文件：`mysql>source导入的文件名;`如我输入的命令行：`mysql>sourcenews.sql;`性能优化36个字节UUID字符串做主键的性能问题可以使用binary16notnull来存储uuid中间的删除哈`unhexreplace'a3eea9105cab11dfbbb5000c29e30cf0','','';`检索出来的时候用hex这样主键只有原来的一半,效率要高些MySQLinsertingUUIDtoabinary16fieldItisadvantageoustostoreaUUIDacctoRFC4122inabinary16fieldinthedatabase.Itisnothardtocreatesuchatableandtoinsertdataintoit.```sqlCREATETABLEIFNOTEXISTStest_tableidBINARY16NOTNULL,namevarchar128NOTNULL,PRIMARYKEYid;INSERTINTOtest_tableid,nameVALUESUNHEXREPLACEUUID,'','','test1',UNHEXREPLACEUUID,'','','test2',UNHEXREPLACEUUID,'','','test3';```", "database/Oracle札记.md": "instantclient连接PL/SQLDevelopwin8可以使用instantclient_10_2，instantclient_11_2没有试过。win10只能使用instantclient_11_2，且需要安装MicrosoftVisualStudio2005Redistributablewww.microsoft.com/enus/download/details.aspx?id=18471步骤TNS_ADMIN=D:\\dev\\instantclient_11_2加D:\\dev\\instantclient_11_2到Path中配置NLS_LANG=SIMPLIFIEDCHINESE_CHINA.ZHS16GBK编写tnsnames.ora```ORCL=DESCRIPTION=ADDRESS_LIST=ADDRESS=PROTOCOL=TCPHOST=192.168.1.106PORT=1521CONNECT_DATA=SERVICE_NAME=orcl```在PLSQLDeveloper中设置Oracle_Home和OCILibrary：Tools>Preferences>Oracle>Connection：Oracle_Home：D:\\dev\\instantclient_11_2OCILibrary：D:\\dev\\instantclient_11_2\\oci.dll创建表空间和用户createtemporarytablespacets_snhb_tmptempfile'/opt/oracle/oradata/oracle10g/snhb_tmp.dbf'size50mautoextendonnext50mmaxsize20480mextentmanagementlocal;createtablespacets_snhbloggingdatafile'/opt/oracle/oradata/oracle10g/snhb.dbf'size50mautoextendonnext50mmaxsize20480mextentmanagementlocal;createusersnhbidentifiedbysnhbdefaulttablespacets_snhbtemporarytablespacets_snhb_tmp;grantconnect,resource,dbatosnhb;grantallprivilegestosnhb;resourceisaroleinoracle,whichgivesyoutherighttocreateobjectstables,procedures,somemorebutnoviews!.ALLPRIVILEGESgrantsalotmoreofsystemprivileges.查看oracle数据库database的版本命令在sqlplus下输入以下任意一个语句```SQL>select*fromv$version;SQL>selectversionfromv$instance;SQL>SelectversionFROMProduct_component_versionWhereSUBSTRPRODUCT,1,6='Oracle';```Oracle锁表```sqlselects.SID,s.serial,s.USERNAME,s.machine,s.OSUSER,s.PROGRAM,l.locked_mode,o.OBJECT_NAME,a.sql_textfromv$sessions,v$locked_objectl,v$sqlareaa,dba_objectsowherel.session_id=s.sidands.prev_sql_addr=a.addressando.object_id=l.object_idorderbysid,s.serial;```www.cnblogs.com/shenckicc/p/5458574.htmlwww.cnblogs.com/dgqblog/p/9243196.htmlwww.cnblogs.com/su1643/p/6598571.html", "database/PL-SQL教程.md": "课程一PL/SQL基本查询与排序本课重点：1、写SELECT语句进行数据库查询2、进行数学运算3、处理空值4、使用别名ALIASES5、连接列6、在SQLPLUS中编辑缓冲，修改SQLSCRIPTS7、ORDERBY进行排序输出。8、使用WHERE字段。一、写SQL命令：不区分大小写。SQL语句用数字分行，在SQLPLUS中被称为缓冲区。最后以；或/结束语句。也可以用RUN来执行语句二、例1：SQL>SELECTdept_id,last_name,manager_id2FROMs_emp;SQL>SELECTlast_name,salary*12,commission_pct2FROMs_emp;对于数值或日期型的字段，可以进行相应的四则运算，优先级与标准的高级语言相同。SQL>SELECTlast_name,salary,12*salary+1002FROMs_emp;三、列的别名ALIASES：计算的时候特别有用；紧跟着列名，或在列名与别名之间加“AS”；如果别名中含有SPACE，特殊字符，或大小写，要用双引号引起。例因字体原因，读者请记住：引号为英文双引号DoubleQuotation：SQL>SELECTlast_name,salary,212*salary+100”AnnualSalary”3FROMs_emp;四、连接符号：||连接不同的列或连接字符串使结果成为一个有意义的短语：SQL>SELECTfirst_name||’’||last_name2||’,’||title”Employees”3FROMs_emp;五、管理NULL值：SQL>SELECTlast_name,title,2salary*NVLcommission_pct,0/100COMM3FROMs_emp;此函数使NULL转化为有意义的一个值，相当于替换NULL。六、SQLPLUS的基本内容，请参考<SQLPLUS简单实用精髓篇>七、ORDERBY操作：与其他SQL92标准数据库相似，排序如：SELECTexprFROMtableORDERBYASC|DESC;从Oracle7release7.0.16开始，ORDERBY可以用别名。另：通过位置判断排序：SQL>SELECTlast_name,salary*122FROMs_emp3ORDERBY2;这样就避免了再写一次很长的表达式。另：多列排序：SQL>SELECTlastname,dept_id,salary2FROMs_emp3ORDERBYdept_id,salaryDESC;八、限制选取行：SELECTexprFROMtableWHEREconditionsORDERBYexpr;例1：SQL>SELECTfirst_name,last_name,start_date2FROMs_emp3WHEREstart_dateBETWEEN’09may91’4AND’17jun91’;例2：SQL>SELECTlast_name2FROMs_emp3WHERElast_nameLIKE’_a%’;//显示所有第二个字母为a的last_name例3：如果有列为NULLSQL>SELECTid,name,credit_rating2FROMs_customer3WHEREsales_rep_idISNULL;优先级：OrderEvaluatedOperator1Allcomparisonoperators=,<>,>,>=,<,<=,IN,LIKE,ISNULL,BETWEEN2AND3OR总结：我们今天主要学习了如何进行查询SELECT操作，具体的组合查询与子查询将在以后的课堂中学习，同时希望大家可以工作、学习中多多摸索，实践!课程二PL/SQL查询行函数本课重点：1、掌握各种在PL/SQL中可用的ROW函数2、使用这些函数的基本概念3、SELECT语句中使用函数4、使用转换函数一、FUNCTION的作用：进行数据计算，修改独立的数据，处理一组记录的输出，不同日期显示格式，进行数据类型转换函数分为：单独函数ROW和分组函数注意：可以嵌套、可以在SELECT,WHERE,和ORDERBY中出现。语法：function_namecolumn|expression,arg1,arg2,...二、字符型函数1、LOWER转小写2、UPPER3、INITCAP首字母大写4、CONCAT连接字符，相当于||5、SUBSTRSUBSTRcolumn|expression,m,n6、LENGTH返回字符串的长度7、NVL转换空值其中，1、2经常用来排杂，也就是排除插入值的大小写混用的干扰，如：SQL>SELECTfirst_name,last_name2FROMs_emp3WHEREUPPERlast_name=’PATEL’;FIRST_NAMELAST_NAMEVikramPatelRadhaPatel三、数学运算函数1、ROUND四舍五入ROUND45.923，2=45.92ROUND45.923，0=46ROUND45.923，1=502、TRUNC截取函数TRUNC45.923，2=45.92TRUNC45.923=45TRUNC45.923，1=403、MOD余除MOD1600，300实例：SQL>SELECTROUND45.923,2,ROUND45.923,0,2ROUND45.923,13FROMSYS.DUAL;四、ORACLE日期格式和日期型函数：1、默认格式为DDMONYY.2、SYSDATE是一个求系统时间的函数3、DUAL［'dju:el是一个伪表，有人称之为空表，但不确切。SQL>SELECTSYSDATE2FROMSYS.DUAL;4、日期中应用的算术运算符例：SQL>SELECTlast_name,SYSDATEstart_date/7WEEKS2FROMs_emp3WHEREdept_id=43;DATE+NUMBER=DATEDATEDATE=NUMBEROFDAYSDATE+NUMBER/24=加1小时5、函数：MONTHS_BETWEENdate1,date2月份间隔，可正，可负，也可是小数ADD_MONTHSdate,n加上N个月，这是一个整数，但可以为负NEXT_DAYdate,‘char’如：NEXT_DAYrestock_date,’FRIDAY’,从此日起下个周五。ROUNDdate,‘fmt’TRUNCdate,‘fmt’解释下面的例子：SQL>SELECTid,start_date,2MONTHS_BETWEENSYSDATE,start_dateTENURE,3ADD_MONTHSstart_date,6REVIEW4FROMs_emp5WHEREMONTHS_BETWEENSYSDATE,start_date<48;我们看到：MONTHS_BETWEENSYSDATE,start_date<48，说明至今工作未满一年的员工。LAST_DAYrestock_date返回本月的最后一天SQL>selectroundsysdate,'MONTH'fromdualROUNDSYSD0111月01roundsysdate,'YEAR'=011月02ROUND之后的值比基值大的最小符合值，大家可以用更改系统时间的方法测试，以15天为分界线，也是非常形象的四舍五入，而TRUNC恰好相反，是对现有的日期的截取。五、转换函数：1、TO_CHAR使一个数字或日期转换为CHAR2、TO_NUMBER把字符转换为NUMBER3、TO_DATE字符转换为日期这几个函数较为简单，但要多多实践，多看复杂的实例。SQL>SELECTID,TO_CHARdate_ordered,’MM/YY’ORDERED2FROMs_ord3WHEREsales_rep_id=11;转换时，要注意正确的缺省格式：SELECTTO_DATE'03MAR92'CORRECTFROMDUAL；//正确SELECTTO_DATE'031092'CORRECTFROMDUAL；//不正确SELECTTO_DATE'031095','MMDDYY'ERRORRFROMDUAL//输出3月10日SELECTTO_DATE'031095','DDMMYY'ERRORRFROMDUAL//输出10月3日4、实例：selectto_charsysdate,'fmDDSPTH\"of\"MONTHYYYYAM'TODAYSFROMDUAL;TODAYSSIXTEENTHof11月2001下午大小写没有什么影响，引号中间的是不参与运算。实例：SELECTROUNDSALARY*1.25FROMONE_TABLE；意义：涨25%工资后，去除小数位。在现实操作中，很有意义。5、混合实例：SQL>SELECTlast_name,TO_CHARstart_date,2’fmDD”of”MonthYYYY’HIREDATE3FROMs_emp4WHEREstart_dateLIKE’%91’;LAST_NAMEHIREDATENagayama17ofJune1991Urguhart18ofJanuary1991Havel27ofFebruary1991这里要注意：fmDD和fmDDSPTH之间的区别。SQL>SELECTid,total,date_ordered2FROMs_ord3WHEREdate_ordered=4TO_DATE’September7,1992’,’Monthdd,YYYY’;六、独立的函数嵌套SQL>SELECTCONCATUPPERlast_name,2SUBSTRtitle,3”VicePresidents”3FROMs_emp4WHEREtitleLIKE’VP%’;*嵌套可以进行到任意深度，从内向外计算。例：SQL>SELECTTO_CHARNEXT_DAYADD_MONTHS2date_ordered,6,’FRIDAY’,3’fmDay,Monthddth,YYYY’4”New6MonthReview”5FROMs_ord6ORDERBYdate_ordered;SQL>SELECTlast_name,2NVLTO_CHARmanager_id,’NoManager’3FROMs_emp4WHEREmanager_idISNULL;对于例子，大家重要的理解，并多做测试，并注意英文版和中文版在日期上的区别。有些教材上的例子，不要盲目的相信其结果，实践后才有发言权，希望大家能够在学习的过程中不要忽略了用，多想一想为什么实例要如此设计，在何种情况下应用此实例来解决问题。这样，我们才真正掌握了知识。课程三从多个表中提取数据本课重点：1、SELECTFROM多个表，使用等连接或非等连接2、使用外连接OUTERJOIN3、使用自连接一、连接的概念：是指一个从多个表中的数据进行的查询。连接一般使用表的主键和外键。连接类型：等连接、不等连接、外连接、自连接二、Cartesianproduct（笛卡儿集）指的是当JOIN条件被省略或无效时，所有表的行交叉都被SELECT出来的现象。Cartesianproduct可以产生大量的记录，除非是你有意如此，否则应该加上某种条件限制。SQL>SELECTname,last_name2FROMs_dept,s_emp;300rowsselected.其中一个表12行，一个表25行。三、简单连接查询：语法结构：SELECTtable.column,table.column...FROMtable1,table2WHEREtable1.column1=table2.column2;如：SQL>SELECTs_emp.last_name,s_emp.dept_id,2s_dept.name3FROMs_emp,s_dept4WHEREs_emp.dept_id=s_dept.id;*注意：表前缀的重要性：SQL>SELECTs_dept.id”DepartmentID”,2s_region.id”RegionID”,3s_region.name”RegionName”4FROMs_dept,s_region5WHEREs_dept.region_id=s_region.id;在WHERE段中，如果没有前缀，两个表中都有ID字段，就显得的模棱两可，AMBIGUOUS。这在实际中应该尽量避免。WHERE字段中，还可以有其他的连接条件，如在上例中，加上：INITCAPs_dept.last_name=’Menchu’;再如：WHEREs_emp.dept_id=s_dept.idANDs_dept.region_id=s_region.idANDs_emp.commission_pct>0;四、表别名ALIAS：1、使用别名进行多表查询。2、仅在这个查询中生效，一旦用了表别名，就不能再用表的原有的名字进行连接。实例：SQL>SELECTc.name”CustomerName”,2c.region_id”RegionID”,3r.name”RegionName”4FROMs_customerc,s_regionr5WHEREc.region_id=r.id;别名最多可以30个字符，但当然越少越好。最好也能容易识别。五、非等连接非等连接一般用在没有明确的等量关系的两个表；最简单的说：非等连接就是在连接中没有“=”出现的连接。SQL>SELECTe.ename,e.job,e.sal,s.grade2FROMempe,salgrades3WHEREe.salBETWEENs.losalANDs.hisal;*说明：Createanonequijointoevaluateanemployee’ssalarygrade.Thesalary必须在另一个表中最高和最低之间。其他操作符<=>=也可以实现，但是BETWEEN是非常简单实用的。BETWEEN....AND是指闭区间的，这点要注意，请大家测试。六、外连接语法结构：SELECTtable.column,table.columnFROMtable1,table2WHEREtable1.column=table2.column+;实例：SQL>SELECTe.last_name,e.id,c.name2FROMs_empe,s_customerc3WHEREe.id+=c.sales_rep_id4ORDERBYe.id;显示.....，即使有的客户没有销售代表。*可以理解为有+号的一边出现了NULL，也可以做为合法的条件。外连接的限制：1、外连接符只能出现在信息缺少的那边。2、在条件中，不能用IN或者OR做连接符。七、自连接同一个表中使用连接符进行查询；FROM的后面用同一个表的两个别名。实例：SQL>SELECTworker.last_name||’worksfor’||2manager.last_name3FROMs_empworker,s_empmanager4WHEREworker.manager_id=manager.id;意味着：一个员工的经理ID匹配了经理的员工号，但这个像绕口令的连接方式并不常用。以后我们会见到一种子查询：selectlast_namefroms_empwheresalary=selectmaxsalaryfroms_emp也可以看作是一种变向的自连接，但通常我们将其归类为子查询。课程四组函数本课重点：1、了解可用的组函数2、说明每个组函数的使用方法3、使用GROUPBY4、通过HAVING来限制返回组一、概念：组函数是指按每组返回结果的函数。组函数可以出现在SELECT和HAVING字段中。GROUPBY把SELECT的结果集分成几个小组。HAVING来限制返回组，对RESULTSET而言。二、组函数：号的函数不做重点1、AVG2、COUNT3、MAX4、MIN5、STDDEV6、SUM7、VARIANCE语法：SELECTcolumn,group_functionFROMtableWHEREconditionGROUPBYgroup_by_expressionHAVINGgroup_conditionORDERBYcolumn;实例1：SQL>SELECTAVGsalary,MAXsalary,MINsalary,2SUMsalary3FROMs_emp4WHEREUPPERtitleLIKE’SALES%’;AVGSALARYMAXSALARYMINSALARYSUMSALARY1476152514007380*说明：很多函数，我们在讲函数的已经向大家介绍过，但在此为何叫分组函数呢，主要是因为它们可以与GROUPBY来形成对不同组的计算，相当于在很多值中进行挑选。*MINMAX函数可以接任何数据类型。如果是MINlast_name,MAXlast_name，返回的是什么呢？千万记住，不是指LAST_NAME的长度，而是指在FIRST字母的前后顺序，第一个相同，然后比较第二个，如：xdopt>cssingkdkdk>adopt>acccc实例2：返回所有非空行个数SQL>SELECTCOUNTcommission_pct2FROMs_emp3WHEREdept_id=31;三、GROUPBY的应用：先看一个简单实例：SQL>SELECTcredit_rating,COUNT*”Cust”2FROMs_customer3GROUPBYcredit_rating;*注意这里别名的应用，复习一下从前的课程，加了引号后，就可以用特殊字符，但也仅有三个：$_，什么对象的名字都如此。当然空格也是可以的。复杂实例：SQL>SELECTtitle,SUMsalaryPAYROLL2FROMs_emp3WHEREtitleNOTLIKE’VP%’4GROUPBYtitle5ORDERBYSUMsalary;这里要注意一下几个CLAUSE的先后次序。WHERE在这里主要是做参与分组的记录的限制。**另外，如果要选取出来一个不加组函数的列，如上面的TITLE，就要把这个列GROUPBY!否则要出错的!信息为：ERRORatline1:ORA00937:notasinglegroupgroupfunction理论很简单，如果不GROUPBYTITLE，显示哪一个呢？这个在试题中经常出现。结论：不加分组函数修饰的列必定要出现在GROUPBY里。错误实例：SQL>SELECTdept_id,AVGsalary2FROMs_emp3WHEREAVGsalary>20004GROUPBYdept_id;5WHEREAVGsalary>2000ERRORatline3:ORA00934:groupfunctionisnotallowedhere应在GROUPBY后面加上HAVINGAVGsalary>2000;因为是用来限制组的返回。多级分组实例：SQL>SELECTdept_id,title,COUNT*2FROMs_emp3GROUPBYdept_id,title;就是先按照DEPT_ID分组，当DEPT_ID相同的时候，再按TITLE分组，而COUNT*以合成的组计数。顺序对结果有决定性的影响。总结：本课我们主要学习了分组函数的使用及如何进行分组查询，我们可以想像一下，SQLSERVER中有COMPUTEBY，来进行分组总数的计算，但在ORACLE中是没有的。大家可以建立一个有多个列，多个重复值的表，然后进行各种分组的演示，用得多了，自然明了。课程五子查询本课重点：1、在条件未知的情况下采用嵌套子查询2、用子查询做数据处理3、子查询排序一、概述：子查询是一种SELECT句式中的高级特性，就是一个SELECT语句作为另一个语句的一个段。我们可以利用子查询来在WHERE字段中引用另一个查询来攻取值以补充其无法事先预知的子结果。子查询可以用在WHERE子句，HAING子句，SELECT或DELETE语句中的FROM子句。*注意：1、子查询必须在一对圆括号里。2、比较符号：>,=,或者IN.3、子查询必须出现在操作符的右边4、子查询不能出现在ORDERBY里试题中有时出现找哪行出错二、子查询的执行过程：NESTEDQUERYMAINQUERYSQL>SELECTdept_idSQL>SELECTlast_name,title2FROMs_emp2FROMs_emp3WHEREUPPERlast_name=’BIRI’;3WHEREdept_id=这里，每个查询只运行一次。当然，子查询要首先被执行，大家设想一下，如果子查询中有一个以上的人的LASTNAME为BIRI，会如何？会出错，因为不能用=来连接。ORA1427:singlerowsubqueryreturnsmorethanonerow以上的查询也被称之为单行子查询。DELECT子查询实例：deletefromnew_tablewherecata_time>to_date'19990901','yyyymmdd'andpro_name=selectpro_namefromnew_productwherepro_addrin'bj','sh'三、子查询中的GROUP函数的应用实例1：SQL>SELECTlast_name,title,salary2FROMs_emp3WHEREsalary<4SELECTAVGsalary5FROMs_emp;实例2：选择出工资最高的员工的家庭住址：selectemp_addrfromemployeeswheresalary=selectmaxsalaryfromemployees;这是一个简单实用的例子，可以衍生出很多情况，在实际应用经常出现，请大家多多思考。实例3：SQL>SELECTdept_id,AVGsalary2FROMs_emp3GROUPBYdept_id4HAVINGAVGsalary>5SELECTAVGsalary6FROMs_emp7WHEREdept_id=32;子查询被多次执行，因为它出现在HAVING子句中。SQL>SELECTtitle,AVGsalary2FROMs_emp3GROUPBYtitle4HAVINGAVGsalary=5SELECTMINAVGsalary6FROMs_emp7GROUPBYtitle;对子查询，我们了解这么多在理论上已经覆盖了所有的知识点，对于UPDATE和DELETE的子查询，不作为重点，但也要练习掌握。今天到这，谢谢大家。课程六运行时应用变量本课重点：1、创建一个SELECT语句，提示USER在运行时先对变量赋值。2、自动定义一系列变量，在SELECT运行时进行提取。3、在SQLPLUS中用ACCEPT定义变量一、概述：变量可以在运行时应用，变量可以出现在WHERE字段，文本串，列名，表名等。1、我们这里的运行时，指的是在SQLPLUS中运行。2、ACCEPT：读取用户输入的值并赋值给变量3、DEFINE：创建并赋值给一个变量4、在做REPORT时经常使用，比如对某个部门的销售信息进行统计，部门名称可以以变量代替。SQLPLUS不支持对输入数据的有效性检查，因此提示要简单且不模棱两可。二、应用实例：1、SQL>SELECTid,last_name,salary2FROMs_emp3WHEREdept_id=&department_number;2、可以在赋值前后进行比较：SETVERIFYON.....1*select*fromempwherelastname='&last_name'输入last_name的值:adopt原值1:select*fromempwherelastname='&last_name'新值1:select*fromempwherelastname='adopt'如果在原语句中没有单引号，那么在输入值的时候要手工加上单引号。一般字符和日期型要在语句中加上单引号。SETVERIFYOFF之后，原值和新值这两句消失。这在ORACLE8I中是默认为ON。3、子句为变量：WHERE&condition;要注意引号三、DEFINE和ACCEPT的应用：1、SETECHOOFF//使内容不显示在用户界面ACCEPTp_dnamePROMPT’Providethedepartmentname:’SELECTd.name,r.id,r.name”REGIONNAME”FROMs_deptd,s_regionrWHEREd.region_id=r.idANDUPPERd.nameLIKEUPPER’%&p_dname%’/SETECHOON存为文件：l7prompt.SQLSQL>STARTl7promptProvidethedepartmentname:sales2、SQL>DEFINEdname=salesSQL>DEFINEdnameDEFINEdname=”sales”CHARSQL>SELECTname2FROMs_dept3WHERElowername=’&dname’;可以正常执行了。SQL>DEFINEdname主要是显示当前的变量是否赋值，值是什么。当然，我们可以用UNDEFINEGO来使变量恢复初始，不然它会一直保持下去。3、如果变量在SQLSCRIPT文件中确定：可以SQL>STARTl7paramPresident来赋值。总结：本课主要针对较古老的SQLPLUS方法，在REPORT和结果集生成方面使用变量，达到方便操作，动态修改的目的。课程七其他数据库对象SEQUENCE创建实例：SQL>CREATESEQUENCEs_dept_id2INCREMENTBY13STARTWITH514MAXVALUE99999995NOCACHE6NOCYCLE;Sequencecreated.1、NEXTVAL和CURRVAL的用法只有在INSERT中，才可以作为子查询出现。以下几个方面不可用子查询：SELECT子句OFAVIEW有DISTINCT的出现的SELECT。有GROUP　BY，HAVING，ORDER　BY的SELECT　子句。SELECT　或DELETE，UPDATE　中的子查询。DEFAULT选项中不能用。2、编辑SEQUENCE只有OWNER或有ALTER权限的用户才能修改SEQUENCE未来的NUMBER受修改的影响。不能修改START　WITH，如果变，则要RE－CREATE。修改会受到某些有效性检验的限制，如MAXVALUE3、删除：DROPSEQUENCEsequence;ORACLE对象之INDEX一、INDEX概述：是ORACLE的一种数据对象，用POINTER来加速查询行。通过快速路径存取方法定位数据并减少I/O。　INDEX独立于表。INDEX由ORACLE　SERVER来使用和保持。二、索引如何建立？1、自动：通过PRIMARY　KEY和UNIQUEKEY约束来建立。2、用户手工建立非唯一性索引。三、创建方法：语法：CREATEINDEXindexONtablecolumn,column...;何时建立INDEX：此列经常被放到WHERE字段或JOIN来作条件查询。此列含有大量的数据。此列含有大量的空值。两个或几个列经常同时放到WHERE字段进行组合查询表很大而且只有少于24%的ROW可能被查询的时候。以下情况不要建立索引：表很小；表被更新频繁。四、查看已经存在的索引：1、USER_INDEXES可以查询索引名和类型。2、USER_IND_COLUMNS包含索引名、表名、列名。实例：SQL>SELECTic.index_name,ic.column_name,2ic.column_positioncol_pos,ix.uniqueness3FROMuser_indexesix,user_ind_columnsic4WHEREic.index_name=ix.index_name5ANDic.table_name=’S_EMP’;五、删除索引：DROPINDEXindex;SYNONYMS同义词语法：CREATEPUBLICSYNONYMsynonymforobject;*注意：此对象不能包含在一个包里；一个私有的同义词不能与同一USER的其他对象重名。DROPSYNONYMD_SUM；课程八用户访问控制本课重点：1、创建用户2、创建角色来进行安全设置3、使用GRANT或REVOKE来控制权限一、概述：ORACLE通过用户名和密码进行权限控制。数据库安全：系统安全和数据安全系统权限：使用户可以访问数据库对象权限：操纵数据库中的对象SCHEMA：各种对象的集合二、系统权限：1、超过80个权限可用。2、DBA有最高的系统权限：CREATENEWUSERREMOVEUSERSREMOVEANYTABLEBACKUPANYTABLE三、创建用户1、CREATEUSERuserIDENTIFIEDBYpassword;2、系统权限：CREATESESSIONConnecttothedatabase.CREATETABLECreatetablesintheuser’sschema.CREATESEQUENCECreateasequenceintheuser’sschema.CREATEVIEWCreateaviewintheuser’sschema.CREATEPROCEDURECreateastoredprocedure,function,orpackageintheuser’sschema.3、授权用户系统权限：GRANTprivilege,privilege...TOuser,user...;GRANTCREATETABLETOSCOTT；四、角色的使用1、概念：角色是一组权限的命名，可以授予给用户。这样就如同给了某个用户一个权限包。2、创建、授予给角色：CREATEROLEMANAGER；GRANTCREATETABLE，CREATEVIEWTOMANAGER；GRANTMANAGERTOCLARK五、修改密码：ALTERUSERuserIDENTIFIEDBYpassword;六、对象权限：1、语句：GRANT{object_priv,object_priv...|ALL}columnsONobjectTO{user,user...|role|PUBLIC}WITHGRANTOPTION;2、实例：最简单：SQL>GRANTselect2ONs_emp3TOsue,rich;稍复杂：SQL>GRANTupdatename,region_id2ONs_dept3TOscott,manager;SQL>GRANTselect,insert2ONs_dept3TOscott4WITHGRANTOPTION;课程九声明变量本课重点：1、了解基本的PLSQL块和区域2、描述变量在PLSQL中的重要性3、区别PLSQL与非PLSQL变量4、声明变量5、执行PLSQL块一、概述：1、PLSQL块结构：DECLARE可选变量声明定义BEGIN必选SQL和PLSQL语句EXCEPTION可选错误处理END；必选二、实例：declarevjobvarchar9;v_countnumber:=0;vtotaldate:=sysdate+7;c_taxconstantnumber3,2:=8.25;v_validbooleannotnull:=true;beginselectsysdateintovtotalfromdual;end;/上例中，如果没有这个SELECT语句，会如何？出错，说明必须有STATEMENTS如果：selectsysdatefromdualintovtotal;同样，也不行。而且变量与赋值的类型要匹配。三、%TYPE的属性声明一个变量使之与数据库某个列的定义相同或与另一个已经定义过的变量相同，所以%TYPE要作为列名的后缀：如：v_last_names_emp.last_name%TYPE;v_first_names_emp.first_name%TYPE;这样做的好处是我们不必去知晓此列的类型与定义或：v_balanceNUMBER7,2;v_minimum_balancev_balance%TYPE:=10;四、声明一个布尔类型的变量1只有TRUE、FALSE、NULL可以赋值给BOOLEAN变量2此变量可以接逻辑运算符NOT、AND、OR。3、变量只能产生TRUE、FALSE、NULL。实例：VSAL1：=50000；VSQL2：=60000；VCOMMSALBOOLEAN：=VSAL1<VSQL2；其实是把TRUE赋值给此变量。五、LOB类型的变量共有CLOB、BLOB、BFILE、NCLOB几种，这里不做为重点。六：使用HOSTVARIABLESSQL>variablennumberSQL>printn:n=v_sal/12;:n这个加了：前缀的变量不是PLSQL变量，而是HOST。七、以下几个PLSQL声明变量，哪个不合法？A、DECLAREV_IDNUMBER4；B、DECLAREV_X，V_Y，V_ZVARCHAR29；C、DECLAREV_BIRTHDATENOTNULL；D、DECLAREV_IN_STOCKBOOLEAN：=1；E、DECLARETYPENAME_TABISTABLEOFVARCHAR220INDEXBYBINARY_INTEGER；DEPT_NAMENAME_TAB；上面的习题我会在下章给出答案，这也正是声明变量的规则和难点。课程十写执行语句本课重点：1、了解PLSQL执行区间的重要性2、写执行语句3、描述嵌套块的规则4、执行且测试PLSQL块5、使用代码惯例一、PLSQL块的语法规则：1、语句可以跨跃几行。2、词汇单元可以包括：分隔符、标识符、文字、和注释内容。3、分隔符：+*/=<>||....4、标识符：最多30个字符，不能有保留字除非用双引号引起。字母开头，不与列同名。5、文字串：如V_ENAME:='FANCY';要用单引号括起来。数值型可以用简单记数和科学记数法。6、注释内容：单行时用多行用/**/与C很相似二、SQL函数在PL/SQL的使用：1、可用的：单行数值型、字符型和转换型，日期型。2、不可用的：最大、最小、DECODE、分组函数。实例：BEGINSELECTTO_CHARHIREDATE,'MON,DD,YYYY'FROMEMP;END;V_comment:=user||':'||sysdate;会编译出错V_comment:=user||':'||to_charsysdate;正确如果有可能，PLSQL都会进行数据一致性的转换，但ORACLE推荐你应该进行显示的转换，因为这样会提高性能。三、嵌套块和变量作用区域1、执行语句允许嵌套时嵌套。2、嵌套块可以看作正常的语句块。3、错误处理模块可以包括一个嵌套块4、exponential指数逻辑、算数、连接、小括号5、看正面实例：declarevjobvarchar9;v_countnumber:=0;vtotaldate:=sysdate+7;c_taxconstantnumber3,2:=8.25;v_validbooleannotnull:=true;tttvtotal%type;beginselectsysdateintovtotalfromdual;体会有无此句与结果的影响dbms_output.put_linevtotal;end;/*注意：在执行块之前，要在SQLPLUS中执行：SETSERVEROUTPUTON三、以实例来说明函数的参数声明作用域declarev_weightnumber3:=600;v_messagevarchar2255:='product10000';begindeclaresubblockv_weightnumber3:=1;v_messagevarchar2255:='pro300';beginv_weight:=v_weight+1;end;v_weight:=v_weight+1;v_message:=v_message||'myname';end;/子块中的V_WEIGHT值为2我们可以在子块中加入：dbms_output.put_line'subblockvalueis'||v_weight;在主体中加入：dbms_output.put_line'mainvalueis'||v_weight;我们发现MAINBLOCK中V_WEIGHT为601改动：1、在主块的声明中加v_datedatedefaultsysdate;在子块中加入：dbms_output.put_line'subblockdatevalueis'||v_date;执行结果：subblockdatevalueis2211月01*说明：主块中的变量，如果子块中没有同名变量声明，则继承主块中的声明和初始化值；2、在子块中加入：v_subchar9;dbms_output.put_line'subblockcharvalueis'||v_sub;此时正常输出。在主块中加入：dbms_output.put_line'maincharvalueis'||v_sub;输出：ORA06550:第21行,第45列:PLS00201:必须说明标识符'V_SUB'*说明：子块中声明的变量主块中并不知晓，因此出错。了解了此实例，一切情况的变量的值的走向就都明了了。课程十一与ORACLESERVER交互本课重点：1、在PLSQL中成功的写SELECT语句2、动态声明PLSQL变量类型与SIZE3、在PLSQL中写DML语句4、在PLSQL中控制事务5、确定DML操作的结果一、PLSQL中的SQL语句：SELECT、DML、COMMIT、ROLLBACK、SAVEPOINT、CURSOR特殊强调：PLSQL不支持DCL，不要问为什么。DBMS_SQLpackageallowsyoutoissueDDLandDCLstatements.二、SELECTSELECTselect_listINTOvariable_name|record_nameFROMtableWHEREcondition;例：SQL>r1declare2v_deptnonumber2;3v_locvarchar215;4begin5selectdeptno,loc6intov_deptno,v_loc7fromdept8wheredname='SALES';9DBMS_OUTPUT.PUT_LINEV_deptno||'and'||v_loc;10*end;30andCHICAGO选取字段与变量个数和类型要一致。声明的变量一定要在SIZE上大于返回的赋值，否则提示缓冲区溢出。如果SELECT语句没有返回值：ORA01403:未找到数据ORA06512:在line5如果有多个值返回：ORA01422:实际返回的行数超出请求的行数这些我们到了错误处理时会逐一讲解。例：上面的例子可以改为：declarev_deptnodept.deptno%type;v_locdept.loc%type;beginselectdeptno,locintov_deptno,v_locfromdeptwheredname='SALES';DBMS_OUTPUT.PUT_LINEV_deptno||'and'||v_loc;end;/这样，可以在未知其他字段大小和类型的时候定义变量，提高兼容性。三、DML操作：1、实例：declarev_empnoemp.empno%type;beginselectmaxempnointov_empnofromemp;v_empno:=v_empno+1;insertintoempempno,ename,job,deptnovaluesv_empno,'asdfasdf','ddddd',10;end;/这样也可以实现如SEQUENCE一样的编号唯一递增。2、更新和删除：这个较为简单：DECLAREV_DEPTNOEMP.DEPtno%type:=10;begindeletefromempwheredeptno=v_deptno;end;/PLSQL首先检查一个标识符是否是一个数据库的列名，如果不是，再假定它是一个PLSQL的标识符。所以如果一个PLSQL的变量名为ID，列中也有个ID，如：SELECTdate_ordered,date_shippedINTOdate_ordered,date_shippedFROMs_ordWHEREid=id;就会返回TOOMANYROWS，这是要尽量避免的。四、SQLCURSOR游标是一个独立SQL工作区，有两种性质的游标：隐式游标：当PARSE和EXECUTE时使用隐式游标。显式游标：是由程序员显式声明的。游标的属性：SQL%ROWCOUNT：一个整数值，最近SQL语句影响的行数。SQL%FOUNDBOOLEAN属性，如果为TRUE，说明最近的SQLSTATEMENT有返回值。SQL%NOTFOUND与SQL%FOUND相反SQL%ISOPEN在隐式游标中经常是FALSE，因为执行后立即自动关闭了。SQL>variablerow_denumberSQL>r1declare2v_deptnonumber:=10;3begin4deletefromempwhere5deptno=v_deptno;6:row_de:=sql%rowcount;7*end;PL/SQL过程已成功完成。SQL>printrow_de这是一个SQLPLUS变量ROW_DE4这时其实并没有真正的删除，而是需要COMMIT或ROLLBACK，来完成事务。课程十二编写控制结构语句本课重点：1、结构控制的的用途和类型2、IF结构3、构造和标识不同的循环4、使用逻辑表5、控制流和嵌套一、控制执行流可以是分支和循环：IFTHENENDIFIFconditionTHENstatements;ELSIFconditionTHENstatements;ELSEstatements;ENDIF;例子：IFV_ENAME='OSBORNE'THENV_MGR:=22;ENDIF;这里我们可以注意，PLSQL和C语言或JAVA在条件上的不同，=代表关系运算，而：=代表赋值。看一个函数：createFUNCTIONcalc_valv_startINNUMBERRETURNNUMBERISBEGINIFv_start>100THENRETURN2*v_start;ELSIFv_start>=50THENRETURN.5*v_start;ELSERETURN.1*v_start;ENDIF;ENDcalc_val;现在，虽然我们尚未讲解CREATE函数或过程，但可以看到IF条件在其中的作用。二、注意LOGICTABLE中的逻辑对应关系1、NOT、AND、OR2、任何表达式中含有空值结果都为NULL3、连接字符串中含有空值会把NULL作为EMPTYSTRINGdeclarev_deptnodept.deptno%type;v_locdept.loc%type;V_FLAGBOOLEAN;V_RECBOOLEAN:=FALSE;此值改为TRUE、NULL、FALSE进行不同的比较V_AVABOOLEAN:=NULL;beginV_FLAG:=V_RECANDV_AVA;IFV_FLAG=TRUETHENDBMS_OUTPUT.PUT_LINE'TRUE';ELSIFV_FLAG=FALSETHENDBMS_OUTPUT.PUT_LINE'FALSE';ELSEDBMS_OUTPUT.PUT_LINE'NULL';ENDIF;end;/值得注意的是：NULLANDFALSE>FALSE，这是在实践中总结出来的。三、基本循环基础：1、LOOPstatement1;statement2;...EXITWHENcondition;ENDLOOP;v_ord_ids_item.ord_id%TYPE:=101;v_counterNUMBER2:=1;BEGIN...LOOPINSERTINTOs_itemord_id,item_idVALUESv_ord_id,v_counter;v_counter:=v_counter+1;EXITWHENv_counter>10;ENDLOOP;2、FOR循环：FORindexINREVERSElower_bound..upper_boundLOOPstatement1;statement2;...ENDLOOP;实例：DECLAREV_LOWERNUMBER:=1;V_UPPERNUMBER:=23;BEGINDBMS_OUTPUT.PUT_LINE'';FORIINV_LOWER..V_UPPERLOOPDBMS_OUTPUT.PUT_LINEI;ENDLOOP;END;/3、WHILE循环：WHILEconditionLOOPstatement1;statement2;...ENDLOOP;4、循环是可以多层嵌套的。可以用<<LABEL>>做循环的标签。...BEGIN<<OuterCloop>>LOOPv_counter:=v_counter+1;EXITWHENv_counter>10;<<InnerCloop>>LOOP...EXITOuter_loopWHENtotal_done=’YES’;CCLeavebothloopsEXITWHENinner_done=’YES’;CCLeaveinnerlooponly...ENDLOOPInner_Loop;...ENDLOOPOuter_loop;END;总结：本章内容较为繁杂，虽然不是很难，而且多数与其他高级语言有某种共性，但大家要多多练习，用实践来检验对某些含糊的猜测。课程十三使用组合数据类型*游标操纵数据本课重点：1、创建用户自定义的PLSQL记录2、利用%ROWTYPE属性来创建记录3、创建PLSQL表4、描述记录、表、记录的表之间的区别一、合成数据类型1、类型分为PLSQL记录和PLSQL表2、包含内部组件3、可重用二、PLSQL记录与3GL中的记录结构相似，与数据库表是两回事是一个方便的途径FETCH一些行FROM一个表来进行相关处理。标准语法格式我们暂不介绍，因为每本书上均有。看例子：declarevjobvarchar9;v_countnumber:=0;vtotaldate:=sysdate+7;c_taxconstantnumber3,2:=8.25;v_validbooleannotnull:=true;tttvtotal%type;typeemp_record_typeisrecordempnonumbernotnull:=100,enameemp.ename%type,job　emp.job%type;emp_recordemp_record_type;beginselectsysdateintovtotalfromdual;体会有无此句与结果的影响dbms_output.put_linevtotal;end;/主要看TYPERECORD出现的位置。每一个例子都是可以成功执行的。我们也可以利用原有的表结构：DECLAREEMP_RECORDEMP%ROWTYPE；游标操纵数据PLSQL游标提供了一种从数据库提取多行数据，然后对每行数据进行单独处理的方法。一、两种游标：显式游标隐式游标二、显式游标：操纵步骤如下：声明游标、打开游标、从游标中取回数据、关闭游标三、声明游标：DECLARECURSOR_NAMEISSELECTSTATMENT能够控制游标的，唯一参数是INIT.ORA中的OPEN_CURSORS，我原来以为是客户端最多可以打开多少个游标，但有本书上讲这是用于管理游标的内存的数量。DECLARECURSORC_NAMEISSELECTENAMEFROMEMPWHEREDEPTNOINSELECTDEPTNOFROMDEPTWHERECITY_ID=‘BJ’说明游标可以用子查询四、打开游标OPENCURSOR_NAME；这时游标将它的指针指向活动集的开始，指针指向第一条记录的前面是因为它还没有执行FETCH命令。如果试图打开一个已经打开的游标，将出错：ORA06511：PL/SQL：CURSORALREADYOPEN我们可以这样：IFNOTC_NAME%ISOPENTHENOPENC_NAME；ENDIF；五、从游标中取回数据FETCHCURSOR_NAMEINTORECORLIST；关闭游标：CLOSECURSOR_NAME六、实例：DECLAREmynamevarchar222;CURSORC_NAMEISSELECTENAMEFROMEMP;beginIFNOTC_NAME%ISOPENTHENOPENC_NAME;endif;LOOPFETCHc_nameintomyname;dbms_output.put_linemyname;exitwhenc_name%notfound;endloop;closec_name;end;/我们将对以上程序进行变形，形成复杂的光标利用。DECLAREmynamevarchar222;thisdeptnoscott.emp.deptno%type;CURSORC_NAMEISSELECTENAME,deptnoFROMEMPorderbydeptnodesc;beginIFNOTC_NAME%ISOPENTHENOPENC_NAME;endif;LOOPFETCHc_nameintomyname,thisdeptno;dbms_output.put_linemyname||','||thisdeptno||','||to_charc_name%rowcount;exitwhenc_name%notfound;endloop;dbms_output.put_line'theTotalrecordisfetchedis'||to_charc_name%rowcount;closec_name;end;/我们增加变量，进行用了排序，使用了光标属性，大家看结果发生的变化，想想为什么。实例精华!!!：DECLAREmynamevarchar222;iinumber;thisdeptnoscott.emp.deptno%type;CURSORC_NAMEISSELECT*FROMEMPorderbydeptnodesc;emp_recordc_name%rowtype;beginii:=1;foremp_recordinc_nameloopdbms_output.put_lineii;ii:=ii+1;endloop;end;/这里使用了游标FOR循环，在FOR循环的开始，进行、和ENDLOOP，分别隐式进行了游标的打开、FETCH和CLOSE。我们甚至可以不声明游标：FORemp_recordinSELECT*FROMDEPTloop这种技术被称为显式游标的自动化。在上面，我们可以将一个表的所有字段输出,如我们将PUT_LINE的II改为emp_record.ename，就可以输出一个字段内容。这种方式非常简单而且效率较高。为了测试光标属性的重要性，我们做一个以下的过程：createorreplacePROCEDUREchange_salaryv_emp_idINNUMBER,formalparametersv_new_salaryINNUMBERISBEGINbeginPL/SQLblockUPDATEempSETsal=v_new_salaryWHEREempno=v_emp_id;COMMIT;ENDchange_salary;/这样，我们在匿名块中，UPDATEDEPTSETDNAME='MYDEPT'WHERE....;IFSQL%FOUNDTHENCOMMIT;ELSEchange_salary7369,9000;ENDIF;我们看到我们通过流程控制了不同的执行结果，对于过程，我们可以用以下几种方法调用：在SQLPLUS中：CALLchange_salary7369,9000;EXECUTEchange_salary7369,9000;在一个块中，如：beginchange_salary7369,9000;end;/最后一课异常处理本章重点：1、定义PLSQL异常2、列举不同的异常处理方法3、捕获非预期的错误4、描述异常的影响5、定制异常的返回信息一、PLSQL异常处理异常是由ORACLE错误或显式的抛出一个错误产生的。如何处理：用一个处理程序来捕获它；将它传递给CALLINGENVIRONMENT二、异常的类型：1、ORACLESERVER预定义错误2、非ORACLESERVER预定义错误，但也是ORACLESERVER的标准错误3、用户自定义异常三、捕捉异常的要点：PlacetheWHENOTHERSclauseafterallotherexceptionhandlingclauses.YoucanhaveatmostoneWHENOTHERSclause.BeginexceptionhandlingsectionoftheblockwiththekeywordEXCEPTION.Defineseveralexceptionhandlers,eachwiththeirownsetofactions,fortheblock.Whenanexceptionoccurs,PL/SQLwillprocessonlyonehandlerbeforeleavingtheblock.EXCEPTIONWHENexception1ORexception2...THENstatement1;四、常用错误：NO_DATA_FOUNDORA01403TOO_MANY_ROWSORA01422INVALID_CURSORORA01001ZERO_DIVIDEORA01476DUP_VAL_ON_INDEXORA00001五、实例PROCEDUREelim_inventory　　v_product_idINs_product.id%TYPEISv_ids_product.id%TYPE;BEGIN　　SELECTidINTOv_idFROMs_productWHEREid=v_product_id;　　DELETEFROMs_inventory　　WHEREproduct_id=v_product_id;　　COMMIT;　　EXCEPTION　　WHENNO_DATA_FOUNDTHEN　　ROLLBACK;　　TEXT_IO.PUT_LINETO_CHARv_product_id||’isinvalid.’;　　WHENTOO_MANY_ROWSTHEN　　ROLLBACK;　　TEXT_IO.PUT_LINE’DatacorruptioninS_PRODUCT.’;　　WHENOTHERSTHEN　　ROLLBACK;　　TEXT_IO.PUT_LINE’Othererroroccurred.’;ENDelim_inventory;在SCOTT环境中使用要稍加改动六、使用nonpredefinedOracle7ServererrorDECLAREE_PRO　EXCEPTION;PRAGMAEXCEPTION_INITE_PRO,ERROR_NUMBER;BEGIN......EXCEPTIONWHENE_PROTHENDBMS_OUTPUT.PUT_LINE'ASDLKFJKASDJFASJDFLKASDF';......END;七、用户自定义exceptionEXCEPTION;RAISEexception;　　EXCEPTIONWHENE_PROTHENDBMS_OUTPUT.PUT_LINE'ASDLKFJKASDJFASJDFLKASDF';......END;这里，只有用户自定义异常是要显式声明的，其他两个不用。在SUNOS5.8中，进行SVRMGRL>OERRORA01840　可返回信息或查错误代码：HTTP://TECHNET.ORACLE.COM/DOC/SERVER.815/A67785/E1500.HTM说回来，以下两个函数：SQLCODEReturnsthenumericvaluefortheerrorcode.YoucanassignittoaNUMBERvariable.SQLERRMReturnscharacterdatacontainingthemessageassociatedwiththeerrornumber.一般这样，EXCEPTION...WHENOTHERSTHENROLLBACK;v_error_code:=SQLCODE;V_ERROR_MESSAGE:=SQLERRM;INSERTINTO........END;八、调用外围环境SQLPLUSPROCEDUREBUILDERDEVELOPER2000OTHER.........也就是把ERRORNUMBER和MESSAGE输出到SCREEN。九、使用RAISE_APPLICATION_ERROREXCEPTIONWHENNO_DATA_FOUNDTHENRAISE_APPLICATION_ERROR20201,'NOMATCHRECORDYOUWANNA';END;当然，RAISE_APPLICATION_ERROR也是可以放在EXECUTE区的IF...THENRAISE_APPLICATION_ERROR;ENDIF;", "database/Redis.md": "Redis适合做什么缓存Redis字符串、哈希表两种数据结构适合用来储存大量的键值对信息队列使用“列表”数据结构，可以实现普通级和优先级队列的功能。使用有序集合”数据结构，可以实现优先级队列：使用“哈希表”数据结构，可以实现延时队列。去重利用“集合”数据结构，可以实现小批量数据的去重利用“字符串数据结构的位操作，可以实现布隆过滤器，从而实现超大规模的数据去重利用Redis自带的HyperLogLog数据结构，可以实现超大规模数据的去重和计数。积分板Redis的“有序集合”功能可实现积分板功能，还实现自动排序、排名功能。“发布／订阅”Redis带的“发布／订阅”模式可以实现多对多的发布／订阅”功能特点及用途字符串用来存储KeyValue结构数据字符串只应用在小量级的数据记录中。如果数据量超过百万级别，那么使用字符串来保存简单的映射关系将会浪费大量内存。此时需要使用Redis的另一种数据结构Hash。储存相同量级的数据，Hash结构消耗的内存只有字符串结构的1/4，但查询速度却不会比字符串差。如果Redis中有大量Key，那么执行“keys＊”命令会对Redis性能造成短暂影响，甚至导致Redis失去响应。因此，绝对不应该在不清楚当前有多少Key的情况下冒然列出当前所有的Key。列表给10万用户发送祝福短信。10台服务器同时从1台公共的Redis列表左侧读取数据。由于Redis是单线程、单进程的数据库，因此10台服务器即使同时对列表执行“lpop”操作，redis也会自动让它们排队，一个一个地弹出最左侧的数据。列表就像是一根平放的水管，可以从左边往里塞入数据，也可以从右边往里塞入数据；以从左边读取数据，也可以从右边读取数据。lpush,rpush,lrange根据索引查看数据,lpop,rpop在弹出数据的同时，被弹出的这个数据也会被从列表中删除。Set元素不能重复，没有顺序。sadd,scard获取数量,spop,smembers获取所有数据,sismember,srem删除sinter交集,sunion并集,sdiff差集。用途1：根据集合内数据不重复的特性实现去重并记录信息。用途2：利用多个集合计算交集、并集和差集。哈希表（hashtable）哈希表在Key里面还有“字段”的概念，“字段”下面才是“值”。即一个哈希表的Key里面可以设置成百千个值对。使用晗希表不仅可以减少Redis的个数，还能优化储存空间。储存相同的内容，占用的内存比字符串要小很多。hset,hmset,hkeys获取所有字段名,hget,hmget,hgetall,hdel,hexists,hlen发布/订阅方法：publish,pubsub,subscribe,listen有序集合（SortedSet）zset有序集合里面的数据跟集合一样，也是不能复的，但是每一个元素又关联了一个分数Score，根据这个分数可以对元素进行排序。分数可以重复。实现排行榜功能zadd,zincrby修改评分,zrangebyscore基于分数从小到大排序,zrevrangebyscore从大到小排序,zrange基于位置排序,zrevrange,zrank查询值排名,zrevrank,zscore,zcard查询有序集合里面一共有多少个值,zcount查询在某个评分范围内的值有少安全管理Redis默认没有密码，并且只能本机访问。使用rediscli连上以后可以执行任意命令。如果要开放外网连接，则需要设置密码，同时禁用危险命令或者对危险命令进行改名。", "database/Redis入门指南_第2版.md": "第6章脚本6.1概览使用脚本的好处1、减少网络开销2、原子操作3、复用脚本类似SQL数据库的存储过程第7章持久化7.1RDB方式RDB方式的持久化是通过快照（Snapshot）完成的，当符合一定条件是Redis会将内存中的所有数据生成一份副本并存储在硬盘上，一个过程称之为“快照”。触发快照的情形：1、根据配置规则进行自动快照。2、用户执行SAVE或BGSAVE命令3、执行FLUSHALL命令4、执行复制（replication）时。7.1.5快照原理1、fork:Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；2、写文件:父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；3、替换:当子进程写入完所有数据后，会用该临时文件替换旧的RDB文件（dump.rdb），至此一次快照操作完成。新的RDB文件存储的是执行fork一刻的内存数据。任何时候RDB文件都是完整的。写时复制策略也保证了在fork的时刻虽然看上去生成了两份内存副本，但实际上内存的占用量并不会增加一倍。通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。希望将损失降到最小，则可以使用AOF方式进行持久化。7.2AOF方式AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低Redis的性能。第8章集群8.1复制Redis提供了复制replication功能，自动将更新的数据从主库同步到其他从库。一主多从原理：从库启动后，向主库发送SYNC命令后，主库立即执行RDB快照，并缓存此期间接收到的命令；快照完成后，主库向从库发送快照文件和缓存命令；从库载入快照文件并执行缓存命令。完成复制初始化后，主库不断将写命令同步到从库。主库之从库可以为下一级从库的主库。即可以构建多级复制的结构。从库持久化另一个相对耗时的操作是持久化，为了提高性能，可以通过复制功能建立一个或若干个从数据库，并在从数据库中启用持久化，同时在主数据库禁用持久化。当从数据库崩溃重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。当开启复制且主数据库关闭持久化功能时，一定不要使用Supervisor以及类似的进程管理工具令主数据库崩溃后自动重启。哨兵能解决手工维护从库或主库的重启以及数据恢复的麻烦。无硬盘复制开启无硬盘复制选项后，Redis在与从库进行复制初始化时将不会将快照内容存储到硬盘上，而是直接通过网络发送给从库，避免了硬盘的性能瓶颈。增量复制8.2哨兵哨兵包括两个功能：1、监控主库和从库运行状态。2、出现故障时，自动将从库转换为主库。哨兵典型架构多哨兵架构8.3集群集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。另外集群支持几乎所有的单机实例支持的命令，对于涉及多键的命令如MGET,如果每个键都位于同一个节点中，则可以正常支持，否则会提示错误。除此之外集群还有一个限制是只能使用默认的0号数据库，如果执行SELECT切换数据库则会提示错误。哨兵与集群是两个独立的功能，但从特性来看哨兵可以视为集群的子集，当不需要数据分片或者已经在客户端进行分片的场景下哨兵就足够使用了，但如果需要进行水平扩容，则集群是一个非常好的选择。第9章管理9.2通信协议Redis支持两种通信协议，一种是二进制安全的统一请求协议unifiedrequestprotocol,另一种是比较直观的便于在telnet程序中输入的简单协议。这两种协议只是命令的格式有区别，命令返回值的格式是一样的。Redis的AOF文件和主从复制时，主数库向从库发送的内容都使用了统一请求协议。", "database/Redis知识.md": "Redis作为缓存当用jdk默认的序列化方案时，对类的版本要求严格一直，否则抛出ClassNotFoundException。比如：几个共用redis缓存的应用，它们共用的jar包版本有差异（serialNo），就会导致整个系统失败。github.com/alexxiyang/shiroredis/issues/78class一旦上线，就不能改变包名或位置，否则无法序列号。www.cnblogs.com/technologykai/p/10097167.htmlRedis应用场景Redis比较适合的一些应用场景：1.取最新N个数据的操作比如典型的取你网站的最新文章，通过下面方式，我们可以将最新的5000条评论的ID放在Redis的List集合中，并将超出集合部分从数据库获取使用LPUSHlatest.comments<ID>命令，向list集合中插入数据插入完成后再用LTRIMlatest.comments05000命令使其永远只保存最近5000个ID然后我们在客户端获取某一页评论时可以用下面的逻辑（伪代码）```javascriptFUNCTIONget_latest_commentsstart,num_items:id_list=redis.lrange\"latest.comments\",start,start+num_items1IFid_list.length<num_itemsid_list=SQL_DB\"SELECT...ORDERBYtimeLIMIT...\"ENDRETURNid_listEND```如果你还有不同的筛选维度，比如某个分类的最新N条，那么你可以再建一个按此分类的List，只存ID的话，Redis是非常高效的。2.排行榜应用，取TOPN操作这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sortedset出马了，将你要排序的值设置成sortedset的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。3.需要精准设定过期时间的应用比如你可以把上面说到的sortedset的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。4.计数器应用Redis的命令都是原子性的，你可以轻松地利用INCR，DECR命令来构建计数器系统。5.Uniq操作，获取某段时间所有数据排重值这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。6.实时系统，反垃圾系统通过上面说到的set功能，你可以知道一个终端用户是否进行了某个操作，可以找到其操作的集合并进行分析统计对比等。没有做不到，只有想不到。7.Pub/Sub构建实时消息系统Redis的Pub/Sub系统可以构建实时的消息系统，比如很多用Pub/Sub构建的实时聊天系统的例子。8.构建队列系统使用list可以构建队列系统，使用sortedset甚至可以构建有优先级的队列系统。9.缓存这个不必说了，性能优于Memcached，数据结构更多样化。转自:blog.nosqlfan.com/html/2235.html?ref=rediszt", "database/《高性能MySQL》（1）.md": "第一章MySQL架构与历史1.1MySQL的逻辑架构!MySQL逻辑架构_v_images/20210625103345187_236.png1.3事务ACID原子性（atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。一致性（consistency）：数据库总是从一个一致性的状态转换到另外一个一致性的状态。隔离性（isolation）：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。1.3.1隔离级别READUNCOMMITTED（未提交读）：事务可以读取未提交的数据，这也被称为脏读（DirtyRead）。在实际应用中一般很少使用。READCOMMITTED（提交读）：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatableread）REPEATABLEREAD（可重复读）：该级别保证了在同一个事务中多次读取同样记录的结果是一致的。它解决了脏读的问题，无法解决另外一个幻读（PhantomRead）的问题。幻读：指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（PhantomRow）。SERIALIZABLE（可串行化）：它通过强制事务串行执行，避免了前面说的幻读的问题。SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。1.3.2死锁当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。1.3.3事务日志使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，顺序I/O，而不是随机I/O，快得多。预写式日志（WriteAheadLogging）：事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。事务日志恢复数据。1.4多版本并发控制InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统（事务）版本号。1.5MySQL的存储引擎MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。1.5.1InnoDB存储引擎", "database/索引.md": "索引my.oschina.net/u/4407645/blog/3469303位图索引（BitMap）适用于值可枚举的字段哈希索引适用于等值检索，通过一次哈希计算即可定位数据的位置。与JAVA中HashMap的实现类似，是用冲突表的方式解决哈希冲突的。BTREE索引BTREE索引是RDBMS最常用的索引BTREE:有序平衡N叉树,每个节点有N个键值和N+1个指针,指向N+1个子节点倒排索引正向索引：给定文档标识，可以获取当前文档的（关键词、词频以及该词在文档中出现的位置信息）反向索引：给定了关键词标识，可以获取关键词（所在的所有文档列表，同时包含词频、位置等信息）", "database/面试之数据库和SQL部分.md": "数据库方面：2.事务是什么？事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：原子性事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。一致性事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如B树索引或双向链表）都必须是正确的。隔离性由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。持久性事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。3.游标的作用？如何知道游标已经到了最后？游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。4.触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别。事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。题目1存在表table（FID，FCLASS，FSSCORE），三字段分别代表姓名、班级、成绩。用最高效、最简单的SQL语句列出人数大于30的各班最高成绩的列表，显示班级、成绩两个字段。参考答案1：selecta.FCLASS,maxa.FSSCOREfromtablea,selectFCLASS,countFIDfromtablehavingcountFID>30groupbyFCLASSbwherea.FCLASS=b.FCLASSgroupbya.FCLASS参考答案2：SelectFCLASS，MaxFSSCOREFromTableGroupByFCLASSHavingCountFID>30题目2studentnameclassnamegrademikeenglish65mikemath75Jerryenglish80Jerrymath68Lidaenglish88Lidachinese77Lidamath90求出各科成绩都大于75分的学生。即得到如下结果studentnameclassnamegradeLidaenglish88Lidachinese77Lidamath90参考答案：select*fromawherenotexistsselect1fromwherestudentname=a.studentnameandgrade<75题目3已知一个表的结构为：姓名科目成绩张三语文20张三数学30张三英语50李四语文70李四数学60李四英语90怎样通过select语句把他变成以下结构：姓名语文数学英语张三203050李四706090参考答案1：selectA.姓名,A.科目as语文,B.科目as数学,C.科目as英语fromstudentA,studentB,studentCwhereA.姓名=B.姓名andB.姓名=C.姓名andA.科目='语文'andB.科目='数学'andC.科目='英语'参考答案2：selectdistinctA._nameas'姓名',selectchengjifromAcwherekemu='语文'andc._name=A._nameas'语文',selectchengjifromAdwherekemu='数学'andd._name=A._nameas'数学',selectchengjifromAewherekemu='英语'ande._name=A._nameas'英语'fromA参考答案3：declare@sqlvarchar4000set@sql='SELECT姓名'select@sql=@sql+',sumcase科目when'''+科目+'''then成绩end'+科目+''fromselectdistinct科目from表名字as学科select@sql=@sql+'from表名字groupby姓名'exec@sql题目4假设只有一个table，名为pages，有四个字段，id,url,title,body。里面储存了很多网页，网页的url地址，title和网页的内容，然后你用一个sql查询将url匹配的排在最前，title匹配的其次，body匹配最后，没有任何字段匹配的，不返回。就是上面这道面试题，让我想了一个下午，在网上找资料，最后用下面方法实现SELECT*FROMpagewhereurllike'%baidu%'ortitlelike'%baidu%'orlike''ORDERBYCHARINDEX'baidu',urlDESC,CHARINDEX'baidu',titleDESC,CHARINDEX'baidu',bodyDESC但我感觉这种方法并不是最简单的，后来把这个方法发给面试的人，他给我了一种更简单方法，只要用基本的Sql语句就可以实现。代码如下selecta.id,a.markfromselectpage.id,100asmarkfrompagewherepage.urllike'%baidu%'unionselectpage.id,50asmarkfrompagewherepage.titlelike'%baidu%'unionselectpage.id,10asmarkfrompagewherepage.bodylike'%baidu%'asaorderbymarkdesc用union实现联合查询，在每个查询语句中定义一个临时变量mark并给mark赋值，在最后的输出时采用mark来排序，这样实现真的好简单。其实这都考验我们对Sql的编成思想。1：找出公司里收入最高的前三名员工：SQL>selectrownum,last_name,salary2fromselectlast_name,salary3froms_emp4orderbysalarydesc5whererownum<=3;ROWNUMLAST_NAMESALARY1Velasquez47502Ropeburn29453Nguyen2897.5注意：请大家分析一下一下语句为什么不对：SQL>selectrownum,last_name,salary2froms_emp3whererownum<=34orderbysalarydesc;ROWNUMLAST_NAMESALARY1Velasquez47503Nagayama26602Ngao20002：找出表中的某一行或某几行的数据：（1）：找出表中第三行数据：用以下方法是不行的，因为rownum后面至可以用<或<=号,不可以用=,>号和其它的比较符号。SQL>select*froms_emp2whererownum=3;norowsselectedSQL>select*froms_emp2whererownumbetween3and5;norowsselected正确的方法如下：SQL>l1selectlast_name,salary2fromselectrownuma,b.*3froms_empb4*wherea=3SQL>/LAST_NAMESALARYNagayama2660（2）：找出第三行到第五行之间的数据：SQL>l1selectlast_name,salary2fromselectrownuma,b.*3froms_empb4*whereabetween3and5SQL>/LAST_NAMESALARYNagayama2660QuickToSee2755Ropeburn29453：找出那些工资高于他们所在部门的平均工资的员工。（1）：第一种方法：SQL>selectlast_name,dept_id,salary2froms_empa3wheresalary>selectavgsalary4froms_emp5wheredept_id=a.dept_id;LAST_NAMEDEPT_IDSALARYVelasquez504750Urguhart412280Menchu422375Biri432090Catchpole442470Havel452483.3Nguyen342897.5Maduro412660Nozaki422280Schwartz45209010rowsselected.（2）：第二种方法：SQL>l1selecta.last_name,a.salary,a.dept_id,b.avgsal2froms_empa,selectdept_id,avgsalaryavgsal3froms_emp4groupbydept_idb5wherea.dept_id=b.dept_id6*anda.salary>b.avgsalSQL>/LAST_NAMESALARYDEPT_IDAVGSALVelasquez4750503847.5Urguhart2280412181.5Menchu2375422055.16667Biri2090431710Catchpole2470441995Havel2483.3452069.1Nguyen2897.5342204Maduro2660412181.5Nozaki2280422055.16667Schwartz2090452069.110rowsselected.4：找出那些工资高于他们所在部门的manager的工资的员工。SQL>l1selectid,last_name,salary,manager_id2froms_empa3wheresalary>selectsalary4froms_emp5*whereid=a.manager_idSQL>/IDLAST_NAMESALARYMANAGER_ID6Urguhart228027Menchu237528Biri209029Catchpole2470210Havel2483.3212Giljum2831313Sedeghi2878.5314Nguyen2897.5315Dumas2755316Maduro2660610rowsselected.题目1：取得最新数据分布在各地的各个监测站会不定期地取数据并存入数据库。现在开始统计：如果监测站当天八点有数据，就取当天八点钟时间段的最新数据，否则取该站的最新数据数据源：createtablestinfostcdvarchar20primarykeystcd,sdate,sdatedatetime,datadecimal5,2insertintostinfovalues'0003','0610109:40',1.5insertintostinfovalues'0002','0610118:04',0.8insertintostinfovalues'0001','0610127:10',1.8insertintostinfovalues'0002','0610127:00',1.7insertintostinfovalues'0001','0610128:02',1.4insertintostinfovalues'0001','0610128:11',1.5insertintostinfovalues'0002','0610128:18',1.6insertintostinfovalues'0002','0610128:30',1.8insertintostinfovalues'0001','0610129:40',1.3insertintostinfovalues'0002','0610129:41',1.5insertintostinfovalues'0003','0610129:45',1.4要求得到结果：假设今天是20061012stcdsdatedata00012006101208:11:00.0001.500022006101208:30:00.0001.800032006101209:45:00.0001.4实现方法：selectstinfo.*fromstinforightjoinselectstcd,maxsdatesdatefromstinfogroupbystcdhavingstcdnotinselectstcdfromstinfowheredatediffday,sdate,getdate=0anddateparthour,sdate=8unionselectstcd,maxsdatesdatefromstinfowheredatediffday,sdate,getdate=0anddateparthour,sdate=8groupbystcdastabonstinfo.stcd=tab.stcdandstinfo.sdate=tab.sdate题目2：按数据范围统计每个监测站的数据个数数据源：题目1的stinfo表及数据要求得到结果：STCD01.01.01.41.41.8>1.80001NULL12100021NULL310003NULLNULL2NULL实现方法：selecttab.stcd,tab1.01.0,tab2.1.01.4,tab3.1.41.8,tab4.>=1.8fromselectstcdfromstinfogroupbystcdastabfullouterjoinselectstcd,countdata'01.0'fromstinfowheredata<1.0groupbystcdastab1ontab.stcd=tab1.stcdfullouterjoinselectstcd,countdata'1.01.4'fromstinfowheredata>=1.0anddata<1.4groupbystcdastab2ontab.stcd=tab2.stcdfullouterjoinselectstcd,countdata'1.41.8'fromstinfowheredata>=1.4anddata<1.8groupbystcdastab3ontab.stcd=tab3.stcdfullouterjoinselectstcd,countdata'>=1.8'fromstinfowheredata>=1.8groupbystcdastab4ontab.stcd=tab4.stcd题目3：行列数据交换提示动态SQL交叉表数据源：createtablesitemvalueSTCDintprimarykeystcd,xmmc,XMMCvarchar20,SValuedecimal4,2insertintositemvaluevalues'0001','ph',7.0insertintositemvaluevalues'0001','cod',0.2insertintositemvaluevalues'0001','do',0.3insertintositemvaluevalues'0001','wt',1.1insertintositemvaluevalues'0002','ph',7.0insertintositemvaluevalues'0002','do',0.2insertintositemvaluevalues'0002','wt',0.2insertintositemvaluevalues'0002','cod',1.5要求得到结果：STCDPHCODDOWT00017.00.20.31.100027.01.50.20.2实现方法：selectstcd,sumcasexmmcwhen'ph'thensvalueelse0endasph,sumcasexmmcwhen'cod'thensvalueelse0endascod,sumcasexmmcwhen'do'thensvalueelse0endasdo,sumcasexmmcwhen'wt'thensvalueelse0endaswtfromsitemvaluegroupbystcd题目4：拆分一个连续字符串提示用存储过程循环拆分declare@sasvarchar100set@str='ph,p,cod,do,cu'要求得到结果：phpcoddo实现方法：createprocedureparse@strvarchar200asdeclare@startasintdeclare@endasintset@start=0set@end=charindex',',@strwhile@end!=0beginprintsubstring@str,@start,@endset@str=substring@str,@end+1,len@strset@end=charindex',',@strendprint@strreturnexecparse'ph,p,cod,do'题目5：用一个函数计算监测站的所有监测项目用函数数据源：createtablesvalueSTCDvarchar20primarykeystcd,sdate,SDatedateTime,SItemvarchar20insertintosvaluevalues'0001','061010','ph'insertintosvaluevalues'0001','061012','cod'insertintosvaluevalues'0002','061015','ph'insertintosvaluevalues'0002','061016','cu'insertintosvaluevalues'0002','061017','p'insertintosvaluevalues'0003','061019','cu'要求得到结果：STCDSItem0001ph,cod0002ph,cu,p0003cu实现方法：CREATEfunctionFun_SUM@chvNameVarchar200returnsvarchar8000asbegindeclare@rvarchar4000set@r=''select@r=@r+','+SItemfromsvaluewhereSTCD=@chvNamereturnstuff@r,1,1,''endSELECTstcd,dbo.Fun_SUMSTCDassItemFROMsvalueGROUPBYSTCD", "misc/01-HowToStudy.md": "1.学习方法及工具1.1.两遍笔记法1.1.1.视频学习视频只听一遍，没听懂才可以看多遍。（看视频太花时间）边听边切图做Word笔记。看完后，整理Word笔记，写成Markdown笔记。定期复习很重要。1.1.2.书籍、博客学习纸质笔记本只能做大纲式的笔记，千万不要写细节。大纲式笔记只记录三种内容：1、各级标题2、关键字（不能记录大段文字）3、疑问点大纲式笔记便于回忆复习。大纲式纸质笔记需要整理、完善成Markdown笔记。1.1.3.Markdown笔记心得图片标记：要有一个好的图片编辑工具，并非常熟练使用。小PDF文件：做成链接，便于Chrome浏览1.2.Markdown编辑工具1.2.1.Markdown编辑器选择好的MD编辑器的标准：1.可以贴图，且图片保存在文件的同级目录，相对地址加载2.支持大纲，且有标题能多级编号3.可以即时预览1.2.2.VSCode常用markdown插件MarkdownAllinOnemarkdownindexmarkdownaddindexPasteImage1.文件>首选项>设置>填入paste，设置Path值为${currentFileDir}/img，（img目录会自动创建）2.屏幕截图之后，使用ctrl+alt+v粘贴成markdown图片MarkdownPreviewEnhanced。各种功能包括：文件导入文件导出（HTML，PDF，Word，Ebook，RFT）定制扩展（修改默认CSS）princexml导出PDF需要blog.csdn.net/Max_xws/article/details/85319679", "misc/IPFS.md": "TOCFilecoin的终极指南：深挖Filecoin白皮书zhuanlan.zhihu.com/p/87632601Filecoin网络如何运作？在Filecoin中有3组用户：客户、存储矿工以及检索矿工。什么是客户、存储矿工以及检索矿工？什么是碎片？What's扇区？What's分配表？什么是订单什么是订单簿？什么是保证？存储市场的买盘、卖盘如何运作的？Manage.PledgeSectorPut.AddOrdersPut.MatchOrdersPut.ReceivePieceManage.AssignOrdersManage.SealSectorManage.ProveSectorManage.RepairOrders检索市场的买盘、卖盘如何运作的？Get.AddOrdersGet.MatchOrdersPut.SendPiece下图显示发生在网络上的所有活动!发生在网络上的所有活动_v_images/20200709161327521_9951.png对Filecoin协议的深入研究什么是DSN?DSN安全操作协调协议有哪些？DSN对两种错误进行容错：管理容错、存储容错。什么是管理容错？什么是存储容错？以往的共识算法有哪些弊端？Filecoin的共识算法是什么？什么是PoST（ProofofSpacetime）？其他一些问题Filecoin协议改进的可能性Filecoin:矿工是怎么赚取FIL的Filecoin系统的参与者有哪些？!Filecoin体系里面价值和代币是如何转移的_v_images/20200709165423472_14025.pngFilecoin的挖矿与BTC有什么不同？存储矿工收益来自哪3个方面？检索矿工收益来自哪个方面？!供需曲线_v_images/20200709170111900_23514.png", "misc/UI框架.md": "EasyUIElementGithub:12Kstar一套为开发者、设计师和产品经理准备的基于Vue2.0的组件库，提供了配套设计资源，帮助你的网站快速成型。由饿了么公司前端团队开源。element.eleme.io//zhCNgithub.com/ElemeFE/elementlayuiGithub:4.5Kstar由职业前端倾情打造，面向所有层次的前后端程序猿，业界最容易使用的前端UI解决方案www.layui.com/github.com/sentsin/layui/和easyui相似MuseUIGithub:2.5Kstar基于Vue2.0和MaterialDesign的UI组件库www.museui.org/github.com/museui/museui很时尚QMUIWebGithub:0.8Kstar官网：qmuiteam.com/webGithub:github.com/QMUI/qmui_webQMUIWeb是一个专注WebUI开发，帮助开发者快速实现特定的一整套设计的框架。框架主要由一个强大的Sass方法合集与内置的工作流构成。通过QMUIWeb，开发者可以很轻松地提高WebUI开发的效率，同时保持了项目的高可维护性与稳健。如果你需要方便地控制项目的整体样式，或者需要应对频繁的界面变动，那么QMUIWeb框架将会是你最好的解决方案。bjuiBJUI客户端框架BestjQueryUI，是基于Bootstrap样式及jQuery库实现的AjaxRIA开源框架。www.bjui.com/VUXGithub:7.5KstarVux（读音v'ju:z，同views）是基于WeUI和Vue2.x开发的移动端UI组件库，主要服务于微信页面。基于webpack+vueloader+vux可以快速开发移动端页面，配合vuxloader方便你在WeUI的基础上定制需要的样式。github.com/airyland/vux其它基于Bootstrap的UIFramework1.Bootflatbootflat.github.io/2.Bootswatchbootswatch.com3.FlatUIgithub.com/designmodo/FlatUI收费4.KendoUIwww.telerik.com/kendoui,收费，专业，部分Web免费：Githubkendouicoregithub.com/telerik/kendouicore5.jQueryUIBootstrapgithub.com/jqueryuibootstrap/jqueryuibootstrap,断更？6.BootMetrogithub.com/aozora/bootmetro，win8风格，断更？2014年最受欢迎WEB前端UI框架参考：www.58img.com/framework/13901.Bootstrapgetbootstrap.com/,Bootstrap中文网www.bootcss.com/2.Foundationfoundation.zurb.com/3.SemanticUIsemanticui.com/4.Purepurecss.io/React资料React入门实例教程www.ruanyifeng.com/blog/2015/03/react.html也许，DOM不是答案www.ruanyifeng.com/blog/2015/02/futureofdom.html我是这样看待React的reactchina.org/t/woshizheyangkandaireactde/28WebComponents组件化ReactBootstrapreactbootstrap.github.io/AGuidetoWebComponentscsstricks.com/modularfuturewebcomponents/2015前端组件化框架之路github.com/xufei/blog/issues/192015前端框架何去何从www.cnblogs.com/sskyy/p/4264371.html", "misc/Vue学习记录.md": "toc开发环境CentOS7安装node参考：www.jianshu.com/p/d4a78b27fe83下载`wgetnodejs.org/dist/latestv13.x/nodev13.14.0linuxx64.tar.xz`解压```shellxzdnodev13.14.0linuxx64.tar.xz得到一个包nodev13.14.0linuxx64.tartarxvfnodev13.14.0linuxx64.tar得到一个目录nodev13.14.0linuxx64```做软链lns/opt/devel/node/bin/node/usr/bin/nodelns/opt/devel/node/bin/npm/usr/bin/npmlns/opt/devel/node/bin/npx/usr/bin/npxnpm使用加速npm```shellnpmconfigsetregistryregistry.npm.taobao.orgglobalnpmconfigsetdisturlnpm.taobao.org/distglobal```下载nodev10.23安装升级npm：`npminstallnpmg`安装cnpm：`npminstallgcnpmregistry=registry.npm.taobao.org`安装VS编译工具：`npmigwindowsbuildtools`i表示installg表示global全局安装nodegyp：`npminstallgnodegyp`安装nodegypwww.cnblogs.com/wangyuxue/p/11218113.htmlVSCode开发环境集成Cmder终端```\"terminal.integrated.shell.windows\":\"cmd.exe\",\"terminal.integrated.shellArgs.windows\":\"/kD:\\\\Dev\\\\cmder\\\\vendor\\\\init.bat\"```此模式下不支持TS自动编译，不建议使用。TypeScript安装`npminstallgtypescript`全局安装`tscv`查看安装版本TS自动编译`tscinit`生成`tsconfig.json`文件修改`tsconfig.json`文件中的`outDir`和`rootDir`设置编译监控：按`Ctrl+Shift+B`，选择`tscwatch`是自动监听，下次保存文件就自动编译。`tscbuild`是编译一次。pm2PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。安装：`npminstallgpm2`express应用来举例。通过`npmstart`启动应用，其实就是调用`node./bin/www``pm2start./bin/wwwwatch`这里用了watch参数，意味着当你的express应用代码发生变化时，pm2会帮你重启服务，多贴心。PM2实用入门指南www.cnblogs.com/chyingp/p/pm2documentation.htmlVue知识ref、reactive、toRef、toRefs的区别vue3reactive函数www.jianshu.com/p/ba1169fa2c97reactive的用法与ref的用法相似，也是将数据变成响应式数据，当数据发生变化时UI也会自动更新。不同的是ref用于基本数据类型，而reactive是用于复杂数据类型，比如对象和数组。vue3toRef函数和toRefs函数www.jianshu.com/p/0c6ad50a9055ref本质是拷贝，修改响应式数据不会影响原始数据；toRef的本质是引用关系，修改响应式数据会影响原始数据。ref数据发生改变，界面会自动更新；toRef当数据发生改变是，界面不会自动更新。toRef传参与ref不同；toRef接收两个参数，第一个参数是哪个对象，第二个参数是对象的哪个属性。toRefs接收一个对象作为参数，它会遍历对象身上的所有属性，然后挨个调用toRef执行。nobinlinkscloud.tencent.com/developer/article/1440562zhuanlan.zhihu.com/p/36223413`npminstallnobinlinks````npmERR!nospcENOTSUP:operationnotsupportedonsocket,symlink'../acorn/bin/acorn'>'/home/baoguoxiao/windows/food/node_modules/.bin/acorn'npmERR!nospcThisismostlikelynotaproblemwithnpmitselfnpmERR!nospcandisrelatedtoinsufficientspaceonyoursystem.```webpackcommandnotfound的解决方法webpackcommandnotfound的解决方法blog.csdn.net/qq_38111015/article/details/79013475```shellnpminstallwebpackgnpminstallDwebpackclinobinlinks```通过ps、grep和kill批量杀死进程`psaux|grepqemu|awk'{print$2}'|xargskill9`npmrundev错误```jsscript{\"dev\":\"exportNODE_ENV=development;webpackwatchconfigwebpack.config.jsmodedevelopment&./bin/www\",}```要成功运行`npmrundev`，需要安装webpack,webpackcli,nodegyp,nodegypbuild；并链接到/usr/local/bin/目录下。```shellnpminstallgwebpacknpminstallgwebpackcli用来编译多语言支持npminstallgnodegypnpminstallgnodegypbuildsudolns/opt/node10/bin/webpack*/usr/local/bin/sudolns/opt/node10/bin/nodegyp*/usr/local/bin/```express`morgan`是express默认的日志中间件，也可以脱离express，作为node.js的日志组件单独使用。www.cnblogs.com/chyingp/p/nodelearningguideexpressmorgan.html```javascript//使用app.uselogger'dev'可以将请求信息打印在控制台app.uselogger\"dev\";//morgan支持stream配置项，可以通过它来实现将日志落地的效果//日志写入文件varaccessLogStream=fs.createWriteStreampath.join__dirname,\"access.log\",{flags:\"a\",};app.usemorgan\"short\",{stream:accessLogStream};````bodyparser`作用是对post请求的请求体进行解析。www.cnblogs.com/chyingp/p/nodejslearningexpressbodyparser.html```jsapp.usebodyParser.json;app.usebodyParser.urlencoded{extended:false};````bodyparser`实现的要点如下：处理不同类型的请求体：比如text、json、urlencoded等，对应的报文主体的格式\b不同。处理不同的编码：比如utf8、gbk等。处理不同的压缩类型：比如gzip、deflare等。其他边界、异常的处理。`cookieparser`是Express的中间件，用来实现cookie的解析www.cnblogs.com/chyingp/p/expresscookieparserdeepin.html```jsvarexpress=require\"express\";varcookieParser=require\"cookieparser\";varapp=express;app.usecookieParser;app.usefunctionreq,res,next{console.logreq.cookies.nick;//第二次访问，输出chyingpnext;};app.usefunctionreq,res,next{res.cookie\"nick\",\"chyingp\";res.end\"ok\";};app.listen3000;```webpack版本>v4，需要安装`webpackcli`。一般和自定义的`webpack.config.js`文件一起使用。例如，将`src/index.js`及其引用文件打包到`dist/bundle.js`文件中。```jsconstpath=require\"path\";module.exports={entry:\"./src/index.js\",output:{path:path.resolve__dirname,\"dist\",filename:\"bundle.js\",},};```nodemonnodemon用来监视node.js应用程序中的任何更改并自动重启服务,非常适合用在开发环境中。nodemon不需要对代码或开发方式进行任何更改。nodemon只是简单的包装你的node应用程序，并监控任何已经改变的文件。nodemon只是node的替换包，只是在运行脚本时将其替换命令行上的node。npmERR!codeELIFECYCLE```jsnpmcachecleanforcedeletenode_modulesfolderdeletepackagelock.jsonfilenpminstall```安装vue支持```shnpminstallvuecligcrossenv是用来接近linux、windows环境变量设置不一致的问题。crossenvNODE_ENV=productionwebpackconfigwebpack.config.jsmodeproductioncrossenvNODE_ENV=production在linux、windows都能认识npminstallgcrossenv```解决npm安装速度慢的方法```shonfigsetregistryregistry.npm.taobao.orgnpmconfigsetsass_binary_sitenpm.taobao.org/mirrors/nodesassnpmconfigsetphantomjs_cdnurlnpm.taobao.org/mirrors/phantomjsnpmconfigsetelectron_mirrornpm.taobao.org/mirrors/electronnpmconfigsetsqlite3_binary_host_mirrornpm.taobao.org/mirrors/sqlite3npmconfigsetprofiler_binary_host_mirrornpm.taobao.org/mirrors/nodeinspectornpmconfigsetchromedriver_cdnurlnpm.taobao.org/mirrors/chromedriver```make提示：g++命令未找到：`yuminstallgccc++`styleloader与vuestyleloader区别`vuestyleloader`跟`styleloader`基本用法跟功能是一样的，都是往dom里面插入一个style标签去让样式生效的，但是`vuestyleloader`支持vue中的ssr（服务端渲染），所以如果需要支持服务端渲染的vue项目，就需要用到`vuestyleloader`了，如果一般的vue项目的话，推荐使用`styleloader`，毕竟`styleloader`支持的功能还是丰富些，比如可以懒注入、可以指定位置插入标签等等。vueresourcevueresource是Vue.js的一款插件，它可以通过XMLHttpRequest或JSONP发起请求并处理响应。也就是说，$.ajax能做的事情，vueresource插件一样也能做到，而且vueresource的API更为简洁。另外，vueresource还提供了非常有用的inteceptor功能，使用inteceptor可以在请求前和请求后附加一些行为，比如使用inteceptor在ajax请求时显示loading界面。get请求```jsvarparams={params:{id:id}};this.$http.geturl,params.thenfunctionres{//响应成功回调vardata=res.body;//数据在res.body里面},functionres{//响应错误回调};```post请求```js//启用{emulateJSON:true}选项后，请求会以application/xwwwformurlencoded作为contenttype,像HTML表单一样。varparams={params:{id:id}};this.$http.posturl,params,{emulateJSON:true}.thenfunctionres{//响应成功回调vardata=res.body;//数据在res.body里面},functionres{//响应错误回调};```JSONP请求```jsvarJSONparams={params:{id:id}jsonp:'callback'//设置回调函数的参数的一个名字，默认是话是callback,}this.$http.jsonpurl,JSONparams.thenres=>{console.logres;},err=>{console.logerr;}```", "misc/wankoko.md": "tocspringboot连接mysql异常SSLHandshakeException:Noappropriateprotocolprotocolisdisabledorciphersuitesareinappropriatestackoverflow.com/questions/38205947/sslhandshakeexceptionnoappropriateprotocol解决办法修改文件`C:\\ProgramFiles\\Java\\jdk1.8.0_291\\jre\\lib\\security\\java.security`，找到```jdk.tls.disabledAlgorithms=SSLv3,TLSv1,TLSv1.1,RC4,DES,MD5withRSA,\\DHkeySize<1024,ECkeySize<224,3DES_EDE_CBC,anon,NULL,\\includejdk.disabled.namedCurves```去掉`TLSv1,TLSv1.1`这两项即可。WARN:EstablishingSSLconnectionwithoutserver'sidentityverificationisnotrecommended.AccordingtoMySQL5.5.45+修改`jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&characterEncoding=utf8&useSSL=false`，加上`useSSL=false`即可。MavenMaven的聚合（多模块）和Parent继承cloud.tencent.com/developer/article/1452768虽然聚合通常伴随着父POM的继承关系，但是这两者不是必须同时存在的，从上面两者的介绍可以看出来，这两者的都有不同的作用，他们的作用不依赖于另一个的配置。父POM是为了抽取统一的配置信息和依赖版本控制，方便子POM直接引用，简化子POM的配置。聚合（多模块）则是为了方便一组项目进行统一的操作而作为一个大的整体，所以要真正根据这两者不同的作用来使用，不必为了聚合而继承同一个父POM，也不比为了继承父POM而设计成多模块。Maven全局排除excludeglobally方式一：Icreatedanemptyjarandcreatedthisdependency:```xml<dependency><groupId>commonslogging</groupId><artifactId>commonslogging</artifactId><scope>system</scope><systemPath>${basedir}/src/lib/empty.jar</systemPath><version>0</version></dependency>```方式二：使用`mavenenforcerplugin`插件commonslang3中常用方法blog.csdn.net/qq_35418518/article/details/89519979blog.csdn.net/qq_37334135/article/details/95480230", "misc/在HTML中引入其它页面.md": "IFrameelement```<iframesrc=\"your.html\"width=\"x\"height=\"y\"><p>Fallbacktext</p></iframe>```Objectelement<objecttype=\"text/html\"data=\"your.html\"></object><embedtype=\"text/html\"src=\"header.html\">Javascriptinsertionexternal.js```jsvarelement='<div><ul><liclass=\"current\"><ahref=\".html\"></a></li><li><ahref=\".html\"></a></li></ul></div>';```container.html```html<scripttype=\"text/javascript\"src=\"external.js\"></script><script>document.getElementById'containingelement'.innerHTMLelement;</script>```AJAX```jsjQuerydocument.readyfunction${$'containingelement'.load'your.html';};```jquery方式1```js$function{$\"dataload\".eachfunction{$this.load$this.data\"load\",function{};};}<navdataload=\"sidepanel.html\"></nav><navdataload=\"footer.html\"></nav>```创建一个文件header.html之类的```html<!Meta><metahttpequiv=\"ContentType\"content=\"text/html;charset=ISO88591\"><!JS><scripttype=\"text/javascript\"src=\"js/lib/jquery1.11.1.min.js\"></script><scripttype=\"text/javascript\"src=\"js/lib/angular.min.js\"></script><scripttype=\"text/javascript\"src=\"js/lib/angularresource.min.js\"></script><scripttype=\"text/javascript\"src=\"js/lib/angularroute.min.js\"></script><linkrel=\"stylesheet\"href=\"css/bootstrap.min.css\"><title>Yourapplication</title>```现在在HTML页面中包含header.html，例如：```html<head><scripttype=\"text/javascript\"src=\"js/lib/jquery1.11.1.min.js\"></script><script>$function{$\"head\".load\"header.html\"};</script></head>```HTML5的import<linkrel=\"import\"href=\"autoloadtemplate.html\">在Chrome61.0，Opera48.0，OperaNeon1.0，AndroidBrowser6.0，ChromeMobile61.0和AdblockerBrowser54.0中测试OK，在Safari10.1，Firefox56.0，Edge38.14和IE11中测试NG。", "misc/工作日志.md": "GolangGomodules使用步骤：blog.csdn.net/fly910905/article/details/104297446Go%20modules%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%EF%BC%9Agomodinitgomodtidygomodverifygomodvendorgolang如何将interface转为int,string,slice,struct等类型www.fidding.me/article/99SpringBoot＠EnableAutoConfiguration通过＠EnableAutoConfiguration启用Spring应用程序上下文的自动配，这个注解会导人一个EnableAutoConfigurationlmportSelector的类，而AutoConfigurationlmportSelector这个类会去读取一个spring.factories下key为EnableAutoConfiguration对应的类全限定名的值。exclude一个AutoConfiguration在`application.properties`文件加入下面这行。`spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration`或者`@EnableAutoConfigurationexclude=SecurityAutoConfiguration.class`@SpringBootApplication的exclude不起作用。@EnableConfigurationPropertiesYapi安装启动安装```mkdiryapicdyapigitclonegithub.com/YMFE/yapi.gitvendors//或者下载zip包解压到vendors目录（clone整个仓库大概140+M，可以通过`gitclonedepth=1github.com/YMFE/yapi.gitvendors`命令减少，大概10+M）cpvendors/config_example.json./config.json//复制完成后请修改相关配置cdvendorsnpminstallproductionregistryregistry.npm.taobao.orgnpmruninstallserver//安装程序会初始化数据库索引和管理员账号，管理员账号名可在config.json配置nodeserver/app.js//启动服务器后，请访问127.0.0.1:{config.json配置的端口}，初次运行会有个编译的过程，请耐心等候```启动启动yapi:/home/dyys/myyapi/startyapi.sh利用pm2方便服务管理维护。```shellnpminstallpm2g//安装pm2cd{项目目录}pm2start\"vendors/server/app.js\"nameyapi//pm2管理yapi服务pm2infoyapi//查看服务信息pm2stopyapi//停止服务pm2restartyapi//重启服务```安装gitweb参考：fcgiwrap和nginx安装aandds.com/blog/toolfcgiwrap.htmlSystemctl用法详解windard.com/blog/2020/06/26/LinuxService安装和配置fcgiwrap安装：`yuminstallfcgiwrap`启动：`systemctlstatusfcgiwrap.service`文件`/lib/systemd/system/fcgiwrap.service`：```shellUnitDescription=SimpleCGIServerAfter=nssuserlookup.targetServiceEnvironmentFile=/etc/sysconfig/fcgiwrapExecStart=/usr/sbin/fcgiwrap${DAEMON_OPTS}c${DAEMON_PROCS}方式一：nohupfcgiwrapfc4sunix:/run/fcgiwrap.socket&：nginx和web服务必须是一台电脑方式二：nohupfcgiwrapfc4stcp:0.0.0.0:9000&：两台电脑启动2个fcgiwrapworker进程ExecStart=/usr/sbin/fcgiwrapfc2sunix:/run/fcgiwrap.socket暂停1秒，等待/run/fcgiwrap.socket生成ExecStartPost=/bin/sleep1ExecStartPost=/usr/bin/chownnginx:nginx/run/fcgiwrap.socketUser=nginxGroup=nginxInstallWantedBy=multiuser.targetAlso=fcgiwrap.socket```修改监听套接字文件的owner：`chownnginx:nginx/var/run/fcgiwrap.socket`。fcgiwrap.service文件已经写入，可以省去。自启动：`systemctlenabledfcgiwrap.service`安装gitweb`yuminstallgitweb`默认gitweb是安装到apache目录中的，也就是/var/www/git目录下，专门用来显示gitweb页面配置nginx```location/gitweb.cgi{root/var/www/git/;includefastcgi_params;gzipoff;fastcgi_paramSCRIPT_NAME/var/www/git/gitweb.cgi;fastcgi_paramGITWEB_CONFIG/etc/gitweb.conf;fastcgi_passunix:/var/run/fcgiwrap.socket;}location/{root/var/www/git/;indexgitweb.cgi;}```配置ReviewBoard的RepositoryRawFileURLMask:192.168.31.200:8180/?p=blocks/blockscomponents.git;a=blob_plain;f=<filename>;h=<revision>整合gogs与ReviewBoardreviewboard对gogs这种第三方的git仓库支持，在添加`Repository`时，只能通过`RawfileURLmask`来实现。AddgetblobAPI4857github.com/gogs/gogs/issues/4857错误：Re:fatal:Notagitrepository:'None'HTTP400,APIError224www.mailarchive.com/reviewboard@googlegroups.com/msg20895.htmlrbtools.api.errors.BadRequestError:fatal:notagitrepository:'None'示例：Repositorytype:GitPath:cddyys.ddns.net:3000/blocks/blockscomponents.gitRawFileURLMask:cddyys.ddns.net:3000/blocks/blockscomponents/raw/2.0.x/<filename>?id=<revision>gitdifffullindex>b.diffrbtpostpdtrackingbranch=origin/2.0.xdifffilename=a.diffsummary=init_blogdescription=\"completeblogindex\"targetpeople=guanjh调试exuser注释掉Task.class的@Component，WebDestroyAction.class的@Componentspring容器启动后执行Spring容器启动完成后，执行初始化加载工作blog.csdn.net/xiaojin21cen/article/details/83418470```java@ComponentpublicclassInitBeanTestimplementsApplicationListener<ContextRefreshedEvent>{//此方法会被多次调用@OverridepublicvoidonApplicationEventContextRefreshedEventevent{/**在web项目中，存在两个容器，一个是rootapplicationcontext，另一个就是我们自己的projectNameservletcontext（作为rootapplicationcontext的子容器）。这种情况下，就会造成onApplicationEvent方法被执行两次。为了避免上面提到的问题，我们可以只在rootapplicationcontext初始化完成后调用逻辑代码*/ifevent.getApplicationContext.getParent==null{//rootapplicationcontext没有parent//TODO这里写下将要初始化的内容}}}```在springboot工程环境的junit测试基于纯spring方式此方式事务是起作用的。```xml<context:annotationconfig/><context:componentscanbasepackage=\"com.ex\"><context:excludefiltertype=\"annotation\"expression=\"org.springframework.stereotype.Controller\"/><context:excludefiltertype=\"annotation\"expression=\"org.springframework.web.bind.annotation.RestController\"/><context:excludefiltertype=\"annotation\"expression=\"org.springframework.boot.autoconfigure.SpringBootApplication\"/><context:excludefiltertype=\"annotation\"expression=\"org.springframework.web.servlet.config.annotation.EnableWebMvc\"/><context:excludefiltertype=\"assignable\"expression=\"com.ex.web.aspect.AppSignCheck\"/><context:excludefiltertype=\"assignable\"expression=\"com.ex.admin.aspect.AdminPermissionAspect\"/></context:componentscan><beanclass=\"com.dyys.framework.util.SpringHelper\"/><beanid=\"transactionManager\"class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"><propertyname=\"dataSource\"ref=\"dsMain\"></property></bean><tx:annotationdriventransactionmanager=\"transactionManager\"></tx:annotationdriven><!DAO接口所在包名，Spring会自动查找其下的类><beanname=\"mainSqlScannerConfigurer\"class=\"org.beetl.sql.ext.spring.BeetlSqlScannerConfigurer\"><!哪些类可以自动注入><propertyname=\"basePackage\"value=\"com.ex\"/><!通过类后缀来自动注入Dao><propertyname=\"daoSuffix\"value=\"Mapper\"/><propertyname=\"sqlManagerFactoryBeanName\"value=\"mainSqlManager\"/></bean><beanid=\"mainSqlManager\"class=\"org.beetl.sql.ext.spring.SqlManagerFactoryBean\"><propertyname=\"cs\"><beanclass=\"org.beetl.sql.ext.spring.SpringConnectionSource\"><propertyname=\"masterSource\"ref=\"dsMain\"></property><!还可以设置从数据库slaves></bean></property><propertyname=\"dbStyle\"><beanclass=\"org.beetl.sql.core.db.MySqlStyle\"/></property><propertyname=\"sqlLoader\"><beanclass=\"org.beetl.sql.core.loader.MarkdownClasspathLoader\"><propertyname=\"sqlRoot\"value=\"sql\"></property></bean></property><propertyname=\"nc\"><beanclass=\"org.beetl.sql.core.DefaultNameConversion\"/></property><propertyname=\"interceptors\"><list><beanclass=\"org.beetl.sql.ext.DebugInterceptor\"></bean></list></property></bean>```测试用例为```java@RunWithSpringRunner.class@PropertySource\"classpath:application.properties\"@ContextConfigurationlocations={\"classpath*:springtest.xml\"}@EnableAutoConfigurationexclude=WebMvcAutoConfiguration.classpublicclassCoinTest{@AutowiredprivateCoinServicecoinService;@TestpublicvoidaddCoinAndFinanceAccount{Coincoin=newCoin\"WKKk\",CoinGroup.MAINSTREAM_COIN.value;LongadminId=11L;coin=coinService.addCoinAndFinanceAccountcoin,adminId;Assert.assertNotNullcoin;}}```基于springboot方式此方式事务不起作用。重写一个Application类。```java@SpringBootApplicationexclude=WebMvcAutoConfiguration.class@ComponentScanexcludeFilters={@ComponentScan.Filtertype=FilterType.ASSIGNABLE_TYPE,value={WebApplication.class,AppSignCheck.class,AdminPermissionAspect.class},@ComponentScan.Filtertype=FilterType.ANNOTATION,value={EnableWebMvc.class,Controller.class,RestController.class}}@EnableTransactionManagementpublicclassTestApplication{publicstaticvoidmainStringargs{SpringApplication.runTestApplication.class,args;}@Bean@Order100publicSpringHelperspringHelper{returnnewSpringHelper;}}```测试用例为：```java@RunWithSpringRunner.class@SpringBootTestclasses=TestApplication.class,webEnvironment=SpringBootTest.WebEnvironment.NONE@TransactionalpublicclassCoinServiceTest{@AutowiredprivateCoinServicecoinService;@TestpublicvoidaddCoinAndFinanceAccount{Coincoin=newCoin\"WKKk\",CoinGroup.MAINSTREAM_COIN.value;LongadminId=11L;coin=coinService.addCoinAndFinanceAccountcoin,adminId;Assert.assertNotNullcoin;}}```mintty乱码在cmder的settings>启动>任务中设置：`minttyoLocale=zh_CNoCharset=GBK`", "misc/挖矿的7个步骤.md": "步骤一：发起交易用户进入钱包，执行一个交易操作，他将一个加密货币或者一个token发送给另一个用户。步骤二：进入交易池现在这个交易被钱包广播，等待区块链上的矿工们来拾取它。在被拾取前，它会一直在“未确认交易池”中等待。所有等待被处理的交易都会在未确认交易池中，未确认交易池不是网络上的一个巨大的池，而是很多小的分散在矿工本地的缓存池。步骤三：确认待打包的交易区块链网络上的矿工有时叫节点，但不完全一样从未确认交易池中选择交易打包成数据块。除了一些额外的元数据外，数据块基本上就是交易数据此时仍然是未确认交易。每个矿工打包它们拾取的交易数据块，多个矿工可以选择同样的交易数据打包。例如，两个矿工，矿工A和矿工B都决定打包交易X。每个区块链对数据块都有最大限制。在比特币区块链上，这个最大值是1MB。在打包交易前，矿工需要先根据区块链的历史数据检查这个交易是否有资格被打包。根据区块链历史数据记录，如果支付者的钱包里有足够的余额，这笔交易被认为是有效的，并且可以被打包上链。假如一个比特币持有者想要加速他的交易进度，他可以选择支付更高的挖矿奖励。矿工通常会优先打包这些支付更高挖矿奖励的交易。步骤四：计算签名出块矿工的工作就是选择交易数据并打包成块。要把这些块添加到区块链上这意味着让区块链上所有节点都接受这个块的数据，这个数据块首先需要签名也叫“工作证明”。这个签名是在解决了一个非常复杂的数学问题后得到的，这个签名是独一无二的。每个区块需要解决的数学问题难度是一样的。为了解决这个数学问题，需要耗费相当多的算力所以，要消耗相当多的电力。这个过程就被叫做挖矿。如果你想知道更多关于这个问题的内容，请继续阅读，如果你只想简单了解一下，请跳到步骤五。挖矿即哈希工作量证明矿工在打包块时需要解决的数学问题实际上就是找到一个以一定量的零开头的哈希函数的输出结果就是签名。这听起来很复杂对吗？但是它并不难理解。开始之前，我们需要先了解一下什么是哈希函数。哈希函数很难解，但其结果非常容易验证。哈希函数的输入值可以是任意字符串，随机输出一个32位的字母和数字的字符串。如果输入中有任何一点小小的变动，输出也将会随机改变。然而，同样的输入字符串只会得到同样的输出。矿工要打包的交易数据就是一个字符串，将它进行哈希计算，就会得到一个32位的输出值。比特币区块链有一个规则，要求打包的数据块签名必须以一定数量的零开头。然而哈希计算的输出值是对它的每个输入值都是随机的，那么，输入的字符串哈希后没有得到这么多零开头的值怎么办呢？这就是为什么矿工需要不断的去改变块里面一个叫\"nonce\"的值，每改变一次nonce的值，就会改变块的数据，哈希运算后得到的签名也会不一样，也就是，每改变一次nonce的值，就会得到一个全新的签名。矿工无限次重复改变nonce的值，直到得到一个符合要求的签名。下图例子中，签名是以7个零开头的。但是具体需要多少个零，取决于区块链上的区块难度。区块难度的问题相对要难一些，所以我建议你先收藏blockdifficulty。这就是矿工们为什么需要为它们打包的数据块找到一个合格的签名，也是需要那么多算力来解决这个数学问题的原因。试想一下需要这么多次更改nonce值并计算需要多少时间和算力呀。此外，当更多的矿工加入到区块链，哈希运算的难度也将增加并且会导致更高的电费支出。现在我们继续第五步。注意：此过程实际上不是定义为数学问题，而是定义确定性问题计算机对数字执行预先确定的操作，以查看输出是否可取。步骤五：广播区块矿工找到了一个合格的签名，他就可以向其他所有矿工广播他的数据块和签名。步骤六：验证区块其他矿工现在要确认通过广播收到的数据块的签名合法性，他们要对这个数据块进行哈希运算检查它是否输出一个以这么多零开头的签名。如果检查通过，其他矿工就会认为这个数据块有效，并且同意将它添加到区块链上他们达成了共识，即他们所有矿工都同意彼此，所以术语叫共识算法。这也是“工作量证明”的来源。签名就是矿工工作的证明已花费的算力，现在，数据块可以加到区块链上了，并且分发到网络上所有其他节点。只要这个数据块中的所有交易数据都跟区块链上的历史数据符合，其他节点将接收这个数据块并将其保存。步骤七当一个数据块被添加到区块链上后，这条区块链上的所有块都认为它是正确的。例如，我的交易包含在第502号块中，并且这条区块链现在最长是第507号块，它的意思就是说我的交易数据被确认过5次507502。它被认为是正确的，因为每次有其他块上链的时候，区块链都会就所有交易记录达成共识，包括你的交易和你的块。你可以说，到这个时候，你交易已经被确认了5次。这也是Etherscan在显示交易详细信息时所指的。你的交易被确认的次数越多即嵌入区块链越深，攻击者就越难更改它。每当新的交易加入到区块链，所有矿工都需要从第三步重新开始，打包一个新的交易数据块。在完成一个块上链前，矿工们不能继续挖矿。1、它可能包含已添加到区块链上已经确认过的交易请记住，多个矿工可以选择同一个交易数据处理，任何重新发起的交易都可能导致它们无效，因为支付者的余额可能已经不足。2、每个块都需要将区块链上的最后一个块的哈希签名添加到到他们自己的元数据中。这也是让数据块链起来的原因。假如一个矿工打包的是已经上链的块，其他矿工会注意到它的签名和区块链上最后一个数据块对不上，并且会拒绝这个块。", "misc/职责.md": "JD职位描述：技术战略规划：参与部门的发展战略规划，依据发展战略负责部门技术方向研究和总体规划，负责技术层面的管理工作；1、技术规划：结合业务发展需求和现状，制定技术发展战略、对系统架构发展进行规划、组织制定和实施重大技术决策和方案；3、技术架构设计：带领技术团队设计与实现产品的技术架构，主导架构评审，保障技术的合理性与可行性；解决目前部门已使用技术框架中存在的问题并进行有效优化；负责部门软件构件库的搭建、第三方控件的选型；管理2、流程规范制定：主导制定并持续优化研发工作流程和规范，保证高效率高质量的技术产出，促进技术成果的沉淀共享，确保技术成果的有效性和持续性；4、目标制定：负责研发部门整体目标制定，推进团队目标、个人目标和工作计划的制定和落地执行；5、团队建设：负责技术团队的招聘、建设、培养，提升团队的工作质量、效率和技术能力，优化项目人员结构，明确职责，定期进行技术培训或分享；6、保障业务：最大程度支撑部门产品的技术实现和稳定运行，力求技术稳定性和先进性为部门发展提供动力，容量规划预备业务的快速增长；完成各项技术工作相关数据统计分析报告，并据此对部门发展提出合理化建议；7、新技术研究：研究部门战略发展相关最新产品和技术的发展方向，调研与产品相符的最新技术，并在系统中使用以提升产品体验。8、完成上级领导交办的其他工作；职位要求：1、8年以上开发经验，3年以上的Java开发经验；2、具备良好的基本功，熟练使用基本的数据结构和算法，深入理解多线程、socket等相关技术；3、熟练掌握Spring等主流的开发框架，深入理解框架实现原理及特性；4、具备良好的编码习惯，结构清晰，命名规范，逻辑性强，代码冗余率低；5、熟悉Java的高级特性，深入理解各种设计模式和应用场景；6、有大规模分布式系统的开发和高可用相关的实践经验，具备设计复杂系统的能力；7、熟练掌握Mongodb数据库，具备Mongodb索引优化、查询优化、分库分表优化、数据库备份还原应用的能力；8、熟练掌握MySql数据库，具备MySql索引优化、查询优化、分库分表优化、数据库备份还原应用的能力；9、熟练掌握一种以上非关系型数据库，理解其使用场景及限制，如：Redis、Memcached等；10、熟悉分布式系统，熟练掌握一种以上服务框架和消息中间件，如：kafka，了解其实现原理；11、熟悉负载均衡和HA的基本原理，熟练掌握一种以上的HA框架，如：ZooKeeper、KeepAlived、LVS、DNAT、SNAT等；12、熟悉前端开发基本原理，熟练掌握一种以上的web框架，如：React、Vue、Angulard；13、对BIM、GIS有相关开发经验者优先；14、具有团队精神和责任感，自驱力强，对技术有持续的热情；15、具有10人以上团队管理经验；16、统招211、985重点大学研究生以上学历；如何学习新技术？快速了解：看视频，入门blog，专题blog。解读代码：去搞清楚每一行代码，并笔记记录。代码选择：github上的codetutrial库最佳，零散代码亦可。不是为了保留代码，是为了记住、理解代码。codetutorial库可长期维护，温故知新。系统学习：看书，做笔记。在掌握技术的用法后，看一本书（不要太多的书）系统的梳理知识点。听娱乐NCE英文歌听书籍，拒绝碎片化听广播面试问题集1、JVM内存模型、GC垃圾回收2、JVM问题定位，调试3、Tomcat及JVM调优TODOLIST弄清这几个接口干什么用的`GenericFilterBeanimplementsFilter,BeanNameAware,EnvironmentAware,EnvironmentCapable,ServletContextAware,InitializingBean,DisposableBean`智能报表flutter的学习SpringCloud学习MySQL主从，读写分离TOGAF咨询方案，企业架构学习", "Coding/01-Groovy编程.md": "TOC第3章正则表达式搜索字符串```groovyPatternpattern=~/^.*?groovy.*$/definput='Probablytheeasiestwaytogetgroovy'+'istotryworkingwithcollections.'ifinput==~/^.*?groovy.*$/{println'Foundgroovy'}ifinput=~/^.*?groovy.*$/{println'Foundgroovy'}defmatcher='TheGroovyCookBookcontainsGroovyrecipes'=~/.oo.\\s/println\"<${matcher00}>\"println\"<${matcher01}>\"println\"<${matcher10}>\"println\"<${matcher11}>\"matcher.each{match>match.each{group>println\"<$group>\"}}input='TheGroovyCookBookcontainsGroovyrecipes'printlninput.replaceAll/\\b\\w*?oo\\w*?\\b/{match>match.toUpperCase}```GroovyBean```groovyclassStudent{LongidStringname}defstudent=newStudentstudent.setName'Charlie'assertstudent.name=='Charlie'//如果类明确定以了构造方法，命名参数构造方法将失效defstudent2=newStudentid:100,name:'Jack'//不可变属性@ImmutableclassCustomer{Stringname,lastNameLongid}defcustomer=newCustomerid:200,name:'Mark',lastName:'Hogan'//unabletoresolveclassImmutable,unabletofindclassforannotationcustomer.name='John'//注解@ToString@ToStringincludeNames=true,excludes='lastName,age'@EqualsAndHashCode@Canonical//==hashCode,equals,toString```构造方法继承```groovy//java的构造方法是不能继承的importgroovy.transform.InheritConstructors@InheritConstructorsclassBusinessExceptionextendsException{}assertnewBusinessException'hello'.message=='hello'defb1=newBusinessException'missingresource'defb2=newBusinessException'catastrophicfailure',b1assertb2.cause.message=='missingresource'```对象Clonejava对象clone是实现Cloneable接口的clone方法。```groovy@AutoCloneclassVehicle{StringbrandStringtypeLongwheelsNumberEngineengine}classEngine{inthorseEngineNumberliter}defv1=newVehiclebrand:'Ferrari',type:'Testarossa',wheelsNumber:4defe1=newEnginehorseEngine:390,liter:4.9v1.engine=e1//assignenginetocardefv2=v1.clone//cloneprintln'Originalvehicleengineliters:'+v1.engine.literprintln'Clonedvehicleengineliters:'+v2.engine.literv2.engine.liter=8println'Originalvehicleengineliters:'+v1.engine.liter//Originalvehicleengineliters:4.9//Clonedvehicleengineliters:4.9//Originalvehicleengineliters:8```闭包```groovydefdoubling={arg1>printlnarg1*2}1,2,3,4.eachdoubling//classExpensiveResource{defopen{println'opened!'}defwriteDatadata{println\"datawritten!$data\"}defclose{println'closed!'}}defe=newExpensiveResourcetry{e.open}finally{e.close}defsafeResourceClosureclosure{defresource=newExpensiveResourcetry{resource.openclosureresource}finally{resource?.close}}safeResource{it>it.writeData'helloworld!'}//defmultiply={x,y>x*y}multiply3,5//curry传入的参数按照形参的顺序defclosureByFour=multiply.curry4closureByFour7//deffilterList={filter,list>list.findAllfilter}defeven={it%2==0}defodd={!evenit}defevenFilterList=filterList.curryevendefoddFilterList=filterList.curryoddassert0,2,4,6,8==evenFilterList0..8assert1,3,5,7==oddFilterList0..8```闭包DSL```groovyimportgroovy.transform.*@CanonicalclassShoppingCart{List<Book>items=UseruserAddressshippingData}@CanonicalclassBook{LongidStringtitleBigDecimalprice}@CanonicalclassUser{LongidStringnameAddressaddress}@CanonicalclassAddress{StringstreetStringcityStringcountry}classECommerceTestDataBuilder{ShoppingCartshoppingCartdefbooks=ShoppingCartbuildclosure{shoppingCart=newShoppingCartclosure.delegate=thisclosureshoppingCart.items=booksshoppingCart}voiditemsintquantity,closure{closure.delegate=thisquantity.times{books<<newBookclosure}}/***methodMissing是实现DSL最关键的。闭包里的titleRANDOM_TITLE的title会触发此方法*/defmethodMissingStringname,args{Bookbook=books.lastifbook.hasPropertyname{defdataStrategy=isDataStrategyargsifdataStrategy{book.@\"$name\"=dataStrategy.execute}else{book.@\"$name\"=args0}}else{thrownewMissingMethodExceptionname,ECommerceTestDataBuilder,args}}defisDataStrategystrategyData{defstrategyClass=nulltry{ifstrategyData.length==1{strategyClass=strategyData0.newInstance}else{strategyClass=strategyData0.newInstance*strategyData1,1}if!strategyClassinstanceofDataPopulationStrategy{strategyClass=null}}catchExceptione{}strategyClass}}interfaceDataPopulationStrategy{defexecute}classRANDOM_TITLEimplementsDataPopulationStrategy{deftitleCache=defignoredTitleWords='Page','Sort','Next'voidgetRandomBookTitles{defslurper=newXmlSlurperslurper.setFeature'apache.org/xml/features/nonvalidating/loadexternaldtd',falsedefdataUrl='m.gutenberg.org/ebooks/search.mobile'deforderBy='/?sort_order=random'defhtmlParser=slurper.parse\"${dataUrl}${orderBy}\"htmlParser.'**'.findAll{it.@class=='title'}.each{ifit.text.tokenize.disjointignoredTitleWords{titleCache<<it.text}}}defexecute{iftitleCache.size==0{'randomBookTitles'}'titleCache.pop'}}classRANDOM_IDimplementsDataPopulationStrategy{LongminValLongmaxValRANDOM_IDmin,max{minVal=minmaxVal=max}defexecute{doublernd=newRandom.nextDoubleminVal+longrnd*maxValminVal}}defshoppingCart=newECommerceTestDataBuilder.build{items5{titleRANDOM_TITLEidRANDOM_ID,100,200000price100}}assertshoppingCart.items.size==5shoppingCart.items.each{assertit.price==100assertit.id>100&&it.id<200000}```其它动态属性dynamicproperties```groovyclassEntity{defdynamicProperties=://setterdefpropertyMissingStringname,value{dynamicPropertiesname=value}//getterdefpropertyMissingStringname{dynamicProperties=name}}classUserextendsEntity{StringfirstNameStringlastName}Useruser=newUser;user.firstName=\"Jagadeesh\";user.lastName=\"Manne\";user.name=\"$user.firstName$user.lastName\";//addingdynamicproperty\"name\"thatdoesntexistinUserdomainprintln\"Name:$user.name\";```", "Coding/01-Java_roadmap.md": "TOC1.一、JVM&Java以《分布式JAVA应用基础与实践》的目录为纲，查阅《深入理解Java虚拟机》的细节，高并发查阅《JAVA并发编程实战》。简称《分J》、《深J》、《并J》1.1.1.1JVM内存管理主要阅读《分J》3.2节、《深J》的第二部分Java内存模型Java内存分配与回收JVM性能分析及调优JVM调优案例FAQJava内存模型FAQifeve.com/jmmfaq/自己编写各种outofmemory，stackoverflow程序HeapOutOfMemoryYoungOutOfMemoryMethodAreaOutOfMemoryConstantPoolOutOfMemoryDirectMemoryOutOfMemoryStackOutOfMemoryStackOverFlow当一个Java程序响应很慢时如何查找问题当一个Java程序频繁FullGC时如何解决问题，如何查看垃圾回收日志当一个Java应用发生OutOfMemory时该如何解决，年轻代、年老代、永久代解决办法不同，导致原因也不同编程验证软引用，弱引用，虚引用1.2.1.2Java执行机制主要阅读《分J》3.1节、《深J》的第三部分类文件结构类加载机制类执行机制案例分析tomcat类加载机制OSGI类加载机制字节码与动态代理FAQ写一个程序要求实现javap的功能（手工完成，不借助ASM等工具）如Java源代码：```publicstaticvoidmainStringargs{inti=0;i+=1;i*=1;System.out.printlni;}```编译后读取class文件输出以下代码：publicstaticvoidmainjava.lang.String;Code:Stack=2,Locals=2,Args_size=10:iconst_01:istore_12:iinc1,15:iload_16:iconst_17:imul8:istore_19:getstatic2;//Fieldjava/lang/System.out:Ljava/io/PrintStream;12:iload_113:invokevirtual3;//Methodjava/io/PrintStream.println:IV16:returnLineNumberTable:line4:0line5:2line6:5line7:9line8:161.3.1.3线程与高并发主要阅读《分J》第4章、《深J》的第五部分、《并J》全书。NIO与并发包Java内存模型与线程线程安全与锁优化FAQBIO、NIO、AIO的区别？Reactor、Preactor区别？线程池原理什么是锁，锁的种类有哪些，每种锁有什么特点，适用场景是什么？同步机制有哪些？写一个死锁的程序什么是守护线程，守护线程和非守护线程的区别以及用法？volatile的作用？2.二、架构设计理解运用23中设计模式，深入理解《企业架构模式》。2.1.2.1设计模式2.2.2.2企业架构模式2.3.2.3常见模式分析MVC模式：SpringMVC原理AOPCGLIB和InvocationHandler的区别：cglib.sourceforge.net/动态代理模式Javassist实现AOP：//www.csg.ci.i.utokyo.ac.jp/~chiba/javassist/ASM实现AOP：asm.ow2.org/FAQ使用模板方法模式和策略模式实现IOC不用synchronized和lock，实现线程安全的单例模式2.4.2.4微服务与SOA微服务API网关RPC框架3.三、大数据3.1.数据存储知识3.1.1.关系型数据库MySQL如何看执行计划如何搭建MySQL主备binlog是什么Derby，H2，PostgreSQLSQLite3.1.2.NoSQL3.2.大数据知识3.2.1.Zookeeper，在linux上部署zk3.2.2.Solr，Lucene，ElasticSearch在linux上部署solr，solrcloud，，新增、删除、查询索引3.2.3.Storm，流式计算，了解Spark，S4在linux上部署storm，用zookeeper做协调，运行stormhelloworld，local和remote模式运行调试stormtopology。3.2.4.Hadoop，离线计算Hdfs：部署NameNode，SecondaryNameNode，DataNode，上传文件、打开文件、更改文件、删除文件MapReduce：部署JobTracker，TaskTracker，编写mrjobHive：部署hive，书写hivesql，得到结果Presto：类hive，不过比hive快，非常值得学习3.2.5.分布式日志收集flume，kafka，logstash3.2.6.数据挖掘，mahout3.2.7.参考资料zookeeper.apache.org/lucene.apache.org/solr/github.com/nathanmarz/storm/wikihadoop.apache.org/prestodb.io/flume.apache.org/，logstash.net/，kafka.apache.org/mahout.apache.org/4.四、网络与安全4.1.网络编程知识4.1.1.用Java写一个简单的静态文件的HTTP服务器实现客户端缓存功能，支持返回304实现可并发下载一个文件使用线程池处理客户端请求使用nio处理客户端请求支持简单的rewrite规则上述功能在实现的时候需要满足“开闭原则”4.1.2.用Java实现FTP、SMTP协议4.1.3.什么是CDN？如果实现？DNS起到什么作用？搭建一个DNS服务器搭建一个Squid或ApacheTrafficServer服务器www.squidcache.org/trafficserver.apache.org/en.wikipedia.org/wiki/Domain_Name_System4.2.网络安全知识4.2.1.什么是DES、AES4.2.2.什么是RSA、DSA4.2.3.什么是MD5，SHA14.2.4.什么是SSL、TLS，为什么HTTPS相对比较安全4.2.5.什么是中间人攻击、如果避免中间人攻击4.2.6.什么是DOS、DDOS、CC攻击4.2.7.什么是CSRF攻击4.2.8.什么是CSS攻击4.2.9.什么是SQL注入攻击4.2.10.什么是Hash碰撞拒绝服务攻击4.2.11.了解并学习下面几种增强安全的技术www.openauthentication.org/HOTPwww.ietf.org/rfc/rfc4226.txtTOTPtools.ietf.org/rfc/rfc6238.txtOCRAtools.ietf.org/rfc/rfc6287.txten.wikipedia.org/wiki/Salt_cryptography4.2.12.用openssl签一个证书部署到apache或nginx5.五、推荐书籍《深入Java虚拟机》《深入理解Java虚拟机》《EffectiveJava》《七周七语言》《七周七数据》《Hadoop技术内幕》《HbaseInAction》《MahoutInAction》《这就是搜索引擎》《SolrInAction》《深入分析JavaWeb技术内幕》《大型网站技术架构》《高性能MySQL》《算法导论》《计算机程序设计艺术》《代码大全》《JavaScript权威指南》参考：Java工程师成神之路www.hollischuang.com/archives/4896.Java开发必备知识6.1.编程语言Groovy_Linksgithub.com/virtualdogbert/Groovy_LinksGroovy的SQL模块www.jianshu.com/p/a0e301f79f9bJava8Streamsmapexampleswww.mkyong.com/java8/java8streamsmapexamples/Java8CConvertListtoMapwww.mkyong.com/java8/java8convertlisttomap/java8的lambda中的map相关操作blog.csdn.net/wabiaozia/article/details/842621956.2.数据库MyBatisPlus入门视频课程www.imooc.com/learn/11306.3.常用工具库modelMapper入门及使用解析www.jianshu.com/p/d97f9ea2d3caCGLIBBeanCopier和BeanMap等实现grefr.iteye.com/blog/20537486.4.开源项目hsweb后台管理基础框架github.com/hsweb/hswebframeworkiBase4J项目gitee.com/iBase4J/iBase4JJEPF软件快速开发平台www.jepf3.com/6.5.工具使用Eclipse远程调试（远程服务器端监听www.cnblogs.com/jianliangWu/p/7110681.htmlEclipse开发工具之安装插件Jrebelsegmentfault.com/a/1190000005746934阿里巴巴程序员常用的15款开发者工具www.infoq.cn/article/1jV*BDxGwld6CWDVIt48非常全的VsCode快捷键blog.csdn.net/p358278505/article/details/74221214eclipse使用jetty:run命令调试blog.csdn.net/huaieli1/article/details/79494871Nginx入门指南wiki.jikexueyuan.com/project/nginx/", "Coding/02-Python惯用法.md": "TOC学习资料：Python教程www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000Python3教程www.runoob.com/python3/python3tutorial.htmlJSON操作load：读取json文件```python读取json文件内容,返回字典格式withopen'./source_file/info.json','r',encoding='utf8'asfp:json_data=json.loadfpprint'这是文件中的json数据：',json_dataprint'这是读取到文件数据的数据类型：',typejson_data```dump：写入json文件```python将字典数据写入到json文件中dict1={'name':'张三','age':18,'sex':'男'}withopen'./source_file/info.json','a',encoding='utf8'asfp:json.dumpdict1,fp,ensure_ascii=False　　如果ensure_ascii''为false，则返回值可以包含非ascii值```loads：将json字符串转换成字典格式```python将json字符串转换成字典格式str1='{\"name\":\"张三\",\"age\":18,\"sex\":\"男\"}'print'这是转换后的数据：',json.loadsstr1```dumps：将字典格式数据转换成json格式;```python将字典格式数据转换成json格式dict1={'name':'张三','age':18,'sex':'男'}print'这是将字典转换之后的数据：',json.dumpsdict1,ensure_ascii=False如果ensure_ascii''为false，则返回值可以包含非ascii值```日期时间```python获取当前时间now=datetime.datetime.nowdatetime=>string格式化输出now.strftime'%Y%m%d%H:%M:%S'string=>datetime字符串转日期t_str='2012030516:26:23'd=datetime.datetime.strptimet_str,'%Y%m%d%H:%M:%S'在datetime模块中有timedelta类，这个类的对象用于表示一个时间间隔，比如两个日期或者时间的差别。计算两个日期的间隔d1=datetime.datetime.strptime'2012030517:41:20','%Y%m%d%H:%M:%S'd2=datetime.datetime.strptime'2012030217:41:20','%Y%m%d%H:%M:%S'delta=d1d2printdelta.days今天的n天后的日期。now=datetime.datetime.nowdelta=datetime.timedeltadays=3n_days=now+delta```自定义排序```pythonimportfunctoolsdefcmpa,b:ifa1==b1:return0eliflena1>=lenb1anda1>b1:return1else:return1emap={'a':'3','b':'2'}sortedLinks=sortedemap.items,key=functools.cmp_to_keycmp```文件操作读取文件最后一行```pythondef__get_last_lineself,filename:\"\"\"getlastlineofafile:paramfilename:filename:return:lastlineorNoneforemptyfile\"\"\"try:filesize=os.path.getsizefilenameiffilesize==0:returnNoneelse:withopenfilename,'rb'asfp:touseseekfromend,mustusemode'rb'offset=8initializeoffset设置偏移量时注意不要超过文件总的字节数，否则会报OSErrorwhileoffset<filesize:offsetcannotexceedfilesizefp.seekoffset,where中where=0,1,2分别表示从文件头，当前指针位置，文件尾偏移，缺省值为0，但是如果要指定where=2，文件打开的方式必须是二进制打开，即使用’rb’模式fp.seekoffset,2readoffsetcharsfromeofrepresentbynumber'2'lines=fp.readlinesreadfromfptoeofiflenlines>=2:ifcontainsatleast2linesreturnlines1thenlastlineistotallyincludedelse:offset*=2enlargeoffset注意边界条件的处理，比如文件只有一行的情况fp.seek0lines=fp.readlinesreturnlines1exceptFileNotFoundError:printfilename+'notfound!'returnNone```语法三元运算符参考：Python之三元运算、集合、函数www.cnblogs.com/hhfzj/p/6978092.html```pythonc=aifa>1elseb如果a大于1的话，c=a，否则c=bss=iforiinrange1,11ifi%2==0循环111间的值（不包括11），如果值能被2整除（即取偶数）```Set```pythona.定义一个列表，通过强制转换来定义集合nums=1,1,2,3,5,6,77,8num_set=setnumsb.直接定义num_set1={1,2,3,3,4}集合不能通过下标来访问元素s.remove333删除元素，如果元素不存在就会报错s.pop删除一个随机的元素，并返回删除的元素s.discare111如果删除的元素存在，删除，不存在不做处理```可变参数```pythondefpost*args:想传多少个参数就传多少个，将传入的参数放到一个元组里printargs调用post'001','denglu',post输出：'001','denglu',<functionpostat0x000001EBEF237400>post```关键字参数```pythondefkw**kwargs:参数不固定，个数不限，和其它类型参数混用时，顺序为：必填参数，默认值参数，可变参数和关键字参数。printkwargs参数被转化为一个字典调用kwkwage=18,name='aaa'd={'age':18,'name':'aaa'}kw**d传入字典调用的时，就得写**{'age':18,'name':'aaa'}```字符串查找定位```pythonchapters=urls=chforchinchaptersidx=urls.indexurlPrefix+posMap.getnovel'name'```字符串与dict转换```pythonimportjsonjson_str='{\"name\":\"jay\",\"sex\":\"male\",\"age\":22}'JSON到字典转化：dictinfo=json.loadsjson_str输出dict类型字典到JSON转化：jsoninfo=json.dumpsdictinfo输出str类型```文件操作遍历文件```pythondefwalkdirrootdir:三个参数：分别返回1.父目录2.所有文件夹名字（不含路径）3.所有文件名字forparent,dirnames,filenamesinos.walkrootdir:fordirnameindirnames:print\"dirpath:\"+os.path.joinparent,dirnameforfilenameinfilenames:print\"filepath:\"+os.path.joinparent,filename```glob文件查找**glob**```pythonimportglobglob.glob'd:\\a\\*\\*.txt'glob.glob'./glob_?.png'glob.glob'../glob_09.png'glob.glob'glob_09.*'```**iglob**获取一个迭代器iterator对象，使用它可以逐个获取匹配的文件路径名。与glob.glob的区别是：glob.glob同时获取所有的匹配路径，而glob.iglob一次只获取一个匹配路径。```pythonimportglobfiles=glob.iglob'*.png'forpnginfiles:printpng```**多模式匹配来搜索文件**```pythonimportitertoolsasit,glob,osdefmultiple_file_types*patterns:returnit.chain.from_iterableglob.globpatternforpatterninpatternsforfilenameinmultiple_file_types\"*.txt\",\"*.py\":addasmanyfiletypearguementsrealpath=os.path.realpathfilenameprintrealpath```", "Coding/02-Python爬虫.md": "TOCrequests库的用法1.get/post请求参数也是字典，也可以传递json类型的参数：```pythonimportrequestsfromfake_useragentimportUserAgentheaders={\"UserAgent\":UserAgent.random}url=\"www.baidu.cn/index/login/login\"params={\"user\":\"1351351335\",账号\"password\":\"123456\"密码}response=requests.posturl,headers=headers,data=paramsresponse.text```2.IP代理```pythonheaders={\"UserAgent\":UserAgent.random}url=\"httpbin.org/get\"proxies={用户名:密码@IP:端口号\"http\":\"yonghuming:123456@192.168.1.1:8088\"}设置访问时间requests.get\"baidu.com/\",timeout=0.1requests.geturl,headers=headers,proxies=proxies```3.session自动保存cookies```pythonheaders={\"UserAgent\":UserAgent.chrome}login_url=\"www.baidu.cn/index/login/login\"params={\"user\":\"yonghuming\",用户名\"password\":\"123456\"密码}session=requests.Sessionresponse=session.postlogin_url,headers=headers,data=paramsinfo_url=\"www.baidu.cn/index/user.html\"resp=session.getinfo_url,headers=headersresp.text```4.获取响应信息`resp.json`获取响应内容以json字符串`resp.text`获取相应内容以字符串`resp.content`获取响应内容以字节的方式`resp.headers`获取响应头内容`resp.url`获取访问地址`resp.encoding`获取网页编码`resp.request.headers`请求头内容`resp.cookie`获取cookieBeautifulSoup课程内容1.爬虫简介2.简单爬虫架构3.URL管理器：管理待抓取URL集合和已抓取URL集合防止重复抓取、防止循环抓取4.网页下载器urllib25.网页解析器BeautifulSoup6.完整实例爬取百度百科Python词条相关的1000个页面数据网页下载器urllib2方法1：最简洁方法```pythonimportur1lib2直接请求response=urllib2.urlopenwww.baidu.com'获取状态码，如果是2ee表示获取成功printresponse.getcode读取内容cont=response.read```方法2：添加data、httpheaderimporturllib2```python创建Request对象request=ur11ib2.Requestur1添加数据request.add_dataa'，‘12添加http的headerrequest.add_header‘UserAgent'，‘Mozilla/5.e'发送请求获取结果response=ur1lib2.urlopenrequest```方法3：添加特殊情景的处理器：HTTPCookieProcessor,ProxyHandler,HTTPSHandler,HTTPRedirectHandler```pythonimportur1lib2，cookielib创建cookie容器cj=cookielib.CookieJar创建1个openeropener=ur11ib2.build_openerur1lib2.HTTPCookieProcessorcj给ur11ib2安装openerur1lib2.install_openeropener使用带有cookie的ur11ib2访问网页response=url1ib2.urlopen\"www.baidu.com/\"```三种方法的示例：```pythonimporturllib2ur1=\"www.baidu.com\"print'第一种方法’response1=ur11ib2.urlopenur1printresponsel.getcodeprintlenresponse1.readprint“第二种方法”request=ur1lib2.Requesturlrequest.add_header\"useragent\"，\"Mozilla/5.e\"response2=ur11ib2.urlopenrequestprintresponse2.getcodeprintlenresponse2.readprint‘第三种方法’cj=cookielib.CookieJaropener=ur11ib2.build_openerur11ib2.HTTPCookieProcessorcjur11ib2.install_openeropenerresponse3=ur11ib2.urlopenur1printresponse3.getcodeprintcjprintresponse3.read```网页解析器Python有哪几种网页解析器？正则表达式：模糊匹配html.parser：结构化解析BeautifulSoup：结构化解析lxml：结构化解析BeautifulSoup安装：pipinstallbeautifulsoup4测试：importbs4解析步骤创建BeautifulSoup对象搜索节点findall、find按节点名称按节点属性值按节点文字访问节点：名称、属性、文字```pythonfrombs4importBeautifulSoup根据HTML网页字符串创建Beautifulsoup对象soup=BeautifulSouphtml_doc，HTML文档字符串'html.parse',HTML解析器from_encoding=‘utf8'HTML文档的编码方法：find_allname，attrs，string查找所有标签为a的节点soup.find_all'a'查找所有标签为a，链接符合/view/123.htm形式的节点soup.find_alla'，href=/view/123.htm'soup.find_all'a'，href=re.compiler\"/view/\\d+\\.html\"查找所有标签为div，class为abc，文字为Python的节点soup.find_alldiv'，class_=‘abc'，string=‘Python'得到节点：<ahref=‘1.htm12>Python</a>获取查找到的节点的标签名称node.name获取查找到的a节点的href属性node‘href2获取查找到的a节点的链接文字node.get_text```BeautifulSoup实例```pythonsoup=BeautifulSouphtml_doc，‘html.parser'，from_encoding='utf8'print‘获取所有的链接”1inks=soup.find_all'a'forlinkinlinks：printlink.name，link'href'，link.get_textprint‘获取Lacie的链接’linknode=soup.find'a'，href='example.com/Lacie'printlink_node.name，link_node'href'，link_node.get_textprint'正则匹配'link_node=soup.find'a',href=re.compiler\"ill\"print‘获P段落文字pnode=soup.find'p'，class_=\"title\"printp_node.name，p_nodel.get_text```Scrapy爬虫框架!_v_images/20191129175709.pngscrapy爬虫项目开发分成四步：新建项目、明确目标、制作爬虫、存储内容安装pipinstallscrapy编译Twised时需要VisualC++BuildTools，可以在这来下载安装：MicrosoftVisualC++BuildToolswww.xdowns.com/soft/38/138/2017/soft_226169.htmldownload_box新建scrapy项目新建项目`scrapystartprojectdouban`douban\\spiders进入douban\\spiders目录，执行：`scrapygenspiderdouban_spidermovie.douban.com`明确目标分析`movie.douban.com/top250`，需要抓取序号、电影名、导演、演员、星级、评价数、描述等。```python序号serial_number=scrapy.Field电影的名称movie_name=scrapy.Field电影的介绍introduce=scrapy.Field星级star=scrapy.Field电影的评论数evaluate=scrapy.Field电影的描述describe=scrapy.Field```爬虫文件编写（制作爬虫）```pythonclassDoubanSpiderSpiderscrapy.Spider:爬虫名称name='douban_spider'允许的域名allowed_domains='movie.douban.com'入口url，扔到调度器里面去start_urls='movie.douban.com/top250'defparseself,response:printresponse.text```进入douban\\spiders目录，执行：`scrapycrawldouban_spider`windows下运行会出现错误：>Couldnotfindaversionthatsatisfiestherequirementwin32apifromversions:Nomatchingdistributionfoundforwin32api解决办法：`pipinstallpypiwin32`远程运行，新建main.py```pythonfromscrapyimportcmdlinecmdline.execute'scrapycrawldouban_spider'.split```保存数据常见问题处理scrapy模拟登录代码演示及cookie原理说明www.jianshu.com/p/830ca5623211", "Coding/02-Python自动化测试.md": "TOCSeleniumPython+Selenium安装及环境配置python使用3.7.2，selenium版本为3.141.0，Firefox版本为52，Geckdriver版本：v0.15.0，chrome版本为73.0.3683.68，IE11，IEDriverServer_x64_3.8.0。IE11测试时，输入字符和动作太慢，跑一个用例需要很长时间，不建议使用。Selenium安装selenium版本为3.141.0```shellpipinstallselenium查看是否安装成功pipshowselenium```浏览器及驱动安装Firefox和chrome要选择合适的版本，版本低了高了都不行。驱动文件需要放在环境变量中，例如可以放在：%PYTHON_HOME%\\Scripts目录下。参考：selenium对应三大浏览器（谷歌、火狐、IE）驱动安装www.cnblogs.com/qiezizi/p/8632058.htmlFirefox使用52版没有出错Firefox需安装驱动：geckdriver，版本v0.15.0可用，版本v0.24.0不可用。下载地址：github.com/mozilla/geckodriver/releases?after=v0.17.0IEIE版本为11，项目需要这个版本，其它版本没有试过。IE11的驱动为：IEDriverServer_x64_3.8.0。版本3.9不可用，无法启动IE11。下载地址：seleniumrelease.storage.googleapis.com/index.html常出现的错误：>UnexpectederrorlaunchingInternetExplorer.Browserzoomlevelwassetto109%.Itshouldbesetto100%将浏览器的缩放调为100%，在状态栏可调>UnexpectederrorlaunchingInternetExplorer.ProtectedModesettingsarenotthesameforallzones.EnableProtectedModemustbesettothesamevalueenabledordisabledforallzones.将所有区域的保护模式勾选去掉即可，如下!_v_images/20191121204959.pngchromechrome版本为73.0.3683.68，对应驱动版本相同，下载地址：npm.taobao.org/mirrors/chromedriver/例子程序```pythonfromseleniumimportwebdriver导入webdriver包fromselenium.webdriver.common.keysimportKeysimporttimedriver=webdriver.Firefox初始化一个火狐浏览器实例：driverdriver=webdriver.Chrome初始化一个IE浏览器实例：driverdriver.maximize_window最大化浏览器time.sleep5暂停5秒钟driver.get\"www.baidu.com\"通过get方法，打开一个url站点driver.find_element_by_id\"kw\".clickdriver.find_element_by_id\"kw\".cleardriver.find_element_by_id\"kw\".send_keys\"java\"driver.find_element_by_id\"kw\".send_keysKeys.ENTER```控制已经打开的chromeChromeDevTools协议可以调试Chrome浏览器，利用它启动chrome后会打开一个端口，selenium通过此端口和chrome交互。`chrome.exeremotedebuggingport=9222userdatadir=\"C:\\selenum\\AutomationProfile\"``userdatadir`指定Chrome配置文件的目录，如果不指定，使用默认目录。不指定时，selenium控制代码如下：```python对应你的chrome的用户数据存放路径profile_dir=r\"C:\\Users\\xxxx\\AppData\\Local\\Google\\Chrome\\UserData\"chrome_options=webdriver.ChromeOptionschrome_options.add_experimental_option\"debuggerAddress\",\"127.0.0.1:9222\"chrome_options.add_argument\"userdatadir=\"+os.path.abspathprofile_dirdriver=webdriver.Chromechrome_options=chrome_options```KatalonRecorder插件安装KatalonRecorder是一个chrome浏览器插件，直接在扩展市场可以安装。安装完成后，可以像录制宏一样录制测试脚本，测试脚本可以导出为python等语言脚本。可以参考：KatalonRecorder自动录制Selenium爬虫脚本www.jianshu.com/p/52ed88e89b57Selenium编程技巧学习资料：SeleniumPython中文文档seleniumpythonzh.readthedocs.io/en/latest/locatingelements.html滚动浏览器屏幕只有在屏幕显示范围内元素，才能被点击等操作。所以要操作这些元素，必须把它的位置滚动到显示区域。方法如下：```python方法一element.location_once_scrolled_into_view此方法滚动不是很准确方法二driver.execute_script\"window.scrollTo0,document.body.scrollHeight;\"滚动一屏```多窗口、多frame切换多窗口切换：```pythondriver.get\"www.baidu.com\"获取百度搜索窗口句柄search_windows=driver.current_window_handle获取打开所有窗口句柄all_handles=driver.window_handlesforhandleinall_handles:ifhandle!=search_windows:driver.switch_to_windowhandle......driver.close关闭当前窗口driver.switch_to_windowsearch_windowsdriver.quit注销WebDriver，并关闭所有相关的窗口```多frame切换：```python通过frame的Id来切换，也可以element来切换driver.switch_to.frame'xURSiframe'.....driver.find_element_by_id\"dologin\".clickdriver.switch_to.default_content跳回最外层的页面```Elementisnotclickableatpoint错误及四种解决方法参考：selenium报错Elementisnotclickableatpoint及四种解决方法blog.csdn.net/lilongsy/article/details/76152620四种原因和解决办法：元素尚未加载让执行等待一会儿。```pythonfromselenium.webdriver.support.uiimportWebDriverWaitWebDriverWaitdriver,10.untilEC.title_contains\"元素\"```元素在iframe里元素在iframe里，在窗口里找是找不到元素的，更是无法点击。所以，要切换到iframe里去找元素。```pythondriver.switch_to_frame\"frameName\"根据框架名来切换driver.switch_to_frame\"frameName.0.child\"子框架driver.switch_to_default_content返回```元素不在显示窗里当元素不在浏览器的显示屏幕内，需要滚动屏幕，使之位于可视范围内。```python任选一种ele.location_once_scrolled_into_viewdriver.execute_script\"window.scrollTo0,document.body.scrollHeight;\"```要点击的元素被覆盖可以使用事件链来解决。例如下拉菜单，通过hover，让子菜单显示，就可以点击了。```pythonmenu=driver.find_element_by_css_selector\".nav\"hidden_submenu=driver.find_element_by_css_selector\".navsubmenu1\"ActionChainsdriver.move_to_elementmenu.clickhidden_submenu.perform```selenium中POST请求参考：selenium爬虫中的post坑www.freebuf.com/column/169007.html如果在selenium程序中，需要对一个rest接口发起POST请求，有三种方式：第三方库，如：seleniumrequests```pythonfromseleniumrequestsimportFirefoxwebdriver=Firefoxresponse=webdriver.request'POST','www.google.com/'printresponse```ajax```pythonbrower=webdriver.Firefoxfirefox_options=fireFoxOptionsjs=\"\"\"varxmlhttp=newXMLHttpRequest;xmlhttp.open\"GET\",\"127.0.0.1/get.php\",false;xmlhttp.setRequestHeader\"Contenttype\",\"application/xwwwformurlencoded\";xmlhttp.setRequestHeader\"UserAgent\",\"Mozilla/5.0\";xmlhttp.send\"test=1\";returnxmlhttp.responseText;\"\"\"brower.implicitly_wait30time.sleep30resp=brower.execute_scriptjs```拼接form表单其原理是解析了原生的post请求后，将其传递的参数重构为form表单，最后再将这些新生成的代码存入html网页。最后，程序会再借用selenium定位submit元素，触发事件提交表单。不推荐这种方式，太麻烦。", "Coding/09-二叉树建立与遍历.md": "算法原理：//先定义数据类型typedefstructBiTNode{chardata;//data你想用什么类型自己变就行了structBiTNode*lchild,*rchild;}BiTNode,*BiTree;//建树也用递归voidcreateTreechardata,BiTree&T//用引用{charc;c=getchar;ifc!=NULL{T=BiTreemallocsizeofBiTNode;T>data=c;createTreedata,lchild;createTreedata,rchild;}else{T=NULL;}}//这是先序建树，中序和后序只是变变顺序//遍历，这是后序，也是递归voidtraverseBiTreeT{ifT{traverseT>lchild;traverseT>rchild;printfT>data;}}//还是那样，先序和中序变一变这三句的顺序就行。下面是c语言的代码：include<stddef.h>include<stdio.h>typedefstructtree{structtree*left;intdate;structtree*right;}treenode,*b_tree;///////插入节点/////////////////////b_treeinsertb_treeroot,intnode{b_treenewnode;b_treecurrentnode;b_treeparentnode;newnode=b_treemallocsizeoftreenode;newnode>date=node;newnode>right=NULL;newnode>left=NULL;ifroot==NULLreturnnewnode;else{currentnode=root;whilecurrentnode!=NULL{parentnode=currentnode;ifcurrentnode>date>nodecurrentnode=currentnode>left;elsecurrentnode=currentnode>right;}ifparentnode>date>nodeparentnode>left=newnode;elseparentnode>right=newnode;}returnroot;}//////建立树///////////////////b_treecreateint*date,intlen{b_treeroot=NULL;inti;fori=0;i<len;i++root=insertroot,datei;returnroot;}//////中序打印////////////////voidprint1b_treeroot{ifroot!=NULL{print1root>left;printf\"%d>\",root>date;print1root>right;}}//////后序打印////////////////voidprint2b_treeroot{ifroot!=NULL{print2root>left;print2root>right;printf\"%d>\",root>date;}}//////前序打印////////////////voidprint3b_treeroot{ifroot!=NULL{printf\"%d>\",root>date;print3root>left;print3root>right;}}//////////在二叉树中查找给定关键字////////////b_treelookforb_treeroot,inte{b_treep1,p2;ifroot!=NULL{ifroot>date==ereturnroot;elsep1=lookforroot>left,e;p2=lookforroot>right,e;ifp1!=NULLreturnp1;elseifp2!=NULLreturnp2;elsereturnNULL;}elsereturnNULL;}main{intarr={1,2,3,4,5,6,7,8};b_treebt=createarr,sizeofarr/sizeofarr0;print1bt;printf\"\\n\";print2bt;printf\"\\n\";print3bt;printf\"\\n\";}", "Coding/09-字符串相似算法之Soundex.md": "概述Soundex是一种语音算法，利用英文的读音计算近似值，通过由四个字符组成的代码来评估两个字符串的相似性。定义Soundex字符串格式为一个字母加三个数字，生成规则如下：1、提取字符串的首字母作为Soundex的第一位。2、按照下表的规则，将剩余的字符进行替换，如果有连续的相等数字，则只保留一个，并去掉数字0。|字母|数字|||||aehiouwy|0||bfpv|1||cgjkqsxz|2||dt|3||l|4||mn|5||r|6|3、如果结果超过4位则取前4位，不足4位向后补0。示例soundex>s005302>s532algorithmic>a4206030502>a426352>a426答案", "Coding/09-排序算法.md": "TOC选择排序与冒泡排序**相同点**：每一轮都把最大或最小的元素筛选出来放在相应的位置上。**不同点**：冒泡排序每次比较和移动相邻的两项，而选择排序每次交换当前项和第n项。即是：```java//冒泡：fori:=1ton1doifai>ai+1thenswapi,i+1;//选择：fori:=1ton1doifai>anthenswapi,n;```总的来说，两种排序比较的次数是相同的，但交换的次数，选择排序是更少的。虽然两者的时间复杂度都是O（n^2但选择排序更快一点。选择排序```C/***每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。*/voidselection_sortintarr,intlen{intmax;forinti=len1;i>=1;i{max=i;//假定第i个元素的关键字最大forintj=0;j<i;j++//找最大元素的下标ifarrmax<arrjmax=j;ifmax!=i{//第i个元素和最大元素交换intt=arri;arri=arrmax;arrmax=t;}}}```冒泡排序```Cvoidbubble_sortintarr,intlen{forinti=1;i<len;i++{forintj=len1;j>=i;j{ifarrj<arrj1{intt=arrj1;arrj1=arrj;arrj=t;}}}}```快速排序快速排序的原理：以第一个记录为“枢轴”，查询记录序列，确定“枢轴“的位置。枢轴将待排序文件分成两部分：枢轴左面的记录的关键字都不大于它的关键字，而枢轴右面的记录的关键字都不小于它的关键字。对枢轴的左右两部分继续实施这一过程，直至全部文件有序。```Cintarr={14,10,11,5,6,15,0,15,16,14,0,8,17,15,7,19,17,1,18,7};/*swap函数：交换vk与vj的值*/inlinevoidswapintv,intk,intj{inttemp;temp=vk;vk=vj;vj=temp;}voidqsortintv,intleft,intright{intj,last;ifleft>=right/*若数组包含的元素个数少于两个*/return;/*则不执行任何操作*/last=left;/*用last记录中比关键字小间的最右位置*/forj=left+1;j<=right;j++{/*划分子集*/ifvj<vleft{swapv,++last,j;}}/*通过上述过程会形成关键字（中left所在位置）小小小...（last所在位置）大大大大（最后）*/swapv,left,last;/*恢复划分的元素*//*小小。。。。关键字大大大大*/qsortv,left,last1;qsortv,last+1,right;}voidmain{intj;qsortarr,0,19;forj=0;j<=19;j++{printf\"%d\",arrj;}printf\"\\n\";}```传统的快速排序是递归的，这就会受到递归栈深度的限制。比如在一台普通的PC上，当待排序元素达到10^6以上时，传统的递归快排会导致栈溢出异常，或者一个莫名其妙的错误结果。所以，对于巨大的数据规模，将快速排序消除递归是十分必要的。而消除递归，又将带来巨大的性能提升，把系统级的消耗降到最低。消除递归的方法，就是模拟栈操作。但是从代码可以看出，这种模拟的消耗几乎可以忽略不计。因此消除递归的快排的效率是有保障的。（虽然下面的代码没有使用随机化，但经过测试，它是目前所有快排编写方法中，效率最高，速度最快的！）```CdefineMAXARRAY10000definePUSHA,B{slsp=A;srsp=B;sp++;}definePOPA,B{sp;A=slsp;B=srsp;}voidquicksortinta,intl,intr{staticintslMAXARRAY,srMAXARRAY,sp;inti,j,p,t;sp=0;PUSHl,r;whilesp{POPl,r;i=l;j=r;p=ai+j/2;whilei<=j{whileai<pi++;whileaj>pj;ifi<=j{t=ai;ai=aj;aj=t;i++;j;}}ifl<jPUSHl,j;ifi<rPUSHi,r;}}```堆排序1.基本概念树形选择排序锦标赛排序，1964年威洛姆斯J.Willioms提出了进一步改正的排序方法，即堆排序heapsort。堆是n个元素的有限序列{K1,K2,…,Kn}，它当且仅当满足如下关系：这是一个上小、底大的堆。若是一个上大、底小的堆，只需把\"<=\"改为\">=\"即可。堆是一种数据元素之间的逻辑关系，常用向量做存储结构。对于满二叉树，当对它的结点由上而下，自左至右编号之后，编号为i的结点是编号为2i和2i+1结点的双亲。反过来讲，结点2i是结点i的左孩子，结点2i+1是结点i的右孩子。图9.7表示完全二叉树和它在向量中的存储状态。结点编号对应向量中的下标号。用堆的概念分析向量中的数据，它显然满足（上小、底大）堆的关系。不难看出满足堆的逻辑关系的一组数据，可画成二叉树的形状，并且它是一棵完全二叉树树形。因此，也可借助完全二叉树来描述堆的概念。若完全二叉树中任一非叶子结点的值小于等于（或大于等于）其左、右孩子结点的值，则从根结点开始按结点编号排列所得的结点序列就是一个堆。在图9.8中a、c是堆，b、d不是堆。2.算法思想堆排序利用了大根堆或小根堆堆顶记录的关键字最大或最小这一特征，使得在当前无序区中选取最大或最小关键字的记录变得简单。（1）用大根堆排序的基本思想①先将初始文件R1..n建成一个大根堆，此堆为初始的无序区②再将关键字最大的记录R1即堆顶和无序区的最后一个记录Rn交换，由此得到新的无序区R1..n1和有序区Rn，且满足R1..n1.keys≤Rn.key③由于交换后新的根R1可能违反堆性质，故应将当前无序区R1..n1调整为堆。然后再次将R1..n1中关键字最大的记录R1和该区间的最后一个记录Rn1交换，由此得到新的无序区R1..n2和有序区Rn1..n，且仍满足关系R1..n2.keys≤Rn1..n.keys，同样要将R1..n2调整为堆。……直到无序区只有一个元素为止。（2）大根堆排序算法的基本操作：①初始化操作：将R1..n构造为初始堆；②每一趟排序的基本操作：将当前无序区的堆顶记录R1和该区间的最后一个记录交换，然后将新的无序区调整为堆亦称重建堆。注意：①只需做n1趟排序，选出较大的n1个关键字即可以使得文件递增有序。②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻，堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。3.具体算法```Ctemplate<classT>Tr,intn{//n为文件的实际记录数，r0没有使用inti,m;nodex;fori=/2;i>=1;iheappassr,i,n;//初建堆//以下for语句为输出堆顶元素、调整堆操作form=n1;m>=1;m{//逻辑堆尾下标m不断变小cout<<r1.key<<\"\";x=r1;r1=rm+1;rm+1=x;//堆顶与堆尾元素对换heappassr,1,m;//恢复堆}cout<<r1.key<<endl;}//heapsort```", "Coding/09-文章整理分段.md": "题目说明文件【Java语言简介.txt】，内容如下：```Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程1。Java具有简单性、面向对象、安全性、平台独立与可移植性、多线程、动态性等特点2！Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等3。```请编写一个程序将这段文字格式化，要求如下：1.如果某一行以【。！】结尾，可认为是一段话结束，段与段之间空一行。2.一段内空行要求去掉，并把非【。！】结尾的行连接起来，放在一行。3.生成的新文件名在原文件后加上_new，即：【Java语言简介_new.txt】转换的结果如下：```Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程1。Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点2。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等3。```知识点1.文件读写：使用Java7以后的文件操作，并做一下总结。2.字符串处理：总结一下常用的字符串处理用法。3.循环控制语句的使用。答案```groovyimportorg.apache.commons.lang3.StringUtilsimportjava.nio.file.StandardOpenOption@Grab'org.apache.commons:commonslang3:3.7'importstaticorg.apache.commons.lang3.StringUtils.*importjava.nio.charset.Charsetimportjava.nio.file.Filesimportjava.nio.file.Pathsifthis.args.size<1{println\"NoInputFile!!!!!\"return}deffilePath=this.args0//deffilePath=\"1.txt\"defendStr=\".。!！?？」》节\".toCharArray.collect{String.valueOfit}deflines=Files.readAllLinesPaths.getfilePath,Charset.forName\"GBK\"deftext=newStringBuilderdefisEnd=truedefupLineIsEnd=falseforinti=0;i<lines.size;i++{Stringline=linesiifStringUtils.isBlankline{continue}line=stripEndline,null;isEnd=checkIsEndline,endStrifupLineIsEnd==false{line=stripStartline,null}text.appendlineifisEnd{text.append\"\\r\\n\\r\\n\"}upLineIsEnd=isEnd}Files.writePaths.get\"02.txt\",Arrays.asListtext,Charset.forName\"GBK\",StandardOpenOption.CREATE,StandardOpenOption.TRUNCATE_EXISTINGdefcheckIsEndStringline,endStr{defisEnd=falseforStringc:endStr{ifline.endsWithc{isEnd=truebreak;}}ifline.contains\"章\"||line.contains\"楔子\"{isEnd=true}returnisEnd}```", "Coding/Dive into Python - 笔记.md": "★字典keys,values和items函数>>>params={\"server\":\"mpilgrim\",\"database\":\"master\",\"uid\":\"sa\",\"pwd\":\"secret\"}>>>params.keys'server','uid','database','pwd'>>>params.values'mpilgrim','sa','master','secret'>>>params.items'server','mpilgrim','uid','sa','database','master','pwd','secret'★join方法和type方法>>>\";\".join\"%s=%s\"%k,vfork,vinparams.itemsjoin连接一个列表'server=mpilgrim;uid=sa;database=master;pwd=secret'>>>typeodbchelper==types.ModuleType可以使用types模块中的常量来进行对象类型的比较True★str方法>>>horsemen='war','pestilence','famine'>>>horsemen.append'Powerbuilder'>>>strhorsemen\"'war','pestilence','famine','Powerbuilder'\">>>strodbchelper\"<module'odbchelper'from'c:\\\\docbook\\\\dip\\\\py\\\\odbchelper.py'>\">>>strNone'None'★callable函数callable函数接收任何对象作为参数，如果参数对象是可调用的，返回True；否则返回False。可调用对象包括函数、类方法，甚至类自身。>>>importstring>>>string.punctuation'!\"$%&\\'*+,./:;<=>?@\\\\^_`{|}~'>>>string.join<functionjoinat00C55A7C>>>>callablestring.punctuationFalse>>>callablestring.joinTrue>>>printstring.join.__doc__任何对象都有docstringjoinlist,sep>stringReturnastringcomposedofthewordsinlist,withinterveningoccurrencesofsep.Thedefaultseparatorisasinglespace.joinfieldsandjoinaresynonymous★getattr函数介绍使用函数，可以返回任何对象的任何属性，并且这个属性的名称可以是直到运行时才知道（即可以是字符串）。>>>li=\"Larry\",\"Curly\">>>li.pop获取列表的pop方法的引用。是引用方法对象本身，而不是调用li.pop。<builtinmethodpopoflistobjectat010DF884>>>>getattrli,\"pop\"返回pop方法的引用，但是此时，方法名称是作为一个字符串参数传递给函数的。<builtinmethodpopoflistobjectat010DF884>>>>getattrli,\"append\"\"Moe\">>>li\"Larry\",\"Curly\",\"Moe\"例4.12.使用创建分发者statsout模块定义了三个函数：output_html、output_xml和output_text。然后主程序定义了唯一的输出函数，如下：importstatsoutdefoutputdata,format=\"text\":output_function=getattrstatsout,\"output_%s\"%formatreturnoutput_functiondata缺省值importstatsoutdefoutputdata,format=\"text\":下面的第三个参数是一个缺省返回值，如果第二个参数指定的属性或者方法没能找到，则将返回这个缺省返回值。output_function=statsout,\"output_%s\"%format,statsout.output_textreturnoutput_functiondata★列表方法count的使用>>>li=\"a\",\"mpilgrim\",\"foo\",\"b\",\"c\",\"b\",\"d\",\"d\">>>elemforeleminliifli.countelem==1count返回某个值在列表中出现的次数，可以用来剔除列表中出现两次以上的值本例中的b和d。'a','mpilgrim','foo','c'★filter方法的使用>>>deffx:returnx%2!=0andx%3!=0...>>>filterf,range2,25对224之间的整数运用函数fx，如果fx的运行结果是真，那么x就加入返回列表5,7,11,13,17,19,23★map方法的使用>>>defcubex:returnx*x*x...>>>mapcube,range1,11对应110之间的整数运用函数cubex，并把cubex的运行结果加入返回列表1,8,27,64,125,216,343,512,729,1000>>>seq=range8>>>defaddx,y:returnx+y...>>>mapadd,seq,seq0,2,4,6,8,10,12,14★reduce方法的使用>>>defaddx,y:returnx+y...>>>reduceadd,range1,11计算110的累加和55>>>defsumseq:...defaddx,y:returnx+y...returnreduceadd,seq,0第三个参数0，是表示列表seq的开始值...>>>sumrange1,1155>>>sum0★and和or布尔逻辑演算符and和or它们并不返回布尔值，而是返回它们实际进行比较的值之一。在布尔环境中从左到右演算表达式的值。0、''、、、{}、None在布尔环境中为假；其它任何东西都为真。>>>''and'b'如果布尔环境中的某个值为假，则and返回第一个假值''>>>'a'and'b'and'c'所有值都为真，所以and返回最后一个真值，'c''c'>>>'a'or'b'如果有一个值为真，or立刻返回该值'a'>>>''oror{}如果所有的值都为假，or返回最后一个假值{}>>>defsidefx:...print\"insidefx\"...return1>>>'a'orsidefx进行or运算时，会一直进行表达式演算直到找到第一个真值，然后就会忽略剩余的比较值。'a'★使用andor技巧>>>a=\"first\">>>b=\"second\">>>1andaorb1and'first'演算值为'first'，然后'first'or'second'的演算值为'first'。'first'>>>0andaorb0and'first'演算值为False，然后0or'second'演算值为'second'。'second'如果a为假，andor技巧和C语言中的bool?a:b语法非常重要的不同。>>>a=\"\">>>b=\"second\">>>1andaorb'second'★安全使用andor技巧>>>a=\"\">>>b=\"second\">>>1andaorb0由于a是一个非空列表，所以它决不会为假。即使a是0或者''或者其它假值，列表a也为真，因为它有一个元素。''★lambda方法>>>g=lambdax:x*2定义单行的最小函数>>>g36>>>lambdax:x*236processFunc=collapseandlambdas:\"\".joins.splitorlambdas:s这里使用了andor技巧的简单形式processFunc是一个函数的引用，但是它到底是哪一个函数还要取决于collapse变量。如果collapse为真，processFuncstring将压缩空白；否则processFuncstring将返回未改变的参数。★为什么对一个docstring使用str？>>>>>>deffoo:print2>>>>>>foo2>>>>>>foo.__doc__>>>foo.__doc__==NoneTrue>>>strfoo.__doc__'None'★ljust方法介绍>>>s='buildConnectionString'>>>s.ljust30ljust用空格填充字符串以符合指定的长度'buildConnectionString'>>>s.ljust20如果指定的长度小于字符串的长度，ljust将简单地返回未变化的字符串，而不会截断字符串。'buildConnectionString'classFileInfoUserDict:\"storefilemetadata\"def__init__self,filename=None:UserDict.__init__selfself\"name\"=filename在类的实例创建后被立即调用。它不是构造函数是因为对象在调用__init__时已经被构造出来了，你已经有了一个对类的新实例的有效引用。必须显示地调用在父类中的合适方法。__init__方法从不返回一个值。__init__方法是可选的>>>importfileinfo>>>f=fileinfo.FileInfo\"/music/_singles/kairo.mp3\">>>f.__class__<classfileinfo.FileInfoat010EC204>>>>f.__doc__'storefilemetadata'>>>f{'name':'/music/_singles/kairo.mp3'}每一个类的实例有一个内置属性，__class__，它是对象的类。这类元数据可以直接通过对象本身的属性，像__class__、__name__和__bases__来得到。你可以像对函数或模块一样来访问实例的docstring。classUserDict:def__init__self,dict=None:self.data={}ifdictisnotNone:self.updatedictupdate方法是一个字典复制器：它把一个字典中的键和值全部拷贝到另一个字典。这个操作并不事先清空目标字典，如果一些键在目标字典中已经存在，则它们将被覆盖，那些键名在目标字典中不存在的则不改变。应该把update看作是合并函数，而不是复制函数。例5.11.直接继承自内建数据类型dictclassFileInfodict:\"storefilemetadata\"def__init__self,filename=None:self\"name\"=filename第一个区别是你不需要导入UserDict模块，因为dict是已经可以使用的内建数据类型。第二个区别是你不是继承自UserDict.UserDict，而是直接继承自dict。第三个区别有些晦涩，但却很重要。UserDict内部的工作方式要求你手工地调用它的__init__方法去正确初始化它的内部数据结构。dict并不这样工作，它不是一个封装所以不需要明确的初始化。专用类方法__getitem__专用方法def__getitem__self,key:returnself.datakey>>>f=fileinfo.FileInfo\"/music/_singles/kairo.mp3\">>>f{'name':'/music/_singles/kairo.mp3'}>>>f.__getitem__\"name\"'/music/_singles/kairo.mp3'>>>f\"name\"'/music/_singles/kairo.mp3'暗地里，Python已经将这个语法转化为f.__getitem__\"name\"的方法调用。__setitem__专用方法>>>f\"genre\"=32>>>f暗地里调用了f.__setitem__\"genre\",32。__repr__在当调用reprinstance时被调用。repr函数是一个内置函数，它返回一个对象的字符串表示。它可以用在任何对象上，不仅仅是类的实例。相当于java的toString方法__cmp__在比较类实例时被调用。通常，你可以通过使用==比较任意两个Python对象，不只是类实例。对于类实例，你可以定义__cmp__方法，自已编写比较逻辑，然后你可以使用==来比较你的类，Python将会替你调用你的__cmp__专用方法。相当于java的equals，需要重载来实现自己的逻辑__len__在调用leninstance时被调用。对于类实例，定义__len__方法，接着自已编写长度的计算，然后调用leninstance，Python将替你调用你的__len__专用方法。__delitem__在调用delinstancekey时调用当你在类实例中使用del时，Python替你调用__delitem__专用方法。classMP3FileInfoFileInfo:\"storeID3v1.0MP3tags\"tagDataMap={\"title\":3,33,stripnulls,\"artist\":33,63,stripnulls,\"album\":63,93,stripnulls,\"year\":93,97,stripnulls,\"comment\":97,126,stripnulls,\"genre\":127,128,ord}>>>importfileinfo>>>fileinfo.MP3FileInfo<classfileinfo.MP3FileInfoat01257FDC>>>>fileinfo.MP3FileInfo.tagDataMap{'title':3,33,<functionstripnullsat0260C8D4>,'genre':127,128,<builtinfunctionord>,'artist':33,63,<functionstripnullsat0260C8D4>,'year':93,97,<functionstripnullsat0260C8D4>,'comment':97,126,<functionstripnullsat0260C8D4>,'album':63,93,<functionstripnullsat0260C8D4>}>>>m=fileinfo.MP3FileInfo>>>m.tagDataMaptagDataMap是一个类属性：字面的意思，一个类的属性。它在创建任何类实例之前就有效了。类属性既可以通过直接对类的引用，也可以通过对类的任意实例的引用来使用。>>>f.seek128,2>>>f.tell7542909>>>tagData=f.read128文件对象的seek方法在被打开文件中移动到另一个位置。第二个参数指出第一个参数是什么意思：0表示移动到一个绝对位置从文件起始处算起，1表示移到一个相对位置从当前位置算起，还有2表示相对于文件尾的位置。tell方法确认了当前位置已经移动了。可选参数指定了读取的最大字节数。如果没有指定参数，read将读到文件末尾。>>>f.closedFalse例6.14.__module__类属性>>>fromfileinfoimportMP3FileInfo>>>MP3FileInfo.__module__'fileinfo'>>>sys.modulesMP3FileInfo.__module__<module'fileinfo'from'fileinfo.pyc'>每个Python类都拥有一个内置的类属性__module__，它定义了这个类的模块的名字。将它与sys.modules字典复合使用，你可以得到定义了某个类的模块的引用。hasattr是一个补充性的函数，用来检查一个对象是否具有一个特定的属性；>>>importos>>>os.path.join\"c:\\\\music\\\\ap\\\\\",\"mahadeva.mp3\"'c:\\\\music\\\\ap\\\\mahadeva.mp3'>>>os.path.join\"c:\\\\music\\\\ap\",\"mahadeva.mp3\"'c:\\\\music\\\\ap\\\\mahadeva.mp3'>>>os.path.expanduser\"~\"'c:\\\\DocumentsandSettings\\\\mpilgrim\\\\MyDocuments'os.path的join函数把一个或多个部分路径名连接成一个路径名。expanduser将对使用~来表示当前用户根目录的路径名进行扩展。例6.17.分割路径名>>>os.path.split\"c:\\\\music\\\\ap\\\\mahadeva.mp3\"'c:\\\\music\\\\ap','mahadeva.mp3'>>>filepath,filename=os.path.split\"c:\\\\music\\\\ap\\\\mahadeva.mp3\">>>filepath'c:\\\\music\\\\ap'>>>filename'mahadeva.mp3'>>>shortname,extension=os.path.splitextfilename>>>shortname'mahadeva'>>>extension'.mp3'split函数对一个全路径名进行分割，返回一个包含路径和文件名的tuple。os.path也包含了一个splitext函数，可以用来对文件名进行分割，并且返回一个包含了文件名和文件扩展名的tuple。例6.18.列出目录>>>fforfinos.listdirdirname...ifos.path.isfileos.path.joindirname,f'AUTOEXEC.BAT','boot.ini','CONFIG.SYS','IO.SYS','MSDOS.SYS','NTDETECT.COM','ntldr','pagefile.sys'>>>fforfinos.listdirdirname...ifos.path.isdiros.path.joindirname,f'cygwin','docbook','DocumentsandSettings','Incoming','Inetpub','Music','ProgramFiles','Python20','RECYCLER','SystemVolumeInformation','TEMP','WINNT'listdir同时返回文件和文件夹，并不指出哪个是文件，哪个是文件夹。我们使用os.path.join来确保得到一个全路径名，但isfile对部分路径相对于当前目录也是有效的。你可以使用os.getcwd来得到当前目录。fileList=os.path.normcasefforfinos.listdirdirectoryos.path.normcasef根据操作系统的缺省值对大小写进行标准化处理。在Windows和MacOS下，normcase将把整个文件名转换为小写字母；而在UNIX兼容的系统下，它将返回未作修改的文件名。>>>importglob>>>glob.glob'c:\\\\music\\\\_singles\\\\*.mp3''c:\\\\music\\\\_singles\\\\a_time_long_forgotten_con.mp3','c:\\\\music\\\\_singles\\\\hellraiser.mp3','c:\\\\music\\\\_singles\\\\kairo.mp3','c:\\\\music\\\\_singles\\\\long_way_home1.mp3','c:\\\\music\\\\_singles\\\\sidewinder.mp3','c:\\\\music\\\\_singles\\\\spinning.mp3'>>>glob.glob'c:\\\\music\\\\_singles\\\\s*.mp3''c:\\\\music\\\\_singles\\\\sidewinder.mp3','c:\\\\music\\\\_singles\\\\spinning.mp3'>>>glob.glob'c:\\\\music\\\\*\\\\*.mp3'glob模块，另一方面，接受一个通配符并且返回文件的或目录的完整路径与之匹配。例8.10.locals介绍>>>deffooarg:...x=1...printlocalslocals\"x\"=2print\"x=\",x这样会打印出x=1，而不是x=2。...>>>foo7{'arg':7,'x':1}函数foo在它的局部名字空间中有两个变量：arg它的值是被传入函数的和x它是在函数里定义的。locals实际上没有返回局部名字空间，它返回的是一个拷贝。所以对它进行改变对局部名字空间中的变量值并无影响。例8.11.globals介绍看看下面列出的在文件BaseHTMLProcessor.py尾部的代码块：if__name__==\"__main__\":fork,vinglobals.items:printk,\"=\",vglobals函数返回一个dictionary，globals返回实际的全局名字空间，而不是一个拷贝：与locals的行为完全相反。所以对globals所返回的dictionary的任何的改动都会直接影响到全局变量。例8.12.locals是只读的，globals不是deffooarg:x=1printlocalslocals\"x\"=2print\"x=\",xz=7print\"z=\",zfoo3globals\"z\"=8print\"z=\",z例8.13.基于dictionary的字符串格式化介绍>>>params={\"server\":\"mpilgrim\",\"database\":\"master\",\"uid\":\"sa\",\"pwd\":\"secret\"}>>>\"%pwds\"%params'secret'>>>\"%pwdsisnotagoodpasswordfor%uids\"%params'secretisnotagoodpasswordforsa'XML解析>>>fromxml.domimportminidom>>>xmldoc=minidom.parse'~/diveintopython/common/py/kgp/binary.xml'>>>xmldoc<xml.dom.minidom.Documentinstanceat010BE87C>>>>printxmldoc.toxml<?xmlversion=\"1.0\"?><grammar><refid=\"bit\"><p>0</p><p>1</p></ref><refid=\"byte\"><p><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/>\\<xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/></p></ref></grammar>minidom.parse接收一个参数本地磁盘上一个XML文档的文件名。你需要将路径改为指向下载的例子所在的目录。但是你也可以传入一个文件对象，或甚至是一个类文件对象。从minidom.parse返回的对象是一个Document对象，它是Node类的一个子对象。toxml是Node类的一个方法toxml打印出了Node表示的XML。对于Document节点，这样就会打印出整个XML文档。>>>xmldoc.childNodes<DOMElement:grammarat17538908>>>>xmldoc.childNodes0得到第一个在本例中，只有一个子节点<DOMElement:grammarat17538908>>>>xmldoc.firstChild<DOMElement:grammarat17538908>每个Node都有一个childNodes属性，它是一个Node对象的列表。一个Document只有一个子节点，即XML文档的根元素Node类有一个firstChild属性，它和childNodes0具有相同的语义。还有一个lastChild属性，它和childNodes1具有相同的语义。例9.10.toxml用于任何节点>>>grammarNode=xmldoc.firstChild>>>printgrammarNode.toxml<grammar><refid=\"bit\"><p>0</p><p>1</p></ref><refid=\"byte\"><p><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/>\\<xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/></p></ref></grammar>每一个Node类都有toxml方法例9.11.子节点可以是文本>>>grammarNode.childNodes<DOMTextnode\"\\n\">,<DOMElement:refat17533332>,\\<DOMTextnode\"\\n\">,<DOMElement:refat17549660>,<DOMTextnode\"\\n\">>>>printgrammarNode.firstChild.toxml>>>printgrammarNode.childNodes1.toxml<refid=\"bit\"><p>0</p><p>1</p></ref>>>>printgrammarNode.childNodes3.toxml<refid=\"byte\"><p><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/>\\<xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/></p></ref>>>>printgrammarNode.lastChild.toxml查看binary.xml中的XML，你可能会认为grammar只有两个子节点，即两个ref元素。但是你忘记了一些东西：硬回车！在'<grammar>'之后，第一个'<ref>'之前是一个硬回车，并且这个文本算作grammar元素的一个子节点。类似地，在每个'</ref>'之后都有一个硬回车；它们都被当作子节点。所以grammar.childNodes实际上是一个有5个对象的列表：3个Text对象和两个Element对象。第一个子节点是一个Text对象，它表示在'<grammar>'标记之后、第一个'<ref>'标记之后的硬回车。第二个子节点是一个Element对象，表示了第一个ref元素。第四个子节点是一个Element对象，表示了第二个ref元素。最后一个子节点是一个Text对象，表示了在'</ref>'结束标记之后、'</grammar>'结束标记之前的硬回车。>>>reflist=xmldoc.getElementsByTagName'ref'>>>reflist<DOMElement:refat136138108>,<DOMElement:refat136144292>>>>printreflist0.toxml<refid=\"bit\"><p>0</p><p>1</p></ref>>>>printreflist1.toxml<refid=\"byte\"><p><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/>\\<xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/></p></ref>例9.22.每个元素都是可搜索的>>>firstref=reflist0>>>printfirstref.toxml<refid=\"bit\"><p>0</p><p>1</p></ref>>>>plist=firstref.getElementsByTagName\"p\">>>plist<DOMElement:pat136140116>,<DOMElement:pat136142172>>>>printplist0.toxml<p>0</p>>>>printplist1.toxml<p>1</p>例9.23.搜索实际上是递归的>>>plist=xmldoc.getElementsByTagName\"p\">>>plist<DOMElement:pat136140116>,<DOMElement:pat136142172>,<DOMElement:pat136146124>>>>plist0.toxml'<p>0</p>'>>>plist1.toxml'<p>1</p>'>>>plist2.toxml'<p><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/>\\<xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/><xrefid=\"bit\"/></p>'例9.24.访问元素属性>>>xmldoc=minidom.parse'binary.xml'>>>reflist=xmldoc.getElementsByTagName'ref'>>>bitref=reflist0>>>printbitref.toxml<refid=\"bit\"><p>0</p><p>1</p></ref>>>>bitref.attributes<xml.dom.minidom.NamedNodeMapinstanceat0x81e0c9c>>>>bitref.attributes.keysu'id'>>>bitref.attributes.values<xml.dom.minidom.Attrinstanceat0x81d5044>>>>bitref.attributes\"id\"<xml.dom.minidom.Attrinstanceat0x81d5044>每个Element对象都有一个attributes属性，它是一个NamedNodeMap对象。NamedNodeMap是一个行为像字典的对象再次将NamedNodeMap视为一个字典，你可以通过attributes.values获取属性值的一个列表。这些值本身是Attr类型的对象。>>>a=bitref.attributes\"id\">>>a<xml.dom.minidom.Attrinstanceat0x81d5044>>>>a.nameu'id'>>>a.valueu'bit'Attr对象完整代表了单个XML元素的单个XML属性。StringIO可以把字符串转换成类文件对象，那么你只要这个对象传递给minidom.parse就可以了。例10.5.解析字符串XML类文件对象方式>>>contents=\"<grammar><refid='bit'><p>0</p><p>1</p></ref></grammar>\">>>ssock=StringIO.StringIOcontents>>>xmldoc=minidom.parsessock>>>ssock.close>>>printxmldoc.toxml<?xmlversion=\"1.0\"?><grammar><refid=\"bit\"><p>0</p><p>1</p></ref></grammar>stdout.pyimportsysprint'Divein'saveout=sys.stdoutfsock=open'out.log','w'sys.stdout=fsockprint'Thismessagewillbeloggedinsteadofdisplayed'sys.stdout=saveoutfsock.close始终在重定向前保存stdout，这样的话之后你还可以将其设回正常。所有后续的输出都会被重定向到刚才打开的新文件上。它设回原来的方式。stderr.pyimportsysfsock=open'error.log','w'sys.stderr=fsockraiseException,'thiserrorwillbelogged'引发一个异常。从屏幕输出上可以注意到这个行为没有在屏幕上打印出任何东西。所有正常的跟踪信息已经写进error.log。还要注意你既没有显式关闭日志文件，也没有将stderr设回最初的值。这样挺好，因为一旦程序崩溃由于引发的异常，Python将替我们清理并关闭文件，因此永远不恢复stderr不会造成什么影响。然而对于stdout，恢复初始值相对更为重要DD你可能会在后面再次操作标准输出。>>>importsys>>>print>>sys.stderr,'enteringfunction'enteringfunctionprint语句的快捷语法可以用于写入任何打开的文件或者是类文件对象。在这里，你可以将单个print语句重定向到stderr而且不用影响后面的print语句。", "Coding/eclipse使用指南.md": "1.常用快捷键查找导航Search>File>FileSearchCTRL+O显示当前类的所有方法，再次输入显示继承的方法Ctrl+Shift+G查看方法在哪里被调用了ALT+←定位上一个编辑位置ALT+→定位下一个编辑位置Ctrl+K查找选中字符串的下一个Ctrl+Shift+K查找选中字符串的上一个Ctrl+Shift+U查看变量在哪里被引用了Ctrl+L定位行号CTRL+E从已打开的编辑器中查找编辑器编辑Alt+Up/DownCtrl+D删除行Ctrl+Alt+Up/Down复制行Shift+Enter在当前行之下创建一个空白行Ctrl+Shift+Enter则在当前行之前插入空白行Ctrl+Shift+X转大写Ctrl+Shift+Y转小写Alt+Shift+A进入列编辑模式编程Ctrl+2，L为本地变量赋值ctrl+.及ctrl+1下一个错误及快速修改Ctrl+Shit+O优化导入importCtrl+Shift+Down切换类中方法的上一个Ctrl+Shift+Up切换类中方法的下一个窗口显示Ctrl+M最大化编辑器Window>NewWindow多窗口编辑，用熟之后，会发现蛮高效的Alt+Shift+QC当编辑窗口最大时，快速打开ConsoleAlt+Shift+T显示Refactor菜单（=右键>Refactor）69Alt+Shift+S显示Source菜单（=右键>Source）69其它Ctrl+B进行build（一般取消了自动build）2.eclipse必备插件eExplorer`culmat.github.io/eExplorer/updatesite/`QuickBookmarksplugin和GrepConsole`eclipse.schedenig.name`EclipseWebDevelopmentToolsEclipseJettyEnhancedClassDecompilerJRebelHTMLEditorUMLPlugin:**ObjectAidUML**：类图很好，时序图要收费。www.objectaid.com/update/current**AmaterasUML**：图不能隐藏Attributes和Operations，时序图不能从代码反向生成，完全需要手动完成。我们真的需要完全从代码生成的SequenceDiagram吗？手动也不错，能按照编码者的意愿画图。github.com/takezoe/amaterasmodeler**ModelGoon**:官网被GFW屏蔽了，在国内有下载。作者崇尚AgileModeling，支持包依赖图，类图，交互图，时序图。类图不支持隐藏Attributes和Operations，时序图要从方法生成，作用也不到。3.常见问题Pineditortab固定tabinEclipse4.6.3inordertogetthepiniconinthetoolbaryouneedtocheckthe\"closeeditorsautomatically\"optionPreferences>General>Editors.经常导入项目失败，清理以下目录：WORKSPACE\\.metadata\\.plugins\\org.eclipse.core.resources\\.projects安装ServerRuntimeEnvironment在线安装：download.eclipse.org/releases/neon，选择安装JSTServerAdapters和JSTServerAdaptersExtensions安装plugin过慢1.打开WindowsPreferences配置窗口，找到Install/UpdateCAvailableSoftwareSites，将里面不用的信息删除，将本次更新不需要的停用（选中之后然后点右边的Disable按钮）。2.在在线安装插件的Install窗口，将下面的Contactallupdatesitesduringinstalltofindrequiredsoftware前面的选项去掉。", "Coding/eclipse插件开发.md": "TOCEclipse平台介绍SWT/JFace和SWT相似的技术是什么？JFace与SWT的关系？swt工具箱插件技术和OSGI插件延迟加载怎么实现的？扩展的声明和实现分离eclipse3.0做了什么重构？OSGI实现新的框架名为EquinoxOSGI的优点？分解为小的可重用组件动态的增删模块RCP技术什么是RCP？富客户端开发平台RCP优点？继承Eclipse的UI和Runtime模块基于OSGI基于SWT/JFace可以添加其他插件EMF技术EMF是什么？解决什么问题？帮用户实现UML建模，并辅助实现代码。适用于模型驱动的程序GEF技术GEF是什么？基于SWT的轻量级绘图系统插件探测器（PluginSpy）Shift+Alt+F1查看eclipse各个视图的源码按下Shift+Alt+F2键，此时鼠标再点击工具栏按钮或菜单项，同样可以调出插件探测器主界面。eclipse源码使用指南模板概览“Templates”向导页包含11个典型示例模板，清单如下：1.Hello，World2.Hello，WorldCommand3.ODADataSourceDesigner（ODA数据源设计器示例）4.ODADataSourceRuntimeDriver（ODA数据源运行时驱动示例）5.Pluginwithamultipageeditor多页编辑器示例）6.Pluginwithapopupmenu（弹出菜单示例）7.Pluginwithapropertypage（属性页示例）8.Pluginwithaview（自定义视图示例）9.Pluginwithaneditor（编辑器示例）10.Pluginwithanincrementalprojectbuilder（工程项目编译器示例）11.Pluginwithsamplehelpcontent（上下文帮助示例）“TemplateSelection”向导页包含17典型示例模板（涉及16个扩展点），扩展点清单如下：1.org.eclipse.core.resources.builders2.org.eclipse.ui.navigator.CommonNavigator3.org.eclipse.ui.decorators4.org.eclipse.ui.editors5.org.eclipse.ui.commands6.org.eclipse.ui.actionSets7.org.eclipse.help.toc8.org.eclipse.ui.importWizards9.org.eclipse.ui.newWizards10.org.eclipse.ui.perspectives11.org.eclipse.ui.popupMenus12.org.eclipse.ui.PreferencePages13.org.eclipse.ui.propertyPages14.org.eclipse.ui.splashHandlers15.org.eclipse.ui.intro.configExtension16.org.eclipse.ui.views扩展项（Extension）“ExtensionWizards”插件源码导入在插件开发透视图中（PluginDevelopment），默认有一个插件视图（Plugins），该视图用于呈现当前Eclipse开发环境下的插件清单，清单包含当前工作区（workspace）中已打开的插件工程项目。!_v_images/20191121204542.png启动Eclipse，通过File菜单的“Import…”菜单项调出导入向导。Ctrl+Shift+A!_v_images/20191121204600.pngtycho使用flowabledesigner导入eclipse，eclipse必须安装graphiti的0.13.2版本：archive.eclipse.org/graphiti/updates/0.13.2blog.csdn.net/soszou/article/details/12775101Tycho则是一群Eclipse、OSGi插件开发人员受不了重复地配置类似的Mavenpom.xml而创造出来的。Tycho大大简化了Eclipse、OSGi插件中的pom.xml，它实际上是一系列专用于buildEclipse插件和OSGi模块的maven插件的集合。Tycho牛逼之处就在于它可以读懂这些metadata，这样程序员就不需要在pom文件里面重新定义一遍。不止如此，为了避免程序员乌龙地在MANIFEST文件和pom文件里面定义的依赖出现冲突，Tycho甚至规定所有的依赖必须定义于MANIFEST文件中（不然没法编译），出现在pom文件中的依赖一律直接被忽略。为了优化对Eclipse插件和OSGi模块的build，Tycho提供了专门的packaging，用来处理专门的模块生命周期，最典型的比如eclipserepository，配合tychop2directorplugin，直接就可以读懂product文件，build整个EclipseRCP的product。PS:feature是插件的集合，我们在给Eclipse安装插件的时候往往安装的是feature，而不是安装一个个的pluginjar官方文档：www.eclipse.org/tycho/documentation.php例子：github.com/jsievers/tychodemoeclipse插件开发tycho使用:ju.outofmemory.cn/entry/260944升级版本号：在根目录执行mvnDtycho.mode=mavenorg.eclipse.tycho:tychoversionsplugin:setversionDnewVersion=1.6.0即可全部替换pom和plugin的版本号如果项目导入后在eclipse中报错，一般是因为缺少了上面说的那个依赖。可以直接复制到eclipse的plugin依赖目录。或者在mvncleaninstall之后，通过安装依赖feature的方式解决。教程BuildingJavaOSGiProjectwithMavenandTychoo7planning.org/en/10137/buildingjavaosgiprojectwithmavenandtychoEclipseTychoforbuildingplugins,OSGibundlesandEclipseapplicationsTutorialwww.vogella.com/tutorials/EclipseTycho/article.htmleclipse插件开发教程EclipseIDEPluginDevelopment:Plugins,Features,UpdateSitesandIDEExtensionswww.vogella.com/tutorials/EclipsePlugin/article.htmlEclipseRCPRichClientPlatformTutorialwww.vogella.com/tutorials/EclipseRCP/article.html", "Coding/Git常用命令.md": "TOCGit推送和删除远程标签Git的推送和删除远程标签命令是相同的，删除操作实际上就是推送空的源标签refs。gitpushorigin标签名等同于如下操作：gitpushoriginrefs/tags/源标签名:refs/tags/目的标签名1、推送标签：gitpushorigin标签名2、删除本地标签：gittagd标签名3、删除远程标签：gitpushorigin:refs/tags/标签名例：gitpushorigin:refs/tags/V3.0.1Release4、其他本地操作打标签：gittagaV3.0.1Releasem\"Taggingversion3.0.1Release\"删除本地仓库标签：gittagdV3.0.1Release列出标签：gittag升级git后，出现fatal:NullReferenceExceptionencountered.出现错误：```fatal:NullReferenceExceptionencountered.error:unabletoreadaskpassresponsefrom'C:\\ProgramFiles\\TortoiseGit\\bin\\SshAskPass.exe'```git和tortoiseGit都不能记住用户名密码了。修复方法如下：```shellgitconfigcredential.helperstoregitconfigunsetcredential.helpergitconfigglobalcredential.helperstore```升级后的git版本为2.19.1，参考：stackoverflow.com/questions/5343068/isthereawaytoskippasswordtypingwhenusinghttpsongithubcheckout子目录以github.com/geekhac/to...子目录为例：gitinittodomvc&&cdtodomvcgitconfigcore.sparsecheckouttrue//设置允许克隆子目录echo'/examples/react/*'>>.git/info/sparsecheckout//设置要克隆的仓库的子目录路径gitremoteaddorigingithub.com/geekhac/to...gitpulloriginmaster强制更新gitfetchallgitresethardorigin/master", "Coding/Gradle常用.md": "TOCGradle介绍1纲要1.1Repository```groovyrepositories{//mavenLocalmaven{url\"maven.aliyun.com/repository/public\"}//maven{url\"192.168.31.200:8081/nexus/content/groups/public/\"}}```1.2pluginapplyplugin:\"java\"applyplugin:\"eclipse\"applyplugin:\"eclipsewtp\"applyplugin:\"idea\"1.3dependencygroup:name/artifact:version查看：192.168.0.207:8081/nexus/content/groups/public/几种Scope：compile,runtime,testCompile,testRuntime```groovyapplyplugin:'java'repositories{mavenCentral}dependencies{compileproject':shared'testCompile'junit:junit:4.11'runtimefiles'libs/a.jar','libs/b.jar'runtimefileTreedir:'libs',include:'*.jar'}```排除传递依赖```groovyconfigurations{compile.excludemodule:'commons'all*.excludegroup:'org.gradle.test.excludes',module:'reports'}dependencies{compile\"org.gradle.test.excludes:api:1.0\"{excludemodule:'shared'}compile\"com.alibaba:dubbo:2.5.3\"{transitive=false}}```查看依赖Tree：gradledependencies>dependencies.txt1.4task默认任务```groovyE:\\gradle_project>gradlebuild:compileJava:processResources:classes:jar:assemble:compileTestJava:processTestResources:testClasses:test:check:buildBUILDSUCCESSFUL```自定义任务```groovytaskhello<<{//<<向Task的actions集合里添加Actionprintln'Hello2'}hello.doFirst{println'Hello1'}hello.doLast{println'Hello3'}hello<<{println'Hello4'}```**指定任务类型**:通过参数type指定该task的类型后，就可以使用该类型task提供的特殊变量或函数。```groovytaskcopyDocstype:Copy{from'src/main/doc'into'build/target/doc'}```**Task依赖**```groovytaskscpdependsOn:assemble{......}taskX.dependsOntaskY```2重点创建项目`gradleinittypejavalibrary`创建java项目`gradleinittypepom`转换maven项目常用指令gradleassemblegradlebuildgradledependenciesgradlecleangradlejargradlewargradlecheckgradletestgradleclasses变量与字符串\"$username\"vs'$username'\"${project.name}\"vs\"$project.name\"常用属性project.name可简写为$name,$name在Task中表示taskNameproject.version```groovyversion='1.0'buildDir=\"target\"sourceSets{main{java{srcDir'src/java'}resources{srcDir'src/resources'}output.resourcesDir=\"${buildDir}/classes/main\"}}```定义属性查看属性：gradlepropertiesSystemProperties:指JVM的systempropertiesgradlexxxDmySystemProp=xxxxProjectProperties:Gradle专门为Project定义的属性```groovygradlexxxPmyProjectProp=xxxxxifproject.hasProperty\"profile\"{//System.setProperty\"spring.profiles.active\",project\"profile\"profile=project\"profile\"}```ExtProperties:动态属性```groovyext{ifproject.hasProperty\"profile\"{profile=project\"profile\"}else{profile=\"dev\"}profiles=\"dev\",\"prod\",\"demo\"serverRoot=\"tomcat_dip\"}```多项目构建多项目定义及结构settings.gradle```groovyinclude'dipappboxservice'include'dipappboxweb'include'idbpres';project\":idbpres\".projectDir=file\"../idbpres\"include'idbpportal';project\":idbpportal\".projectDir=file\"../idbpcore/idbpportal\"```多项目的集中配置allprojects{xxx}这段代码表示，对于所有的projectsubprojects{xxxx}的这段代码表示，对于所有的子projectproject':core'{xxxx}多项目的Task执行```groovyallprojects{taskhello<<{println\"helloworld\"}}```gradlehello:在所有项目上执行gradle:core:hello:仅在core项目上执行，等效于进入core项目根目录，直接执行gradlehello包含文件applyfrom:\"./libraries.gradle\"几个常用插件applyplugin:'mavenpublish'scp```groovyconfigurations{sshAntTask}dependencies{sshAntTask\"org.apache.ant:antjsch:1.7.1\",\"jsch:jsch:0.1.29\"}taskscpdependsOn:assemble{doLast{ant.taskdefname:'sshexec',classname:'org.apache.tools.ant.taskdefs.optional.ssh.SSHExec',classpath:project.configurations.sshAntTask.asPathant.sshexechost:\"${serverIP}\",username:\"${serverAccount}\",password:\"${serverPwd}\",command:\"cd${serverRoot}/appbox/;/bin/bashl./shutdown.sh;rmrfwebapps/ROOT*;rmrfwork;\",trust:'true',failonerror:'true'ant.taskdefname:\"scp\",classname:\"org.apache.tools.ant.taskdefs.optional.ssh.Scp\",classpath:configurations.sshAntTask.asPathant.scptodir:\"${serverAccount}:${serverPwd}@${serverIP}:~/${serverRoot}/appbox/webapps\",trust:true{filesetdir:\"${project.buildDir}/libs\"{includename:\"**/*.war\"//inasaparametertothe}}ant.sshexechost:\"${serverIP}\",username:\"${serverAccount}\",password:\"${serverPwd}\",command:\"cd${serverRoot}/appbox/;/bin/bashl./startup.sh\",trust:'true',failonerror:'true'}}```", "Coding/IntelliJ Idea 常用.md": "TOC快捷键十大IntellijIDEA快捷键blog.csdn.net/dc_726/article/details/42784275IntellijIDEA的快捷键、常用技巧和相关设置zyjustin9.iteye.com/blog/2173093查找导航Ctrl+N查找类Ctrl+Shift+N查找文件Ctrl+F查找文本Ctrl+Shift+F查找文本Ctrl+F12启动类Eclipse的\"QuickOutline\"功能编辑Ctrl+Shift+Up/DownAlt+Shift+Up/DownCtrl+X剪切行Ctrl+Y删除行Ctrl+D复制行编程Alt+Enter快速修复，引入局部变量Shift+F6重构重命名Ctrl+P方法参数提示Ctrl+Q显示注释文档Tab键补全代码Ctrl+Alt+O优化导入的类和包idea实现类似eclipse的OrganizeImports的功能：Settings>Editor>General>AutoImport，勾上Optimizeimportsonthefly和AddunambiguousimportsontheflyCtrl+Alt+Shift+N在整个项目内查找变量或方法，也可以使用Navigate|Symbol菜单Ctrl+Alt+L格式化代码Alt+Insert生成代码如get,set方法,构造函数等Ctrl+E或者Alt+Shift+C最近更改的代码Ctrl+R替换文本Ctrl+Shift+Space自动补全代码Ctrl+空格代码提示Ctrl+Alt+Space类名或接口名提示Ctrl+Shift+Alt+N查找类中的方法或变量Alt+Shift+C对比最近修改的代码Ctrl+/或Ctrl+Shift+/注释（//或者/*...*/）Ctrl+J自动代码Ctrl+E最近打开的文件Ctrl+H显示类结构图Alt+F1查找代码所在位置Alt+1快速打开或隐藏工程面板Ctrl+Alt+left/right返回至上次的位置Alt+left/right切换代码视图Alt+Up/Down在方法间快速移动定位F2或Shift+F2移动到有错误的代码选中文本，按Ctrl+Shift+F7，高亮显示所有该文本，按Esc高亮消失。Ctrl+W选中代码，连续按会有其他效果选中文本，按Alt+F3，逐个往下查找相同文本，并高亮显示。Ctrl+Up/Down光标跳转到第一行或最后一行下Ctrl+B快速打开光标处的类或方法激活服务idea.liyang.ioidea.uri.ci", "Coding/JRebel安装及使用.md": "TOCidea安装JRebel安装在Settings>plugins查找jrebel然后安装激活在jrebelserver处，写上：139.199.89.239:1008/884146873b91428689ba2dc813b107ce如果出现激活过期的情况，请重新生成guid，替换原来的guid即可邮箱随便写，即可激活。参考：Jrebel激活服务blog.csdn.net/cjwcjwwjcwjc/article/details/80050633配置1.Idea中ctrl+shift+a，在弹出浮层中输入registry；2.进入如下界面，将compiler.automake.allow.when.app.running选中,退出该界面。3.再设置idea为自动编译。settings>Build,Execution,Deployment>Compiler选中：Buildprojectautomatically和Compileindependentmodulesinparallel4.项目中配置Jrebel：在项目的src/resources文件夹右键,弹出菜单最下边JReble>rebel.xml5.在启动类中右键,使用JrebelDebug或者Run进行启动参考：使用jRebel在IntelliJIDEA中进行Java热部署blog.csdn.net/liuzhigang828/article/details/72875190eclipse安装JRebel安装在EclipseMarketplace查找jrebel然后安装激活在菜单Help>JRebel>Activation>ConnecttoLicenseServer，写上：139.199.89.239:1008/884146873b91428689ba2dc813b107ce如果出现激活过期的情况，请重新生成guid，替换原来的guid即可邮箱随便写，即可激活。配置1.在菜单Help>JRebel>Configuration>Projects下勾选相关的项目，rebel会自动在项目的src/resources文件夹下生成rebel.xml2.在运行的Application的配置中勾选上【EnableJRebelagent】", "Coding/Maven常用.md": "TOC向repo发布第三方jarmvndeploy:deployfileDgroupId=com.oracleDartifactId=ojdbc6Dversion=11.2.0.4Dpackaging=jarDfile=ojdbc6.jarDrepositoryId=gmrepoDurl=dev.snhb.group:8081/nexus/content/repositories/releases跳过测试DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/testclasses下。Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。常用repository仓库```xml<repositories><repository><id>aliyunrepo</id><name>Aliyunrepo</name><url>maven.aliyun.com/repository/public</url></repository></repositories><pluginRepositories><pluginRepository><id>aliyunrepo</id><url>maven.aliyun.com/repository/public</url></pluginRepository></pluginRepositories>```指定编码```xml<!文件拷贝时的编码><project.build.sourceEncoding>UTF8</project.build.sourceEncoding><project.reporting.outputEncoding>UTF8</project.reporting.outputEncoding><!编译时的编码><maven.compiler.encoding>UTF8</maven.compiler.encoding>```指定编译的JDK版本**SettingthesourceandtargetoftheJavaCompiler**```xml<properties><maven.compiler.source>1.8</maven.compiler.source><maven.compiler.target>1.8</maven.compiler.target></properties>```使用atom语法mvnio.takari.polyglot:polyglottranslateplugin:translateDinput=pom.xmlDoutput=pom.atom创建web项目```mvnarchetype:generateDgroupId={projectpackaging}DartifactId={projectname}DarchetypeArtifactId=mavenarchetypewebappDinteractiveMode=false或mvnarchetype:generateDarchetypeArtifactId=mavenarchetypewebappDinteractiveMode=falseDgroupId=com.cdjdgmDartifactId=webshell```DependencyScopecompile默认的scope，表示dependency都可以在生命周期中使用。而且，这些dependencies会传递到依赖的项目中。provided跟compile相似，但是表明了dependency由JDK或者容器提供，例如ServletAP和一些JavaEEAPIs。这个scope只能作用在编译和测试时，同时没有传递性。runtime表示dependency不作用在编译时，但会作用在运行和测试时test表示dependency作用在测试时，不作用在运行时。system跟provided相似，但是在系统中要以外部JAR包的形式提供，maven不会在repository查找它。发布部署Nexuspom.xml文件：```xml<distributionManagement><repository><id>releases</id><url>dev.snhb.group:8081/nexus/content/repositories/releases/</url></repository><snapshotRepository><id>snapshots</id><url>dev.snhb.group:8081/nexus/content/repositories/snapshots/</url></snapshotRepository></distributionManagement>```~/.m2/settings.xml:```xml<servers><server><id>releases</id><username>deployment</username><password>your_pwd</password></server></servers>```向仓库导入jar包1.安装到本地库：mvninstall:installfileDfile=D:\\JAR_LIB\\pinyin4j2.5.0.jarDgroupId=net.sourceforge.pinyin4jDartifactId=pinyin4jDversion=2.5.0Dpackaging=jarDgeneratePom=trueDcreateChecksum=true2.安装到私服mvndeploy:deployfileDfile=pinyin4j2.5.0.jarDgroupId=net.sourceforge.pinyin4jDartifactId=pinyin4jDversion=2.5.0Dpackaging=jarDrepositoryId=et_nexus_repoDurl=10.143.132.66:8081/nexus/content/repositories/thirdpartyeclipse警告：mavenenforcerplugingoal\"enforce\"isignoredbym2e.警告状况描述：父项目使用插件mavenenforcerplugin，所有子项目中<parent>标签处均会提示mavenenforcerplugingoal\"enforce\"isignoredbym2e警告信息。警告引发原因：MyEclipse/Eclipse使用的m2e插件，所以会忽略没有与m2e插件关联的maven插件，从而造成警告信息。警告解决方法：为父项目加入lifecyclemapping插件即可。```xml<build><pluginManagement><plugins><!Thisplugin'sconfigurationisusedtostoreEclipsem2esettingsonly.IthasnoinfluenceontheMavenbuilditself.><plugin><groupId>org.eclipse.m2e</groupId><artifactId>lifecyclemapping</artifactId><version>1.0.0</version><configuration><lifecycleMappingMetadata><pluginExecutions><pluginExecution><pluginExecutionFilter><groupId>org.apache.maven.plugins</groupId><artifactId>mavenenforcerplugin</artifactId><versionRange>1.0.0,</versionRange><goals><goal>enforce</goal></goals></pluginExecutionFilter><action><ignore/></action></pluginExecution></pluginExecutions></lifecycleMappingMetadata></configuration></plugin></plugins></pluginManagement></build>```", "Coding/Unicode解析.md": "UTF8UTF8使用一至四个字节为每个字符编码：128个USASCII字符只需一个字节编码（Unicode范围由U+0000至U+007F）。带有附加符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及它拿字母则需要二个字节编码（Unicode范围由U+0080至U+07FF）。其他基本多文种平面（BMP）中的字符（这包含了大部分常用字）使用三个字节编码。其他极少使用的Unicode辅助平面的字符使用四字节编码。对上述提及的第四种字符而言，UTF8使用四个字节来编码似乎太耗费资源了。但UTF8对所有常用的字符都可以用三个字节表示，而且它的另一种选择，UTF16编码，对前述的第四种字符同样需要四个字节来编码，所以要决定UTF8或UTF16哪种编码比较有效率，还要视所使用的字符的分布范围而定。UTF16在基本多语言平面内定义的符号（（BasicMultilingualPlane,BMP），或称第零平面（Plane0）），使用2个字节表示，在此之外的字符其他平面内的字符，则使用4个字节表示。其编码方法是：1如果字符编码U小于0x10000,也就是十进制的0到65535之内，则直接使用两字节表示；2如果字符编码U大于0x10000,由于UNICODE编码范围最大为0x10FFFF,从0x10000到0x10FFFF之间共有0xFFFFF个编码，也就是需要20个bit就可以标示这些编码.用U'表示从00xFFFFF之间的值，将其前10bit作为低位和16bit的数值0XD800进行或操作，将后10bit作为低位和0XDC做或操作，这样组成的4个byte就构成了U的编码。16进制编码范围UTF16表示方法二进制10进制码范围字节数量000000000000FFFFxxxxxxxxxxxxxxxx0655352000100000010FFFF110110yyyyyyyyyy110111xxxxxxxxxx6553611141114UTF16比起UTF8，好处在于大部分字符都以固定长度的字节（2字节）储存，但UTF16却无法相容于ASCII编码。当存储纯中文文本时，用UTF16编码的文件比用UTF8编码要小", "Coding/经典Ｃ源程序100例.md": "【程序1】题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去　　　　　　掉不满足条件的排列。2.程序源代码：main{inti,j,k;printf\"\\n\";fori=1;i<5;i++　　　　／*以下为三重循环*/　forj=1;j<5;j++　　　fork=1;k<5;k++　　　{　　　　ifi!=k&&i!=j&&j!=k　　　/*确保i、j、k三位互不相同*/　　　　printf\"%d,%d,%d\\n\",i,j,k;　　　}}==============================================================【程序2】题目：企业发放的奖金根据利润提成。利润I低于或等于10万元时，奖金可提10%；利润高　　　于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可可提　　　成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于　　　40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于　　　100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。　　　　　　2.程序源代码：main{longinti;intbonus1,bonus2,bonus4,bonus6,bonus10,bonus;scanf\"%ld\",&i;bonus1=100000*0.1;bonus2=bonus1+100000*0.75;bonus4=bonus2+200000*0.5;bonus6=bonus4+200000*0.3;bonus10=bonus6+400000*0.15;　ifi<=100000　　bonus=i*0.1;　elseifi<=200000　　　　　bonus=bonus1+i100000*0.075;　　　　elseifi<=400000　　　　　　　　bonus=bonus2+i200000*0.05;　　　　　　　elseifi<=600000　　　　　　　　　　　bonus=bonus4+i400000*0.03;　　　　　　　　　　elseifi<=1000000　　　　　　　　　　　　　　bonus=bonus6+i600000*0.015;　　　　　　　　　　　　　else　　　　　　　　　　　　　　bonus=bonus10+i1000000*0.01;printf\"bonus=%d\",bonus;}==============================================================【程序3】题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后　　　　　　的结果满足如下条件，即是结果。请看具体分析：2.程序源代码：include\"math.h\"main{longinti,x,y,z;fori=1;i<100000;i++　{x=sqrti+100;　　/*x为加上100后开方后的结果*/　　y=sqrti+268;　　/*y为再加上168后开方后的结果*/　　　ifx*x==i+100&&y*y==i+268/*如果一个数的平方根的平方等于该数，这说明此数是完全平方数*/　　　　printf\"\\n%ld\\n\",i;　}}==============================================================【程序4】题目：输入某年某月某日，判断这一天是这一年的第几天？1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊　　　　　　情况，闰年且输入月份大于3时需考虑多加一天。2.程序源代码：main{intday,month,year,sum,leap;printf\"\\npleaseinputyear,month,day\\n\";scanf\"%d,%d,%d\",&year,&month,&day;switchmonth/*先计算某月以前月份的总天数*/{　case1:sum=0;break;　case2:sum=31;break;　case3:sum=59;break;　case4:sum=90;break;　case5:sum=120;break;　case6:sum=151;break;　case7:sum=181;break;　case8:sum=212;break;　case9:sum=243;break;　case10:sum=273;break;　case11:sum=304;break;　case12:sum=334;break;　default:printf\"dataerror\";break;}sum=sum+day;　/*再加上某天的天数*/　ifyear%400==0||year%4==0&&year%100!=0/*判断是不是闰年*/　　leap=1;　else　　leap=0;ifleap==1&&month>2/*如果是闰年且月份大于2,总天数应该加一天*/sum++;printf\"Itisthe%dthday.\",sum;}=============================================================【程序8】题目：输出9*9口诀。1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。2.程序源代码：include\"stdio.h\"main{inti,j,result;printf\"\\n\";fori=1;i<10;i++{forj=1;j<10;j++{result=i*j;printf\"%d*%d=%3d\",i,j,result;/*3d表示左对齐，占3位*/}printf\"\\n\";/*每一行后换行*/}}==============================================================【程序9】题目：要求输出国际象棋棋盘。1.程序分析：用i控制行，j来控制列，根据i+j的和的变化来控制输出黑方格，还是白方格。2.程序源代码：include\"stdio.h\"main{inti,j;fori=0;i<8;i++{forj=0;j<8;j++ifi+j%2==0printf\"%c%c\",219,219;elseprintf\"\";printf\"\\n\";}}==============================================================【程序14】题目：将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：1如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。2如果n<>k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,　重复执行第一步。3如果n不能被k整除，则用k+1作为k的值,重复执行第一步。2.程序源代码：/*zhengintisdividedyinshu*/main{intn,i;printf\"\\npleaseinputanumber:\\n\";scanf\"%d\",&n;printf\"%d=\",n;fori=2;i<=n;i++　{　　whilen!=i　　{　　　ifn%i==0　　　{printf\"%d*\",i;　　　　n=n/i;　　　}　　　else　　　　break;　　}}printf\"%d\",n;}==============================================================【程序15】题目：利用条件运算符的嵌套来完成此题：学习成绩>=90分的同学用A表示，6089分之间的用B表示，　　　60分以下的用C表示。1.程序分析：a>b?a:b这是条件运算符的基本例子。2.程序源代码：main{　intscore;　chargrade;　printf\"pleaseinputascore\\n\";　scanf\"%d\",&score;　grade=score>=90?'A':score>=60?'B':'C';　printf\"%dbelongsto%c\",score,grade;}==============================================================【程序16】题目：输入两个正整数m和n，求其最大公约数和最小公倍数。1.程序分析：利用辗除法。2.程序源代码：main{　inta,b,num1,num2,temp;　printf\"pleaseinputtwonumbers:\\n\";　scanf\"%d,%d\",&num1,&num2;　ifnum1　{temp=num1;　　num1=num2;　　　num2=temp;　}a=num1;b=num2;whileb!=0/*利用辗除法，直到b为0为止*/　{　　temp=a%b;　　a=b;　　b=temp;　}printf\"gongyueshu:%d\\n\",a;printf\"gongbeishu:%d\\n\",num1*num2/a;}==============================================================【程序17】题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。1.程序分析：利用while语句,条件为输入的字符不为'\\n'.　　　　　　2.程序源代码：include\"stdio.h\"main{charc;　intletters=0,space=0,digit=0,others=0;　printf\"pleaseinputsomecharacters\\n\";　whilec=getchar!='\\n'　{　ifc>='a'&&c<='z'||c>='A'&&c<='Z'　　letters++;　elseifc==''　　space++;　　　elseifc>='0'&&c<='9'　　　　　　　digit++;　　　　　else　　　　　　　others++;}printf\"allinall:char=%dspace=%ddigit=%dothers=%d\\n\",letters,space,digit,others;}==============================================================【程序18】题目：求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222此时　　　共有5个数相加，几个数相加有键盘控制。1.程序分析：关键是计算出每一项的值。2.程序源代码：main{　inta,n,count=1;　longintsn=0,tn=0;　printf\"pleaseinputaandn\\n\";　scanf\"%d,%d\",&a,&n;　printf\"a=%d,n=%d\\n\",a,n;　whilecount<=n　{　　tn=tn+a;　　sn=sn+tn;　　a=a*10;　　++count;　}printf\"a+aa+...=%ld\\n\",sn;}==============================================================【程序19】题目：一个数如果恰好等于它的因子之和，这个数就称为“完数”。例如6=1＋2＋3.编程　　　找出1000以内的所有完数。1.程序分析：请参照程序<上页程序14.2.程序源代码：main{staticintk10;inti,j,n,s;forj=2;j<1000;j++　{　n=1;　s=j;　　fori=1;i　　{　　　ifj%i==0　　　{　n++;　　　　s=si;　　　　kn=i;　　　}　　}　ifs==0　{　printf\"%disawanshu\",j;　fori=0;i　printf\"%d,\",k;　printf\"%d\\n\",kn;　}}}==============================================================【程序20】题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在　　　第10次落地时，共经过多少米？第10次反弹多高？1.程序分析：见下面注释2.程序源代码：main{floatsn=100.0,hn=sn/2;intn;forn=2;n<=10;n++　{　　sn=sn+2*hn;/*第n次落地时共经过的米数*/　　hn=hn/2;/*第n次反跳高度*/　}printf\"thetotalofroadis%f\\n\",sn;printf\"thetenthis%fmeter\\n\",hn;}【程序21】题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个　　　第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下　　　的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。1.程序分析：采取逆向思维的方法，从后往前推断。2.程序源代码：main{intday,x1,x2;day=9;x2=1;whileday>0　{x1=x2+1*2;/*第一天的桃子数是第2天桃子数加1后的2倍*/　x2=x1;　day;　}printf\"thetotalis%d\\n\",x1;}==============================================================【程序22】题目：两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定　　　比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出　　　三队赛手的名单。1.程序分析：判断素数的方法：用一个数分别去除2到sqrt这个数，如果能被整除，　　　　　　则表明此数不是素数，反之是素数。　　　　　　2.程序源代码：main{chari,j,k;/*i是a的对手，j是b的对手，k是c的对手*/fori='x';i<='z';i++　forj='x';j<='z';j++　{　ifi!=j　　fork='x';k<='z';k++　　{ifi!=k&&j!=k　　　{ifi!='x'&&k!='x'&&k!='z'　　　printf\"orderisa%c\\tb%c\\tc%c\\n\",i,j,k;　　　}　　}　}}==============================================================【程序23】题目：打印出如下图案（菱形）****************************1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重　　　　　　for循环，第一层控制行，第二层控制列。2.程序源代码：main{inti,j,k;fori=0;i<=3;i++　{　forj=0;j<=2i;j++　　printf\"\";　fork=0;k<=2*i;k++　　printf\"*\";　printf\"\\n\";　}fori=0;i<=2;i++　{　forj=0;j<=i;j++　　printf\"\";　fork=0;k<=42*i;k++　　printf\"*\";　printf\"\\n\";　}}==============================================================【程序24】题目：有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13...求出这个数列的前20项之和。1.程序分析：请抓住分子与分母的变化规律。2.程序源代码：main{intn,t,number=20;floata=2,b=1,s=0;forn=1;n<=number;n++　{　s=s+a/b;　t=a;a=a+b;b=t;/*这部分是程序的关键，请读者猜猜t的作用*/　}printf\"sumis%9.6f\\n\",s;}==============================================================【程序25】题目：求1+2!+3!+...+20!的和1.程序分析：此程序只是把累加变成了累乘。2.程序源代码：main{floatn,s=0,t=1;forn=1;n<=20;n++　{　t*=n;　s+=t;　}printf\"1+2!+3!...+20!=%e\\n\",s;}==============================================================【程序26】题目：利用递归方法求5!。1.程序分析：递归公式：fn=fn_1*4!2.程序源代码：include\"stdio.h\"main{inti;intfact;fori=0;i<5;i++　printf\"\\40:%d!=%d\\n\",i,facti;}intfactjintj;{intsum;ifj==0　sum=1;else　sum=j*factj1;returnsum;}==============================================================【程序27】题目：利用递归函数调用方式，将所输入的5个字符，以相反顺序打印出来。1.程序分析：2.程序源代码：include\"stdio.h\"main{inti=5;voidpalinintn;printf\"\\40:\";palini;printf\"\\n\";}voidpalinnintn;{charnext;ifn<=1　{　next=getchar;　printf\"\\n\\0:\";　putcharnext;　}else　{　next=getchar;　palinn1;　putcharnext;　}}==============================================================【程序28】题目：有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第　　　3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后　　　问第一个人，他说是10岁。请问第五个人多大？1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道　　　　　　第四人的岁数，依次类推，推到第一人（10岁），再往回推。2.程序源代码：agenintn;{intc;ifn==1c=10;elsec=agen1+2;returnc;}main{printf\"%d\",age5;}==============================================================【程序29】题目：给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。1.程序分析：学会分解出每一位数，如下解释：这里是一种简单的算法，师专数002班赵鑫提供2.程序源代码：main{longa,b,c,d,e,x;scanf\"%ld\",&x;a=x/10000;/*分解出万位*/b=x%10000/1000;/*分解出千位*/c=x%1000/100;/*分解出百位*/d=x%100/10;/*分解出十位*/e=x%10;/*分解出个位*/ifa!=0printf\"thereare5,%ld%ld%ld%ld%ld\\n\",e,d,c,b,a;elseifb!=0printf\"thereare4,%ld%ld%ld%ld\\n\",e,d,c,b;　　elseifc!=0printf\"thereare3,%ld%ld%ld\\n\",e,d,c;　　　　elseifd!=0printf\"thereare2,%ld%ld\\n\",e,d;　　　　　　elseife!=0printf\"thereare1,%ld\\n\",e;}==============================================================【程序30】题目：一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。　　　1.程序分析：同29例2.程序源代码：main{longge,shi,qian,wan,x;scanf\"%ld\",&x;wan=x/10000;qian=x%10000/1000;shi=x%100/10;ge=x%10;ifge==wan&&shi==qian/*个位等于万位并且十位等于千位*/　printf\"thisnumberisahuiwen\\n\";else　printf\"thisnumberisnotahuiwen\\n\";}程序31】题目：请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续　　　判断第二个字母。1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。2.程序源代码：includevoidmain{charletter;printf\"pleaseinputthefirstletterofsomeday\\n\";whileletter=getch!='Y'/*当所按字母为Y时才结束*/{switchletter{case'S':printf\"pleaseinputsecondletter\\n\";　　　　　ifletter=getch=='a'　　　　　　printf\"saturday\\n\";　　　　　elseifletter=getch=='u'　　　　　　　　　printf\"sunday\\n\";　　　　　　　elseprintf\"dataerror\\n\";　　　　　break;case'F':printf\"friday\\n\";break;case'M':printf\"monday\\n\";break;case'T':printf\"pleaseinputsecondletter\\n\";　　　　　ifletter=getch=='u'　　　　　　printf\"tuesday\\n\";　　　　　elseifletter=getch=='h'　　　　　　　　　printf\"thursday\\n\";　　　　　　　elseprintf\"dataerror\\n\";　　　　　break;case'W':printf\"wednesday\\n\";break;default:printf\"dataerror\\n\";　　}　}}==============================================================【程序32】题目：Pressanykeytochangecolor,doyouwanttotryit.Pleasehurryup!1.程序分析：　　　　　　　　　　　　2.程序源代码：includevoidmainvoid{intcolor;forcolor=0;color<8;color++　{　textbackgroundcolor;/*设置文本的背景颜色*/　cprintf\"Thisiscolor%d\\r\\n\",color;　cprintf\"Pressanykeytocontinue\\r\\n\";　getch;/*输入字符看不见*/　}}==============================================================【程序33】题目：学习gotoxy与clrscr函数　　　1.程序分析：2.程序源代码：includevoidmainvoid{clrscr;/*清屏函数*/textbackground2;gotoxy1,5;/*定位函数*/cprintf\"Outputatrow5column1\\n\";textbackground3;gotoxy20,10;cprintf\"Outputatrow10column20\\n\";}==============================================================【程序34】题目：练习函数调用1.程序分析：2.程序源代码：includevoidhello_worldvoid{printf\"Hello,world!\\n\";}voidthree_hellosvoid{intcounter;forcounter=1;counter<=3;counter++hello_world;/*调用此函数*/}voidmainvoid{three_hellos;/*调用此函数*/}==============================================================【程序35】题目：文本颜色设置1.程序分析：2.程序源代码：includevoidmainvoid{intcolor;forcolor=1;color<16;color++　{　textcolorcolor;/*设置文本颜色*/　cprintf\"Thisiscolor%d\\r\\n\",color;　}textcolor128+15;cprintf\"Thisisblinking\\r\\n\";}==============================================================【程序36】题目：求100之内的素数　　　1.程序分析：2.程序源代码：includeinclude\"math.h\"defineN101main{inti,j,line,aN;fori=2;iajmin=j;tem=a;a=amin;amin=tem;}/*outputdata*/printf\"Aftersorted\\n\";fori=0;iend　a10=number;else　{fori=0;i<10;i++　　{ifa>number　　　{temp1=a;　　　　a=number;　　　forj=i+1;j<11;j++　　　{temp2=aj;　　　　aj=temp1;　　　　temp1=temp2;　　　}　　　break;　　　}　　}}fori=0;i<11;i++　printf\"%6d\",a;}==============================================================【程序40】题目：将一个数组逆序输出。1.程序分析：用第一个与最后一个交换。2.程序源代码：defineN5main{intaN={9,6,5,4,1},i,temp;　printf\"\\noriginalarray:\\n\";　fori=0;i\";scanf\"%d\",&num;printf\"\\40:Thesquareforthisnumberis%d\\n\",SQnum;ifnum>=50　again=TRUE;else　again=FALSE;}}==============================================================【程序47】题目：宏define命令练习21.程序分析：　　　　　　　　　　　　2.程序源代码：include\"stdio.h\"defineexchangea,b{\\/*宏定义中允许包含两道衣裳命令的情形，此时必须在最右边加上\"\\\"*/　　　　　　　　　　　　intt;\\　　　　　　　　　　　　t=a;\\　　　　　　　　　　　　a=b;\\　　　　　　　　　　　　b=t;\\　　　　　　　　　　　}voidmainvoid{intx=10;inty=20;printf\"x=%d;y=%d\\n\",x,y;exchangex,y;printf\"x=%d;y=%d\\n\",x,y;}==============================================================【程序48】题目：宏define命令练习3　　　1.程序分析：2.程序源代码：defineLAG>defineSMA<defineEQ==include\"stdio.h\"voidmain{inti=10;intj=20;ifiLAGjprintf\"\\40:%dlargerthan%d\\n\",i,j;elseifiEQjprintf\"\\40:%dequalto%d\\n\",i,j;elseifiSMAjprintf\"\\40:%dsmallerthan%d\\n\",i,j;elseprintf\"\\40:Nosuchvalue.\\n\";}==============================================================【程序49】题目：ififdef和ifndef的综合应用。1.程序分析：2.程序源代码：include\"stdio.h\"defineMAXdefineMAXIMUMx,yx>y?x:ydefineMINIMUMx,yx>y?y:xvoidmain{inta=10,b=20;ifdefMAXprintf\"\\40:Thelargeroneis%d\\n\",MAXIMUMa,b;elseprintf\"\\40:Theloweroneis%d\\n\",MINIMUMa,b;endififndefMINprintf\"\\40:Theloweroneis%d\\n\",MINIMUMa,b;elseprintf\"\\40:Thelargeroneis%d\\n\",MAXIMUMa,b;endifundefMAXifdefMAXprintf\"\\40:Thelargeroneis%d\\n\",MAXIMUMa,b;elseprintf\"\\40:Theloweroneis%d\\n\",MINIMUMa,b;endifdefineMINifndefMINprintf\"\\40:Theloweroneis%d\\n\",MINIMUMa,b;elseprintf\"\\40:Thelargeroneis%d\\n\",MAXIMUMa,b;endif}==============================================================【程序50】题目：include的应用练习　　　1.程序分析：2.程序源代码：test.h文件如下：defineLAG>defineSMA<defineEQ==include\"test.h\"/*一个新文件50.c，包含test.h*/include\"stdio.h\"voidmain{inti=10;intj=20;ifiLAGjprintf\"\\40:%dlargerthan%d\\n\",i,j;elseifiEQjprintf\"\\40:%dequalto%d\\n\",i,j;elseifiSMAjprintf\"\\40:%dsmallerthan%d\\n\",i,j;elseprintf\"\\40:Nosuchvalue.\\n\";}【程序51】题目：学习使用按位与&。　　　1.程序分析：0&0=0;0&1=0;1&0=0;1&1=12.程序源代码：include\"stdio.h\"main{inta,b;a=077;b=a&3;printf\"\\40:Thea&bdecimalis%d\\n\",b;b&=7;printf\"\\40:Thea&bdecimalis%d\\n\",b;}==============================================================【程序52】题目：学习使用按位或|。1.程序分析：0|0=0;0|1=1;1|0=1;1|1=1　　　　　　　　　　　　2.程序源代码：include\"stdio.h\"main{inta,b;a=077;b=a|3;printf\"\\40:Thea&bdecimalis%d\\n\",b;b|=7;printf\"\\40:Thea&bdecimalis%d\\n\",b;}==============================================================【程序53】题目：学习使用按位异或^。　　　1.程序分析：0^0=0;0^1=1;1^0=1;1^1=02.程序源代码：include\"stdio.h\"main{inta,b;a=077;b=a^3;printf\"\\40:Thea&bdecimalis%d\\n\",b;b^=7;printf\"\\40:Thea&bdecimalis%d\\n\",b;}==============================================================【程序54】题目：取一个整数a从右端开始的4～7位。程序分析：可以这样考虑：1先使a右移4位。2设置一个低4位全为1,其余全为0的数。可用~~0<<43将上面二者进行&运算。2.程序源代码：main{unsigneda,b,c,d;scanf\"%o\",&a;b=a>>4;c=~~0<<4;d=b&c;printf\"%o\\n%o\\n\",a,d;}==============================================================【程序55】题目：学习使用按位取反~。　　　1.程序分析：~0=1;~1=0;2.程序源代码：include\"stdio.h\"main{inta,b;a=234;b=~a;printf\"\\40:Thea's1complementdecimalis%d\\n\",b;a=~a;printf\"\\40:Thea's1complementhexidecimalis%x\\n\",a;}==============================================================【程序56】题目：画图，学用circle画圆形。　　　1.程序分析：2.程序源代码：/*circle*/include\"graphics.h\"main{intdriver,mode,i;floatj=1,k=1;driver=VGA;mode=VGAHI;initgraph&driver,&mode,\"\";setbkcolorYELLOW;fori=0;i<=25;i++{setcolor8;circle310,250,k;k=k+j;j=j+0.3;}}==============================================================【程序57】题目：画图，学用line画直线。1.程序分析：　　　　　　　　　　　2.程序源代码：include\"graphics.h\"main{intdriver,mode,i;floatx0,y0,y1,x1;floatj=12,k;driver=VGA;mode=VGAHI;initgraph&driver,&mode,\"\";setbkcolorGREEN;x0=263;y0=263;y1=275;x1=275;fori=0;i<=18;i++{setcolor5;linex0,y0,x0,y1;x0=x05;y0=y05;x1=x1+5;y1=y1+5;j=j+10;}x0=263;y1=275;y0=263;fori=0;i<=20;i++{setcolor5;linex0,y0,x0,y1;x0=x0+5;y0=y0+5;y1=y15;}}==============================================================【程序58】题目：画图，学用rectangle画方形。　　　1.程序分析：利用for循环控制100999个数，每个数分解出个位，十位，百位。2.程序源代码：include\"graphics.h\"main{intx0,y0,y1,x1,driver,mode,i;driver=VGA;mode=VGAHI;initgraph&driver,&mode,\"\";setbkcolorYELLOW;x0=263;y0=263;y1=275;x1=275;fori=0;i<=18;i++{setcolor1;rectanglex0,y0,x1,y1;x0=x05;y0=y05;x1=x1+5;y1=y1+5;}settextstyleDEFAULT_FONT,HORIZ_DIR,2;outtextxy150,40,\"Howbeautifulitis!\";line130,60,480,60;setcolor2;circle269,269,137;}==============================================================【程序59】题目：画图，综合例子。1.程序分析：2.程序源代码：definePAI3.1415926defineB0.809include\"graphics.h\"include\"math.h\"main{inti,j,k,x0,y0,x,y,driver,mode;floata;driver=CGA;mode=CGAC0;initgraph&driver,&mode,\"\";setcolor3;setbkcolorGREEN;x0=150;y0=100;circlex0,y0,10;circlex0,y0,20;circlex0,y0,50;fori=0;i<16;i++{　a=2*PAI/16*i;　x=ceilx0+48*cosa;　y=ceily0+48*sina*B;　setcolor2;linex0,y0,x,y;}setcolor3;circlex0,y0,60;/*Make0timenormalsizeletters*/settextstyleDEFAULT_FONT,HORIZ_DIR,0;outtextxy10,170,\"pressakey\";getch;setfillstyleHATCH_FILL,YELLOW;floodfill202,100,WHITE;getch;fork=0;k<=500;k++{　setcolor3;　fori=0;i<=16;i++　{　　a=2*PAI/16*i+2*PAI/180*k;　　x=ceilx0+48*cosa;　　y=ceily0+48+sina*B;　　setcolor2;linex0,y0,x,y;　}　forj=1;j<=50;j++　{　　a=2*PAI/16*i+2*PAI/180*k1;　　x=ceilx0+48*cosa;　　y=ceily0+48*sina*B;　　linex0,y0,x,y;　}}restorecrtmode;}==============================================================【程序60】题目：画图，综合例子。　　　1.程序分析：2.程序源代码：include\"graphics.h\"defineLEFT0defineTOP0defineRIGHT639defineBOTTOM479defineLINES400defineMAXCOLOR15main{intdriver,mode,error;intx1,y1;intx2,y2;intdx1,dy1,dx2,dy2,i=1;intcount=0;intcolor=0;driver=VGA;mode=VGAHI;initgraph&driver,&mode,\"\";x1=x2=y1=y2=10;dx1=dy1=2;dx2=dy2=3;while!kbhit{　linex1,y1,x2,y2;　x1+=dx1;y1+=dy1;　x2+=dx2;y2+dy2;　ifx1<=LEFT||x1>=RIGHT　dx1=dx1;　ify1<=TOP||y1>=BOTTOM　　dy1=dy1;　ifx2<=LEFT||x2>=RIGHT　　dx2=dx2;　ify2<=TOP||y2>=BOTTOM　　dy2=dy2;　if++count>LINES　{　　setcolorcolor;　　color=color>=MAXCOLOR?0:++color;　}}closegraph;}smlie200412109:00经典c程序100例==6170【程序61】题目：打印出杨辉三角形（要求打印出10行如下图）　　　1.程序分析：　　　　　1　　　　　　1　1　　　　　　1　2　1　　　　　　1　3　3　1　　　　　　1　4　6　4　1　　　　　　1　5　10　10　5　1　2.程序源代码：main{inti,j;inta1010;printf\"\\n\";fori=0;i<10;i++　{a0=1;　a=1;}fori=2;i<10;i++　forj=1;jn2swappointer1,pointer2;ifn1>n3swappointer1,pointer3;ifn2>n3swappointer2,pointer3;printf\"thesortednumbersare:%d,%d,%d\\n\",n1,n2,n3;}swapp1,p2int*p1,*p2;{intp;p=*p1;*p1=*p2;*p2=p;}==============================================================【程序67】题目：输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。1.程序分析：谭浩强的书中答案有问题。　　　　　　2.程序源代码：main{intnumber10;inputnumber;max_minnumber;outputnumber;}inputnumberintnumber10;{inti;fori=0;i<9;i++　scanf\"%d,\",&number;　scanf\"%d\",&number9;}max_minarrayintarray10;{int*max,*min,k,l;int*p,*arr_end;arr_end=array+10;max=min=array;forp=array+1;p*maxmax=p;　elseif*p<*minmin=p;　k=*max;　l=*min;　*p=array0;array0=l;l=*p;　*p=array9;array9=k;k=*p;　return;}outputarrayintarray10;{int*p;forp=array;parray;p　*p=*p1;　*array=array_end;　m;　ifm>0movearray,n,m;}==============================================================【程序69】题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出　　　圈子，问最后留下的是原来第几号的那位。1.程序分析：2.程序源代码：definenmax50main{inti,k,m,n,numnmax,*p;printf\"pleaseinputthetotalofnumbers:\";scanf\"%d\",&n;p=num;fori=0;i\\n\";fori=0;i<=4;i++{　scanf\"%d\",&num;　ptr>data=num;　ptr>next=linkmallocsizeofnode;　ifi==4ptr>next=NULL;　elseptr=ptr>next;}ptr=head;whileptr!=NULL{printf\"Thevalueis==>%d\\n\",ptr>data;　ptr=ptr>next;}}==============================================================【程序73】题目：反向输出一个链表。　　　1.程序分析：2.程序源代码：/*reverseoutputalist*/include\"stdlib.h\"include\"stdio.h\"structlist{intdata;　structlist*next;};typedefstructlistnode;typedefnode*link;voidmain{linkptr,head,tail;　　intnum,i;　tail=linkmallocsizeofnode;　tail>next=NULL;　ptr=tail;　printf\"\\npleaseinput5data==>\\n\";　fori=0;i<=4;i++　{　　scanf\"%d\",&num;　　ptr>data=num;　　head=linkmallocsizeofnode;　　head>next=ptr;　　ptr=head;　}ptr=ptr>next;whileptr!=NULL{printf\"Thevalueis==>%d\\n\",ptr>data;　ptr=ptr>next;}}==============================================================【程序74】题目：连接两个链表。1.程序分析：2.程序源代码：include\"stdlib.h\"include\"stdio.h\"structlist{intdata;structlist*next;};typedefstructlistnode;typedefnode*link;linkdelete_nodelinkpointer,linktmp{iftmp==NULL/*deletefirstnode*/　returnpointer>next;else{iftmp>next>next==NULL/*deletelastnode*/　　tmp>next=NULL;　else/*deletetheothernode*/　　tmp>next=tmp>next>next;　returnpointer;}}voidselection_sortlinkpointer,intnum{linktmp,btmp;　inti,min;　fori=0;idata;　btmp=NULL;　whiletmp>next　{ifmin>tmp>next>data　{min=tmp>next>data;　　btmp=tmp;　}　tmp=tmp>next;　}printf\"\\40:%d\\n\",min;pointer=delete_nodepointer,btmp;}}linkcreate_listintarray,intnum{linktmp1,tmp2,pointer;inti;pointer=linkmallocsizeofnode;pointer>data=array0;tmp1=pointer;fori=1;inext=NULL;　tmp2>data=array;　tmp1>next=tmp2;　tmp1=tmp1>next;}returnpointer;}linkconcatenatelinkpointer1,linkpointer2{linktmp;tmp=pointer1;whiletmp>next　tmp=tmp>next;tmp>next=pointer2;returnpointer1;}voidmainvoid{intarr1={3,12,8,9,11};　linkptr;　ptr=create_listarr1,5;　selection_sortptr,5;}==============================================================【程序75】题目：放松一下，算一道简单的题目。1.程序分析：2.程序源代码：main{inti,n;fori=1;i<5;i++{n=0;　ifi!=1　n=n+1;　ifi==3　n=n+1;　ifi==4　n=n+1;　ifi!=4　n=n+1;　ifn==3　　printf\"zhuhaoshideshi:%c\",64+i;　}}==============================================================【程序76】题目：编写一个函数，输入n为偶数时，调用函数求1/2+1/4+...+1/n,当输入n为奇数时，调用函数　　　1/1+1/3+...+1/n利用指针函数1.程序分析：2.程序源代码：maininclude\"stdio.h\"main{floatpeven,podd,dcall;floatsum;intn;while1{　scanf\"%d\",&n;　ifn>1　　break;}ifn%2==0{　printf\"Even=\";　sum=dcallpeven,n;}else{　printf\"Odd=\";　sum=dcallpodd,n;}printf\"%f\",sum;}floatpevenintn{floats;inti;s=1;fori=2;i<=n;i+=2　s+=1/floati;returns;}floatpoddnintn;{floats;inti;s=0;fori=1;i<=n;i+=2　s+=1/floati;returns;}floatdcallfp,nfloat*fp;intn;{floats;s=*fpn;returns;}==============================================================【程序77】题目：填空练习（指向指针的指针）1.程序分析：　　　　　2.程序源代码：main{char*s={\"man\",\"woman\",\"girl\",\"boy\",\"sister\"};char**q;intk;fork=0;k<5;k++{　　　　　　　;/*这里填写什么语句*/　printf\"%s\\n\",*q;}}==============================================================【程序78】题目：找到年龄最大的人，并输出。请找出程序中有什么问题。1.程序分析：2.程序源代码：defineN4include\"stdio.h\"staticstructman{charname20;intage;}personN={\"li\",18,\"wang\",19,\"zhang\",20,\"sun\",22};main{structman*q,*p;inti,m=0;p=person;fori=0;iage　q=p++;　m=q>age;}printf\"%s,%d\",*q.name,*q.age;}==============================================================【程序79】题目：字符串排序。1.程序分析：2.程序源代码：main{char*str120,*str220,*str320;charswap;printf\"pleaseinputthreestrings\\n\";scanf\"%s\",str1;scanf\"%s\",str2;scanf\"%s\",str3;ifstrcmpstr1,str2>0swapstr1,str2;ifstrcmpstr1,str3>0swapstr1,str3;ifstrcmpstr2,str3>0swapstr2,str3;printf\"afterbeingsorted\\n\";printf\"%s\\n%s\\n%s\\n\",str1,str2,str3;}charswapp1,p2char*p1,*p2;{char*p20;strcpyp,p1;strcpyp1,p2;strcpyp2,p;}==============================================================【程序80】题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只　　　猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了　　　一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，　　　问海滩上原来最少有多少个桃子？1.程序分析：2.程序源代码：main{inti,m,j,k,count;fori=4;i<10000;i+=4{count=0;m=i;fork=0;k<5;k++{　j=i/4*5+1;　i=j;　ifj%4==0　　count++;　else　　break;}　i=m;　ifcount==4　{printf\"%d\\n\",count;　　break;}}}smlie200412109:01经典c程序100例==8190【程序81】题目：809*??=800*??+9*??+1其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。1.程序分析：2.程序源代码：outputlongb,longi{printf\"\\n%ld/%ld=809*%ld+%ld\",b,i,i,b%i;}main{longinta,b,i;a=809;fori=10;i<100;i++{b=i*a+1;ifb>=1000&&b<=10000&&8*i<100&&9*i>=100outputb,i;}}==============================================================【程序82】题目：八进制转换为十进制1.程序分析：　　　　　　　　　　　2.程序源代码：main{char*p,s6;intn;p=s;getsp;n=0;while*p!='\\0'{n=n*8+*p'0';p++;}printf\"%d\",n;}==============================================================【程序83】题目：求0―7所能组成的奇数个数。1.程序分析：2.程序源代码：main{longsum=4,s=4;intj;forj=2;j<=8;j++/*jisplaceofnumber*/{printf\"\\n%ld\",sum;ifj<=2s*=7;elses*=8;sum+=s;}printf\"\\nsum=%ld\",sum;}==============================================================【程序84】题目：一个偶数总能表示为两个素数之和。1.程序分析：2.程序源代码：include\"stdio.h\"include\"math.h\"main{inta,b,c,d;scanf\"%d\",&a;forb=3;b<=a/2;b+=2{forc=2;c<=sqrtb;c++ifb%c==0break;ifc>sqrtbd=ab;elsebreak;forc=2;c<=sqrtd;c++ifd%c==0break;ifc>sqrtdprintf\"%d=%d+%d\\n\",a,b,d;}}==============================================================【程序85】题目：判断一个素数能被几个9整除1.程序分析：2.程序源代码：main{longintm9=9,sum=9;intzi,n1=1,c9=1;scanf\"%d\",&zi;whilen1!=0{if!sum%zin1=0;else{m9=m9*10;sum=sum+m9;c9++;}}printf\"%ld,canbedividedby%d\\\"9\\\"\",sum,c9;}==============================================================【程序86】题目：两个字符串连接程序1.程序分析：2.程序源代码：include\"stdio.h\"main{chara=\"acegikm\";charb=\"bdfhjlnpq\";charc80,*p;inti=0,j=0,k=0;whilea!='\\0'&&bj!='\\0'{ifa{ck=a;i++;}elseck=bj++;k++;}ck='\\0';ifa=='\\0'p=b+j;elsep=a+i;strcatc,p;putsc;}==============================================================【程序87】题目：回答结果（结构体变量传递）1.程序分析：　　　　　2.程序源代码：include\"stdio.h\"structstudent{intx;charc;}a;main{a.x=3;a.c='a';fa;printf\"%d,%c\",a.x,a.c;}fstructstudentb{b.x=20;b.c='y';}==============================================================【程序88】题目：读取7个数（1―50）的整数值，每读取一个值，程序打印出该值个数的＊。1.程序分析：2.程序源代码：main{inti,a,n=1;whilen<=7{do{　　　scanf\"%d\",&a;　　　}whilea<1||a>50;fori=1;i<=a;i++　printf\"*\";printf\"\\n\";n++;}getch;}==============================================================【程序89】题目：某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：　　　每位数字都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。1.程序分析：2.程序源代码：main{inta,i,aa4,t;scanf\"%d\",&a;aa0=a%10;aa1=a%100/10;aa2=a%1000/100;aa3=a/1000;fori=0;i<=3;i++　{aa+=5;　aa%=10;　}fori=0;i<=3/2;i++　{t=aa;　aa=aa3i;　aa3i=t;　}fori=3;i>=0;iprintf\"%d\",aa;}==============================================================【程序90】题目：专升本一题，读结果。1.程序分析：2.程序源代码：include\"stdio.h\"defineM5main{intaM={1,2,3,4,5};inti,j,t;i=0;j=M1;whilei{t=*a+i;*a+i=*a+j;*a+j=t;i++;j;}fori=0;iprintf\"%d\",*a+i;}smlie200412109:02经典c程序100例==91100【程序91】题目：时间函数举例11.程序分析：2.程序源代码：include\"stdio.h\"include\"time.h\"voidmain{time_tlt;/*definealonginttimevarible*/lt=timeNULL;/*systemtimeanddate*/printfctime<;/*englishformatoutput*/printfasctimelocaltime<;/*tranfertotm*/printfasctimegmtime<;/*tranfertoGreenwichtime*/}==============================================================【程序92】题目：时间函数举例21.程序分析：　　　　　　　　　　　2.程序源代码：/*calculatetime*/include\"time.h\"include\"stdio.h\"main{time_tstart,end;inti;start=timeNULL;fori=0;i<3000;i++{printf\"\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\n\";}end=timeNULL;printf\"\\1:Thedifferentis%6.3f\\n\",difftimeend,start;}==============================================================【程序93】题目：时间函数举例31.程序分析：2.程序源代码：/*calculatetime*/include\"time.h\"include\"stdio.h\"main{clock_tstart,end;inti;doublevar;start=clock;fori=0;i<10000;i++{printf\"\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\n\";}end=clock;printf\"\\1:Thedifferentis%6.3f\\n\",doubleendstart;}==============================================================【程序94】题目：时间函数举例4,一个猜数游戏，判断一个人反应快慢。（版主初学时编的）1.程序分析：2.程序源代码：include\"time.h\"include\"stdlib.h\"include\"stdio.h\"main{charc;clock_tstart,end;time_ta,b;doublevar;inti,guess;srandtimeNULL;printf\"doyouwanttoplayit.'y'or'n'\\n\";loop:whilec=getchar=='y'{i=rand%100;printf\"\\npleaseinputnumberyouguess:\\n\";start=clock;a=timeNULL;scanf\"%d\",&guess;whileguess!=i{ifguess>i{printf\"pleaseinputalittlesmaller.\\n\";scanf\"%d\",&guess;}else{printf\"pleaseinputalittlebigger.\\n\";scanf\"%d\",&guess;}}end=clock;b=timeNULL;printf\"\\1:Ittookyou%6.3fseconds\\n\",var=doubleendstart/18.2;printf\"\\1:ittookyou%6.3fseconds\\n\\n\",difftimeb,a;ifvar<15printf\"\\1\\1Youareveryclever!\\1\\1\\n\\n\";elseifvar<25printf\"\\1\\1youarenormal!\\1\\1\\n\\n\";elseprintf\"\\1\\1youarestupid!\\1\\1\\n\\n\";printf\"\\1\\1Congradulations\\1\\1\\n\\n\";printf\"Thenumberyouguessis%d\",i;}printf\"\\ndoyouwanttotryitagain?\\\"yy\\\".or.\\\"n\\\"\\n\";ifc=getch=='y'gotoloop;}==============================================================【程序95】题目：家庭财务管理小程序1.程序分析：2.程序源代码：/*moneymanagementsystem*/include\"stdio.h\"include\"dos.h\"main{FILE*fp;structdated;floatsum,chm=0.0;intlen,i,j=0;intc;charch4=\"\",ch116=\"\",chtime12=\"\",chshop16,chmoney8;pp:clrscr;sum=0.0;gotoxy1,1;printf\"||\";gotoxy1,2;printf\"|moneymanagementsystemC1.02000.03|\";gotoxy1,3;printf\"||\";gotoxy1,4;printf\"|moneyrecords|todaycostlist|\";gotoxy1,5;printf\"|||\";gotoxy1,6;printf\"|date:||\";gotoxy1,7;printf\"|||||\";gotoxy1,8;printf\"|||\";gotoxy1,9;printf\"|thgs:||\";gotoxy1,10;printf\"|||||\";gotoxy1,11;printf\"|||\";gotoxy1,12;printf\"|cost:||\";gotoxy1,13;printf\"|||||\";gotoxy1,14;printf\"|||\";gotoxy1,15;printf\"|||\";gotoxy1,16;printf\"|||\";gotoxy1,17;printf\"|||\";gotoxy1,18;printf\"|||\";gotoxy1,19;printf\"|||\";gotoxy1,20;printf\"|||\";gotoxy1,21;printf\"|||\";gotoxy1,22;printf\"|||\";gotoxy1,23;printf\"||\";i=0;getdate&d;sprintfchtime,\"%4d.%02d.%02d\",d.da_year,d.da_mon,d.da_day;for;;{gotoxy3,24;printf\"Tab__browsecostlistEsc__quit\";gotoxy13,10;printf\"\";gotoxy13,13;printf\"\";gotoxy13,7;printf\"%s\",chtime;j=18;ch0=getch;ifch0==27break;strcpychshop,\"\";strcpychmoney,\"\";ifch0==9{mm:i=0;fp=fopen\"home.dat\",\"r+\";gotoxy3,24;printf\"\";gotoxy6,4;printf\"listrecords\";gotoxy1,5;printf\"||\";gotoxy41,4;printf\"\";gotoxy41,5;printf\"|\";whilefscanffp,\"%10s%14s%f\\n\",chtime,chshop,&chm!=EOF{ifi==36{getch;i=0;}ifi%36<17{gotoxy4,6+i;printf\"\";gotoxy4,6+i;}elseifi%36>16{gotoxy41,4+i17;printf\"\";gotoxy42,4+i17;}i++;sum=sum+chm;printf\"%10s%14s%6.1f\\n\",chtime,chshop,chm;}gotoxy1,23;printf\"||\";gotoxy1,24;printf\"||\";gotoxy1,25;printf\"||\";gotoxy10,24;printf\"totalis%8.1f$\",sum;fclosefp;gotoxy49,24;printf\"pressanykeyto.....\";getch;gotopp;}else{whilech0!='\\r'{ifj<10{strncatchtime,ch,1;j++;}ifch0==8{len=strlenchtime1;ifj>15{len=len+1;j=11;}strcpych1,\"\";j=j2;strncatch1,chtime,len;strcpychtime,\"\";strncatchtime,ch1,len1;gotoxy13,7;printf\"\";}gotoxy13,7;printf\"%s\",chtime;ch0=getch;ifch0==9gotomm;ifch0==27exit1;}gotoxy3,24;printf\"\";gotoxy13,10;j=0;ch0=getch;whilech0!='\\r'{ifj<14{strncatchshop,ch,1;j++;}ifch0==8{len=strlenchshop1;strcpych1,\"\";j=j2;strncatch1,chshop,len;strcpychshop,\"\";strncatchshop,ch1,len1;gotoxy13,10;printf\"\";}gotoxy13,10;printf\"%s\",chshop;ch0=getch;}gotoxy13,13;j=0;ch0=getch;whilech0!='\\r'{ifj<6{strncatchmoney,ch,1;j++;}ifch0==8{len=strlenchmoney1;strcpych1,\"\";j=j2;strncatch1,chmoney,len;strcpychmoney,\"\";strncatchmoney,ch1,len1;gotoxy13,13;printf\"\";}gotoxy13,13;printf\"%s\",chmoney;ch0=getch;}ifstrlenchshop==0||strlenchmoney==0continue;iffp=fopen\"home.dat\",\"a+\"!=NULL;fprintffp,\"%10s%14s%6s\",chtime,chshop,chmoney;fputc'\\n',fp;fclosefp;i++;gotoxy41,5+i;printf\"%10s%14s%6s\",chtime,chshop,chmoney;}}}==============================================================【程序96】题目：计算字符串中子串出现的次数1.程序分析：2.程序源代码：include\"string.h\"include\"stdio.h\"main{charstr120,str220,*p1,*p2;intsum=0;printf\"pleaseinputtwostrings\\n\";scanf\"%s%s\",str1,str2;p1=str1;p2=str2;while*p1!='\\0'{if*p1==*p2{while*p1==*p2&&*p2!='\\0'{p1++;p2++;}}elsep1++;if*p2=='\\0'sum++;p2=str2;}printf\"%d\",sum;getch;}==============================================================【程序97】题目：从键盘输入一些字符，逐个把它们送到磁盘上去，直到输入一个为止。1.程序分析：　　　　　2.程序源代码：include\"stdio.h\"main{FILE*fp;charch,filename10;scanf\"%s\",filename;iffp=fopenfilename,\"w\"==NULL{printf\"cannotopenfile\\n\";exit0;}ch=getchar;ch=getchar;whilech!=''{fputcch,fp;putcharch;ch=getchar;}fclosefp;}==============================================================【程序98】题目：从键盘输入一个字符串，将小写字母全部转换成大写字母，然后输出到一个磁盘文件“test”中保存。　　　输入的字符串以！结束。1.程序分析：2.程序源代码：include\"stdio.h\"main{FILE*fp;charstr100,filename10;inti=0;iffp=fopen\"test\",\"w\"==NULL{printf\"cannotopenthefile\\n\";exit0;}printf\"pleaseinputastring:\\n\";getsstr;whilestr!='!'{ifstr>='a'&&str<='z'str=str32;fputcstr,fp;i++;}fclosefp;fp=fopen\"test\",\"r\";fgetsstr,strlenstr+1,fp;printf\"%s\\n\",str;fclosefp;}Lasteditedbysmlieon2004121at17:04smlie200412109:03==============================================================【程序99】题目：有两个磁盘文件A和B,各存放一行字母，要求把这两个文件中的信息合并（按字母顺序排列），　　　输出到一个新文件C中。1.程序分析：2.程序源代码：include\"stdio.h\"main{FILE*fp;inti,j,n,ni;charc160,t,ch;iffp=fopen\"A\",\"r\"==NULL{printf\"fileAcannotbeopened\\n\";exit0;}printf\"\\nAcontentsare:\\n\";fori=0;ch=fgetcfp!=EOF;i++{c=ch;putcharc;}fclosefp;ni=i;iffp=fopen\"B\",\"r\"==NULL{printf\"fileBcannotbeopened\\n\";exit0;}printf\"\\nBcontentsare:\\n\";fori=0;ch=fgetcfp!=EOF;i++{c=ch;putcharc;}fclosefp;n=i;fori=0;icj{t=c;c=cj;cj=t;}printf\"\\nCfileis:\\n\";fp=fopen\"C\",\"w\";fori=0;i", "Coding/编码习惯及方式总结.md": "小模块开发方法：1、编写Story。不会写的、懒得写的人，可以简单的将需求一条一条的列出来2、画出业务流程。可以使用流程图、时序图、数据流图、活动图、协作图3、画出ER图。并在ER图上推演业务流程。4、定义出接口，并为每一个接口写上注释。注释内按照实现流程来写。这些接口通常是Service方法5、写单元测试。优先测试Service方法6、实现代码。7、按照业务流程进行测试。这个测试是集成测试8、整理业务流程，完成需求、设计文档编写。", "Coding/编程之道--编码思维.md": "高效编程的思维包括两种：程序构造的逻辑思维和程序测试思维。程序测试思维程序测试思维是精益求精的匠人思维一种体现。小学生做作业。我儿子上小学四年级，每天放学后老师会布置作业，有时他为了快点完成任务，作业就会有各种错误。第二天老师要求把做错的题抄写下来，再做一遍，有点的题目篇幅很长，光抄题就要花费很多时间，在加上当天还有新作业，所以如果前天作业做不好，第二天基本是要加倍。程序开发亦如此。匆匆忙忙粗心大意开发出来的程序，一旦测试出bug来，需要反复地和测试人员沟通，反复为了bug修复进入同一段程序，正常工作反复的被打断，都需要很多时间。bug如果越是在后期发现，需要的沟通时间越高，而且此时修复bug需要把此前大部分活动重做一遍，比如：需求理解、熟悉代码、修复、测试、发布、客户部署等。例子：树导航测试与开发等价类：对输入可能进行类，代表值。数字、字母、特殊字符。边界值：无节点添加节点，添加很多节点。路径覆盖：经验总结切换到测试人员的立场来看待自己的程序做对才是高效率，不要陷入泥沼先精准，再提速才能又好又快", "Coding\\Java/001-byte数组与int，long，short，byte转换.md": "题目说明分别按照byte数组的高位在前低位在后、低位在前高位在后两种情况，完成以下几个转换，并写成工具类做为备用。byte数组转换成short类型byte数组转换成int类型byte数组转换成long类型short类型转换成byte数组int类型转换成byte数组long类型转换成byte数组知识点二进制高低位Java类型定义（可以参考【Java核心技术1】）", "Coding\\Java/001-SQL-50题.md": "学生表Student|S_id学号|S_name姓名|S_age02年龄|S_sex02性别||||||教师表Teacher|T_id教师编号|T_name姓名|T_age02年龄|T_sex02性别||||||课程表02Course|C_id课程编号|C_name02课程名称|T_id02教师编号|||||成绩表02Sc|S_id学号|C_id02课程编号|score02分数|||||1、查询“001”课程比“002”课程成绩高的所有学生的学号；2、查询平均成绩大于60分的同学的学号和平均成绩；3、查询所有同学的学号、姓名、选课数、总成绩；4、查询姓“李”的老师的个数；5、查询没学过“叶平”老师课的同学的学号、姓名；6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；9、查询所有课程成绩小于60分的同学的学号、姓名；10、查询没有学全所有课的同学的学号、姓名；11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；15、删除学习“叶平”老师课的SC表记录；16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、2号课的平均成绩；17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示：学生ID,,数据库,企业管理,英语,有效课程数,有效平均分18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分19、按各科平均成绩从低到高和及格率的百分数从高到低顺序20、查询如下课程平均成绩和及格率的百分数用\"1行\"显示:企业管理（001），马克思（002），OO&UML（003），数据库（004）21、查询不同老师所教不同课程平均分从高到低显示22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理（001），马克思（002），UML（003），数据库（004）学生ID,学生姓名,企业管理,马克思,UML,数据库,平均成绩23、统计列印各科成绩,各分数段人数:课程ID,课程名称,10085,8570,7060,<6024、查询学生平均成绩及其名次25、查询各科成绩前三名的记录:不考虑成绩并列情况26、查询每门课程被选修的学生数27、查询出只选修了一门课程的全部学生的学号和姓名28、查询男生、女生人数29、查询姓“张”的学生名单30、查询同名同性学生名单，并统计同名人数31、1981年出生的学生名单注：Student表中Sage列的类型是datetime32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数35、查询所有学生的选课情况；36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；37、查询不及格的课程，并按课程号从大到小排列38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；39、求选了课程的学生人数40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩41、查询各个课程及相应的选修人数42、查询不同课程成绩相同的学生的学号、课程号、学生成绩43、查询每门功成绩最好的前两名44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列45、检索至少选修两门课程的学生学号46、查询全部学生都选修的课程的课程号和课程名47、查询没学过“叶平”老师讲授的任一门课程的学生姓名48、查询两门以上不及格课程的同学的学号及其平均成绩49、检索“004”课程分数小于60，按分数降序排列的同学学号50、删除“002”同学的“001”课程的成绩答案1、查询“001”课程比“002”课程成绩高的所有学生的学号；```sqlselecta.Sfromselects,scorefromSCwhereC='001'a,selects,scorefromSCwhereC='002'wherea.score>b.scoreanda.s=b.s;```2、查询平均成绩大于60分的同学的学号和平均成绩；```sqlselectS,avgscorefromscgroupbyShavingavgscore>60;```3、查询所有同学的学号、姓名、选课数、总成绩；```sqlselectStudent.S,Student.Sname,countSC.C,sumscorefromStudentleftOuterjoinSConStudent.S=SC.SgroupbyStudent.S,Sname```4、查询姓“李”的老师的个数；```sqlselectcountdistinctTnamefromTeacherwhereTnamelike'李%';```5、查询没学过“叶平”老师课的同学的学号、姓名；```sqlselectStudent.S,Student.SnamefromStudentwhereSnotinselectdistinctSC.SfromSC,Course,TeacherwhereSC.C=Course.CandTeacher.T=Course.TandTeacher.Tname='叶平';```6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；```sqlselectStudent.S,Student.SnamefromStudent,SCwhereStudent.S=SC.SandSC.C='001'andexistsSelect*fromSCasSC_2whereSC_2.S=SC.SandSC_2.C='002';```7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；```sqlselectS,SnamefromStudentwhereSinselectSfromSC,Course,TeacherwhereSC.C=Course.CandTeacher.T=Course.TandTeacher.Tname='叶平'groupbyShavingcountSC.C=selectcountCfromCourse,TeacherwhereTeacher.T=Course.TandTname='叶平';```8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；```sqlSelectS,SnamefromselectStudent.S,Student.Sname,score,selectscorefromSCSC_2whereSC_2.S=Student.SandSC_2.C='002'score2fromStudent,SCwhereStudent.S=SC.SandC='001'S_2wherescore2<score;```9、查询所有课程成绩小于60分的同学的学号、姓名；```sqlselectS,SnamefromStudentwhereSnotinselectStudent.SfromStudent,SCwhereS.S=SC.Sandscore>60;```10、查询没有学全所有课的同学的学号、姓名；```sqlselectStudent.S,Student.SnamefromStudent,SCwhereStudent.S=SC.SgroupbyStudent.S,Student.SnamehavingcountC<selectcountCfromCourse;```11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；```sqlselectS,SnamefromStudent,SCwhereStudent.S=SC.SandCinselectCfromSCwhereS='1001';```12、查询至少学过学号为“001”同学所有一门课的其他同学学号和姓名；```sqlselectdistinctSC.S,SnamefromStudent,SCwhereStudent.S=SC.SandCinselectCfromSCwhereS='001';```13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；```sqlupdateSCsetscore=selectavgSC_2.scorefromSCSC_2whereSC_2.C=SC.CfromCourse,TeacherwhereCourse.C=SC.CandCourse.T=Teacher.TandTeacher.Tname='叶平';```14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；```sqlselectSfromSCwhereCinselectCfromSCwhereS='1002'groupbyShavingcount*=selectcount*fromSCwhereS='1002';```15、删除学习“叶平”老师课的SC表记录；```sqlDelectSCfromcourse,TeacherwhereCourse.C=SC.CandCourse.T=Teacher.TandTname='叶平';```16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号、2号课的平均成绩；```sqlInsertSCselectS,'002',SelectavgscorefromSCwhereC='002'fromStudentwhereSnotinSelectSfromSCwhereC='002';```17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示：学生ID,,数据库,企业管理,英语,有效课程数,有效平均分```sqlSELECTSas学生ID,SELECTscoreFROMSCWHERESC.S=t.SANDC='004'AS数据库,SELECTscoreFROMSCWHERESC.S=t.SANDC='001'AS企业管理,SELECTscoreFROMSCWHERESC.S=t.SANDC='006'AS英语,COUNT*AS有效课程数,AVGt.scoreAS平均成绩FROMSCAStGROUPBYSORDERBYavgt.score```18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分```sqlSELECTL.CAs课程ID,L.scoreAS最高分,R.scoreAS最低分FROMSCL,SCASRWHEREL.C=R.CandL.score=SELECTMAXIL.scoreFROMSCASIL,StudentASIMWHEREL.C=IL.CandIM.S=IL.SGROUPBYIL.CANDR.Score=SELECTMINIR.scoreFROMSCASIRWHERER.C=IR.CGROUPBYIR.C;```19、按各科平均成绩从低到高和及格率的百分数从高到低顺序```sqlSELECTt.CAS课程号,maxcourse.CnameAS课程名,isnullAVGscore,0AS平均成绩,100*SUMCASEWHENisnullscore,0>=60THEN1ELSE0END/COUNT*AS及格百分数FROMSCT,Coursewheret.C=course.CGROUPBYt.CORDERBY100*SUMCASEWHENisnullscore,0>=60THEN1ELSE0END/COUNT*DESC```20、查询如下课程平均成绩和及格率的百分数用\"1行\"显示:企业管理（001），马克思（002），OO&UML（003），数据库（004）```sqlSELECTSUMCASEWHENC='001'THENscoreELSE0END/SUMCASECWHEN'001'THEN1ELSE0ENDAS企业管理平均分,100*SUMCASEWHENC='001'ANDscore>=60THEN1ELSE0END/SUMCASEWHENC='001'THEN1ELSE0ENDAS企业管理及格百分数,SUMCASEWHENC='002'THENscoreELSE0END/SUMCASECWHEN'002'THEN1ELSE0ENDAS马克思平均分,100*SUMCASEWHENC='002'ANDscore>=60THEN1ELSE0END/SUMCASEWHENC='002'THEN1ELSE0ENDAS马克思及格百分数,SUMCASEWHENC='003'THENscoreELSE0END/SUMCASECWHEN'003'THEN1ELSE0ENDASUML平均分,100*SUMCASEWHENC='003'ANDscore>=60THEN1ELSE0END/SUMCASEWHENC='003'THEN1ELSE0ENDASUML及格百分数,SUMCASEWHENC='004'THENscoreELSE0END/SUMCASECWHEN'004'THEN1ELSE0ENDAS数据库平均分,100*SUMCASEWHENC='004'ANDscore>=60THEN1ELSE0END/SUMCASEWHENC='004'THEN1ELSE0ENDAS数据库及格百分数FROMSC```21、查询不同老师所教不同课程平均分从高到低显示```sqlSELECTmaxZ.TAS教师ID,MAXZ.TnameAS教师姓名,C.CAS课程ＩＤ,MAXC.CnameAS课程名称,AVGScoreAS平均成绩FROMSCAST,CourseASC,TeacherASZwhereT.C=C.CandC.T=Z.TGROUPBYC.CORDERBYAVGScoreDESC```22、查询如下课程成绩第3名到第6名的学生成绩单：企业管理（001），马克思（002），UML（003），数据库（004）学生ID,学生姓名,企业管理,马克思,UML,数据库,平均成绩```sqlSELECTDISTINCTtop3SC.SAs学生学号,Student.SnameAS学生姓名,T1.scoreAS企业管理,T2.scoreAS马克思,T3.scoreASUML,T4.scoreAS数据库,ISNULLT1.score,0+ISNULLT2.score,0+ISNULLT3.score,0+ISNULLT4.score,0as总分FROMStudent,SCLEFTJOINSCAST1ONSC.S=T1.SANDT1.C='001'LEFTJOINSCAST2ONSC.S=T2.SANDT2.C='002'LEFTJOINSCAST3ONSC.S=T3.SANDT3.C='003'LEFTJOINSCAST4ONSC.S=T4.SANDT4.C='004'WHEREstudent.S=SC.SandISNULLT1.score,0+ISNULLT2.score,0+ISNULLT3.score,0+ISNULLT4.score,0NOTINSELECTDISTINCTTOP15WITHTIESISNULLT1.score,0+ISNULLT2.score,0+ISNULLT3.score,0+ISNULLT4.score,0FROMscLEFTJOINscAST1ONsc.S=T1.SANDT1.C='k1'LEFTJOINscAST2ONsc.S=T2.SANDT2.C='k2'LEFTJOINscAST3ONsc.S=T3.SANDT3.C='k3'LEFTJOINscAST4ONsc.S=T4.SANDT4.C='k4'ORDERBYISNULLT1.score,0+ISNULLT2.score,0+ISNULLT3.score,0+ISNULLT4.score,0DESC;```23、统计列印各科成绩,各分数段人数:课程ID,课程名称,10085,8570,7060,<60```sqlSELECTSC.Cas课程ID,Cnameas课程名称,SUMCASEWHENscoreBETWEEN85AND100THEN1ELSE0ENDAS10085,SUMCASEWHENscoreBETWEEN70AND85THEN1ELSE0ENDAS8570,SUMCASEWHENscoreBETWEEN60AND70THEN1ELSE0ENDAS7060,SUMCASEWHENscore<60THEN1ELSE0ENDAS60FROMSC,CoursewhereSC.C=Course.CGROUPBYSC.C,Cname;```24、查询学生平均成绩及其名次```sqlSELECT1+SELECTCOUNTdistinct平均成绩FROMSELECTS,AVGscoreAS平均成绩FROMSCGROUPBYSAST1WHERE平均成绩>T2.平均成绩as名次,Sas学生学号,平均成绩FROMSELECTS,AVGscore平均成绩FROMSCGROUPBYSAST2ORDERBY平均成绩desc;```25、查询各科成绩前三名的记录:不考虑成绩并列情况```sqlSELECTt1.Sas学生ID,t1.Cas课程ID,Scoreas分数FROMSCt1WHEREscoreINSELECTTOP3scoreFROMSCWHEREt1.C=CORDERBYscoreDESCORDERBYt1.C;```26、查询每门课程被选修的学生数```sqlselectc,countSfromscgroupbyC;```27、查询出只选修了一门课程的全部学生的学号和姓名```sqlselectSC.S,Student.Sname,countCAS选课数fromSC,StudentwhereSC.S=Student.SgroupbySC.S,Student.SnamehavingcountC=1;```28、查询男生、女生人数```sqlSelectcountSsexas男生人数fromStudentgroupbySsexhavingSsex='男';SelectcountSsexas女生人数fromStudentgroupbySsexhavingSsex='女'；```29、查询姓“张”的学生名单```sqlSELECTSnameFROMStudentWHERESnamelike'张%';```30、查询同名同性学生名单，并统计同名人数```sqlselectSname,count*fromStudentgroupbySnamehavingcount*>1;```31、1981年出生的学生名单注：Student表中Sage列的类型是datetime```sqlselectSname,CONVERTchar11,DATEPARTyear,SageasagefromstudentwhereCONVERTchar11,DATEPARTyear,Sage='1981';```32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列```sqlSelectC,AvgscorefromSCgroupbyCorderbyAvgscore,CDESC;```33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩```sqlselectSname,SC.S,avgscorefromStudent,SCwhereStudent.S=SC.SgroupbySC.S,Snamehavingavgscore>85;```34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数```sqlSelectSname,isnullscore,0fromStudent,SC,CoursewhereSC.S=Student.SandSC.C=Course.CandCourse.Cname='数据库'andscore<60;```35、查询所有学生的选课情况；```sqlSELECTSC.S,SC.C,Sname,CnameFROMSC,Student,CoursewhereSC.S=Student.SandSC.C=Course.C;```36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；```sqlSELECTdistinctstudent.S,student.Sname,SC.C,SC.scoreFROMstudent,ScWHERESC.score>=70ANDSC.S=student.S;```37、查询不及格的课程，并按课程号从大到小排列```sqlselectcfromscwherescore<60orderbyC;```38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；```sqlselectSC.S,Student.SnamefromSC,StudentwhereSC.S=Student.SandScore>80andC='003';```39、求选了课程的学生人数```sqlselectcount*fromsc;```40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩```sqlselectStudent.Sname,scorefromStudent,SC,CourseC,TeacherwhereStudent.S=SC.SandSC.C=C.CandC.T=Teacher.TandTeacher.Tname='叶平'andSC.score=selectmaxscorefromSCwhereC=C.C;```41、查询各个课程及相应的选修人数```sqlselectcount*fromscgroupbyC;```42、查询不同课程成绩相同的学生的学号、课程号、学生成绩```sqlselectdistinctA.S,B.scorefromSCA,SCBwhereA.Score=B.ScoreandA.C<>B.C;```43、查询每门功成绩最好的前两名```sqlSELECTt1.Sas学生ID,t1.Cas课程ID,Scoreas分数FROMSCt1WHEREscoreINSELECTTOP2scoreFROMSCWHEREt1.C=CORDERBYscoreDESCORDERBYt1.C;```44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列```sqlselectCas课程号,count*as人数fromscgroupbyCorderbycount*desc,c```45、检索至少选修两门课程的学生学号```sqlselectSfromscgroupbyshavingcount*>=2```46、查询全部学生都选修的课程的课程号和课程名```sqlselectC,CnamefromCoursewhereCinselectcfromscgroupbyc```47、查询没学过“叶平”老师讲授的任一门课程的学生姓名```sqlselectSnamefromStudentwhereSnotinselectSfromCourse,Teacher,SCwhereCourse.T=Teacher.TandSC.C=course.CandTname='叶平';```48、查询两门以上不及格课程的同学的学号及其平均成绩```sqlselectS,avgisnullscore,0fromSCwhereSinselectSfromSCwherescore<60groupbyShavingcount*>2groupbyS;```49、检索“004”课程分数小于60，按分数降序排列的同学学号```sqlselectSfromSCwhereC='004'andscore<60orderbyscoredesc;```50、删除“002”同学的“001”课程的成绩```sqldeletefromScwhereS='001'andC='001';```", "Coding\\Java/01_Java核心.md": "TOC1.通用编程1.1.Java序列化1.1.1.什么是序列化序列化：对象>字节流，用于持久化、网络传输。反序列化：字节流>对象。只需实现java.io.Serializable接口，JDK通过ObjectOutputStreamwriteObject完成序列化。对象序列号字节流分为三部分：序列化头信息部分、类的描述部分以及属性域的值部分。**序列化的的基本步骤**1.输出序列化的头部信息，包括标识序列化协议的幻数以及协议的版本；2.按照由子类到父类的顺序，递归的输出类的描述信息，直到不再有父类为止；类描述信息按照类元数据，类属性信息的顺序写入序列化流中；3.按照由父类到子类的顺序，递归的输出对象域的实际数据值；而对象的属性信息是按照基本数据类型到java对象类型的顺序写入序列化流中；其中java对象类型的属性会从步骤1重新开始递归的输出，直到不再存在java对象类型的属性。1.1.2.Java序列化的安全问题Java序列化算法简单且公开的，网络传输时将导致字节流被截获后，可以反序列化，泄露敏感信息；反序列化无验证机制，导致截获的字节流容易被篡改；反序列化无需构造方法即可创建对象；1.1.3.自定义序列化Java提供了三种实现方案，前两种方案实际上是自定义第三部分信息属性域的值部分的输出方式，而第三种方法不仅可以自定义第三部分信息的输出，还可以自定义第二部分信息（类描述部分）信息的输出。java.io.Serializable接口自定义序列化的核心是：在要序列化的类中添加如下签名方式的两个方法：```javaprivatevoidreadObjectjava.io.ObjectInputStreamstreamthrowsIOException,ClassNotFoundException;privatevoidwriteObjectjava.io.ObjectOutputStreamstreamthrowsIOException;```JDK中序列化的调用栈与具体代码如下：```javajava.io.ObjectOutputStream.writeObject………………………………………………………………①└java.io.ObjectOutputStream.writeObject0……………………………………………………………②└java.io.ObjectOutputStream.writeOrdinaryObject…………………………………………③├java.io.ObjectOutputStream.writeClassDesc………………………………………………④└java.io.ObjectOutputStream.writeSerialData……………………………………………⑤```其中序列化第二部分信息（类的描述部分）由③④完成，而⑤主要完成的就是第三部分信息的序列化。```javaprivatevoidwriteSerialDataObjectobj,ObjectStreamClassdescthrowsIOException{//获取序列化对象由子类到父类的类描述集合ObjectStreamClass.ClassDataSlotslots=desc.getClassDataLayout;forinti=0;i<slots.length;i++{ObjectStreamClassslotDesc=slotsi.desc;//判断序列化类是否实现了writeObject方法ifslotDesc.hasWriteObjectMethod{PutFieldImploldPut=curPut;curPut=null;//中略SerialCallbackContextoldContext=curContext;try{curContext=newSerialCallbackContextobj,slotDesc;bout.setBlockDataModetrue;//如果实现了wirteObjcet方法，通过反射机制调用该方法slotDesc.invokeWriteObjectobj,this;bout.setBlockDataModefalse;bout.writeByteTC_ENDBLOCKDATA;}finally{//中略}else{//如果序列化类未实现writeObject方法，调用默认的属性值序列化方式defaultWriteFieldsobj,slotDesc;}```1.1.3.1.java.io.Externalizable自定义形式当对象实现了java.io.Externalizable接口时，就可以灵活的控制它的序列化和反序列化过程，该接口继承自java.io.Serializable。Externalizable接口定义了两个方法writeExternal和readExternal。Externalizable接口的writeExternalreadExternal方法的作用仍是序列化第三部分信息属性域的值部分。当实现了该接口后，再在该类中添加writeObjectreadObjcet方法，那么writeObjectreadObjcet方法将会失效，具体原因通过阅读源码就了然了。1.1.3.2.新建一个自己的序列化类自定义一个自己的序列化类需要三个步骤，第一步需要继承ObjectOutputStreamObjectInputStream；第二步在构造函数调用父类的无参构造函数；第三步重写父类的writeObjectOverridereadObjcetOverride方法，在该方法中自定义序列化方案。反序列化类与此类似，这里不再赘述。1.1.3.3.序列化流验证机制Java序列化提供一套验证机制。序列化类通过实现java.io.ObjectInputValidation接口，就可以做到验证了。```JavapublicclassAppleimplementsSerializable,ObjectInputValidation{publicvoidvalidateObjectthrowsInvalidObjectException{//添加验证的对象属性的hash值，来判断序列化流是否被篡改。booleanflag=hash;ifflag{//未被篡改}else{thrownewInvalidObjectException\"流信息被篡改了\";}}}```Java序列化验证机制的基本原理：将想要验证的序列化类注册到java.io.ObjectInputStream类的验证回调列表中，将对象从流中反序列化出来后，会遍历回调列表，调用序列化类的validateObject方法来进行验证操作。1.2.正则表达式查询：```javaStringstr=\"abcefgABC\";StringregEx=\"a|f\";//表示a或fPatternp=Pattern.compileregEx;Matcherm=p.matcherstr;booleanrs=m.find;booleanrs=m.find3;//从指定的字符（第三个字符）开始查找匹配//如果str中有regEx，那么rs为true，否则为flase。如果想在查找时忽略大小写，则可以写成：Patternp=Pattern.compileregEx,Pattern.CASE_INSENSITIVE;//String类提供的matches方法也支持正则表达式，返回boolean\"1234\".matches\"?\\\\d+\"```提取：```javaPatternp=Pattern.compile\"^java.+?\\n\",Pattern.CASE_INSENSITIVE|Pattern.MULTILINE;Matcherm=p.matcher\"javahasregex\\nJavahasregex\\n\"+\"JAVAhasprettygoodregularexpressions\\n\"+\"RegularexpressionsareinJava\";whilem.find{forintj=0;j<=m.groupCount;j++{//此处可以通过start和end方法取得匹配的位置System.out.print\"\"+m.groupj+\"\";}System.out.println;}```m.groupi是指正则表达式中的第i个括号中的内容，m.groupCount是括号的个数;分割：```javaStringregEx=\"::\";Patternp=Pattern.compileregEx;Stringr=p.split\"xd::abc::cde\";//执行后，r就是{\"xd\",\"abc\",\"cde\"}，其实分割时还有更简单的方法：Stringstr=\"xd::abc::cde\";Stringr=str.split\"::\";```替换（删除）：```JAVAStringregEx=\"a+\";//表示一个或多个aPatternp=Pattern.compileregEx;Matcherm=p.matcher\"aaabbcedaccdeaa\";Strings=m.replaceAll\"A\";//结果为\"AbbcedAccdeA\"。如果写成空串，既可达到删除的功能，比如：Strings=m.replaceAll\"\";//结果为\"bbcedccde\"//String类提供replaceAll和replaceFirst方法也支持正则表达式：Stringss=s.replaceFirst\"a+\",\"A\";Stringss=s.replaceAll\"shrubbery|tree|herring\",\"banana\";```2.对象和类2.1.浅拷贝和深拷贝java里的clone分为：1.浅复制（浅克隆）:浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。2.深复制（深克隆）：深复制把要复制的对象所引用的对象都复制了一遍。Java中对象的克隆,为了获取对象的一份拷贝，我们可以利用Object类的clone方法。必须要遵循下面三点1.在派生类中覆盖基类的clone方法，并声明为public【Object类中的clone方法为protected的】。2.在派生类的clone方法中，调用super.clone。3.在派生类中实现Cloneable接口。Object类里的clone方法是浅复制（浅克隆）浅拷贝：```java@OverridepublicObjectclonethrowsCloneNotSupportedException{returnsuper.clone;}```深拷贝1：```java@OverridepublicObjectclonethrowsCloneNotSupportedException{Studentstudent=Studentsuper.clone;//将引用的对象teacher也clone下student.setTeacherTeacherstudent.getTeacher.clone;returnstudent;}```深拷贝2：```javapublicObjectdeepCopythrowsException{//将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。//所以利用这个特性可以实现对象的深拷贝ByteArrayOutputStreambos=newByteArrayOutputStream;ObjectOutputStreamoos=newObjectOutputStreambos;oos.writeObjectthis;//将流序列化成对象ByteArrayInputStreambis=newByteArrayInputStreambos.toByteArray;ObjectInputStreamois=newObjectInputStreambis;returnois.readObject;}```深拷贝、浅拷贝ImplementtheCloneableinterfacewithintheclassthatyouwanttoclone;thencallthatobject'sclonemethodtomakeacopyofit.ThefollowingcodedemonstrateshowtomaketheTeamclasscloneable:```javapackageorg.tubez.util;publicclassTeamimplementsTeamType,Cloneable,Serializable{privateStringname;privateStringcity;publicStringgetName{returnname;}publicvoidsetNameStringname{this.name=name;}publicStringgetCity{returncity;}publicvoidsetCityStringcity{this.city=city;}publicStringgetFullName{returnthis.name+\"\"+this.city;}/***OverridesObject'sclonemethodtocreateadeepcopy**@return*/publicObjectclone{Objectobj=null;try{ByteArrayOutputStreambaos=newByteArrayOutputStream;ObjectOutputStreamoos=newObjectOutputStreambaos;oos.writeObjectthis;oos.close;ByteArrayInputStreambais=newByteArrayInputStreambaos.toByteArray;ObjectInputStreamois=newObjectInputStreambais;obj=ois.readObject;ois.close;}catchIOExceptione{e.printStackTrace;}catchClassNotFoundExceptioncnfe{cnfe.printStackTrace;}returnobj;}/***OverridesObject'sclonemethodtocreateashallowcopy**@return*/publicObjectshallowCopyClone{try{returnsuper.clone;}catchCloneNotSupportedExceptionex{returnnull;}}@OverridepublicbooleanequalsObjectobj{ifthis==obj{returntrue;}ifobjinstanceofTeam{Teamother=Teamobj;returnother.getName.equalsthis.getName&&other.getCity.equalsthis.getCity;}else{returnfalse;}}}```Next,tomakeadeepcopyofaTeamobject,theclonemethodneedstobecalledagainstthatobject.Tomakeashallowcopyoftheobject,theshallowCopyClonemethodmustbecalled.Thefollowingcodedemonstratesthistechnique:```javaTeamteam1=newTeam;Teamteam2=newTeam;team1.setCity\"Boston\";team1.setName\"Bandits\";team2.setCity\"Chicago\";team2.setName\"Wildcats\";Teamteam3=team1;Teamteam4=Teamteam2.clone;Teamteam5=team1.shallowCopyClone;System.out.println\"Team3:\";System.out.printlnteam3.getCity;System.out.printlnteam3.getName;System.out.println\"Team4:\";System.out.printlnteam4.getCity;System.out.printlnteam4.getName;//Teamsmovetodifferentcitiesteam1.setCity\"St.Louis\";team2.setCity\"Orlando\";System.out.println\"Team3:\";System.out.printlnteam3.getCity;System.out.printlnteam3.getName;System.out.println\"Team4:\";System.out.printlnteam4.getCity;System.out.printlnteam4.getName;System.out.println\"Team5:\";System.out.printlnteam5.getCity;System.out.printlnteam5.getName;ifteam1==team3{System.out.println\"team1andteam3areequal\";}else{System.out.println\"team1andteam3areNOTequal\";}ifteam1==team5{System.out.println\"team1andteam5areequal\";}else{System.out.println\"team1andteam5areNOTequal\";}```Althoughthiscodedoesnotdoverymuch,itdemonstrateshowtomakeacloneofanobject.Theresultingoutputwouldbeasfollows.Team3:BostonBanditsTeam4:ChicagoWildcatsTeam3:St.LouisBanditsTeam4:ChicagoWildcatsTeam5:BostonBanditsteam1andteam3areequalteam1andteam5areNOTequal3.泛型4.枚举和注解5.Lambda和Stream`www.jianshu.com/p/613a6118e2e0`Java8Streamsmapexampleswww.mkyong.com/java8/java8streamsmapexamples/6.集合Java中Map常见有HashMap、TreeMap、ConcurrentHashMap、LinkedHashMap、WeakHashMap、IdentityHashMap等。6.1.FAQ字符串hash算法为啥使用31？ConcurrentHashMap和HashMap在实现上有什么差异？WeakHashMap使用在哪些场景？TreeMap和LinkedHashMap是如何保证它的顺序的？它们两个哪个的有序实现比较好？用Map实现缓存有哪些方式？6.2.hashcodehashcode是对象导出的一个整数值。Object类的hashCode为每一个对象返回一个默认的散列码，其值为对象的存储地址。而字符串的hashcode算法是hash=31*hash+charAti;如果a.equalsb为true，那么a和b必须具有相同的hashcode；!_v_images/20191129175524.png这就决定了存入HashMap、HashSet的对象必须覆盖实现equals和hashCode方法，当发生散列冲突时，要调用equals方法查看对象是否已经存在。6.3.TreeSetTreeSet是一个有序集合，可以自动地对元素进行排序，排序是用树结构完成（用redblacktree实现），元素被添加到树中，被放置在正确的排序位置上，而迭代器总是以排好序的顺序访问每一个元素。将元素添加到树中要比添加到散列表中慢，但是，比将元素添加到数组或链表的正确位置上还是要快很多。（add：hash>tree>arr/linked放入TreeSet中的元素必须实现Comparable或构造treeSet时指定Comparator。```javaclassItemimplementsComparable<Item>{publicintcompareToItemother{......}}publicTreeSetComparator<?superE>comparator```6.4.队列与双端队列队列是在尾部添加一个元素，在头部删除一个元素。双端队列是可以在头部hehe尾部同时添加或删除元素。Deque有两个实现ArrayDeque和LinkedDeque。优先级队列（PriorityQueue）按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，调用remove方法时，总是获取队列最小的元素，但此时并没有对所有的元素进行排序，其排序是迭代完成的。优先级队列使用了堆（heap）这种数据结构。heap是一个可以自我调整的二叉树，对树执行add和remove操作时，可以让最小的元素移动到根，而不必花时间对元素进行排序。使用优先级队列的典型示例是任务调度。总是先执行优先级最高的任务（1设为最高）。6.5.MapHashMap对键进行散列，TreeMap的键必须实现Comparable接口。散列或比较函数只能作用于键。WeakHashMap的特点是，当除了自身有对key的引用外，此key没有其他对象引用，那么此map会自动丢弃此键值对。```javaStringa=newString\"a\";Stringb=newString\"b\";Map<String,String>map=newHashMap<>;map.puta,\"aaa\";map.putb,\"bbb\";Map<String,String>weakmap=newWeakHashMap<>;weakmap.puta,\"aaa\";weakmap.putb,\"bbb\";map.removea;a=null;//a指向null后，除了WeakHashMap中还保存a引用外已经没有指向a的引用了，所以WeakHashMap会自动回收a的键值对b=null;//虽然b对象指向了null，但HashMap中还有指向b的指针，所以b将保留在内存中System.gc;forMap.Entry<String,String>en:map.entrySet{System.out.println\"map:\"+en.getKey+\":\"+en.getValue;}//out:map:b:bbbforMap.Entry<String,String>en:weakmap.entrySet{System.out.println\"weakmap:\"+en.getKey+\":\"+en.getValue;}//out:weakmap:b:bbb```6.6.LinkedHashSet&LinkedHashMap!_v_images/20191129175539.pngLinkedHash可以避免元素随机排列，当元素插入hash桶（bucket）中时，就会并入双向链表中。LinkedHashMap的iterator顺序是*访问顺序*，而不是插入顺序。每次调用get/put方法时，受到影响的元素被移动到链表的尾部（散列桶中不受影响）。LinkedHashMap可用来构造高速缓存。LinkedHashMap最常用元素放在链表尾部，头部是最不常用的元素。遵循缓存“最近最少使用”原则，删除链表头部元素，最近访问元素放在表尾。覆盖LinkedHashMapremoveEldestEntry方法可以判断是否删除最旧的元素。```java/***返回true时，删除eldest元素，添加一个新元素；*返回false时，仅调整元素在链表的位置。*不翻盖时，默认返回false，链表长度不可控。*/protectedbooleanremoveEldestEntryMap.Entry<K,V>eldest{returnsize>100;//超过100个元素时，删除最旧的元素}```6.7.IdentityHashMapIdentityHashMap键的散列值不是使用hashCode计算的，而是使用identityHashCode计算的（使用键对象的内存地址计算散列码）。IdentityHashMap元素比较是使用==，而不是equals，即直接比较内存地址。也就是说，不同键对象，即使内容相同，也被视为不同的对象。常用于对象遍历算法（如：对象序列化？*不是很明白？*）6.8.视图与包装器```javaCardcardDeck=newCard23;......//返回一个对象视图（对象引用映射，故不能修改此List），而非ArrayListList<Card>cardList=Arrays.asListcardDeck;List<String>names=Arrays.asList\"aa\",\"bb\",\"cc\";//publicstatic<T>List<T>nCopiesintn,To//创建一个100个字符串的List，每一个串为DEFUALT，次串只被存储一次//返回的List对象不可修改，即add方法不能用List<String>strs=Collections.nCopies100,\"DEFAULT\";//返回一个视图对象，它是一个不可修改的单元素集合publicstatic<T>Set<T>singletonTo;//只有一个元素publicstatic<T>List<T>singletonListTo;publicstatic<K,V>Map<K,V>singletonMapKkey,Vvalue;//不可修改视图，用于查看，防止非法修改publicstatic<T>Collection<T>unmodifiableCollectionCollection<?extendsT>c;publicstatic<T>List<T>unmodifiableListList<?extendsT>list;publicstatic<T>Set<T>unmodifiableSetSet<?extendsT>s;publicstatic<T>SortedSet<T>unmodifiableSortedSetSortedSet<T>s;publicstatic<K,V>Map<K,V>unmodifiableMapMap<?extendsK,?extendsV>m;//同步视图publicstatic<K,V>Map<K,V>synchronizedMapMap<K,V>m;//检查视图，用来检查泛型类型不匹配publicstatic<E>List<E>checkedListList<E>list,Class<E>type;List<String>safeStrings=Collections.checkedListlist,String.class;```6.9.一些用法方法一：倒序遍历想遍历又想删除，你应该倒着来```javaArrayList<String>list=newArrayList<String>;list.add\"one\";intn=list.size;forinti=n1;i>=0;i{iflist.geti.equals\"one\"{list.removei;}}System.out.printlnlist;```方法二：Iterator接口```javaIterator<String>itr=list.iterator;whileitr.hasNext{Stringe=sListIterator.next;ife.equals\"3\"{itr.remove;}}```7.文件7.1.InputStream转换成String的几种方法方法1```javaInputStreaminputStream=newFileInputStream\"d:/sample.txt\";Scannerscanner=newScannerinputStream,\"UTF8\";Stringtext=scanner.useDelimiter\"\\\\A\".next;System.out.printlntext;scanner.close;```方法2```javaInputStreaminputStream=newFileInputStream\"d:/sample.txt\";StringBuilderstringBuilder=newStringBuilder;BufferedReaderbufferedReader=newBufferedReadernewInputStreamReaderinputStream;booleanfirstLine=true;Stringline=null;;whileline=bufferedReader.readLine!=null{if!firstLine{stringBuilder.appendSystem.getProperty\"line.separator\";}else{firstLine=false;}stringBuilder.appendline;}System.out.printlnstringBuilder.toString;```方法3```javaInputStreaminputStream=newFileInputStream\"d:/sample.txt\";bytebuffer=newbyte2048;intreadBytes=0;StringBuilderstringBuilder=newStringBuilder;whilereadBytes=inputStream.readbuffer>0{stringBuilder.appendnewStringbuffer,0,readBytes;}System.out.printlnstringBuilder.toString;```方法4```javaimportorg.apache.commons.io.IOUtils;InputStreaminputStream=newFileInputStream\"d:/sample.txt\";Stringtext=IOUtils.toStringinputStream;System.out.printlntext;```方法5```javaimportcom.google.common.io.CharStreams;InputStreaminputStream=newFileInputStream\"d:/sample.txt\";Stringtext=CharStreams.toStringnewInputStreamReaderinputStream,\"UTF8\";System.out.printlntext;```方法6```javabytebytes=Files.readAllBytesPaths.get\"d:/sample.txt\";Stringtext=newStringbytes;System.out.printlntext;```7.2.java读取classpath下文件的两种方法java读取文件的两种方法：java.io和java.lang.ClassLoader（1）java.io:相对于当前用户目录的相对路径读取；注重与磁盘文件打交道或者纯javaproject中使用。（虽然ClassLoader方式更通用，但是如果不是javaEE环境，要定位到classpath路径下去读文件是不合理的。）它适用于非JavaWebProject。```JAVAFilefile=newFile\"...\";FileInputStreamfis=newFileInputStream\"...\";FileReaderfr=newFileReader\"...\";```（2）java.lang.ClassLoader:相对于classpath的相对路径读取；建议在javaEE环境中都使用这种方式。```JAVAClassLoaderloader=XXXClass.class.getClassLoader;//orClassLoaderloader=Thread.currentThread.getContextClassLoader;URLurl=loader.getResource\"...\";Filefile=newFileurl.getFile;InputStreaminput=loader.getResourceAsStream\"...\";```它适用于WebProject或jar文件。**总结：**推荐使用相对于当前classpath的相对路径来查找资源，也就是ClassLoader方式。ClassLoader类的getResourceStringname,getResourceAsStreamStringname等方法。读取属性文件常用到的ResourceBundle类的getBundleStringpath也是如此。通过查看ClassLoader类及其相关类的源代码，我发现，它实际上还是使用了URI形式的绝对路径。通过得到当前classpath的URI形式的绝对路径，构建了相对路径的URI形式的绝对路径。7.3.监控目录的变化ByusingaWatchService,youcansubscribetobenotifiedoneventshappeningonthatfolder.Inthisexample,wesubscribeforENTRY_CREATE,ENTRY_MODIFY,andENTRY_DELETEevents:```javaSystem.out.println\"WatchEvent,pressq<Enter>toexit\";FileSystemfileSystem=FileSystems.getDefault;WatchServiceservice=fileSystem.newWatchService;Pathpath=fileSystem.getPath\".\";System.out.println\"Watching:\"+path.toAbsolutePath;path.registerservice,StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE,StandardWatchEventKinds.ENTRY_MODIFY;booleanshouldContinue=true;whileshouldContinue{WatchKeykey=service.poll250,TimeUnit.MILLISECONDS;//CodetostoptheprogramwhileSystem.in.available>0{intreadChar=System.in.read;ifreadChar=='q'||readChar=='Q'{shouldContinue=false;break;}}ifkey==nullcontinue;forWatchEvent<?>event:key.pollEvents{ifevent.kind==StandardWatchEventKinds.OVERFLOWcontinue;WatchEvent<Path>ev=WatchEvent<Path>event;Pathfilename=ev.context;System.out.println\"Eventdetected:\"+filename.toString+\"\"+ev.kind;}booleanvalid=key.reset;if!valid{break;}}```7.4.读取Jar包中的资源文件参考：Java:ListingthecontentsofaresourcedirectoryUsingURLConnectiontolistfilesanddirectoriesonFTPserver```java/***Listdirectorycontentsforaresourcefolder.Notrecursive.*Thisisbasicallyabruteforceimplementation.*WorksforregularfilesandalsoJARs.**@paramclazzAnyjavaclassthatlivesinthesameplaceastheresourcesyouwant.*@parampathShouldendwith\"/\",butnotstartwithone.*@returnJustthenameofeachmemberitem,notthefullpaths.*/StringgetResourceListingClassclazz,StringpaththrowsURISyntaxException,IOException{URLdirURL=clazz.getClassLoader.getResourcepath;ifdirURL!=null&&dirURL.getProtocol.equals\"file\"{/*Afilepath:easyenough*/returnnewFiledirURL.toURI.list;}ifdirURL==null{/**Incaseofajarfile,wecan'tactuallyfindadirectory.*Havetoassumethesamejarasclazz.*/Stringme=clazz.getName.replace\".\",\"/\"+\".class\";dirURL=clazz.getClassLoader.getResourceme;}ifdirURL.getProtocol.equals\"jar\"{/*AJARpath*/StringjarPath=dirURL.getPath.substring5,dirURL.getPath.indexOf\"!\";//stripoutonlytheJARfileJarFilejar=newJarFileURLDecoder.decodejarPath,\"UTF8\";Enumeration<JarEntry>entries=jar.entries;//givesALLentriesinjarSet<String>result=newHashSet<String>;//avoidduplicatesincaseitisasubdirectorywhileentries.hasMoreElements{Stringname=entries.nextElement.getName;ifname.startsWithpath{//filteraccordingtothepathStringentry=name.substringpath.length;intcheckSubdir=entry.indexOf\"/\";ifcheckSubdir>=0{//ifitisasubdirectory,wejustreturnthedirectorynameentry=entry.substring0,checkSubdir;}result.addentry;}}returnresult.toArraynewStringresult.size;}thrownewUnsupportedOperationException\"CannotlistfilesforURL\"+dirURL;}```", "Coding\\Java/Hibernate问答集.md": "<fontcolor=red>KeyGenerator</font>1.Assigned主键由外部程序负责生成，无需Hibernate参与。2.hilo通过hi/lo算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态。3.seqhilo与hilo类似，通过hi/lo算法实现的主键生成机制，只是主键历史状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。4.increment主键按数值顺序递增。此方式的实现机制为在当前应用实例中维持一个变量，以保存着当前的最大值，之后每次需要生成主键的时候将此值加1作为主键。这种方式可能产生的问题是：如果当前有多个实例访问同一个数据库，那么由于各个实例各自维护主键状态，不同实例可能生成同样的主键，从而造成主键重复异常。因此，如果同一数据库有多个实例访问，此方式必须避免使用。5.identity采用数据库提供的主键生成机制。如DB2、SQLServer、MySQL中的主键生成机制。6.sequence采用数据库提供的sequence机制生成主键。如Oralce中的Sequence。7.native由Hibernate根据底层数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式。8.uuid.hex由Hibernate基于128位唯一值产生算法生成16进制数值（编码后以长度32的字符串表示）作为主键。9.uuid.string与uuid.hex类似，只是生成的主键未进行编码（长度16）。在某些数据库中可能出现问题（如PostgreSQL）。10.foreign使用外部表的字段作为主键。一般而言，利用uuid.hex方式生成主键将提供最好的性能和数据库平台适应性。另外由于常用的数据库，如Oracle、DB2、SQLServer、MySql等，都提供了易用的主键生成机制（AutoIncrease字段或者Sequence）。我们可以在数据库提供的主键生成机制上，采用generatorclass=native的主键生成方式。对于并发Insert要求较高的系统，推荐采用uuid.hex作为主键生成机制。如果需要采用定制的主键产生算法，则在此处配置主键生成器，主键生成器必须实现net.sf.hibernate.id.IdentifierGenerator接口。<fontcolor=red>Inverse和和Cascade</font><u>Inverse指的是关联关系的控制方向，而cascade指的是层级之间的连锁操作。</u>Inverse，直译为“反转”。关联关系中，inverse=”false”的为主动方，由主动方负责维护关联关系。具体可参见一对多关系中的描述。而Cascade，译为“级联”，表明对象的级联关系，如TUser的Cascade设为all，就表明如果发生对user对象的操作，需要对user所关联的对象也进行同样的操作。如对user对象执行save操作，则必须对user对象相关联的address也执行save操作。<fontcolor=red>锁机制</font>Hibernate支持两种锁机制：即通常所说的“悲观锁（PessimisticLocking）”和“乐观锁（OptimisticLocking）”。**悲观锁（PessimisticLocking）**悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。<u>悲观锁的实现，往往依靠数据库提供的锁机制</u>（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。一个典型的倚赖数据库的悲观锁调用：```javaStringhqlStr=\"fromTUserasuserwhereuser.name='Erica'\";Queryquery=session.createQueryhqlStr;query.setLockMode\"user\",LockMode.UPGRADE;//加锁//select*fromt_userwherename='Erica'forupdateListuserList=query.list;//执行查询，获取数据```这里Hibernate通过使用数据库的forupdate子句实现了悲观锁机制。这条sql语句锁定了t_user表中所有符合检索条件（name='Erica'）的记录。本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。Hibernate的加锁模式有：LockMode.NONE：无锁机制。LockMode.WRITE：Hibernate在Insert和Update记录的时候会自动获取。LockMode.READ：Hibernate在读取记录的时候会自动获取。以上这三种锁机制一般由Hibernate内部使用，如Hibernate为了保证Update过程中对象不会被外界修改，会在save方法实现中自动为目标对象加上WRITE锁。LockMode.UPGRADE：利用数据库的forupdate子句加锁。LockMode.UPGRADE_NOWAIT：Oracle的特定实现，利用Oracle的forupdatenowait子句实现加锁。上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现：Criteria.setLockMode、Query.setLockMode、Session.lock**乐观锁（OptimisticLocking）**乐观锁，大多是基于数据版本（Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量下的系统整体性能表现。需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。<fontcolor=red>Cache管理</font>在我们的系统与第三方系统共享数据库的情况下，Hibernate的Cache机制可能失效。如果在同一套系统中，基于Hibernate和基于JDBC的两种数据访问方式并存，那么通过JDBC更新数据库的时候，Hibernate同样无法获知数据更新的情况，从而导致脏数据的出现。Hibernate中的Cache大致分为两层，第一层Cache在Session实现，属于事务级数据缓冲，一旦事务结束，这个Cache也就失效。此层Cache为内置实现，无需我们进行干涉。第二层Cache，是Hibernate中对其实例范围内的数据进行缓存的管理容器。也是这里我们讨论的。Hibernate提供了面向第三方Cache实现的接口,第二级Cache实现有：EHCache、OSCache等。cacheusage可选值有以下几种：1.readonly只读。2.readwrite可读可写。3.nonstrictreadwrite如果程序对并发数据修改要求不是非常严格，只是偶尔需要更新数据，可以采用本选项，以减少无谓的检查，获得较好的性能。4.transactional事务性cache。在事务性Cache中，Cache的相关操作也被添加到事务之中，如果由于某种原因导致事务失败，我们可以连同缓冲池中的数据一同回滚到事务开始之前的状态。目前Hibernate内置的Cache中，只有JBossCache支持事务性的Cache实现。<fontcolor=red>Hibernate查询的N+1问题及解决方案</font>Hibernate数据库查询，用的最多的是两个方法：Query.list;Query.iterate;对于list方法而言，实际上Hibernate是通过一条SelectSQL获取所有的记录。并将其读出，填入到POJO中返回。而iterate方法，则是首先通过一条SelectSQL获取所有符合查询条件的记录的id，再对这个id集合进行循环操作，通过单独的SelectSQL取出每个id所对应的记录，之后填入POJO中返回。也就是说，对于list操作，需要一条SQL完成。而对于iterate操作，需要n+1条SQL。看上去iterate方法似乎有些多余，但在不同的情况下确依然有其独特的功效，如对海量数据的查询，如果用list方法将结果集一次取出，内存的开销可能无法承受。另一方面，对于我们现在的Cache机制而言，list方法将不会从Cache中读取数据，它总是一次性从数据库中直接读出所有符合条件的记录。而iterate方法因为每次根据id获取数据，这样的实现机制也就为从Cache读取数据提供了可能，hibernate首先会根据这个id在本地Cache内寻找对应的数据，如果没找到，再去数据库中检索。如果系统设计中对Cache比较倚重，则请注意编码中这两种不同方法的应用组合，有针对性的改善代码，最大程度提升系统的整体性能表现。```java/***会出现N+1问题，所谓的N+1指的是发出了N+1条sql语句**1:发出一条查询id列表的语句*Hibernate:selectstudent0_.idascol_0_0_fromt_studentstudent0_**N:根据id发出N条sql语句，加载相关的对象*Hibernate:selectstudent0_.idasid0_0_,student0_.nameasname0_0_,*student0_.createTimeascreateTime0_0_,student0_.classesidasclassesid0_0_*fromt_studentstudent0_wherestudent0_.id=?*/Iteratoriter=session.createQuery\"fromStudent\".iterate;whileiter.hasNext{Studentstudent=Studentiter.next;System.out.printlnstudent.getName;}```iterate是使用缓存的（session里面缓存，也即是一级缓存）list和iterate配合使用```java/****在默认情况下，每次执行list查询实体对象都会发出查询语句，除非配置了查询缓存*虽然一级缓存中存在Student数据，但list不用，所以仍然发出查询语句，**其实list就是只向缓存中放入数据，而不利用缓存中的数据*/Liststudents=session.createQuery\"fromStudent\".list;forIteratoriter=students.iterator;iter.hasNext;{Studentstudent=Studentiter.next;System.out.printlnstudent.getName;}System.out.println\"\";/***避免了N+1问题**因为执行list操作后会将数据放到session的缓存中（一级缓存），所以采用iterate的时候*首先会发出一条查询id列表的语句，再根据id到缓存中加载相应的数据，如果缓存中存在与之匹配的数据*则不再发出根据id查询的sql语句，直接使用缓存中的数据**Iterate方法如果缓存中存在数据，它可以提高性能，否则出现N+1问题**/Iteratoriter=session.createQuery\"fromStudent\".iterate;whileiter.hasNext{Studentstudent=Studentiter.next;System.out.printlnstudent.getName;}```<fontcolor=red>比较Hibernate的三种检索策略优缺点</font>1.立即检索；优点：对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；缺点：1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；2.延迟检索：优点：由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；缺点：应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；3.迫切左外连接检索优点：1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少；缺点：1可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能；<fontcolor=red>Hibernate的实体Bean三种状态？这三种状态的转换过程？</font><fontcolor=red>在数据库中条件查询速度很慢的时候,如何优化?</font>1.建索引2.减少表之间的关联3.优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面4.简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据<fontcolor=red>session.load和session.get的区别</font>Session.load/get方法均可以根据指定的实体类和id从数据库读取记录，并返回与之对应的实体对象。其区别在于：如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObjectNotFoundException。Load方法可返回实体的代理类实例，而get方法永远直接返回实体类。load方法可以充分利用内部缓存和二级缓存中的现有数据，而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，直接调用SQL完成数据读取。Session在加载实体对象时，将经过的过程：首先，Hibernate中维持了两级缓存。第一级缓存由Session实例维护，其中保持了Session当前所有关联实体的数据，也称为内部缓存。而第二级缓存则存在于SessionFactory层次，由当前所有由本SessionFactory构造的Session实例共享。出于性能考虑，避免无谓的数据库访问，Session在调用数据库查询功能之前，会先在缓存中进行查询。首先在第一级缓存中，通过实体类型和id进行查找，如果第一级缓存查找命中，且数据状态合法，则直接返回。之后，Session会在当前“NonExists”记录中进行查找，如果“NonExists”记录中存在同样的查询条件，则返回null。“NonExists”记录了当前Session实例在之前所有查询操作中，未能查询到有效数据的查询条件（相当于一个查询黑名单列表）。如此一来，如果Session中一个无效的查询条件重复出现，即可迅速作出判断，从而获得最佳的性能表现。对于load方法而言，如果内部缓存中未发现有效数据，则查询第二级缓存，如果第二级缓存命中，则返回。如在缓存中未发现有效数据，则发起数据库查询操作（SelectSQL），如经过查询未发现对应记录，则将此次查询的信息在“NonExists”中加以记录，并返回null。根据映射配置和SelectSQL得到的ResultSet，创建对应的数据对象。将其数据对象纳入当前Session实体管理容器（一级缓存）。执行Interceptor.onLoad方法（如果有对应的Interceptor）。将数据对象纳入二级缓存。如果数据对象实现了LifeCycle接口，则调用数据对象的onLoad方法。返回数据对象。<fontcolor=red>Session管理</font>大多数情况下，Session管理的目标聚焦于通过合理的设计，避免Session的频繁创建和销毁，从而避免大量的内存开销和频繁的JVM垃圾回收，保证系统高效平滑运行。在各种Session管理方案中，ThreadLocal模式得到了大量使用。ThreadLocal是Java中一种较为特殊的线程绑定机制。通过ThreadLocal存取的数据，总是与当前线程相关，也就是说，JVM为每个运行的线程，绑定了私有的本地实例存取空间，从而为多线程环境常出现的并发访问问题提供了一种隔离机制。首先，我们需要知道，SessionFactory负责创建Session，SessionFactory是线程安全的，多个并发线程可以同时访问一个SessionFactory并从中获取Session实例。而Session并非线程安全，也就是说，如果多个线程同时使用一个Session实例进行数据存取，则将会导致Session数据存取逻辑混乱。下面是一个典型的Servlet，我们试图通过一个类变量session实现Session的重用，以避免每次操作都要重新创建：```javapublicclassTestServletextendsHttpServlet{privateSessionsession;publicvoiddoGetHttpServletRequestrequest,HttpServletResponseresponsethrowsServletException,IOException{session=getSession;doSomething;session.flush;}publicvoiddoSomething{......//基于session的存取操作}}```代码看上去正确无误，甚至在我们单机测试的时候可能也不会发生什么问题，但这样的代码一旦编译部署到实际运行环境中，接踵而来的莫名其妙的错误很可能会使得我们摸不找头脑。问题出在哪里？首先，Servlet运行是多线程的，而应用服务器并不会为每个线程都创建一个Servlet实例，也就是说，TestServlet在应用服务器中只有一个实例（在Tomcat中是这样，其他的应用服务器可能有不同的实现），而这个实例会被许多个线程并发调用，doGet方法也将被不同的线程反复调用，可想而知，每次调用doGet方法，这个唯一的TestServlet实例的session变量都会被重置，线程A的运行过程中，其他的线程如果也被执行，那么session的引用将发生改变，之后线程A再调用session，可能此时的session与其之前所用的session就不再一致，显然，错误也就不期而至。ThreadLocal的出现，使得这个问题迎刃而解。我们对上面的例子进行一些小小的修改：```javapublicclassTestServletextendsHttpServlet{privateThreadLocallocalSession=newThreadLocal;publicvoiddoGetHttpServletRequestrequest,HttpServletResponseresponsethrowsServletException,IOException{localSession.setgetSession;doSomething;session.flush;}publicvoiddoSomething{Sessionsession=SessionlocalSession.get;......//基于session的存取操作}}```可以看到，localSession是一个ThreadLocal类型的对象，在doGet方法中，我们通过其set方法将获取的session实例保存，而在doSomething方法中，通过get方法取出session实例。这也就是ThreadLocal的独特之处，它会为每个线程维护一个私有的变量空间。实际上，其实现原理是在JVM中维护一个Map，这个Map的key就是当前的线程对象，而value则是线程通过ThreadLocal.set方法保存的对象实例。当线程调用ThreadLocal.get方法时，ThreadLocal会根据当前线程对象的引用，取出Map中对应的对象返回。这样，ThreadLocal通过以各个线程对象的引用作为区分，从而将不同线程的变量隔离开来。回到上面的例子，通过应用ThreadLocal机制，线程A的session实例只能为线程A所用，同样，其他线程的session实例也各自从属于自己的线程。这样，我们就实现了线程安全的Session共享机制。**spring对hibernate是如何避免session的线程不安全的呢？**", "Coding\\Java/Jackson json序列化.md": "Jackson：自定义处理序列化和反序列化jackson中自定义处理序列化和反序列化jackyrong.iteye.com/blog/2005323```javapublicclassItemSerializerextendsJsonSerializer<Item>{@OverridepublicvoidserializeItemvalue,JsonGeneratorjgen,SerializerProviderproviderthrowsIOException,JsonProcessingException{jgen.writeStartObject;jgen.writeNumberField\"id\",value.id;jgen.writeStringField\"itemName\",value.itemName;jgen.writeNumberField\"owner\",value.owner.id;jgen.writeEndObject;}}......ItemmyItem=newItem1,\"theItem\",newUser2,\"theUser\";ObjectMappermapper=newObjectMapper;SimpleModulemodule=newSimpleModule;module.addSerializerItem.class,newItemSerializer;mapper.registerModulemodule;Stringserialized=mapper.writeValueAsStringmyItem;```更简单的方法：```java@JsonSerializeusing=ItemSerializer.classpublicclassItem{...}```Jackson：自定义忽略规则Jacksonserialization:howtoignoresuperclasspropertiesstackoverflow.com/questions/26945580/jacksonserializationhowtoignoresuperclassproperties```javaprivatestaticclassIgnoreInheritedIntrospectorextendsJacksonAnnotationIntrospector{@OverridepublicbooleanhasIgnoreMarkerfinalAnnotatedMemberm{returnm.getDeclaringClass==Base.class||super.hasIgnoreMarkerm;}}publicstaticvoidmainStringargsthrowsJsonProcessingException{finalObjectMappermapper=newObjectMapper;mapper.setAnnotationIntrospectornewIgnoreInheritedIntrospector;finalBeanbean=newBean\"a\",\"b\";System.out.printlnmapper.writerWithDefaultPrettyPrinter.writeValueAsStringbean;}```Jackson：在POJO的json序列化字符串中加入自定义属性Jackson:HowtoaddcustompropertytotheJSONwithoutmodifyingthePOJOstackoverflow.com/questions/14714328/jacksonhowtoaddcustompropertytothejsonwithoutmodifyingthepojo```javapublicclassJacksonSerializeWithExtraField{@TestpublicvoidtestAddExtraFieldthrowsException{ObjectMappermapper=newObjectMapper;mapper.registerModulenewSimpleModule{publicvoidsetupModuleSetupContextcontext{super.setupModulecontext;context.addBeanSerializerModifiernewBeanSerializerModifier{publicJsonSerializer<?>modifySerializerSerializationConfigconfig,BeanDescriptionbeanDesc,JsonSerializer<?>serializer{ifserializerinstanceofBeanSerializerBase{returnnewExtraFieldSerializerBeanSerializerBaseserializer;}returnserializer;}};}};mapper.writeValueSystem.out,newMyClass;//prints{\"classField\":\"classFieldValue\",\"extraField\":\"extraFieldValue\"}}classMyClass{privateStringclassField=\"classFieldValue\";publicStringgetClassField{returnclassField;}publicvoidsetClassFieldStringclassField{this.classField=classField;}}classExtraFieldSerializerextendsBeanSerializerBase{ExtraFieldSerializerBeanSerializerBasesource{supersource;}ExtraFieldSerializerExtraFieldSerializersource,ObjectIdWriterobjectIdWriter{supersource,objectIdWriter;}ExtraFieldSerializerExtraFieldSerializersource,StringtoIgnore{supersource,toIgnore;}protectedBeanSerializerBasewithObjectIdWriterObjectIdWriterobjectIdWriter{returnnewExtraFieldSerializerthis,objectIdWriter;}protectedBeanSerializerBasewithIgnoralsStringtoIgnore{returnnewExtraFieldSerializerthis,toIgnore;}publicvoidserializeObjectbean,JsonGeneratorjgen,SerializerProviderproviderthrowsIOException,JsonGenerationException{jgen.writeStartObject;serializeFieldsbean,jgen,provider;jgen.writeStringField\"extraField\",\"extraFieldValue\";jgen.writeEndObject;}}}```", "Coding\\Java/Java并发编程.md": "聊聊并发（一）――深入分析Volatile的实现原理www.infoq.cn/article/ftfjavavolatile聊聊并发（二）――JavaSE1.6中的Synchronizedwww.infoq.cn/article/javase16synchronized聊聊并发（三）――JAVA线程池的分析和使用www.infoq.cn/article/javathreadPool聊聊并发（四）――深入分析ConcurrentHashMapwww.infoq.cn/article/ConcurrentHashMap聊聊并发（五）――原子操作的实现原理www.infoq.cn/article/atomicoperation聊聊并发（六）――ConcurrentLinkedQueue的实现原理分析www.infoq.cn/article/ConcurrentLinkedQueue聊聊并发（七）――Java中的阻塞队列www.infoq.cn/article/javablockingqueue聊聊并发（八）――Fork/Join框架介绍www.infoq.cn/article/forkjoinintroduction聊聊并发――生产者消费者模式www.infoq.cn/article/producersandconsumersmode双重检查锁定与延迟初始化www.infoq.cn/article/doublecheckedlockingwithdelayinitialization1.Java线程1.1.1.进程状态转换my.oschina.net/mingdongcheng/blog/139263www.cnblogs.com/mengdd/archive/2013/02/20/2917966.htmlblog.javachen.com/2013/06/08/noteaboutjavathread.htmlm.oschina.net/blog/83586```flownew=>start:新建e=>end:终止runnable=>subroutine:就绪running=>subroutine:运行blocked=>subroutine:阻塞newright>runnableright>runningright>erunnable>blocked>running```1.1.2.Java线程基础一个Java应用总是从main方法开始运行，mian方法运行在一个线程内，它被称为主线程。线程总体分两类：用户线程和守候线程。当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。1.1.3.中断线程一旦创建一个新的线程，就产生一个新的调用栈。每一个线程都有一个*中断状态interruptedstatus*，当调用interrupt方法时，*中断状态*将被置位。每个线程都应该不时检查这个标志，以判断线程是否被中断。```javawhile!Thread.currentThread.isInterrupted{//domorework}```当在一个被阻塞的线程（调用sleep或wait）上调用interrupt方法时，将会抛出InterruptedException异常。2.一、线程基础知识2.1.什么是线程安全当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。1、类的行为与其规范完全一致2、在共享访问对象可变状态时需要进行正确的管理3、继承Thread与实现Runnable接口4、实现线程安全1、内置锁2、Adhoc、栈封闭ThreadLocal3、状态私有、不变性4、只读共享5、线程安全共享（对象内部实现线程安全，多线程间通过接口来访问）5、设计原则？2.2.线程间通信方式通信是指线程之间以何种机制来交换信息。在Java中线程之间的通信机制有两种：共享内存和消息传递。在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写读内存中的公共状态来隐式进行通信。延伸阅读点Java内存模型在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。1、共享内存2、管道流3、线程A等待（Wait），线程B唤醒（notify）归属于Object4、Thread类Join让彼此交替运行的线程顺序执行，线程A通过调用线程B.join,线程A需要等线程B执行完再执行5、观察者模式Observable、Observer2.3.如何实现线程安全1、类不可变、无状态2、线程封闭技术：单线程内访问数据，不需要同步。Adhoc：维护线程封闭性职责完全有程序实现来担当JDBC的Connection,Swing事件分发线程.栈封闭：使用局部变量，保存在线程栈中不对外共享。延伸阅读点：方法调用和执行是怎样实现的？ThreadLock：线程局部变量副本。3、只读共享4、synchronized5、ReentrantLock6、同步工具类：CountDownLatch：闭锁，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。CyclicBarrier：栅栏，当一个线程到达屏障时（通过调用CyclicBarrier.await），它会被阻塞，直到所有线程都到达屏障，然后在该点允许所有线程继续执行。与CountDownLatch不同的是，CyclicBarrier所有公共线程都到达后，可以继续执行下一个目标点，而CountDownLatch第一次到达指定点后，也就是记数器减制零，就无法再次执行下一目标工作Semaphore：信号量，主要用于限制资源允许访问的许可数。3.二、线程同步3.1.ThreadLocal源码分析理解3.2.synchronized3.3.ReentrantLock案例3.4.ReentrantLock与synchronized区别3.5.volatile关键字3.6.CAS4.三、集合与JUC框架Java多线程1、线程安全？1、类的行为与其规范完全一致2、在共享访问对象可变状态时需要进行正确的管理3、继承Thread与实现Runnable接口4、实现线程安全1、内置锁2、Adhoc、栈封闭ThreadLocal3、状态私有、不变性4、只读共享5、线程安全共享（对象内部实现线程安全，多线程间通过接口来访问）5、设计原则？1、2、同步1、ReentrantLock1、CAS2、独占锁3、锁公平性如何实现？AbstractQueuedSynchronizer2、synchronizedVSReentrantLock1、Lock上锁时提供更多的选择性与可见性2、synchronized会让获取锁的线程无期限等待，tryLock指定等待时间（独占锁）3、Synchronization同步代码简洁易于维护，Lock强制tryfinally结构并且要释放锁4、synchronized不提供不公平锁，永远公平5、conditions结合LOCK3、偏向锁4、ReentrantReadWriteLock5、ReadWriteLock3、CAS原理4、原子类5、AbstractQueuedSynchronizer2、同步1、ReentrantLock1、CAS2、独占锁3、锁公平性如何实现？AbstractQueuedSynchronizer2、synchronizedVSReentrantLock1、Lock上锁时提供更多的选择性与可见性2、synchronized会让获取锁的线程无期限等待，tryLock指定等待时间（独占锁）3、Synchronization同步代码简洁易于维护，Lock强制tryfinally结构并且要释放锁4、synchronized不提供不公平锁，永远公平5、conditions结合LOCK3、偏向锁4、ReentrantReadWriteLock5、ReadWriteLock3、CAS原理4、原子类5、AbstractQueuedSynchronizer5.BIO、NIO、AIO5.1.1.同步vs异步、阻塞vs非阻塞<u>一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。</u>同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。同步和异步是针对应用程序和OS内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。所以，IO操作可以分为3类：同步阻塞（即早期的IO操作）、同步非阻塞（NIO）、异步（AIO）。**同步阻塞**：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。**同步非阻塞**：在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。**异步**：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。”5.1.2.ReactorvsProactor一、ReactorandProactorIO读写时，多路复用机制都会依赖一个事件多路分离器，它负责把源事件的IO事件分离出来，分别到相应的read/write事件分离器。涉及到事件分离器的两种模式分别就是Reactor和Proactor，Reactor是基于同步IO的，Proactor是基于异步IO的。在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生比如文件描述符可读写，或者是socket可读写,事件分离者就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。在Proactor模式中，事件处理者或者代由事件分离者发起直接发起一个异步读写操作相当于请求，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作称有overlapped的技术，事件分离者等IOCompletion事件完成.这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例类操作类似。在Reactor中实现读：注册读就绪事件和相应的事件处理器事件分离器等待事件事件到来，激活分离器，分离器调用事件对应的处理器。事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。与如下Proactor真异步中的读过程比较：处理器发起异步读操作注意：操作系统必须支持异步IO。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。事件分离器等待操作完成事件在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。事件分离器呼唤处理器。事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。可以看出，两个模式的相同点，都是对某个IO事件的事件通知即告诉某个模块，这个IO操作可以进行或已经完成。在结构上，两者也有相同点：demultiplexor负责提交IO操作异步、查询设备是否可操作同步，然后当条件满足时，就回调handler;不同点在于，异步情况下Proactor，当回调handler时，表示IO操作已经完成;同步情况下Reactor，回调handler时，表示IO设备可以进行某个操作canreadorcanwrite，handler这个时候开始提交操作。<u>NIO通常采用Reactor模式，AIO通常采用Proactor模式。AIO简化了程序的编写，stream的读取和写入都有OS来完成，不需要像NIO那样子遍历Selector。Windows基于IOCP实现AIO，Linux只有eppoll模拟实现了AIO。</u>5.1.3.BIO、NIO、AIO适用场景分析BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。GitHub项目：github.com/Hellblazer/Pinkiegithub.com/rfqu/df4jgithub.com/dublintech/async_nio2_java7_examplesgithub.com/killme2008/geckogithub.com/koush/AndroidAsyncgithub.com/kilim/kilim帖子：stackoverflow.com/questions/16580914/javaniohttpclientrequestswiththreadpoolschenkangxian.iteye.com/blog/1288246weixiaolu.iteye.com/blog/1479656nobywhy1.iteye.com/blog/1508412www.ibm.com/developerworks/cn/java/jjavaio/ByteBuffer仔细阅读TIJ相关章节：TIJ4英文版：NewI/OP701页；中文版：18.10新I/OP584页网文：blog.csdn.net/wfeng007/article/details/5308614cuisuqiang.iteye.com/blog/1443212volatile用在多线程，同步变量。线程为了提高效率，将某成员变量如A拷贝了一份（如B），线程中对A的访问其实访问的是B。只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。volatile告诉jvm，它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A参考：sakyone.iteye.com/blog/668091www.infoq.com/cn/articles/ftfjavavolatilewww.ibm.com/developerworks/cn/java/jjtp06197.htmlExecutorService线程池my.oschina.net/20076678/blog/33392blog.csdn.net/peachpi/article/details/6771946ReentrantLock可重入锁tenyears.iteye.com/blog/48750www.blogjava.net/killme2008/archive/2007/09/14/145195.htmlmy.oschina.net/noahxiao/blog/101558LinkedBlockingDequeblog.csdn.net/guangcigeyun/article/details/82783555.1.4.常用异步框架5.1.4.1.Akka网络间异步调用。应用场景：服务端要处理大量的客户端的请求，并且处理请求耗费较长的时间。这时就需要使用并发处理。多线程是一种方法，这里使用Akka框架处理并发。Akka有三个角色：Client、Master、WorkerClient傻乎乎地发同步请求给Master，一直等到结果返回客户端才离开。Master接收客户端发来的请求，然后将请求交给Worker处理，处理完成之后将结果返回给Client。Worker负责具体的业务处理，它耗费的事件比较长。参考：分布式应用框架Akka快速入门blog.csdn.net/jmppok/article/details/17264495", "Coding\\Java/Java数据库访问.md": "Java数据库访问操作大概分为三类：JDBC、ORM、ActiveRecord1.JDBC1.sql2owww.sql2o.org,sql2oGithubgithub.com/StanAccy/sql2o2.SpringJdbcTemplatedocs.spring.io/spring/docs/current/springframeworkreference/html/jdbc.html,SpringJdbcTemplate用法详解692088846.iteye.com/blog/19624693.jOOQwww.jooq.org4.MyBatismybatis.github.io/mybatis3/，学习参考《MyBatis手册中文版》5.JDBIjdbi.org/众所周知，MySQL的MyISAM存储引擎是不支持事务的，然而，Mybatis对MySQL的MyISAM引擎都支持事务回滚；而SpringJdbc的事务职能支持InnoDB，对MyISAM是无法回滚。2.ORMHibernatehibernate.org/Ebeanebeanorm.github.io其他ORMLiteormlite.comMicroORMgithub.com/rufiao/persistsormulawww.sormula.org/home/3.ActiveRecordActiveJDBCjavalite.io/activejdbcActiveJpaGithubgithub.com/ActiveJpa/activejpa参考：基于Java的ActiveRecord开源项目my.oschina.net/huangyong/blog/267968只使用JFinal的ActiveRecord定义了一个servlet，然后在里面初始化了，在action里面就可以使用Article了```javapublicvoidinit{C3p0Pluginc3p0Plugin=newC3p0PluginjdbcUrl,username,passwd;c3p0Plugin.start;ActiveRecordPluginarp=newActiveRecordPluginc3p0Plugin;arp.addMapping\"jo_user\",Article.class;arp.start;System.out.println\"系统自定义初始化加载项完成...\";}```JFinal使用Spring的事务管理重写DbKit类，将Connection的获取与释放的地方均采用spring的DataSourceUtils来处理，这样就既可以直接使用spring的声明式事务，又可以使用Jfinal的activeRecord插件快速开发。总结比较喜欢的几种组合：1.springboot+gorm,例子见Github2.springboot+ebean，springbootebeanstartergithub.com/shailesh17/springbootebeanstarter3.springboot+sql2o/mybatis+自封装github.com/mybatis/mybatis3/issues/368", "Coding\\Java/Java网络协议编程.md": "TOC类型、bitbit:1bit位=1二进制数据byte:1byte=8bit位（128~127）字母:1字母=1byte=8bit位short:16位char:Unicode字符，16bit位int:32bit位，比如int类型占用4个字节，32位long:64bit位float:32bit位double:64bit位汉字：1汉字=2byte=16bit（***这里不是很准确，当编码不同的时候，1个汉字所占的字节数也会有所不同，有些编码是占2个字节，有些则不是，可能是3个或者4个***）byte、char、int区别与转换byte是字节数据类型，是有符号型的，占1个字节；大小范围为128―127;char是字符数据类型，是无符号型的，占2字节Unicode码）；大小范围是0―65535;char是一个16位二进制的Unicode字符，JAVA用char来表示一个字符；char可以表中文字符，byte不可以；char、byte、int对于英文字符，可以相互转化```javabyteg='b';//b对应ASCII是98charh=charg;chari=85;//U对应ASCII是85intj='h';//h对应ASCII是104```byte数组与16进制转换javabyte与十六进制字符串相互转换blog.csdn.net/worm0527/article/details/69939307byte数组与10进制转换开始说说高位优先和低位优先，我们看如下代码：inti=10;那么i在内存中的布局如何哪？假设内存是从低－－－>高增长的在低位优先的硬件里面，内存布局如下：00001010000000000000000000000000而在高位优先的内存中：00000000000000000000000000001010这就是我们经常听说的高位优先，低位优先。单片机的一个存储单元只能存储八位字节，题目已经指明‘两个8位二进制无符号数相加，其和可能超过8位’。存储这个超过8位的‘和’就不能用一个存储单元了，需要两个，有两个就有前后之分了，把‘和’的高于8位的高低位分开存储，低位在前高位在后就是这个意思。byte数组和int之间的转换www.cnblogs.com/lizhenlin/p/6807856.html如何判断变量在内存中如何放置的?低位在前还是高位在前blog.csdn.net/sweetfather/article/details/79781521原码、反码、补码1.byte的大小为8bits而int的大小为32bits2.java的二进制采用的是补码形式在这里先温习下计算机基础理论byte是一个字节保存的，有8个位，即8个0、1。8位的第一个位是符号位，也就是说00000001代表的是数字110000000代表的就是1所以正数最大位01111111，也就是数字127负数最大为11111111，也就是数字128上面说的是二进制原码，但是在java中采用的是补码的形式，下面介绍下什么是补码1、反码：一个数如果是正，则它的反码与原码相同；一个数如果是负，则符号位为1，其余各位是对原码取反；2、补码：利用溢出，我们可以将减法变成加法对于十进制数，从9得到5可用减法：9－4＝5因为4+6＝10，我们可以将6作为4的补数改写为加法：9+6＝15（去掉高位1，也就是减10）得到5.对于十六进制数，从c到5可用减法：c－7＝5因为7+9＝16将9作为7的补数改写为加法：c+9＝15（去掉高位1，也就是减16）得到5.在计算机中，如果我们用1个字节表示一个数，一个字节有8位，超过8位就进1，在内存中情况为（100000000），进位1被丢弃。⑴一个数为正，则它的原码、反码、补码相同⑵一个数为负，刚符号位为1，其余各位是对原码取反，然后整个数加11的原码为100000011的反码为11111110+11的补码为111111110的原码为000000000的反码为11111111（正零和负零的反码相同）+10的补码为100000000（舍掉打头的1，正零和负零的补码相同）Integer.toHexString的参数是int，如果不进行&0xff，那么当一个byte会转换成int时，由于int是32位，而byte只有8位这时会进行补位，例如补码11111111的十进制数为1转换为int时变为11111111111111111111111111111111好多1啊，呵呵！即0xffffffff但是这个数是不对的，这种补位就会造成误差。和0xff相与后，高24比特就会被清0了，结果就对了。Java中的一个byte，其范围是128~127的，而Integer.toHexString的参数本来是int，如果不进行&0xff，那么当一个byte会转换成int时，对于负数，会做位扩展，举例来说，一个byte的1（即0xff），会被转换成int的1（即0xffffffff），那么转化出的结果就不是我们想要的了。而0xff默认是整形，所以，一个byte跟0xff相与会先将那个byte转化成整形运算，这样，结果中的高的24个比特就总会被清0，于是结果总是我们想要的。", "Coding\\Java/JMS学习.md": "!_v_images/20191129172446.png!_v_images/20191129172455.png", "Coding\\Java/JVM垃圾回收机制.md": "!JVM垃圾回收机制_v_images/20210625105919560_19035.png", "Coding\\Java/shiro总结.md": "TOC学习序列Shiro学习系列blog.csdn.net/qq_34021712/column/info/26947springboot整合shiroshiro介绍一springboot整合shiro快速入门二springboot整合shiroWhitelabelErrorPage解决三springboot整合shiro配置记住我四springboot整合shiroehcache缓存五springboot整合shirosession管理六springboot整合shiro在线人数以及并发登录人数控制七springboot整合shiro登录失败次数限制八springboot整合shiro实现验证码认证九springboot使用shiro整合redis作为缓存十Shiro使用redis作为缓存解决shiro频繁访问Redis十一解决Shiro频繁访问Redis读取和更新session十二shiro整合oauth2.0服务端和客户端实现入门教程十三关于shiro使用密码加密加盐之后序列化失败的问题十四springboot整合shiro对密码进行MD5并加盐处理十五springboot整合shiro实现自己的登出十六springboot整合shiro关于登出时,redis中缓存没有清理干净的问题十七springboot整合shiroSimpleAuthenticationInfo参数该使用username还是User实体十八ApacheShiro+Zookeeper系统集群安全解决方案之缓存管理www.bbsmax.com/A/kvJ3EXo9dg/（一）shiro入门介绍（二）shiro的INI配置（三）shiro身份认证（ShiroAuthentication）（四）shiro授权（Authentication）访问控制（五）分布式集群系统下的高可用session解决方案（六）分布式集群系统下的高可用session解决方案Session共享（七）分布式集群系统下cache共享（八）web集群时session同步的3种方法SessionDAOvsCacheManagerSessionDAO、CacheManager两者的职责不一样。SessionDAO可以实现有缓存的，也可以实现没有的；而CacheManager不仅仅用于CachingSessionDAO，还有CachingRealmCacheManager实例会自动地直接传送到SessionDAO（通过EnterpriseCacheSessionDAO实现CacheManagerAware接口的性质）。然后，当SessionManager要求EnterpriseCacheSessionDAO去持久化一个Session时，它使用一个CacheManager去存储Session数据。如果想Session存于Redis中，有两种方式：1、实现Redis的SessionDAO就行；2、实现Redis的CacheManager，而SessionDao使用EnterpriseCacheSessionDAO，并设置cacheManager。集群HazelcastSupportinApacheShirostormpath.com/blog/hazelcastsupportapacheshiroApacheShiro+Zookeeper系统集群安全解决方案之缓存管理www.bbsmax.com/A/kvJ3EXo9dg/如今的系统多不是孤军奋战,在多结点会话共享管理方面有着各自的解决办法,比如Session粘连,基于Web容器的各种处理等或者类似本文说的完全接管Web容器的Session管理,只是做法不尽相同.而本...Apacheshiro集群实现系列www.bbsmax.com/A/GBJrlweEd0/备用：blog.csdn.net/lishehe/article/details/45218251Token、JWT登录Shrio框架Token认证思路blog.csdn.net/u011687186/article/details/80702912shiro实现免密登录，解决三方登录问题blog.csdn.net/qq_40194399/article/details/85539158shiro框架的构建以及与JWT的整合github.com/HowieYuan/ShiroSpringBootShiro基于SpringBoot+JWT搭建简单的restful服务github.com/SmithCruise/SpringBootShiroSession问题shiro的session和servlet的session的区别blog.csdn.net/suruiliang/article/details/78824448shiro将ServletHttpSession包装成了ShiroHttpSessionblog.csdn.net/u013628152/article/details/84031784OAuth2集成shiro整合oauth2.0服务端和客户端实现入门教程十三blog.csdn.net/qq_34021712/article/details/80510774teedao例子代码github.com/zhangtr/teedaoCAS集成springboot2.0集成shiro和pac4jcas单点登录www.cnblogs.com/suiyueqiannian/p/9359597.html20181101springmvc下shiro的session,request等问题www.cnblogs.com/vinozly/p/5080692.htmlSession数据共享的前后端分离Shiro实战www.cnblogs.com/shenjixiaodao/p/7426594.htmlwww.jianshu.com/p/eab0b28f6feablog.csdn.net/achenyuan/article/details/78541529www.cnblogs.com/vinozly/p/5080692.htmljinnianshilongnian.iteye.com/blog/2025656Oldspringrain技术详解5shiro的httpSessionwww.9iu.org/2013/12/20/springrain5shirohttpsession.htmljsessionid传递方式对session实现机制bbs.landingbj.com/showtopic.jsp?rootid=174571&CPages=1解决iframe中jsessionid无法传递导致session丢失的问题618119.com/archives/2007/12/19/48.html实现跨域cookie共享www.verydemo.com/demo_c432_i2937.htmlapacheshiro集群实现（一）session共享blog.csdn.net/michaelliuyang/article/details/8819852apacheshiro集群实现（二）―cache共享blog.csdn.net/michaelliuyang/article/details/8820390alexxiyang/shiroredisgithub.com/alexxiyang/shiroredis使用Redis让Shiro实现集群jetgeng.github.io/blog/html/2014/09/07/redis_shiro.html", "Coding\\Java/YuGongLauncher.java.md": "YuGongLauncher.java```java/**1、使用commonsconfiguration读取properties和xml配置文件。commonsconfiguration有1.10和2.x两个版本。2、读取classpath下的文件。YuGongLauncher.class.getClassLoader.getResourceAsStreamconf3、使用ShutdownHook在程序退出时，关闭线程，避免无法关闭JVM。Runtime.getRuntime.addShutdownHooknewThread{*/publicclassYuGongLauncher{privatestaticfinalStringCLASSPATH_URL_PREFIX=\"classpath:\";privatestaticfinalLoggerlogger=LoggerFactory.getLoggerYuGongLauncher.class;publicstaticvoidmainStringargsthrowsThrowable{try{Stringconf=System.getProperty\"yugong.conf\",\"classpath:yugong.properties\";PropertiesConfigurationconfig=newPropertiesConfiguration;ifconf.startsWithCLASSPATH_URL_PREFIX{conf=StringUtils.substringAfterconf,CLASSPATH_URL_PREFIX;config.loadYuGongLauncher.class.getClassLoader.getResourceAsStreamconf;}else{config.loadnewFileInputStreamconf;}logger.info\"starttheYuGong.\";finalYuGongControllercontroller=newYuGongControllerconfig;controller.start;logger.info\"theYuGongisrunningnow......\";logger.infoVersionInfo.getBuildVersion;Runtime.getRuntime.addShutdownHooknewThread{publicvoidrun{ifcontroller.isStart{try{logger.info\"stoptheYuGong\";controller.stop;}catchThrowablee{logger.warn\"somethinggoeswrongwhenstoppingYuGong:\\n{}\",ExceptionUtils.getFullStackTracee;}finally{logger.info\"YuGongisdown.\";}}}};controller.waitForDone;//如果所有都完成，则进行退出Thread.sleep3*1000;//等待3s，清理上下文logger.info\"stoptheYuGong\";ifcontroller.isStart{controller.stop;}logger.info\"YuGongisdown.\";}catchThrowablee{logger.error\"SomethinggoeswrongwhenstartinguptheYuGong:\\n{}\",ExceptionUtils.getFullStackTracee;System.exit0;}}}```", "Coding\\Java/深入理解Java内存模型.md": "深入理解Java内存模型深入理解Java内存模型书www.infoq.cn/article/java_memory_model深入理解Java内存模型（一）――基础www.infoq.cn/article/javamemorymodel1深入理解Java内存模型（二）――重排序www.infoq.cn/article/javamemorymodel2深入理解Java内存模型（三）――顺序一致性www.infoq.cn/article/javamemorymodel3深入理解Java内存模型（四）――volatilewww.infoq.cn/article/javamemorymodel4深入理解Java内存模型（五）――锁www.infoq.cn/article/javamemorymodel5深入理解Java内存模型（六）――finalwww.infoq.cn/article/javamemorymodel6深入理解Java内存模型（七）――总结www.infoq.cn/article/javamemorymodel7", "Coding\\Java/深入理解Java虚拟机2nd：JVM高级特性与最佳实践.md": "第2章Java内存区域与内存溢出异常2.2运行时数据区域!_v_images/20200403094930.png2.2.1程序计数器（ProgramCounterRegister）较小的内存空间字节码的行号指示器“线程私有”无OutOfMemoryError情况2.2.2Java虚拟机栈线程私有，生命周期与线程相同方法的调用过程对应着一个栈帧（StackFrame）在虚拟机栈中入栈到出栈的过程栈帧存储方法的局部变量表、操作数栈、动态链接、方法出口等信息局部变量表存放了编译期可知的各种基木数据类型、对象引用reference、returnAddress类型局部变量表所需的内存空间在编译期间已经确定两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常2.2.3本地方法栈（NativeMethodStack）类似虚拟机栈，为调用Native方法服务也会抛出StackOverflowError和OutOfMemoryError异常2.2.4Java堆（heap）被所有线程共享的一块大内存所有的对象实例以及数组都要在堆上分配堆是垃圾收集器管理的主要区域物理上不连续、逻辑上是连续的即可如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会她出OutOfMemoryError异常2.2.5方法区（MethodArea,NonHeap）被所有线程共享存储类信息、常量、静态变量、JIT编译后的代码等为堆的一个逻辑部分可以不实现垃圾收集，这区域的内存回收目标主要是针对常量池的回收和对类型的卸载2.2.6运行时常量池（RuntimeConstantPool）存放各种字面量和符号引用运行期间也可能将新的常量放人池中2.2.7直接内存不是虚拟机运行时数据区的一部分超过物理内存的限制，可导致OutOfMemoryError异常NIO的DirectByteBuffer对象直接操作这块内存的引用设置Xmx2.3HotSpot虚拟机对象探秘", "Coding\\JavaEE/01-MyBatis.md": "TOCMyBatis使用指南www.mybatis.org/mybatis3/zh/index.htmlMyBatisPlus使用指南mp.baomidou.com/guide/MyBatis学习总结blog.csdn.net/javalean/article/category/7621882插件：深入理解MyBatis（五）―MyBatis的插件机制blog.csdn.net/u013967175/article/details/779176420插件机制MyBatis允许使用插件拦截具体的方法调用，具体的拦截点包含四类：Executor：update，query，flushStatement，commit，rollback，getTransaction，close，isClosed等方法；ParameterHandler：getParameterObject，setParameters等方法；ResultSetHandler：handleResultSets，handleOutputParameters；StatementHandler：prepare，parameterize，batch，update，query在初始化Configuration对象时会解析标签生成Interceptor实例并加入拦截器链InterceptorChain；插件生成的时机就是Executor，ParameterHandler，ResultSetHandler，StatementHandler这四个接口的实现类初始化的时候，会调用pluginAll方法，根据InterceptorChain拦截链中的拦截器决定是否生成代理类；拦截器执行的顺序是：Executor，ParameterHandler，ResultSetHandler，StatamentHandler;", "Coding\\JavaEE/02_Spring学习.md": "TOCHowtoscaninterfacesinacustomSpringnamespaceThisarticledoesnotaimtoaddresshowtobuildacustomSpringnamespace,todoso,SpringdocumentationintegratesExtensibleXMLauthoring.Butawaytocreateaproxybasedonainterface.MyfirstideawastouseSpringcomponentscantofindmyannotatedinterfaces,andtoproxyitviaaBeanPostProcessororsomethingsimilar,butitcannotworksbecausecomponentscancanonlybeusedtoloadimplementationsandBeanPostProcessoraswell.AsI'musingacustomnamespace,soaparser,ImadesomeresearchthroughSpringnamespaceelementsandIfoundtheattribute:basepackage.Andoneofitsassociatedclass:ClassPathScanningCandidateComponentProvider.Byextendingthisclass,myannotatedinterfacescanbefound,andtheparserwillbeinchargetocreatetheproxyaroundtheseinterfaces.Thescannerimplementationisquietsimple:```javastaticclassMyAnnotComponentProviderextendsClassPathScanningCandidateComponentProvider{publicMyAnnotComponentProvider{superfalse;addIncludeFilternewAnnotationTypeFilterMyAnnot.class,false;}@OverrideprotectedbooleanisCandidateComponentAnnotatedBeanDefinitionbeanDefinition{returnbeanDefinition.getMetadata.isInterface;}}```Theconstructordefinesascannerwithoutanyfilterbycallingthesuperconstructorwithfalse.AddafilterontheannotationtofoundintheclasspathbyusingAnnotationTypeFilter.Thesecondargumentspecifiesonlythesearchmustincludemetaannotationornot.BasedontheBeanDefinition,isCandidateComponentmustmustcheckifthefoundbeaniselligible.Next,useitasfollow:```javaClassPathScanningCandidateComponentProvidercomponentProvider=newMyAnnotComponentProvider;componentProvider.setResourceLoaderparserContext.getReaderContext.getResourceLoader;finalStringbasePackage=element.getAttribute\"basepackage\";Set<BeanDefinition>beans=componentProvider.findCandidateComponentsbasePackage;```Instanciatethescanner,andgiveitaResourceLoader.InaSpringXMLparser,itcanbereachedbyParserContextGetthepackagetoparseby,forexample,getthevalueofthebasepackageattributeCallthemethodfindCandidateComponentstogetaSetofBeanDefinition.BeanFactoryPostProcessors用法还是从refresh方法进去，在obtainFreshBeanFactory方法中，就已经loadBeanDefinitons了，容器做了一些准备工作后，调用了invokeBeanFactoryPostProcessorsbeanFactory方法。这里把beanFactoryPostprocessor都调用了一遍。```javapublicvoidrefreshthrowsBeansException,IllegalStateException{synchronizedthis.startupShutdownMonitor{//Preparethiscontextforrefreshing.prepareRefresh;//Tellthesubclasstorefreshtheinternalbeanfactory.ConfigurableListableBeanFactorybeanFactory=obtainFreshBeanFactory;//Preparethebeanfactoryforuseinthiscontext.prepareBeanFactorybeanFactory;try{//Allowspostprocessingofthebeanfactoryincontextsubclasses.postProcessBeanFactorybeanFactory;//在这里invokeBeanFactoryPostProcessorsbeanFactory;//Registerbeanprocessorsthatinterceptbeancreation.registerBeanPostProcessorsbeanFactory;//Initializemessagesourceforthiscontext.initMessageSource;//Initializeeventmulticasterforthiscontext.initApplicationEventMulticaster;//Initializeotherspecialbeansinspecificcontextsubclasses.onRefresh;//Checkforlistenerbeansandregisterthem.registerListeners;//Instantiateallremainingnonlazyinitsingletons.finishBeanFactoryInitializationbeanFactory;//Laststep:publishcorrespondingevent.finishRefresh;}catchBeansExceptionex{//Destroyalreadycreatedsingletonstoavoiddanglingresources.destroyBeans;//Reset'active'flag.cancelRefreshex;//Propagateexceptiontocaller.throwex;}}}publicinterfaceBeanFactoryPostProcessor{//这里提供了修改beanFacotry的机会voidpostProcessBeanFactoryConfigurableListableBeanFactorybeanFactorythrowsBeansException;}publicinterfaceBeanDefinitionRegistryPostProcessorextendsBeanFactoryPostProcessor{//这个接口继承了postprocessor并且将beanFactory转成了registry能够访问到beanDefinition。voidpostProcessBeanDefinitionRegistryBeanDefinitionRegistryregistrythrowsBeansException;}```Order是spring的接口，实现了该接口的Spring都可以对对象集合排序。这个方法的具体类容如下```javaprotectedvoidinvokeBeanFactoryPostProcessorsConfigurableListableBeanFactorybeanFactory{//InvokeBeanDefinitionRegistryPostProcessorsfirst,ifany.Set<String>processedBeans=newHashSet<String>;ifbeanFactoryinstanceofBeanDefinitionRegistry{BeanDefinitionRegistryregistry=BeanDefinitionRegistrybeanFactory;List<BeanFactoryPostProcessor>regularPostProcessors=newLinkedList<BeanFactoryPostProcessor>;List<BeanDefinitionRegistryPostProcessor>registryPostProcessors=newLinkedList<BeanDefinitionRegistryPostProcessor>;forBeanFactoryPostProcessorpostProcessor:getBeanFactoryPostProcessors{ifpostProcessorinstanceofBeanDefinitionRegistryPostProcessor{BeanDefinitionRegistryPostProcessorregistryPostProcessor=BeanDefinitionRegistryPostProcessorpostProcessor;registryPostProcessor.postProcessBeanDefinitionRegistryregistry;registryPostProcessors.addregistryPostProcessor;}else{regularPostProcessors.addpostProcessor;}}Map<String,BeanDefinitionRegistryPostProcessor>beanMap=beanFactory.getBeansOfTypeBeanDefinitionRegistryPostProcessor.class,true,false;List<BeanDefinitionRegistryPostProcessor>registryPostProcessorBeans=newArrayList<BeanDefinitionRegistryPostProcessor>beanMap.values;OrderComparator.sortregistryPostProcessorBeans;forBeanDefinitionRegistryPostProcessorpostProcessor:registryPostProcessorBeans{postProcessor.postProcessBeanDefinitionRegistryregistry;}invokeBeanFactoryPostProcessorsregistryPostProcessors,beanFactory;invokeBeanFactoryPostProcessorsregistryPostProcessorBeans,beanFactory;invokeBeanFactoryPostProcessorsregularPostProcessors,beanFactory;processedBeans.addAllbeanMap.keySet;}else{//Invokefactoryprocessorsregisteredwiththecontextinstance.invokeBeanFactoryPostProcessorsgetBeanFactoryPostProcessors,beanFactory;}//上半部分结束//DonotinitializeFactoryBeanshere:Weneedtoleaveallregularbeans//uninitializedtoletthebeanfactorypostprocessorsapplytothem!StringpostProcessorNames=beanFactory.getBeanNamesForTypeBeanFactoryPostProcessor.class,true,false;//SeparatebetweenBeanFactoryPostProcessorsthatimplementPriorityOrdered,//Ordered,andtherest.List<BeanFactoryPostProcessor>priorityOrderedPostProcessors=newArrayList<BeanFactoryPostProcessor>;List<String>orderedPostProcessorNames=newArrayList<String>;List<String>nonOrderedPostProcessorNames=newArrayList<String>;forStringppName:postProcessorNames{ifprocessedBeans.containsppName{//skipalreadyprocessedinfirstphaseabove}elseifisTypeMatchppName,PriorityOrdered.class{priorityOrderedPostProcessors.addbeanFactory.getBeanppName,BeanFactoryPostProcessor.class;}elseifisTypeMatchppName,Ordered.class{orderedPostProcessorNames.addppName;}else{nonOrderedPostProcessorNames.addppName;}}//First,invoketheBeanFactoryPostProcessorsthatimplementPriorityOrdered.OrderComparator.sortpriorityOrderedPostProcessors;invokeBeanFactoryPostProcessorspriorityOrderedPostProcessors,beanFactory;//Next,invoketheBeanFactoryPostProcessorsthatimplementOrdered.List<BeanFactoryPostProcessor>orderedPostProcessors=newArrayList<BeanFactoryPostProcessor>;forStringpostProcessorName:orderedPostProcessorNames{orderedPostProcessors.addgetBeanpostProcessorName,BeanFactoryPostProcessor.class;}OrderComparator.sortorderedPostProcessors;invokeBeanFactoryPostProcessorsorderedPostProcessors,beanFactory;//Finally,invokeallotherBeanFactoryPostProcessors.List<BeanFactoryPostProcessor>nonOrderedPostProcessors=newArrayList<BeanFactoryPostProcessor>;forStringpostProcessorName:nonOrderedPostProcessorNames{nonOrderedPostProcessors.addgetBeanpostProcessorName,BeanFactoryPostProcessor.class;}invokeBeanFactoryPostProcessorsnonOrderedPostProcessors,beanFactory;}```方法可以看做上下两部分。上半部分建了三个集合分别存了三种postprocessor然后调用了其方法修改了beanFactory。下半部分就不太懂了，因为我觉得上半部分明明已经调用过一次了，下面的除了排序之外岂不是又重复了一次。总而言之，beanFactoryPostprocessor的作用是在beanFactory初始化之后提供一个修改的机会。spring已经提供了不少实现，我们自己也可以写一些实现配置在xml中或者手动调用。比如自己写代码使用```javaConfigurableListableBeanFactorybeanFactory=newXmlBeanFactorynewClassPathResource\"xxxx.xml\";BeanFactoryPostProcessormyBfpp=BeanFactoryPostProcessorbeanFactory.getBean\"mypostprocessor\";myBfpp.postProcessBeanFactorybeanFactory;System.out.printlnbeanFactory.getBean\"test\";```spring也提供了不少实现，我们最常用的三个：propertyPlaceholerConfigurer、CustomerEditorConfigurer、propertyOverrideConfigurer等。propertyPlaceholerConfigurer：从.properties文件中读数据替换xml中的值```xml<beanid=\"propertyConfigurer\"class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"><propertyname=\"locations\">//也可以写location只配置一个<list><value>/WEBINF/mail.properties</value><value>classpath:conf/sqlmap/jdbc.properties</value>//注意这两种value值的写法</list></property></bean><beanid=\"A\"class=\"com.xx.xx\"><propertyname=\"password\"value=\"${A.password}\"/><propertyname=\"username\"value=\"$A.username}\"/></bean>```propertyOverrideConfigurer:从.properties文件中读数据替换xml的值，和上面的有点类似，但这个智能一点，而且可以有默认值，如果properties文件中没有定义，不会报错。对于`<beanname=\"A\"><propertyname=\"B\"></p></b>`。他会去properties文件里找A.B的值。如果没找到就使用xml里的默认值```xml<beanid=\"bfpp\"class=\"org.springframework.beans.factory.config.propertyOverrideConfigurerfigurer\"><propertyname=\"location\"value=\"classpath:/METAINF/xxxx.properties\"/></bean><beanid=\"A\"class=\"com.xx.xx\"><propertyname=\"password\"value=\"\"/><propertyname=\"username\"value=\"\"/></bean>```properties文件中写A.password、A.usernameCustomerEditorConfigurer。这个是用来向容器注册propertyEditor的。propertyEditor是一个接口有里面主要有两个方法：setAsText,getAsText.顾名思义，把字符串解析成值。xml文件里我们填的都是字符串，而转成bean的属性，需要一个editor。spring默认有一些可以处理基础数据类型和byteArray.File.url.uuid什么的，如果想要自己拓展,需要自己写一个类继承PropertyEditorSupport,他实现了PropertyEditor接口，我们继承更方便，写好自己的editer之后需要配置CustomerEditorConfigurer```xml<beanid=\"customEditorConfigurer\"class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\"><propertyname=\"customEditors\"><map><entrykey=\"要解析成的类型比如java.util.Date\"><beanclass=\"MyEditer自己写的类\"/></entry></map></property></bean>```实现：CustomerEditorConfigurer里有一个map，key是要转的目标类型，value是实现了PropertyEditor的类。当上面容器调用到这个postProcessor的时候，他将map里的成员注册到beanFactory里```javapublicvoidpostProcessBeanFactoryConfigurableListableBeanFactorybeanFactorythrowsBeansException{ifthis.customEditors!=null{forIteratorit=this.customEditors.keySet.iterator;it.hasNext;{Objectkey=it.next;ClassrequiredType=null;ifkeyinstanceofClass{requiredType=Classkey;}elseifkeyinstanceofString{StringclassName=Stringkey;try{requiredType=ClassUtils.forNameclassName;}catchClassNotFoundExceptionex{thrownewBeanInitializationException\"Couldnotloadrequiredtype\"+className+\"forcustomeditor\",ex;}}else{thrownewBeanInitializationException\"Invalidkey\"+key+\"forcustomeditorneedstobeClassorString\";}Objectvalue=this.customEditors.getkey;if!valueinstanceofPropertyEditor{thrownewBeanInitializationException\"Mappedvalue\"+value+\"forcustomeditorkey\"+key+\"isnotofrequiredtype\"+PropertyEditor.class.getName+\"\";}beanFactory.registerCustomEditorrequiredType,PropertyEditorvalue;}}}}```当SpringcreateBean的时候，就是在instantiateBean方法中会先创建BeanWrapper然后initBeanWrapper。在这个方法中beanWrapper又会将这些以及spring提供的公共的Editor注册给自己。然后在接下来的populate方法中，会调用ObjectresolvedValue=valueResolver.resolveValueIfNecessary\"beanproperty'\"+pv.getName+\"'\",pv.getValue;这个方法再重载一下，最终就会用到Editor将beanDefinition中存的信息转成相应的类型，返回，然后注入给beanIoc容器Bean实例化的几种场景Bean实例化的几种场景1、BeanDefinitionRegistryPostProcessor实例化：标准BeanFactoryPostProcessor的扩展，BeanFactoryPostProcessor的作用是用来进一步定义注册的BeanDefinition，IoC容器本质就是Bean管理，所以BeanFactoryPostProcessor本身也是Bean，要对BeanFactoryPostProcessor的BeanDefinition进一步定义就通过BeanDefinitionRegistryPostProcessor进行注册，BeanDefinitionRegistryPostProcessor及其子类是Ioc容器最实例化的一类Bean。它们在ConfigurableApplicationContext（ApplicationContext子接口）实现类调用refresh方法调用invokeBeanFactoryPostProcessorsbeanFactory;方法时就被实例化。2、BeanFactoryPostProcessor实例化：仅次于BeanDefinitionRegistryPostProcessor被实例化。它们在同一个方法进行实例化，只是顺序有先后。```javaPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessorsConfigurableListableBeanFactorybeanFactory,List<BeanFactoryPostProcessor>beanFactoryPostProcessors```3、BeanPostProcessorss实例化：BeanPostProcessors是Ioc容器Bean管理的扩展点，定义了Bean实例化前后的回调方法，那它实例化肯定是得比普通的Bean早。ConfigurableApplicationContext.registerBeanPostProcessorsbeanFactory方法负责对BeanPostProcessors进行实例化。实际上实例化BeanPostProcessor的类是PostProcessorRegistrationDelegate.registerBeanPostProcessorsbeanFactory,this;4、MessageSource类型Bean实例化：对应refresh调用的initMessageSource;5、ApplicationEventMulticaster（事件广播）类型Bean实例化：负责ApplicationEvent事件广播的bean，refresh调用initApplicationEventMulticaster;进行实例化。这个Bean是不需要进行配置的，但它通用是在Ioc容器内，而且还是单例的。6、AbstractApplicationContext类的子类可能会实例化个性化的Bean，refresh调用onRefresh;方法做这个事情。7、ApplicationListener类型Bean实例化：ApplicationEventMulticaster负责事件广播，它得注册广播对象，所有ApplicationListener都会在registerListeners;实例化。1~7对应的Bean都是一些特殊的Bean，除6是由子类决定，其他的都是按照类型进行实例化，实例化调用的方法是：BeanFactory的StringgetBeanNamesForTypeClass<?>type,booleanincludeNonSingletons,booleanallowEagerInit;方法，并且这些Bean设置lazyinit是无效的，设置singleton也是无效的8、非lazyinit且singleton的Bean实例化：调用inishBeanFactoryInitializationbeanFactory;```javaprotectedvoidfinishBeanFactoryInitializationConfigurableListableBeanFactorybeanFactory{//有容器转换服务bean时先实例化这种BeanifbeanFactory.containsBeanCONVERSION_SERVICE_BEAN_NAME&&beanFactory.isTypeMatchCONVERSION_SERVICE_BEAN_NAME,ConversionService.class{beanFactory.setConversionServicebeanFactory.getBeanCONVERSION_SERVICE_BEAN_NAME,ConversionService.class;}//实例化LoadTimeWeaverAware类型BeanStringweaverAwareNames=beanFactory.getBeanNamesForTypeLoadTimeWeaverAware.class,false,false;forStringweaverAwareName:weaverAwareNames{getBeanweaverAwareName;}//停止使用临时类加载器beanFactory.setTempClassLoadernull;//缓存容器中所有注册的BeanDefinition元数据，以防被修改beanFactory.freezeConfiguration;//实例化剩余的所有非lazyinitsingletonBeanbeanFactory.preInstantiateSingletons;}protectedvoidfinishBeanFactoryInitializationConfigurableListableBeanFactorybeanFactory{//有容器转换服务bean时先实例化这种BeanifbeanFactory.containsBeanCONVERSION_SERVICE_BEAN_NAME&&beanFactory.isTypeMatchCONVERSION_SERVICE_BEAN_NAME,ConversionService.class{beanFactory.setConversionServicebeanFactory.getBeanCONVERSION_SERVICE_BEAN_NAME,ConversionService.class;}//实例化LoadTimeWeaverAware类型BeanStringweaverAwareNames=beanFactory.getBeanNamesForTypeLoadTimeWeaverAware.class,false,false;forStringweaverAwareName:weaverAwareNames{getBeanweaverAwareName;}//停止使用临时类加载器beanFactory.setTempClassLoadernull;//缓存容器中所有注册的BeanDefinition元数据，以防被修改beanFactory.freezeConfiguration;//实例化剩余的所有非lazyinitsingletonBeanbeanFactory.preInstantiateSingletons;}```9、其他Bean实例化场景：a.上述18对应的Bean实例化依赖其他Bean时，那个Bean同时被实例化（这个在分析createBean说明）；b.延迟实例化的singletonBean在第一次通过getBean主动实例化它时实例化；c.prototype每次调用getBean时都实例化；其他Scope的在它的生命周期内第一次通过getBean主动实例化时实例化。Spring动态加载Groovy类**动机：这个是干啥的？**>1、最近做的项目属于数据分析类型，要求数据分析功能做到快速上线。该项目当前使用的语言是Java+Groovy。项目中，简单的数据分析工作，如一些统计、排序、过滤等，都放在Groovy里完成。需要上线新的数据分析功能时，只需要编写一个新的脚本，并热加载到JVM中即可。>2、规则引擎：一般而言，规则引擎的规则可以是一段表达式（JEXL、MVEL），或是固化在类中的程序代码片段，前者灵活可配，后者与系统的服务集成得更好（能直接调用），为了兼顾这两个特点，可使用GroovyBean来实现规则。**实现方式**实现方式分两种：1）通过Spring的Groovy定时刷新支持。2）通过子类化SpringContext，每次重新该子Context。**Spring定时刷新Groovy**参考实现：spring+groovy很强大blog.csdn.net/qq362228416/article/details/8811136github.com/impanxh/boot_dynamiccontroller核心代码如下：```java//只有这个对象才能注册bean到spring容器DefaultListableBeanFactorybeanFactory=DefaultListableBeanFactorycontext.getAutowireCapableBeanFactory;//因为spring会自动将xml解析成BeanDefinition对象然后进行实例化，这里我们没有用xml，所以自己定义BeanDefinition//这些信息跟spring配置文件的方式差不多，只不过有些东西lang:groovy标签帮我们完成了finalStringrefreshCheckDelay=\"org.springframework.scripting.support.ScriptFactoryPostProcessor.refreshCheckDelay\";finalStringlanguage=\"org.springframework.scripting.support.ScriptFactoryPostProcessor.language\";StringrealDirectory=Thread.currentThread.getContextClassLoader.getResourcedirectory.getFile;Fileroot=newFileThread.currentThread.getContextClassLoader.getResource\".\".getFile;Filefiles=newFilerealDirectory.listFilesnewFileFilter{@OverridepublicbooleanacceptFilepathname{returnpathname.getName.endsWith\".groovy\"?true:false;}};forFilefile:files{GenericBeanDefinitionbd=newGenericBeanDefinition;bd.setBeanClassName\"org.springframework.scripting.groovy.GroovyScriptFactory\";//刷新时间bd.setAttributerefreshCheckDelay,500;//语言脚本bd.setAttributelanguage,\"groovy\";//文件目录bd.getConstructorArgumentValues.addIndexedArgumentValue0,file.getPath.replaceroot.getPath,\"\";//注册到spring容器beanFactory.registerBeanDefinitionfile.getName.replace\".groovy\",\"\",bd;}```**重新加载Groovy的子Context**参考实现：基于Groovy实现SpringBean的动态加载blog.csdn.net/luxianping/article/details/52144782gitee.com/joshuazhan/demo4j/tree/master/spring/groovy/dynamic核心代码如下：```javaClassPathXmlApplicationContextoldContext=this.ruleContext;//通过配置文件重新加载Stringconfig={ruleConfig.getURI.toString};ClassPathXmlApplicationContextnewContext=newClassPathXmlApplicationContextconfig,parentContext;this.ruleContext=newContext;//销毁旧的规则Contextifnull!=oldContext&&oldContext.isActive{oldContext.close;}```", "Coding\\JavaEE/FreeMarker精要.md": "toc一、FreeMarker基本1语法1.1条件判断```html<ifcondition><elseifcondition><else></if>```其中condition是boolean值,可以进行返回boolean的表达式如<ifuser.age>23></if><ifuser.name==\"mimi\"></if>如果condition的包含的字符没有双引号引起来,就表示这是个变量${},不用在condition里使用${}来表示变量<ifx>3></if>这种方式是错误的,因为freemarker会先解释前面那个\">\",可以使用<ifx>3></if>或<ifx&gt;1><?if>1.2循环语句```html<listuserListasuser>…${user!user_index}//从0开始计数,记录当前是第几个元素<ifitem_has_next></if>//测试当前的item是不是最后一个元素<break>//跳出循环</list>```索引index```html<list0..fields?size1asi>${fieldsi}</list>```排序```html<listlist?sortasl>…</list>//升序，序列中的变量必须是：字符串（按首字母排序）,数字，日期值。<listuserList?sort_by“age”asuser>…</list>//子变量排序<listlist?reverseasl>…</list>//降序排序<listuserList?sort_by“age”?reverseasuser>…</list>//让用户按年龄降序排序```1.3Null处理```html<ifuser?>${user}</if>//如果user存在才显示<h1>Welcome${user!\"Anonymous\"}!</h1>//如果user为null，取\"!\"后面的默认值//假设前提：user.name为null${user.name}//异常${user.name!}//显示空白${user.name!'vakin'}//若user.name不为空则显示本身的值，否则显示vakin```对于多级对象属性的情况使用来防止中间的变量为null```html//使用??或exists判断对象不为null，if_exists表不存在<ifuser.name??>${user.name}</if><ifaaa?if_exists>aaa不存在！</if><ifaaa?exists>aaa存在，值为${aaa}</if>${user.name!\"Anonymous\"}```空字符串判断```html<ifperson.name!=\"\">${person.name!}</if>```1.4引入页面<include>可以使用它导入共用的的东西,比如footer,head各种ftltags可以嵌套使用3.表达式可以在${...}<if>的condition中进行各种表达式计算比如+,,*,/,%产生boolean值的表达式>,<,==,!=,>=,<=,&&,||,!当然>,>=比较特殊,因为它包括tags的结束符所以应该转义&gt;,&gte;也可以使用包裹着4.buildinsbuildins是修饰各种变量的有用funtion,比如要使用string变成大写,使用string的upper_casebuildin,使用方法是在变量后加?如user?upper_casefreemarker提供了各种变量类型的许多buildins常用的有str?html:将str中包含的html特殊字符转义,比如<被转义成为&lt;str?cap_first:第一个字符大写str?lower_case:字符串转小写str?upper_case:字符串转大写str?trim:删除字符串两边空格列表有个sizebuildin显示列表的长度sequence?size可以将浮点数修改为int1.9?intY果是1,只取int部分，不做各种舍取操作5.在模板里定义变量比如<assignuser=\"pp\">他会隐藏module里面的user变量,如果有的话6.命名空间默认的各种变量都是定义在mainnamespace中，虽然我们没有注意到当我们写各种模板时,我们希望各个模板的变量不要被隐藏，这时这要到命名空间了.当我们在主模板中引入其他模板时,这时不要使用<include>了，而使用<import><import\"/lib/my_test.ftl\"asmy>这样我们要调用my_test.ftl中的变量时就用my.var调用了7.空格处理freemarker默认是不会压缩template中的空格,也就是你写了什么就是什么这在一些应用可能有用,但在web应用无疑是浪费带宽,所以应该压缩一下freemarker的output,可以在template中用<compress>包裹内容.但是如果每个文件都使用<compress>会有点麻烦,也可以configuration那个freemarker的主要配置类对象中设置config.setWhitespaceTriptrue;但我测试是无效二、FreeMarker编程式操作1.freemarker.template.Configuration这是freemarker设置的中心地方,他还负责创建新的template,缓存预编译的template.Configuration的生命周期一般是应用级的,所以一般是在应用的开始时创建Configuration.```javaConfigurationconfig=newConfiguration;//getthetemplateTemplatetemplate=config.getTemplate\"test.ftl\";//buildmoduleMaproot=newHashMap;root.put\"user\",\"bigfan\";//MergedatamodelwithtemplateWriterout=newOutputStreamWriterSystem.out;template.processroot,out;out.flush;```2.freemarker的有效变量在freemarker内部,有效的变量必须是实现了freemarker.template.TemplateModel接口的java对象,但是我们之前用的String,List等并没有实现这个接口，其实这是因为freemarker使用了一种叫做objectwrapping的方式将java标准类转换为相应的实现了这个接口的类.3.freemarker内部有两大数据类型:Scalar,Container其中Scalar包括Boolean,Number,String,Date基中Container包括Hashes,sequences,Collections4.设置Sharedvariables这些变量在所有的template中都是有效的.config.setSharedVariable\"company\",\"FooInc.\";5.settings是影响freemarker行为的值比如locale,number_format可以有三个层次的settings:1.在Configuration中设置的setting，使用setter方法比如myCfg.setLocalejava.util.Locale.ITALY;myCfg.setNumberFormat\"0.\";也可以在.properties文件中定义namevalue,再使用myCfg.setSetting方法2.Template层也可以设置setting,但是template是可缓存的,所以必须在template第一次创建时就设置setting,而这比较难控制3.Environment层,template对象可以得到freemarker.core.Environment这个对象,再使用这个对象的setter进行设置,应该在执行template.process之前就设置好4.还可以在template文件中进行设置,使用directive<settinglocale=\"it_IT\"><settingnumber_format=\"0.\">6.Templateloadersfreemarker有三种loader：文件方式,classpath,servletContextvoidsetDirectoryForTemplateLoadingFiledir;voidsetClassForTemplateLoadingClasscl,Stringprefix;voidsetServletContextForTemplateLoadingObjectservletContext,Stringpath;7.Templatecaching当从configuration中getTemplate时,configuration会缓存template,所以下次再拿相同的template就不会重新创建template和解释这个template.如果修改template文件后,freemarker会重新读取和解释这个template,默认时间是5秒钟去判断文件是否修改.有一个\"updatedelay\"相关的设置可以修改这个值.但是如果是使用classpath方式load模板的话,并不会提示说你已经修改了模板文件.因为在classpath的文件的默认是被认为不会被修改的.8.freemarker会用本地locale格式化数字比如10000会被输出10,000这有时对后端程序是有害的.我们可以使用cfg.setNumberFormat\"0.\";也可以使用数字的buildin\"c\"比如${userId?c}也可以试试在模板文件中使用<number_format\"0.\">9.freemarker的properties配置文件可以在classpath中定义freemarker.properties配置文件配置模板:template_update_delay=30insecondsdefault_encoding=utf8locale=utf8whitespace_stripping=trueauto_import=\"/WEBINF/content/index.ftl\"asp,\"/WEBINF/content2/index.ftl\"ascmstag_syntax=auto_detecturl_escaping_charset=UTF8datetime_format=yyyyMMddHH:mm:ssdate_format=yyyyMMddtime_format=HH:mm:ssnumber_format=0.;boolean_format=true,false", "Coding\\JavaEE/Java事务设计策略.md": "阅读《Java事务设计策略》4853页对SQL事务隔离级别的简单理解数据库死锁数据库中死锁那些事儿Spring事务传播性与隔离级别一、事务的隔离级别使用Spring声明式事务时，有一个非常重要的概念就是事务属性。事务属性通常由事务的传播行为，事务的隔离级别，事务的超时值和事务只读标志组成。org.springframework.transaction包里面的TransactionDefinition类getTimeout方法，它返回事务必须在多少秒内完成。isReadOnly,事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的。getIsolationLevel方法返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据。在TransactionDefinition接口中定义了四个不同的事务隔离级别:1ISOLATION_DEFAULT这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别读未提交.另外四个与JDBC的隔离级别相对应2ISOLATION_READ_UNCOMMITTED这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。3ISOLATION_READ_COMMITTED保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。4ISOLATION_REPEATABLE_READ这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生不可重复读SQL标准定义了4类隔离级别分别是：可串行化，可重复读，读已提交，读未提交。l可串行化Serializable是事务最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。因为它采用了类似线程同步的概念，当一个事务开始操作数据时，其他所有的事务都不能进行除查询外的其他操作，只能等待当前事务完成提交。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。l可重复读RepeatableRead这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。它采用的是数据缓存策略，即当事务开始后，第一次读取数据后会把数据缓存起来，当再次进行相同操作时，直接返回缓存的数据，这样即使数据库内容发生了改变，当前事务内所读取的结果还是一致的。l读已提交ReadCommitted这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。一个事务在结束时会执行一个命令，commit（提交）或者rollback（回滚），前者即确认事务所做的操作，后者则为撤销整个事务的所有操作。此隔离级别的服务将不会看到其他并行服务在commit之前所进行的操作。l读未提交ReadUncommitted这是最低的隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（DirtyRead），因为别的服务有可能会执行rollback操作，这样提前读取到的数据可能会出现问题。四种级别的隔离，各有自己的优缺点，级别越高则安全性越高，但并发性越低，低级别的隔离则支持更高的并发处理，并要求较低的系统开销，究竟使用哪种，还有根据具体项目的相关要求而决定。二、事务的传播性质定义了关于客户端和被调用方法的事务边界。传播规则就是在说明新的事务是否要被启动或是挂起，或者方法是否要在事务环境中运行。在TransactionDefinition接口中定义了七个事务传播行为:1PROPAGATION_REQUIRED如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务;2PROPAGATION_SUPPORTS如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行;3PROPAGATION_MANDATORY如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异;4PROPAGATION_REQUIRES_NEW总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起;5PROPAGATION_NOT_SUPPORTED总是非事务地执行，并挂起任何存在的事务;6PROPAGATION_NEVER总是非事务地执行，如果存在一个活动事务，则抛出异常;7PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中.如果没有活动事务,则按TransactionDefinition.PROPAGATION_REQUIRED属性执行;", "Coding\\JavaEE/Netty学习.md": "5种Unix网络I/O模型阻塞I/O模型!_v_images/20191129175042.png非阻塞I/O模型!_v_images/20191129175050.pngI/O复用模型!_v_images/20191129175059.png!_v_images/20191129175108.png信号驱动I/O模型!_v_images/20191129175117.png异步I/O!_v_images/20191129175135.png!_v_images/20191129175147.png", "Coding\\JavaEE/spring-boot属性文件加密.md": "1引入jar包在build.gradle文件中加入下面的依赖，并刷新gradle：```runtime\"com.github.ulisesbocchio:jasyptspringbootstarter:1.16\"```刷新后，在本机的gradle本地库中能找到jasypt1.9.2.jar文件，如果找不到，去网上下载。2加密密码加密命令如下：```javacpjasypt1.9.2.jarorg.jasypt.intf.cli.JasyptPBEStringEncryptionCLIinput=\"test123\"password=e9fbdb2d3b21algorithm=PBEWithMD5AndDES```test123为原密码，e9fbdb2d3b21为加密盐（后面要用）。命令回显如下：```ENVIRONMENTRuntime:OracleCorporationJavaHotSpotTM64BitServerVM25.121b13ARGUMENTSalgorithm:PBEWithMD5AndDESinput:test123password:e9fbdb2d3b21OUTPUTArGx5ir2xs+CmXRhMnThpQ==```3在程序application.properties中设置密文和盐```jasypt.encryptor.password=e9fbdb2d3b21spring.datasource.password=ENCArGx5ir2xs+CmXRhMnThpQ==```在程序中设置密文需要使用格式：ENC密文4在Java命令行配置密文在启动命令中配置JVM参数（jasypt.encryptor.password），注入加密密文的密码。如：```javaDfile.encoding=UTF8Djasypt.encryptor.password=e9fbdb2d3b21jarXmx512msettlement.jar```", "Coding\\JavaEE/Spring-Cloud.md": "tocSpringCloud", "Coding\\JavaEE/Tomcat调优.md": "Tomcat类加载机制Tomcat类加载图!Tomcat类加载图_v_images/20210625110312139_22851.pngCommon类加载器，负责加载Tomcat和Web应用都复用的类Catalina类加载器，负责加载Tomcat专用的类，而这些被加载的类在Web应用中将不可见Shared类加载器，负责加载Tomcat下所有的Web应用程序都复用的类，而这些被加载的类在Tomcat中将不可见WebApp类加载器，负责加载具体的某个Web应用程序所使用到的类，而这些被加载的类在Tomcat和其他的Web应用程序都将不可见Jsp类加载器，每个jsp页面一个类加载器，不同的jsp页面有不同的类加载器，方便实现jsp页面的热插拔JVM之内存模型汪十号：JVM之内存模型zhuanlan.zhihu.com/p/44296601JVM内存结构图!JVM内存结构图_v_images/20210625110237476_29990.pngTomcat调优包括两个部分：史上最强Tomcat8性能优化调优一般从网络IO、CPU、内存、硬盘IO等几个方面着手。1、Tomcat的自身调优采用动静分离节约Tomcat的性能调整Tomcat的执行器线程池```xml<Executorname=\"tomcatThreadPool\"namePrefix=\"catalinaexec\"maxThreads=\"500\"minSpareThreads=\"50\"prestartminSpareThreads=\"true\"maxQueueSize=\"100\"/><!参数说明：maxThreads：最大并发数，默认设置200，一般建议在500~1000，根据硬件设施和业务来判断minSpareThreads：Tomcat初始化时创建的线程数，默认设置25prestartminSpareThreads：在Tomcat初始化的时候就初始化minSpareThreads的参数值，如果不等于true，minSpareThreads的值就没啥效果了maxQueueSize，最大的等待队列数，超过则拒绝请求><!在Connector中设置executor属性指向上面的执行器><Connectorexecutor=\"tomcatThreadPool\"port=\"8080\"protocol=\"HTTP/1.1\"connectionTimeout=\"20000\"redirectPort=\"8443\"/>```调整Tomcat的连接器修改Tomcat的运行模式tomcat7及以下推荐使用nio，tomcat8建议使用nio2```xml<Connectorexecutor=\"tomcatThreadPool\"port=\"8080\"protocol=\"org.apache.coyote.http11.Http11Nio2Protocol\"connectionTimeout=\"20000\"redirectPort=\"8443\"/>```apr：安装起来最困难，但是从操作系统级别来解决异步的IO问题，大幅度的提高性能禁用AJP连接器AJP（ApacheJServerProtocol）是针对与Apache结合使用的tcp协议，由于一般使用nginx，所以可以禁用掉。<!禁用AJP连接><!<Connectorport=\"8009\"protocol=\"AJP/1.3\"redirectPort=\"8443\"/>>2、JVM的调优设置垃圾回收器调优Jvm内存`JAVA_OPTS=\"Dfile.encoding=UTF8serverXms1024mXmx2048mXX:NewSize=512mXX:MaxNewSize=1024mXX:PermSize=256mXX:MaxPermSize=256mXX:MaxTenuringThreshold=10XX:NewRatio=2XX:+DisableExplicitGC\"`Xmx1024m设置JVM最大可用内存为1024MBXms1024m设置JVM最小内存为1024m。此值可以设置与Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。XX:NewSize设置年轻代大小XX:MaxNewSize设置最大的年轻代大小XX:PermSize设置永久代大小XX:MaxPermSize设置最大永久代大小XX:NewRatio=4设置年轻代（包括Eden和两个Survivor区）与终身代的比值（除去永久代）。设置为4，则年轻代与终身代所占比值为1：4，年轻代占整个堆栈的1/5XX:MaxTenuringThreshold=0设置垃圾最大年龄，默认为：15。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。XX:+DisableExplicitGC这个将会忽略手动调用GC的代码使得System.gc的调用就会变成一个空调用，完全不会触发任何GC。", "Coding\\JavaEE/Tomcat配置.md": "最大并发会话连接数设置详解Tomcat的连接数与线程池www.importnew.com/27309.htmlConnector中的几个参数功能如下：1、acceptCountaccept队列的长度；当accept队列中连接的个数达到acceptCount时，队列满，进来的请求一律被拒绝。默认值是100。2、maxConnectionsTomcat在任意时刻接收和处理的最大连接数。当Tomcat接收的连接数达到maxConnections时，Acceptor线程不会读取accept队列中的连接；这时accept队列中的线程会一直阻塞着，直到Tomcat接收的连接数小于maxConnections。如果设置为1，则连接数不受限制。默认值与连接器使用的协议有关：NIO的默认值是10000，APR/native的默认值是8192，而BIO的默认值为maxThreads（如果配置了Executor，则默认值是Executor的maxThreads）。在windows下，APR/native的maxConnections值会自动调整为设置值以下最大的1024的整数倍；如设置为2000，则最大值实际是1024。3、maxThreads请求处理线程的最大数量。默认值是200（Tomcat7和8都是的）。如果该Connector绑定了Executor，这个值会被忽略，因为该Connector将使用绑定的Executor，而不是内置的线程池来执行任务。maxThreads规定的是最大的线程数目，并不是实际running的CPU数量；实际上，maxThreads的大小比CPU核心数量要大得多。这是因为，处理请求的线程真正用于计算的时间可能很少，大多数时间可能在阻塞，如等待数据库返回数据、等待硬盘读写数据等。因此，在某一时刻，只有少数的线程真正的在使用物理CPU，大多数线程都在等待；因此线程数远大于物理核心数才是合理的。换句话说，Tomcat通过使用比CPU核心数量多得多的线程数，可以使CPU忙碌起来，大大提高CPU的利用率。4、参数设置（1）maxThreads的设置既与应用的特点有关，也与服务器的CPU核心数量有关。通过前面介绍可以知道，maxThreads数量应该远大于CPU核心数量；而且CPU核心数越大，maxThreads应该越大；应用中CPU越不密集（IO越密集），maxThreads应该越大，以便能够充分利用CPU。当然，maxThreads的值并不是越大越好，如果maxThreads过大，那么CPU会花费大量的时间用于线程的切换，整体效率会降低。（2）maxConnections的设置与Tomcat的运行模式有关。如果tomcat使用的是BIO，那么maxConnections的值应该与maxThreads一致；如果tomcat使用的是NIO，那么类似于Tomcat的默认值，maxConnections值应该远大于maxThreads。（3）通过前面的介绍可以知道，虽然tomcat同时可以处理的连接数目是maxConnections，但服务器中可以同时接收的连接数为maxConnections+acceptCount。acceptCount的设置，与应用在连接过高情况下希望做出什么反应有关系。如果设置过大，后面进入的请求等待时间会很长；如果设置过小，后面进入的请求立马返回connectionrefused。", "Coding\\JavaEE/实现类似MyBatis的注解Mapper.md": "本文讲解在Spring中实现类似MyBatis的注解Mapper功能。以查询为例，定义一个接口，并接口上标注@Dao注解；定义一个查询方法，并在其上标注上@Select注解，填充上命名参数的sql；使用@Param注解在方法参数上标明sql命名参数，所有预定义过程完成。使用spring的@Autowired注入即可调用。主要知识点利用类ClassPathScanningCandidateComponentProvider查找自定义注解的类。利用Java的动态代理实现接口的代理类。利用类BeanFactoryPostProcessor接口将代理类注入到spring容器中。定义三个注解@Dao作用于接口上，表明此接口的代理实现类是可以动态注入到Spring容器中。<pre>@Target{ElementType.TYPE}@RetentionRetentionPolicy.RUNTIME@Documentedpublic@interfaceDao{Stringvaluedefault\"\";}</pre>@Select作用于方法上，用来填写方法需要使用的SQL，sql的格式采用JDBC的命名查询格式。<pre>@RetentionRetentionPolicy.RUNTIME@TargetElementType.METHODpublic@interfaceSelect{Stringvalue;}</pre>@Param作用于方法的参数上，用来表明参数的名称。PS:由于Java的接口不是类，方法参数无法存入局部变量表中，因此在运行时是无法获取接口方法准确的参数名称，只能获得arg0,arg1这类的名称，所以需要采用注解来指定。<pre>@RetentionRetentionPolicy.RUNTIME@TargetElementType.PARAMETERpublic@interfaceParam{Stringvalue;}</pre>使用示例定义接口类<pre>@DaopublicinterfaceUserDao{@Select\"select*fromm_userwherelogin_Name=:loginName\"UserfindUserByAccount@Param\"loginName\"StringloginName;@Select\"select*fromm_userwherelogin_Name=:loginName\"Page<User>paginateUserByAccount@Param\"pageNo\"IntegerpageNo,@Param\"pageSize\"IntegerpageSize,@Param\"loginName\"StringloginName;}</pre>测试类<pre>@RunWithSpringJUnit4ClassRunner.class@ContextConfigurationlocations=\"classpath:applicationContext.xml\"publicclassUserDaoTest{@AutowiredUserDaouserDao;@Testpublicvoidtest_findUserByAccount{Stringaccount=\"support1\";Useruser=userDao.findUserByAccountaccount;Assert.assertNotNulluser.getId;}@TestpublicvoidpaginateUserByAccount{IntegerpageNo=1;IntegerpageSize=10;Stringaccount=\"support1\";Page<User>pageUser=userDao.paginateUserByAccountpageNo,pageSize,account;Assert.assertNotNullpageUser;}}</pre>扫描标有@Dao注解的类<pre>publicclassDaoAnnotationComponentProviderextendsClassPathScanningCandidateComponentProvider{publicDaoAnnotationComponentProvider{superfalse;//添加scan的类型：@DaoaddIncludeFilternewAnnotationTypeFilterDao.class,false;}@OverrideprotectedbooleanisCandidateComponentAnnotatedBeanDefinitionbeanDefinition{//返回true表示要scaninterfacereturnbeanDefinition.getMetadata.isInterface;}}</pre>实现@Dao接口类的代理类采用Java的动态代理实现，实现接口InvocationHandler即可。主要的思路是：从@Select接口获取SQL，通过Reflection获取Method的返回类型，从@Param中获取参数名称，此参数名称和SQL中名称参数一一对应。<pre>publicclassDaoInvocationHandlerImplimplementsInvocationHandler{privatestaticLoggerlogger=LoggerFactory.getLoggerDaoInvocationHandlerImpl.class;privatefinalstaticStringPAGE_NO=\"pageNo\";privatefinalstaticStringPAGE_SIZE=\"pageSize\";@SuppressWarnings\"unchecked\"@OverridepublicObjectinvokeObjectproxy,Methodmethod,ObjectargsthrowsThrowable{SelectannoSelect=method.getAnnotationSelect.class;ifannoSelect!=null{Map<String,Object>params=newHashMap<>;Parameterparameters=method.getParameters;forinti=0;i<parameters.length;i++{Class<?>paramClass=parametersi.getType;ifparamClass.isAssignableFromMap.class{params.putAllMap<String,Object>argsi;}else{ParamannoParam=parametersi.getAnnotationParam.class;StringparamName=annoParam.value;params.putparamName,argsi;}}ObjectretObj=callJdbcmethod,String.join\"\",annoSelect.value,params;returnretObj;}else{returnmethod.invokethis,args;}}privateObjectcallJdbcMethodmethod,Stringsql,Map<String,Object>params{logger.debugString.format\"%s==>SQL:%s,参数:%s\",method.getName,sql,params.toString;ObjectretObj=null;Finderfinder=Finder.ofsql.bindparams;Class<?>retClass=method.getReturnType;ifretClass.isAssignableFromList.class{ParameterizedTyperetType=ParameterizedTypemethod.getGenericReturnType;Class<?>clazz=Class<?>retType.getActualTypeArguments0;retObj=finder.listclazz;}elseifretClass.isAssignableFromMap.class{retObj=finder.firstMap.class;}elseifretClass.isAssignableFromPage.class{ParameterizedTyperetType=ParameterizedTypemethod.getGenericReturnType;Class<?>clazz=Class<?>retType.getActualTypeArguments0;Objectpn=params.getPAGE_NO;Objectps=params.getPAGE_SIZE;ifObjectUtils.isEmptypn||ObjectUtils.isEmptyps{thrownewIllegalArgumentException\"缺少pageNo/pageSize参数\";}intpageNo=Integer.valueOfpn.toString;intpageSize=Integer.valueOfps.toString;retObj=finder.paginateclazz,pageNo,pageSize;}else{retObj=finder.firstretClass;}logger.debugString.format\"<==成功执行查询%s\",method.getName;returnretObj;}}</pre>将Dao的代理类注入到Spring容器中<pre>publicclassDaoBeanProcessorimplementsBeanFactoryPostProcessor,ResourceLoaderAware{privateResourceLoaderresourceLoader;/**@Dao接口类所在的包，可以是逗号分割的多个包名*/privateStringpackages;@OverridepublicvoidsetResourceLoaderResourceLoaderresourceLoader{this.resourceLoader=resourceLoader;}@OverridepublicvoidpostProcessBeanFactoryConfigurableListableBeanFactorybeanFactorythrowsBeansException{Set<BeanDefinition>beans=scanCallerInterfaceDef;DefaultListableBeanFactorybf=DefaultListableBeanFactorybeanFactory;registerDaoProxyBeanbeans,bf;}privateSet<BeanDefinition>scanCallerInterfaceDef{ClassPathScanningCandidateComponentProvidercomponentProvider=newDaoAnnotationComponentProvider;componentProvider.setResourceLoaderresourceLoader;Set<BeanDefinition>beans=newLinkedHashSet<BeanDefinition>;StringpkgArr=packages.split\",\";forStringpkg:pkgArr{beans.addAllcomponentProvider.findCandidateComponentspkg.trim;}returnbeans;}privatevoidregisterDaoProxyBeanSet<BeanDefinition>beans,DefaultListableBeanFactorybeanFactory{forBeanDefinitionbd:beans{Class<?>clazz=null;try{clazz=Class.forNamebd.getBeanClassName;}catchClassNotFoundExceptione{e.printStackTrace;continue;}Stringname=clazz.getSimpleName;Objectobj=DaoProxyFactory.getDaoBeanclazz;beanFactory.registerSingletonname.substring0,1.toUpperCase+name.substring1,obj;}}publicStringgetPackages{returnpackages;}publicvoidsetPackagesStringpackages{this.packages=packages;}}</pre>不要忘了在spring中配置这类的实例：```<beanclass=\"com.xx.DaoBeanProcessor\"><propertyname=\"packages\"value=\"com.xxx\"/></bean>```", "life/GJH简历_中文.md": "管江淮```性别：男出生年月：19771学历：硕士工作年限：10+年电话：18109032120电子邮件：15756953@qq.com```教育经历本科，1997/92001/7，成都理工大学，计算机软件专业。硕士，2006/92009/7，电子科技大学，软件工程。专业技能熟悉且多次负责从零建立软件研发团队，运作研发团队，善于建设团队和培养人才；熟练面向对象的系统分析与设计，具有多个行业分析与产品规划经验；熟练基于SpringBoot/SpringCloud/dubbo分布式系统架构设计，具有分布式系统架构经验；了解Oracle/MySQL/MongoDB/Redis等数据库；了解大前端，了解Vue/Flutter；工作经历**TechnicalDirector,2018/3至今,成都道衍云算科技有限公司**与朋友一起创业，担任技术总监，负责公司的技术与研发工作；在决策层面，负责制定产品发展路径、确定技术路线、定岗位明职责、制定研发管理过程、制定运维实施制度等工作；在团队建设方面，负责制定岗位明职责、制定人才发展晋升通道、按职位制定学习和培养方案、招聘、培训等；在研发执行方面，负责产品整体规划与分层细化、组织人力团队、定职责、监督与指导、工作评价等工作，完成三评审：需求评审、计划评审、代码评审；在架构方面，负责投标技术方案编写、制定产品技术方案、制定或评审架构设计、核心架构实现等；在运维客服方面，建立实施流程、与客户沟通机制、客户反馈处理机制等；公司产品业务涉及电厂信息化、智能环卫、基建信息化、区块链、高考志愿等行业；下属团队35人，分4个研发组（每组46开发人员和1个测试人员）、一个架构组（3人）、一个产品设计组（3人）、一个运维组（5人）。**TechnicalDirector/Architect,2014/52018/3,成都交大光芒科技股份有限公司**担任架构师，负责公司铁路SOA分布式信息化平台的架构设计与实现，以及各业务项目的设计与评审；担任技术总监，负责研发过程优化与管理、产品体系规划、技术方案决策、人员培养；下属团队分产品设计组、研发组、测试组，产品设计组3人，测试组3人，研发组15+人数；获得1次最佳创新员工，1次优秀员工。**TechnicalDirector,2012/122014/4,成都易达出行科技有限公司**加入朋友的创业团队，担任技术总监，负责公司租车产品的研发工作；完成了公司基础平台的架构设计与实现，实现了租车产品的上线运营；下属团队10+人，测试、运维、产品、美工各1人，App开发2~4人、后端开发4+人。**TechnicalManager/Architect,2011/52012/10,丰益（上海）信息技术有限公司**担任公司成都研发部技术经理，负责建立成都团队、制定研发管理过程；兼任架构师，负责公司全国农产品收购系统架构设计、项目管理工作；下属团队12人，测试2人，产品经理由上海同事担任。**ProjectManager/Teacher,2009/72011/4,四川华迪信息技术有限公司**担任项目经理，负责电子政务项目、健康检查项目的投标宣讲、需求调研、设计与开发，团队人数10+；担任培训讲师，负责大学生实训项目，教授过多门课程，管理过多个班级。**SoftwareEngineer,2004/92005/5,亚信成都分公司**从事电信业务（经营分析）开发与维护。**SoftwareEngineer/ProjectSoftwareManager,2001/72004/7,东软（大连）国际合作事业部**担任项目经理，负责对日ERP项目的开发和管理工作；02年和03年连续两年被授予东软年度优秀员工，期间被派往日本一段时间；下属团队分3个研发小组，每组58人，独立的测试团队。项目经历**高考生涯规划平台**2020/112021/57个月>担任角色：Architect>承担任务：1）完成整体的技术架构；2）完成产品设计。>此产品旨在为高考后的准大学生提供未来的职业规划服务，此平台是一个基于云服务的多租户平台。目前覆盖功能包括院校及专业管理、个人性格评测、分数线管理、职业学习、志愿填报、专家服务、加盟商管理、分销管理、支付等等。**城市智慧环卫平台**2020/8至今10个月>担任角色：Architect>承担任务：1）完成整体的技术架构；2）完成产品设计。>此产品旨在为城市环境卫生提供解决方案，环卫行业方兴未艾，此方案并不全面。目前覆盖垃圾分类、垃圾清运、资源再回收、街道清扫等。主要功能包括楼宇垃圾分类、网格化管理、清运调度管理、清扫排班与考勤管理、回收分拣管理等等。**能源集团基建管理系统**2019/5至今15+个月>担任角色：Architect>承担任务：1）完成整体的技术架构；2）完成产品设计。>此产品旨在为管理和协调能源集团基础设施。板块上覆盖工程施工管理、基建安全管理、后评估管理等。主要功能包括工程标准管理、项目管理、商务物资管理、进度管控、质量管理、项目验收、安全随手拍、安全网格化管理、后评估管理等等。**能源集团垃圾焚烧厂业务信息化平台**2018/3至今20+个月>担任角色：Architect>承担任务：1）完成整体的技术架构；2）完成产品设计。>此产品旨在为整个垃圾焚烧电厂提供信息化解决方案。板块上覆盖生产管理系统MES、安全监控系统SIS、指标分析系统等。主要功能包括设备管理、两票三制管理（工作票、操作票、交接班、巡检、维修）、发电设备数据采集与监控、发电指标分析等等。**铁路供电运营及维护平台**2014/82015/1113个月>担任角色：Architect>承担任务：1）完成整体的技术架构；2）完成产品设计。>此产品旨在为铁路供电段业务提供信息化解决方案。覆盖铁路供电业务的调度、接触网、变电、配电、轨道车、给水等几大专业的业务。核心功能包括调度作业计划、电调命令管理、铁路设备管理、接触网巡视、6C、施工计划、配电设备巡视与检修等等。**途咖租车移动互联网平台**2012/122014/315个月>担任角色：ProductManager/Architect>承担任务：1）完成整体的技术架构；2）完成产品设计、验收。>此产品是一个租车的移动互联网应用。提供App、微信、机顶盒、Web等多种途径订车，由自动调度服务器调度整个业务流程，并提供业务支撑及管理。**农产品收购系统**2011/62012/814个月>担任角色：Architect>承担任务：1）完成系统整体的技术架构；2）完成产品设计。>此系统是对益海嘉里全国各地工厂的农产品收购业务进行全流程的监控与管理。系统采用JavaEE6技术体系实现，采用IBM的Websphere/DB2集群做为后台支撑，采用Message中间件、流程引擎进行业务解耦，是个大型的企业应用。**电子政务系统**2009/122010/67个月>担任角色：ProjectManager/Architect>承担任务：1）完成需求调研及分析；2）完成系统架构与设计；3）项目管理。>此项目是为成都市及下级县市所有行政权力事项（行政许可、行政处罚、行政强制、行政征收、其他行政权力等）实现在线统一接件和办理系统。此项目采用了基于SSH2的架构实现、基于RUP的分析和设计方法和Scrum的敏捷开发模式。**TME（ERP）**2002/62003/915个月>担任角色：ProjectManager>承担任务：1）项目开发过程管理；2）解决重大技术问题。>此项目是日本NEC公司的一个企业ERP系统。系统基于J2EE的B/S三层架构，前台采用JSP、Swing和Applet，后台采用EJB2实现。此项目人数达25人。", "life/IT技术栈(能力模型).md": "", "life/[经典语录]读完了，你会放下很多事.md": "人生就是一列开往坟墓的列车，路途上会有很多站口，没有一个人可以至始至终陪你走完，你会看到来来往往、上上下下的人。如果幸运，会有人陪你走过一段，当这个人要下车的时候，即使不舍，也该心存感激，然后挥手道别，因为，说不定下一站会有另外一个人会陪你走的更远。1.当明天变成了今天成为了昨天，最后成为记忆里不再需要的某一天，我们突然发现自己在不知不觉中已被时间推着向前走，这不是静止火车里，与相邻列车交错时，仿佛自己在前进的错觉，而是我们真是的在成长，在这件事里成了另一个自己。2.咖啡苦与甜，不在于怎么搅拌，而在于是否放糖；一段伤痛，不在于怎么忘记，而在于是否有勇气重新开始。3.为什么要那么痛苦地忘记一个人，时间自然会使你忘记。如果时间不可以让你忘记不应该记住的人，我们失去的岁月又有什么意义？4.如果某个男人主动替你拎包，把你放在道路的里边走。主动为你拉椅子，不要因此而感激涕零。这只能说明他之前有无数个女朋友教过他这一点。而能让他记住的女人，永远是改变了他的那个女人，而不是你。所以，越是细节完美的男人，对女人而言越是挑战。5.吵架时为什么会大声？原因是，当两个人相互愤怒的时候，他们的心和心相距很远；为了填补这段距离，他们必须呼喊，这样彼此才能听到。他们越是愤怒，心和心距离则越是遥远，于是，他们只是越发强力呼喊，他们彼此才能听到。反过来，也是恋爱时为什么喃喃低语的原因。6.从正面看，是伟大的神（God）;从反面看，是卑鄙小人（dog）。其实，人们所犯的罪恶（evil），反过来，正是为了活着（live）。――换个角度很多事情便不一样。7.同时追两只兔子的人，一只也不会逮到。不要贪图无所不有，否则你将一无所有；不要试图无所不知，否则你将一无所知；不要企图无所不能，否则你将一无所能。8.人生中十种无能为力的事:①、倒向你的墙；②离你而去的人；③、流逝的时间；④、没有选择的出身；⑤、莫名其妙的孤独；⑥、无可奈何的遗忘；⑦、永远的过去；⑧、别人的嘲笑；⑨、不可避免的死亡；⑩、不可救药的喜欢。9.笨人的爱情是批发出去的，仅凭“让我一次爱个够”的蛮力；聪明人得爱情是零售出去的，懂得“只爱一点点”的精妙。10.友谊、爱情、婚姻都好比铺水泥路，隔上一段就要留出一条缝隙，保持着一点点距离。不留缝隙，路面很快级会膨胀、坏掉。11.金钱是个颇有神力的照妖镜，小人、伪君子在它面前皆原形毕露；爱情是个手法高超的化妆师，爱人、年轻人受它影响都荣光焕发。12.心脏是一座有两间卧室的房子，一件住着痛苦，一间住着快乐‘人得意之时不能笑的太响，否则会吵醒隔壁的痛苦。13.当地球180°转弯，白天就要变成黑夜；当地球继续180°转弯，黑夜又恢复白天。当我们为了一个人180°转弯，我们背对着自己的叹息；当我们为了自己再次180°转弯，其实一切都可以重新开始！14.每个人都是上帝咬过一口的苹果，都是有缺陷的！有的人呢缺陷比较大，那是因为上帝特别钟爱Ta的芬芳！15.爱情是零度的冰，友情是零度的水，也许我们是最好的冰水混合物。走到一起后，升温，化为友情的水；降温，结成爱情的冰。不冷不热间，就是爱情与友情的暧昧。16.我以为终有一天，我会彻底将爱情忘记，将你忘记，可是，忽然有一天，我听到了一首旧歌，我的眼泪就下来了，因为这首歌，我们一起听过。17.我们许多时候并不是因为安定了，想要结婚；而是无法与某人安定下来，所以才要结婚。18.热恋时，情侣们常感叹上辈子积了什么德；结婚后，夫妻们常怀疑上辈子造了什么孽。19.爱情就像攥在手里的沙子，越刻意地攥得紧，流失的就越快。20.同样的一瓶水，便利店里2块钱，五星级酒店里却30块，很多时候，一个人的价值取决于所在的位置。21.哲人无忧，智者常乐，并不是因为所爱的一切他们拥有了，而是所拥有的一切他们都爱。22.一只脚踩扁了紫罗兰，紫罗兰却把香味留在那脚上，这就是宽恕。23.永远不要认为别人的老公或老婆比自己的好，因为他们的爱并不是你，24.请感谢伤害你的人，因为他磨砺了你的心志！请感谢绊倒你的人，因为他强化了你的双腿！请感谢欺骗你的人呢，因为他增进了你的智慧！请感谢藐视你的人，因为他觉醒了你的自尊！请感谢遗弃你的人，因为他教会了你该独立！25.生命中有一些人与我们擦肩了，却来不及遇见；遇见了，却来不及相识；相识了，却来不及熟悉；熟悉了，却还是要说再见！26.真正的爱情不在于你知道他（她）有多好才要在一起；而是明知道他（她）有太多的不好还是不愿离开。27.怀旧，不是因为那个时代多么好，而是那个时候，你年轻。28.两个人之间的感情就像织毛衣，建立的时候一针一线，小心而漫长，拆除的时候却只需轻轻一拉。29.人生试题一共有四道题目：学业、事业、婚姻、家庭。平均分高才能及格，切莫花太多的时间和精力在任一题目上。30.幸福不是被致命的错误所扼杀，而是被不断重复出现的小错一点点分解掉的。31.婚姻不是1+1=2，而是0.5+0.5=1。即，两人各消去一半自己的个性和缺点，然后凑合在一起才完整。32.我们最大的情敌不是第三者，而是岁月。33.女人的幸福在于：他真的爱我：男人的幸福在于：她值得我爱。", "life/[读书]卓有成效的管理者.md": "核心观点我们的工作必须是卓有成效的，而卓有成效是可以学会的。那么怎样做到卓有成效呢，德鲁克给出了如下方法：“时间管理为重要的工作留出“整块”时间”:“把眼光集中在自己的贡献和价值上”:“充分发挥人的的长处”;“要事优先集中于重要的领域，”;“有效决策－做正确的事”这5个方法,看起来似乎有些平淡无奇，但是，深入浅出的观点背后是入木三分的深刻，反复咀嚼后更体会到甘甜无比回味无穷。\u000b1、时间管理为重要的工作留出“整块”时间时间是一个稀缺资源，如不能有效利用，将很难卓有成效。但是,各种会议、协调工作、沟通交流包围着我们，让我们常常疲于奔命日常事务而荒于要务。我们常常觉得，有一件重要的任务，比如说整理项目文档。因为复杂，需要留待有时间时慢慢解剖，然而时间几个月后都没有到来；因为时间总被电话、邮件,琐碎的事务分割成一块块的……德鲁克说，重要的来做。例如做一个计划，整理项目文档，用45个小时集中精力也许就能做出雏形，然后零敲碎打修修补补即可；如果每天只花少量的时间，哪怕用一个月时间也做不出来。问题是，怎样找到整块的时间呢？德鲁克也开出了药方：追踪时间记录，删除不必要的浪费。人们对时间的印象往往和实际存有差距。一位CEO言之凿凿地说，他的时间1/3花在会见重要客户，1/3用于商谈业务，1/3用于重要社会活动。但拿过秘书做的时间统计后，他惊讶地发现，原来自己花很多时间帮熟悉的老客户催订单，这原本是销售经理的事情。另一位每天疲于参加各种宴会和社会活动的CEO，经过仔细鉴别之后发现，有相当多的活动本来是不必参加的，而主人的邀请不过是碍于情面。授权。授权不是把自己的工作交给别人去做，而是只做属于自己，别人无法替代的工作。所以德鲁克建议:比如一上班,就列出自己一天的任务，然后为重要工作留出整块时间，琐事集中处理。2、我们必须把目光集中到贡献上,着眼于对企业的贡献。通过强调贡献，使自身的价值转化组织成果.组织聘我们，就是希望我们对组织有贡献,重视贡献就是重视成果,就是希望我们不是为了完成任务而工作,而是为了取得成果而工作,许多人重视勤奋,但忽略成果,我们经常感觉自己忙忙碌碌,回过头,却不知道自己忙了些什么。一个人能重视贡献，是人才发展最大的动力，可以将眼光放得更远，这样也就提高自己的工作水准。重视贡献的人最后都成为了有所作为的人，他们之所以成功，因为他们能适应不同的价值观承诺.3、要求充分发挥人的长处使平凡的人做出不平凡的事。组织不能依赖于天才,因为天才稀少如凤毛麟角。绩效精神要求每个人都充分发挥他的长处,把个人放在他能做什么上，而不是他不能做什么上。优秀的组织都懂得利用每个人的长处,同时还使其成员的缺点相抵消。4、要事优先集中于重要的领域，有效的管理者坚持把重要的事放在前面做，精力集中于少数主要领域,每次只做好一件事。在少数重要的领域当中，如果有优秀的绩效就可以产生重要的成果。实际上“要事优先”是和“掌握自己的时间”相辅相成的。也是支撑着管理者工作卓有成效的两大支柱，缺一不可。我们所关心的不再是如何处理时间资源，而是管理者的终极产品组织和管理者的绩效问题。没有什么比忙忙碌碌更容易，没有什么比事半功倍更难。推荐”高效理念黄金法则――麦肯锡卓越工作方法”5、有效决策－做正确的事有效决策的五个要素非常重要:1.了解问题的性质，是经常性的，还是突发性的个案，用制定规范解决，还是根据实际情况个案处理。2.要确定边界条件，哪些是原则性的问题，哪些可以机动灵活。3.权衡和比较各种方案。特别是对立的方案,让我们从另外的角度,去审视和看待问题.4.兼顾执行的具体措施，让决策变成可以被落实贯彻的行动。5.重视意见的反馈，来印证和检查决策的正确性和有效性。有了以上五点,我想所有的难题都可以找到解决方案。德鲁克经典管理箴言一个平静无波的工厂，必是管理上了轨道，如果一个工厂高潮迭起，大家忙得不可开交，就必是管理不善。管理好的工厂，总是单调无味，没有任何激动人心的事件，那是因为凡是可能发生的危机都早已预见，且已将解决办法变成了例行工作。张瑞敏也说:过去好的工厂的标志,总是轰轰烈烈，大干快上而又激动人心的，但仔细琢磨，那些”心中无数决心大”的誓师大会,表面上是轰轰烈烈，但从本质上看对提高管理的有效性却没有任何帮助，那些在突发事件中表现英勇的人和事的确激动人心，但我们需要的不是停留在对这些英雄人物大张旗鼓的表彰上，而是要扎扎实实建立避免发生这类突发事件的机制。就是要防患于未然，将例外管理变成例行管理.一个组织的“士气”并不意味着“人们在一起相处得是否好”，其检验标准应该是绩效。如果人与人之间的关系不以达成出色绩效为目标，那么实际上就是不良的人际关系，就是互相迁就，互相包庇,并会导致团队士气的萎靡。在工作的环境下，如果我们不能有所成就，就算我们能与人和谐相处，愉快交谈，那又有什么意义呢?反过来说:如果能在工作上取的成绩，即使偶尔疾言厉色，也不至于影响人际关系.“我永远不会提拔一个从不犯错误、特别是从不犯大错误的人担任高层的工作。他肯定将成为一个工作平庸的管理者。”“人们工作时，不可避免犯有这样或那样的错误”。“一个人越好，他犯的错误就越多――因为他会努力尝试更多的新东西。”会议是管理者每日使用的管理工具,所以,为了使会议更加有效,有效的管理者会问：“我为什么要召开这次会议，是为了取得某项决策，还是为了宣布什么？还是为了澄清我们应该做些什么,”他在会前一定要想清楚会议的目的，因为他一定坚持:会议必须真正有所贡献.所以,有效的管理者会提前说明会议的目的，要求达成的贡献，同时，他还会在会议过程中设法让会议紧紧围绕主题，在会议结束之前，他应当回到开场所介绍的主题，使会议获得的结论和主题相符。", "life/△修身之道--积极主动.md": "关注圈：影响圈：365需求、团队技术架构家务孩子的教育可主动的事情：工作中下属搞砸事情时，能心平气和的解决，抱怨不能解决问题积极的解决问题，消极的抱怨于事无补重视承诺，积极兑现承诺生活中对饭菜不抱怨，评论只有一种：夸奖对孩子是引导式的教育、身体力行的教育，批评式教育会带来更多的反抗对地铁工作人员要和善，理解他们的工作我心似渊：生气使心里不平静承地铁、公交对人和善仁者无敌：敌意是有臭味，别人是能够嗅到的；敌意并不能为你赢得任何东西爱是奉献。欲望满足使人得到快感，奉献使人得到快乐。接受与改变充分利用你能改变的，积极的接受你不能改变的积极的去完成你不愿意做的事，要比被动的被安排好。人人都害怕陌生的事物，不愿去改变。改变有风险，但也总会有新的机会。", "life/△修身之道--自省与思考.md": "思考改变自己的不愿意：人人都会害怕麻烦和困难，你愿意做的事情，往往是愉快的、容易的。主动去挑战或完成你不愿意做的事，要比被动好多了。很多人都不愿意接受改变，但是改变总是能带了新的机会。批评是防止失败的机会。别人的批评是对自己的完善。随时接受别人的批评，来完善自我，完善工作。批评起作用的两个方面：第一、当你没有很好的去检查的或不愿意去检查你的工作时，批评是别人在帮你检查工作。第二、不同的人看事情的角度不同，批评可以防止思维定势。1藏不住话。把不高兴的话、抱怨的话藏在心里。碰到不高兴的事情，哪怕是好像教育和劝诫，也不要马上说出来，记在心里，事后想好劝说和教育方式，再来表达；或者让不高兴的事随风而去。思想>行为>习惯>性格>命运习惯和品德的养成：总体的过程是发现问题>分析问题>解决问题。发现一个问题或道理，就想想在生活中可以做哪些事可以解决这种问题，并拿起笔记下来。提醒自己每天要做好这些事。大街上看地图,饭馆里不厌其烦的询问菜价都没什么可耻的,想了解自己不熟悉的东西没什么丢人,也不代表你无能,任何人都有一个从无知到知的过程书签中收藏的网页中的知识不是你的,经过自己思考过并总结过的知识才是自己的知识今天看了日本横滨举行的世乒赛，CCTV的几个评球国手反复的说，不要老想着赢球或输球的后果，要思考战术问题，即思考怎么打每一个球的问题。老想赢球，会患得患失，使自己紧张彷徨；而集中精神想每一个球的细节，会使人更加兴奋、自信。这些到和人的做事情一样。想一想我自己，找工作时老想找工作的结果，总是让人没有信心，彷徨；多想想笔试和面试的内容，反而使人放松。既然自己缺乏自律,不能改变自己,那么就让别人来改变和约束自己当别人需要你的帮助或协助，开口请求时，不要因为打扰了你而懊恼，而要热心的帮他完成事情。人之间的友情就像储蓄帐户，你存了多少才能取多少。人之间的关系，即人脉，对成功非常重要。是什么消耗了你的精力？1、网络强迫症2、来自于同事或朋友的干扰3、身体不适4、遇到障碍www.lifebang.com/archives/464互联网阅读相对传统阅读却有根本的差异，依靠搜索获得的资讯只能属于速食式的“浅阅读”，多读经典的书，记住消化它们，刻在骨子里，这是主食，再不愿意吃也要坚持。杂志、报纸、上网浏览的信息，这些都是辅食，为了补充自己的不足，扩大自己的知识面和兴趣，这些东西也是越多越好。任何时候都不要丢掉信心,不要失去心中那份小看一切的骄傲,想想当年如果进入一中读书,我就一定能上大学吗?在横车也能上大学,凭借的就是心中那份不服输的骄傲。仁恕：爱心与宽容激励你的团队中成员最好的方法是，原谅他的错误，赞扬他的长处和他做对了事；尽量多的赞美和宽容，尽量少的批评和计较。别人和你一起做事，尽管你不满意，但你还是要感恩，因为如果没有他，你的处境可能更糟。这是一种宽容。1、生活、工作关注视野让自己过得更好，逃离不好。能让自己过得更好，为什么为了过得不好而挣扎呢？1、财经、房产、自己的事业【佛心禅语】1、天下难事，必起于易；天下大事，必做于细。2、太阳光大，父母恩大，君子量大，小人气大。3、静能制动，沉能制浮，宽能制褊，缓能制急。4、有才而性缓，定属大才。有智而气和，斯为大智。5、缓事宜急干，敏则有功；急事宜缓办，忙则多错。6、大着肚皮容物，立定脚跟做人图难于其易，为大于其细。天下难事必作于易，天下大事必作于细。是以圣人终不为大，故能成其大。美德与习惯按规律作息和经常锻炼身体能使精力充沛，能使你的工作效率和有效的工作时间更长。要事第一。用一天中精力最充沛的时间来做对人生长远发展最重要最有利的事情。积极主动。积极的思维，困难既是机遇。你不愿意做的事一定是你的弱项。逃避或拖延只能使问题更严重。安逸是慢性毒药，而改变总能带来机会。工作好习惯：欲罢不能的连续工作是犯错的前兆；间歇思考能让人更清楚目标在哪里；和同事讨论问题能消除精神疲劳；上班前想想今天要干什么，下班前总结今天的干了什么；随手记录你的错误和灵感，记住错误和思考灵感都能让人进步。工作百分百，做事百分之百二；上班勤奋，下班充电。多做事，少辩解，少评论，少争论。辩解是没有信心的表现，对解决问题毫无用处。油多菜好吃，嘴多招人厌。得意时少说话，得意则忘形，言多则必失。发怒有伤身体，别人拿他人的白痴言论和愚蠢行为来惩罚自己。发怒时作出的决定是愚蠢的决定。图难于其易,为大于其细;何为易？何为细？易是熟悉、容易完成；细是能改变全局的小事或突破口。又曰：多则惑，少则得。不可在多个选择中犹豫和徘徊而错失良机，弱水三千只取一瓢饮，选择一个突破口，坚持到底则必有突破。如何帮助他人？帮助他人能给我们带来什么？常想想自己能为别人做什么。帮助他人可以成就自己：能力的肯定；树立威信和扩大影响力；热心且愿承担责任。自动为上司解决麻烦，让上司省心和放心是职场之王道，做好事情是实现王道的最好方法。别人不愿干的事，可能是你的机会。“信”字是自己声誉和形象的保证。自己说过的事，自己一定做到；要求别人做的事，要时时盯着，保证达到自己的要求。目标是前进的明灯，是前进的动力。时刻提醒自己，你的大目标是什么，短期目标是什么。宽容是管理者最重要的一项品质。人人都会犯错，但不是人人都会宽容，宽容是一种能力；赞扬比批评更能解决问题；要批评时，要先赞扬而后批评；批评只针对态度，而不针对能力。多解图和五个算式。多解图告诉我们，与你不同的声音可能真理；五个算式告诉我们，人总是容易先看别人的缺点，而忽略优点。先赞扬而后批评。要想得到某一个职位，必先有该职位的能力。观察这个职位上的人如何处事，想想同样的事你做得会和他一样吗？观察你的同事和上司的优缺点、脾气性格；确定和每一个人的交往方式。读书，读事，读人。从书中学习，从周围的事中学习，从别人身上学习，这些都学习都必须深刻的思考。别人的批评是完善自我、预防失败的良药。第一、别人的批评是在帮你指出为人处事的缺失、工作的疏漏。第二、别人的批评可以防止思维定势。故不积步，无以致千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。P无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹八跪而二螯，非蛇之穴，无可寄托者，用心躁也。虽有天下易生之物也，一日暴之，十日寒之，未有能生者也。――《孟子・告子上》", "life/☆修身之道.md": "TOC夫妻相处之道去解决问题。丢掉抱怨、批评。多一些关爱。包容：不在家人面前争强好胜，在家把自己当做说话最没分量的。坚守原则，镇定自若势穷观初心，功...自律自律还是要从自己生活中的一些小事做起,一点一点的积累就养成了好的习惯。生活中的小事就像一把把锁，把狂放、浮躁的心锁住，使你不能随便的放纵自己。1、早起。早起能保证一天斗志昂扬2、早睡。早谁能保证早起3、睡前洗脸刷牙。它们能告诉你，不要因为很困，就不管不顾的、随心所欲的倒在床上4、知道明天要干什么。它能驱动你不停前进5、经常看励志的书自省与思考思考和总结过的知识才是自己的知识：收藏的知识不是你的知识最少需要过两遍：看一遍，思考一遍，总结一遍读书读人读事，省己省人省事自助则天助，自强则天齐日常功夫，无限禅机世事洞明即文章小中见大，自然乾坤一日三省，无心思道爱与宽容宽以待人，严以待己宽厚待人，天高海阔忠恕待人，养德远害慈悲为怀，百福之基祸福转换，吃亏是福心怀慈悲，和谐共生有容乃大，百毒不侵谦虚难得糊涂：傻与不傻，要看你会不会装傻。自满招损，自谦受益收敛锋芒，大智若愚韬光养晦，韬光养德如履薄冰，如临深渊大智若愚，大巧似拙大音希声，大象无形树大招风，虚名可虑谦虚谨慎，真诚待人祸兮福依，福兮祸伏月盈则亏，花开则谢坚忍毅力少年戒躁，老成戒惰精勤不懈，终成正果坚忍自强，万事可过耐得寂寞，甘苦自知勤勉不苦，淡泊不枯积极主动：把困难当作机会磨难是良伴，逆境吃得苦中苦，方为甜...逆境如洪炉，百炼...诚信实事求是心气平和宠辱不惊，去留无意心平气和，邪魔不侵不以物喜，不以己悲不温不火，才是懿德清浊并包，善恶兼容悠闲镇定，宽洪忠厚身贫心富，知足常乐完全本心，尽得世道利禄看淡，远害全身平淡最乐，得失最苦我为本原，以我役物保持乐观，远离嫉妒简单人生，知足常乐爱好趣味高远，人自不俗快乐生活，不虚此生寄情自然，心胸开阔", "life/《论语》心得.md": "《论语》心得仁恕：【原文】1・2有子1曰：“其为人也孝弟2，而好犯上者3，鲜4矣；不好犯上，而好作乱者，未之有也5。君子务本6，本立而道生7。孝弟也者，其为人之本与8？”【译文】有子说：”孝顺父母，顺从兄长，而喜好触犯上层统治者，这样的人是很少见的。不喜好触犯上层统治者，而喜好造反的人是没有的。君子专心致力于根本的事务，根本建立了，治国做人的原则也就有了。孝顺父母、顺从兄长，这就是仁的根本啊！”【原文】1・6子曰：“弟子1入2则孝，出3则弟，谨4而信，5爱众，而亲仁6，行有余力7，则以学文8。”【译文】孔子说：“弟子们在父母跟前，就孝顺父母；出门在外，要顺从师长，言行要谨慎，要诚实可信，寡言少语，要广泛地去爱众人，亲近那些有仁德的人。这样躬行实践之后，还有余力的话，就再去学习文献知识。”【原文】4・1子曰：“里仁为美1，择不处仁2，焉得知3？”【译文】孔子说：“跟有仁德的人住在一起，才是好的。如果你选择的住处不是跟有仁德的人在一起，怎么能说你是明智的呢？”【评析】每个人的道德修养既是个人自身的事，又必然与所处的外界环境有关。重视居住的环境，重视对朋友的选择，这是儒家一贯注重的问题。近朱者赤、近墨者黑，与有仁德的人住在一起，耳濡目染，都会受到仁德者的影响；反之，就不大可能养成仁的情操。【原文】5・5或曰：“雍1也仁而不佞2。”子曰：“焉用佞？御人以口给3，屡憎于人，不知其仁4。焉用佞？”【译文】有人说：“冉雍这个人有仁德但不善辩。”孔子说：“何必要能言善辩呢？靠伶牙利齿和人辩论，常常招致别人的讨厌，这样的人我不知道他是不是做到仁，但何必要能言善辩呢？”【评析】孔子针对有人对冉雍的评论，提出自己的看法。他认为人只要有仁德就足够了，根本不需要能言善辩，伶牙利齿，这两者在孔子观念中是对立的。善说的人肯定没有仁德，而有仁德者则不必有辩才。要以德服人，不以嘴服人。【原文】6・26宰我问曰：“仁者虽告之曰井有仁1焉，其从之也？”子曰：“何为其然也？君子可逝2也，不可陷3也；可欺也，不可罔也。”【译文】宰我问道：“对于有仁德的人，别人告诉他井里掉下去一位仁人啦，他会跟着下去吗？”孔子说：“为什么要这样做呢？君子可以到井边去救，却不可以陷入井中；君子可能被欺骗，但不可能被迷惑。”【评析】宰我所问的这个问题的确是比较尖锐的。“井有仁焉，其从之也？”对此，孔子的回答似乎不那么令人信服。他认为下井救人是不必要的，只要到井边寻找救人之法也就可以了。这就为君子不诚心救人找到这样一个借口。这恐怕与他一贯倡导的“见义不为非君子”的观点是截然相反的了。【原文】7・30子曰：“仁远乎哉？我欲仁，斯仁至矣。”【译文】孔子说：“仁难道离我们很远吗？只要我想达到仁，仁就来了。”【评析】从本章孔子的言论来看，仁是人天生的本性，因此为仁就全靠自身的努力，不能依靠外界的力量，“我欲仁，斯仁至矣。”这种认识的基础，仍然是靠道德的自觉，要经过不懈的努力，就有可能达到仁。这里，孔子强调了人进行道德修养的主观能动性，有其重要意义。【原文】12・1颜渊问仁。子曰：“克己复礼1为仁。一日克己复礼，天下归仁焉2。为仁由己，而由人乎哉？”颜渊曰：“请问其目3。”子曰：“非礼勿视，非礼勿听，非礼勿言，非礼勿动。”颜渊曰：“回虽不敏，请事4斯语矣。”【译文】颜渊问怎样做才是仁。孔子说：“克制自己，一切都照着礼的要求去做，这就是仁。一旦这样做了，天下的一切就都归于仁了。实行仁德，完全在于自己，难道还在于别人吗？”颜渊说：“请问实行仁的条目。”孔子说：“不合于礼的不要看，不合于礼的不要听，不合于礼的不要说，不合于礼的不要做。”颜渊说：“我虽然愚笨，也要照您的这些话去做。”【评析】“克己复礼为仁”，这是孔子关于什么是仁的主要解释。在这里，孔子以礼来规定仁，依礼而行就是仁的根本要求。所以，礼以仁为基础，以仁来维护。仁是内在的，礼是外在的，二者紧密结合。这里实际上包括两个方面的内容，一是克己，二是复礼。克己复礼就是通过人们的道德修养自觉地遵守礼的规定。这是孔子思想的核心内容，贯穿于《论语》一书的始终。【原文】13・19樊迟问仁。子曰：“居处恭，执事敬，与人忠。虽之夷狄，不可弃也。”【译文】樊迟问怎样才是仁。孔子说：“平常在家规规矩矩，办事严肃认真，待人忠心诚意。即使到了夷狄之地，也不可背弃。”【评析】这里孔子对“仁”的解释，是以“恭”、“敬”、“忠”三个德目为基本内涵。在家恭敬有礼，就是要符合孝悌的道德要求；办事严肃谨慎，就是要符合“礼”的要求；待人忠厚诚实显示出仁德的本色。【原文】15・10子贡问为仁。子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”【译文】子贡问怎样实行仁德。孔子说：“做工的人想把活儿做好，必须首先使他的工具锋利。住在这个国家，就要事奉大夫中的那些贤者，与士人中的仁者交朋友。”【评析】“工欲善其事，必先利其器”这句话在民间已为人们所熟知。这就是“磨刀不误砍柴功”。在本章中，孔子以此作比喻，说明实行仁德的方式，就是要事奉贤者，结交仁者，这是需要首先做到的。【原文】15・24子贡问曰：“有一言而可以终身行之者乎？”子曰：“其恕乎！己所不欲，勿施于人。”【译文】子贡问孔子问道：“有没有一个字可以终身奉行的呢？”孔子回答说：“那就是恕吧！自己不愿意的，不要强加给别人。”【评析】“忠恕之道”可以说是孔子的发明。这个发明对后人影响很大。孔子把“忠恕之道”看成是处理人己关系的一条准则，这也是儒家伦理的一个特色。这样，可以消除别人对自己的怨恨，缓和人际关系，安定当时的社会秩序。【原文】17・6子张问仁于孔子。孔子曰：“能行五者于天下为仁矣。”“请问之。”曰：“恭、宽、信、敏、惠。恭则不侮，宽则得众，信则人任焉，敏则有功，惠则足以使人。”【译文】子张向孔子问仁。孔子说：“能够处处实行五种品德。就是仁人了。”子张说：“请问哪五种。”孔子说：“庄重、宽厚、诚实、勤敏、慈惠。庄重就不致遭受侮辱，宽厚就会得到众人的拥护，诚信就能得到别人的任用，勤敏就会提高工作效率，慈惠就能够使唤人。”【原文】19・6子夏曰；“博学而笃志1，切问2而近思，仁在其中矣。”【译文】子夏说：“博览群书广泛学习而已记得牢固，就与切身有关的问题提出疑问并且去思考，仁就在其中了。”恒：忍：礼：慎言敏行：忠：忠就是待人真诚，对工作认真负责信：信是指诚实无欺，言行一致勇：律己：智：知人义：", "life/五项管理.md": "五项管理，终于收集齐了，与大家分享！《心态管理》、《目标管理》、《时间管理》、《学习管理》《行动管理》第一部分《心态管理》1、任何限制都是从自己的内心开始的（如果你连自己都不相信，你又怎么能够指望别人相信你，不要再给自己设限，那样你将白来一世，世界上没有后悔药可以买，人最终还是要靠自己，除此之外谁也帮不了你）2、心态决定未来（你的思维、行动、未来的世界早都是由你的心态已经决定好了的，你想最终怎么过，那就要问问你自己有什么样的心态了）只能告诉你：积极的心态像太阳，照到哪里哪里亮，而消极的心态就像是月亮，初一、十五不一样3、生活就是一面镜子，你用什么态度对待它，他就用什么态度回馈你（你是笑还是哭呢，全在你一念之间，好好想想到底该怎样去照“镜子”）4、成功====心态*能力（能力不会为零，要想数值更大，成功的机会更多，你该怎么办？这种算术问题不用我教了吧）5、有斗志再大的困难都不怕，一旦失去斗志，你将往往一事无成（持之以恒不是谁都能做到的，时刻扪心自问一下，你怎么样？）6、先有交流的机会；再有交心的机会；才有交易的机会（人都要为自己而活，不要活在别人的世界里，自己认为对的就抓紧时间去做吧，那样即使失败也不会后悔）7、内心的世界控制外在的世界（不要低估自己的潜意识，好好利用一下，存在定有道理）8、要学会心态转换（挫折==存折；压力===动力；障碍===最爱）9、改变别人也许很难，那就试着改变自己并影响他人（我们可以做的就是用乐观的心态感染周围的人）10、事情在你手里出了差错，记住是你自己的问题不能怪罪他人11、永远想你得到的，不要想你失去的（不要给自己找郁闷）12、不冒险比冒险更危险（失败是你通往成功所积累的财富，失败越多，财富越大，更何况你冒险了并不一定失败，更大程度会是成功）13、你认为你行你就行（自己否定自己，别人认为你行你也行不了）14、帮助别人就是帮助自己（人之初、性本善）15、上帝为你关上一扇门，同时又为你打开一扇窗（阳光一般是从窗户照射进来的，你又何必留恋那黑暗之门）16、只有管好自己才能管好别人（不要把制度当成狼狗，只要别人不要自己，身体力行，作出榜样）第二部分《目标管理》1、有目标者自有千计万计，无目标者只感千难万难（目标就是灯塔，让你少走弯路的引导者）2、目标不明确，努力再多也是劳而无功（与其做无用功，不如先找好灯塔方向不对，努力白费）3、做对的事比把事做对更重要（对的事情就是你的目标）4、人之所以伟大，是因为目标伟大5、世界上没有懒惰的人，只有没有目标的人（没有目标就没有动力）6、目标聚集原则（瞄准靶心再开枪；锁定客户在出手；不要用机关枪打鸟；不要大海里捞针；目标要单一，精准并聚焦）7、实现目标没有捷径可以走（不经历风雨怎能见彩虹）8、目标要不断校正（与时俱进，但大的方向要走对）9、企业家的高度决定了企业的高度，企业家的远见决定了企业的远见10、只要你有目标整个世界都为你让路11、成功的尺度不是做了多少工作二十获得多少成果12、把目标分解成远期、中期和近期（督促自己去逐步完成）第三部分时间管理1、时间用在哪里，你的结果就在哪里2、你抛弃时间，时间也会抛弃你3、浪费时间等于慢性自杀（有效利用时间能拓展你生命的宽度，浪费时间就等于缩短你的生命）4、从不浪费时间的人，没有功夫抱怨时间不够用5、做事从不拖延（给自己设定时限，并督促自己去实现）6、条理要清晰（能做到的要马上行动，待做的事情记入日志，保留的东西立即归档，做不出决定的先扔掉）7、要马上行动（立即记录，立即行动，天天反省，马上改进）8、20%的重要事项要用80%的时间来保证完成9、一万年太久，只争朝夕（珍惜现在，而不是打算明天将怎么怎么样）10、没有安排不了的时间，只有自己没有安排时间11、时间管理上的帕金森定律（给你多少时间你花多少时间，时间太多反而让你托磨工作，效率极低，并且会托磨到最后一刻，所以你唯一需要做的就是如何提高你的工作效率）12、会时间管理的人是少做而不是多做（并不是你做的多，就代表你是用功的，应把时间花在最重要的事情上）13、时间的最大损失是拖延、期待和依赖将来14、人生最大的成功就是在最短的时间内达成最多的目标15、富人爱时间穷人爱金钱时间一去不复返，千金散尽还复来第四部分《学习管理》1、参加读书分享会（讨论心得，互相学习）2、很多时候我们不缺少学习而缺少的是练习（不用于到实践中就等于白学）3、专家是持续学习出来的（每天学习一小时，一年后成为专家，三年行业专家，五年国家级专家，你能做到吗？看似简单，先试试再说）4、向一流人士学习，与成功人士为伍（学习一流人士的成功经验可以帮助我们少走弯路，与成功人士交朋友可以扩大人脉资源）5、大量学习成功者所读的书籍（里面定有走向成功的规律可循）6、每天进步1%一年之后的今天你就进步了365%（何乐而不为）每天学习一些新知识，每天进步一点点，总会有质变的一天7、把学到的知识总结归纳，能够说清楚才是自己的，否则书读的再多也白费8、现在更需要专家，而不是通才（就像看病，很多人是去找专家的）9、相信你为工作付出的永远比它给你的要少（不要天天哭着喊着喊累，为什么要这样呢？）10、最有效的学习方式就是“做”（“听”能吸收２0％；“说”能吸收５0％；“做”要吸收７0％）11、不要只低头拉磨，还要长抬头看天（外面的世界是精彩的，不要把自己封闭起来）12、时刻问自己两句（１、我学到了什么２、工作上我将如何改进）13、学习是一把手的工程（学习力就是企业的竞争力）14、高知高酬，高智高位15、明天的文盲将会是那些不会主动寻求新知识的人第五部分《行动管理》１、责任/２＝0（如果一件事交给两个人去做就会造成容易推诿，推卸责任，办事拖沓）２、行动是治疗恐惧的良药（要害怕什么就去做什么）３、穿上鞋子才知道哪里夹脚（先行动起来，在行动中纠正、调整、完善、检查）４、把相同卖的不同（你比竞争对手做得更好不容易，做得不同却很容易）５、任何事都是做出来的不是说出来的６、行动比语言更能取信于人Actionspeakslouderthanwords７、士兵要死在战场上不能死在战壕里；销售人员要死在市场上，不能死在工厂里８、跟对人，做对事用对方法９、世上没有做不成的事，只有做不成事的人１０、永远把注意力集中在解决问题的方法上１１、人之初，性本懒，要想做，制度管１２、读万卷书，不如行万里", "life/你的碌碌无为，恰恰是因为做得太多.md": "你的碌碌无为，恰恰是因为做得太多文/燕麦小姐有个朋友给我留言，说生活总是忙碌。希拉里传记在桌上躺了很久，一直都没有看。想做的事和应该做的事总是那么矛盾。没错，我们生活在一个混乱的年代。每时每刻，无数琐事侵蚀着我们的生活。就在你打开这篇文章的时候，也许，你的客户又打进一个电话。那边的房租就要到期，下个月的英语考试近在眼前。淘宝京东的购物节，又占据了你一个晚上。一边奔波于眼前的苟且，一边梦想着远方的田野。而你的手机里，还躺着未曾追完的电视剧。周末的舞蹈班和演讲班，一样都不能落下。仿佛只有这样用力地生活，才是通往成功的唯一出路。然而忙碌并没有让我们生活得更好，反而让一切更糟。大部分人的碌碌无为，并不是因为做得太少，而恰恰是因为做得太多。1一次只做一件事的人才会领先于这个世界我曾经也是个忙忙碌碌的人，四处涉猎从不停息。工作中的完美主义让我如履薄冰，生怕一个不经意的纰漏，就会显示自己的无能。直到多年后我才明白，很多我们孜孜以求的事情，其实并没有那么重要。著名的二八法则告诉我们，大部分人的主要成就，都来自于那些少数的重要事情。我们部门去年招了一个新人，负责产品的采购计划和执行。然而没到两个月，她就提出了离职。原因是这份工作实在太累，她天天加班，已经没有了个人生活。这个说法让我们惊讶不已。她的工作量其实并不大，又怎么会天天加班呢？后来这份工作由一位管理培训生接手。他做起来轻松自如，毫不费力。问起原因，他说，之前那个天天加班的人，是个吹毛求疵的完美主义，每一封非正式的邮件，都要反复推敲。这样事无巨细的工作方式，不累才怪。而这位管理培训生，用大部分的时间做了一件事情。他根据公司的实际情况，完成了一个创新项目。这个项目给公司节省了200万美金。他也因此获得了年度贡献奖。优秀和平庸的差距，往往只在于一件事。`优秀的人能把这一件事做好，而平庸的人做了太多事情却依然碌碌无为`。因为我们的时间和精力都是有限的。成功的秘诀就在于一件事。你是否能把这件事情做好，决定了你能够走多远。肯德基做好了一份食谱，成为了一家伟大的公司。乔布斯做好了一款手机，颠覆了这个时代的传播方式。在这个混乱而充满诱惑的时代里，我们并不需要做太多。只需要做好一件事情，你就能找到撬动整个地球的支点。从此以后，不再迷失于五光十色的诱惑。想做的事太多，应该做的事也太多。然而最重要的事情永远只有一件。借用美国作家奥格・曼狄诺的一句名言：“一次只做一件事的人，才会领先于这个世界。”2找到多米诺的起点才会带动整个人生我的前同事杨小姐，曾经是一位胖妞，感情和工作都不如意。2014年的春天，她只做了一件事情，那就是减肥。从130斤减到100斤，然后意想不到的事情发生了。由于体重的变化带来精神面貌的改变，她成功跳槽到一家跨国公司，做了自己想做的工作。紧接着遇见一位同样在跨国公司工作的男人，他们在一起了。我的另一位朋友汤先生，曾经一度在人生的低谷。丢了工作，和女友分手，社交圈狭小，处处碰壁。越是如此，越是不甘心。当他混迹于各种俱乐部想要寻找新女友的时候，我给了他一个建议。从此他不再混迹于俱乐部，也不再急着寻找新女友，而是全力以赴地开始做一件事情：工作，工作，再工作。如今，他已是一名高级项目经理，年薪40万，身边的女友亦是才貌双全。这就是多米诺骨牌效应。当你做成了一件事情之后，其它各种好事都会接连而来，人生就会有奇遇。而我们所要做的，只是找到那个多米诺骨牌的起点，从这里开始，带动你的整个人生。还有一个圈子里人尽皆知的故事。深圳的一个上班族，开了个微信公众号，在过去的一年里专心写文，积累了几十万粉丝。然而就凭这一件事情，她认识了很多人，获得很多机会，过上了自己想要的生活。还有我的朋友小乙，在过去的十五年里只培养了一个爱好，那就是跳舞。因为跳舞，他养成了出色的气质。因为跳舞，他成为了公司的焦点。因为跳舞，他还成为了一个舞蹈学校的股东。`\"给我一个支点，我就能撬起整个地球。\"`我越来越体会到这句话的含义。这不只是一个哲学命题，更是一个人生智慧。到处涉猎往往一事无成。做好一件事情，却能带你走向更宽阔的世界。就像奇妙的多米诺骨牌，从一张小小的牌开始，带来的联动力量能够推倒整幢大楼。而你的那张牌，又在哪里？3做了这件事其它的事都变得简单了曾经有人反驳我说，她去年只做了一件事，那就是专心怀孕，结果没有怀上，浪费了一年。我笑。最重要的事情只有一件。但也不能拉到篮子里就是菜啊。于是有人问我，最重要的事情，究竟应该是哪一件？我想，以下这些方法，也许能帮你找到最重要的那件事。首先，这件事必须和你的人生愿景息息相关。如果只做一件事情，让你觉得自己没有白活，你会做哪件事情？第二，这件事情必须很明确。宽泛的画画、写作、旅行，并不能成为一件事情。还必须有明确的描述。所以第二个问题是，如果你只做一件事情，能够成为一个旅行家，你会做哪件事情？也许，你开了一个博客，专门写不同地方的美食以及人们对于食物的不同态度。这将会成为你的第一张多米诺骨牌。第三，做了这件事，其他的事都变得简单或不那么重要了。你去了很多城市旅行，悉心研究了不同地方的食物和风土人情。由于角度新颖，渐渐获得了一些关注。于是有人来聘请你做导游，有人请你给餐厅或旅行社写广告软文，还有人约你写一本关于旅行与美食的书。你的业务越来越多，生活也越来越忙，渐渐地没有时间再写博客。那么，在这么多事情当中，只要做了哪件事情，就会让其他的事变得简单或不那么重要了？博客是你的宣传平台，导游或软文只是一些额外收益，而写一本书，能让你有更多的成长。同时，书的内容还转化成你的博客文章。于是，写好一本书，就成了那件最重要的事情。这是一个普通人逆袭的故事。也许隐含了光荣和梦想。也许还有一些不为人知的艰辛在里面。但是，努力做好一件事情，是成功的唯一法则。人生太短，我们没有时间为太多不相干的事情分心。人生其实也挺长，足够你把一件事情做到最好。不时地问问自己，只做哪一件事情，能够实现我的人生价值？只做哪一件事情，能够让我的工作获得提升？只做哪一件事情，能够让爱情升温，让家庭和睦？纷杂世界里，最重要的事情其实只有一件。不怀疑，不慌张。拿得起，也要守得住。在这个瞬息万变的时代里，从容看岁月到地老天荒。", "life/健康小结.md": "!_v_images/20191118211840.png有病及时治疗、吃药前期比晚期好治疗，小病拖成大病。运动保持标准体重，迈开腿。肥胖会导致各种疾病。自律有规律的作息：早睡才能早起。戒掉不良习惯：通宵玩游戏、看小说，有躺的地方不坐着。管住嘴不要把剩下的都吃完，美其名曰怕浪费。多好吃的东西，都不能贪多，35口即可。修身养性少生气。没必要拿别人的错误、没有做好的事情惩罚自己。减慢速度，沉着冷静的办事，急躁伤肝。", "life/华为离职副总裁徐家骏给任正非的辞职信，太震撼了！.md": "华为离职副总裁徐家骏给任正非的辞职信，太震撼了！徐家骏是华为数据中心的头，技术超级牛人，一级部门总监，华为副总裁，年收入过千万。从一个普通的公司职员，到年薪千万的华为副总裁，再到离开华为转战百度，徐家骏的十年从业经历和经验对于任何渴望成功的人来说绝对可资借鉴，我们从中也可以一窥华为公司的运作过程和徐的职业规划。世界上本没有好工作，下的功夫够了，好工作自会找上门的。还有最重要的一点：珍爱生命。正非兄：转眼工作十年了，在华为的十年，正是华为从名不出专业圈子到现在成为路人皆知的大公司，高速发展的十年，见证了公司多年的奋斗历程。也投身其中，在大潮中边学边游泳，走到今天。现在我要离开公司了，准备去开始新的事业，接受全新的挑战，我将要去做的事情，风险很大，很有可能是九死一生，九死后还能不能有一生，也难说。在开始新的事业之前，想起了对过去的十年做个一个详细的总结。在一个象华为这样高速发展的大企业工作，有时是一种炼狱般的锻炼，如果我能够总结十年的经验和教训，从中学到关键的做事、做人的道理，我想对将来一定大有益处。这些年来有些人离开公司，写一些东西或书，对公司指手画脚、评头论足、指点江山，对公司的高层领导逐个点评一番，我个人感觉除了带来一些娱乐价值，还有什么益处呢?公司照样在发展，发展的背后，6万人种种梦想、努力、贡献、牺牲、奋斗、抱怨、不满、沉淀、离去、希望、失落;发展的背后，种种机会、重大决策、危机、失误等等的内在逻辑又岂是局外人说得清楚?我不想多说公司，只是想对自己的工作经历好好反思反思，想想自己做了什么努力，做了什么贡献，做了什么自己最高兴、做了什么自己最受益、学到了什么?总得说来，我在华为的十年是懵懵懂懂过来的，当初我好像没有什么远大的理想、没有详细的规划，只是想着把一件一件事情做好。通过自己的总结和反思，将来我希望自己能够更加有规划、更加清晰一点。大概想了想，我觉得有以下几点，是这些年深有体会的经验和教训，值得今后再发扬。一、“从小事做起，学会吃亏，与他人合作”这是研究生毕业前最后一堂课，电子电路的老师最后送给我们几句话，虽然我忘了这位老师的名字，但这几句话却至今铭记。在华为的工作实践，越发感受到这简单的几条的道理深刻。从小事做起不是一直满足于做小事，也不是夸夸其谈好高骛远。学会吃亏不是忍受吃亏，是不斤斤计较于一时一地的是非得失，是有勇气关键时候的放弃。二、“心有多大，舞台就有多大”我们很多的成功，来自于敢想，敢做，就象我第一次接到问题单，根本不懂，但敢去试，敢去解决，还真的解决了;就像我们做SPES，即使没人、没技术、没积累，还有CISCO等大公司也在做，我们也敢做，敢推行，不盲目崇拜或畏惧权威，也取得了成功。当然，这不只是盲目的胆大，心大还意味着积极地关注广大的外部世界，开阔宽容的心胸接受种种新鲜事物。三、“好好学习，天天向上”这句话用来形容对IT人的要求，最贴切不过了。真正的成功者和专家都是“最不怕学习”的人，啥东西不懂，拿过来学呗。我们IT现在有个技术大牛谭博，其实他不是天生大牛，也是从外行通过学习成为超级专家的，他自己有一次跟我说，当年一开始做UNIX系统管理员时，看到提示符大吃一惊，因为自己用过多年在UNIX下搞开发都是%提示符，从未有过管理员权限。看看专家的当初就这水平!当年跟我做备份项目时，我让他研究一下ORALCE数据库时点回退的备份和恢复方法，他望文生义，以为数据库的回退是象人倒退走路一样的，这很有点幽默的味道了，但他天天早上起来，上班前先看一小时书，多年积累下来，现在在系统、数据库、开发等多个领域已成为没人挑战的超级专家了。但是，学习绝对不是光从书本学习，其实更重要的是从实践工作中学习，向周边学习。比如说我在华为觉得学到最重要的一个理念是“要善于利用逆境”，华为在冬天的时候没有天天强调困难，而是提出“利用冬天的机会扭转全球竞争格局”并真的取得成功，如果没有这个冬天，华为可能还要落后业界大腕更多年份;华为在被CISCO起诉时没有慌乱，而是积极应对，利用了这次起诉达到了花几亿美金可能达不到的提高知名度的效果。等等这些，把几乎是灭顶之灾的境遇反而转化为成功的有利条件，对我留下的印象十分深刻，也对公司高层十分佩服。四、勇于实践，勇于犯错，善于反思很多事情知易行难，关键是要有行动，特别是管理类的一些理论、方法、观念。空谈、空规划一点用处都没有，不如实际把它做出来，做出来后不断反思改进，实实在在最有说服力。没有实践中的反复演练和反思，即使是人人皆知的东西要做好都其实不容易，举个小例子，比如做管理者要会倾听，我想华为99.9%的管理者都很懂这一点，但实际做的如何呢?华为有多少管理者做到了不打断别人讲话?不急于下结论给定义?不急于提供解决方案?有多少管理者能够做到自然地引导对方表达?问问对方感受?确认自己明白对方?五、要有方法、有套路，对问题系统思考、对解决方案有战略性的设计在前几年的工作中，由于取得了一点成功，技术上也有了一点研究，就开始夜郎自大起来了，后来公司化重金请来了大批顾问，一开始对有些顾问还真不怎么感冒。后来几年公司规模越来越大、IT的复杂性越来越增加的情况下，逐渐理解了很多。西方公司职业化的专家，做任何事情都有方法论、有套路，甚至于如何开一个会都有很多套路，后来我对这些套路的研究有了兴趣，自己总结出了不少套路并给部门的骨干培训和讨论。在一个复杂的环境下，很多问题已经不能就事论事来研究和解决，非常需要系统性的方法和战略性的眼光。对于一个组织的运作来讲，制度和流程的设计尤其需要这一点。爱恩斯坦说过：Wecan‘tsolveproblemsbyusingthesamekindofthinkingweusedwhenwecreatedthem.六、独立思考，不人云亦云公司大了，人多了，混日子也容易了。人很容易陷入随波逐流、不深入业务的境地，而看不到问题和危险。专家有过一个研究，雪崩发生时，一般受害者都是一批一批的，很少有单个人的受害者，原因很简单，单个人在雪崩多发地会相当小心和警觉。但一个群体，群体越大，每个个体就会有一种虚幻的安全感和人云亦云的判断，但现实是不管群体的力量有多大，雪崩都是不可抵抗的。因此我觉得在大的机构里，保持独立思考的能力尤为重要。七、少抱怨、少空谈、积极主动，多干实事我曾经是个抱怨很多的愤青，经常容易陷入抱怨之中。但多年的工作使得我有所转变，因为知道了抱怨是最无济于事的。世界上永远有不完美的事情，永远有麻烦，唯一的解决之道是面对它，解决它。做实实在在的事情，改变我们不满的现状，改变我们不满的自己。实际上也有很多值得抱怨的事情都是我们自己一手搞出来的，比如社会上很常见的是高级干部退下来了，抱怨人心不古、感慨世态炎凉，如果好好去探究一下，原因很可能是他权位在手春风得意时不可一世、视他人如粪土造成的。八、对职业负责、对目标负责，对自己负责，成功者往往自觉自律、信守承诺、心无旁骛大企业肯定会有绩效考核、会有论功行赏、会有KPI、会有领导指示、甚至会有一点企业政治，但如果我们片面地追求考核成绩、片面追求KPI指标、片面追求权钱利益，片面地对上负责、对别人负责，而不对自己负责、不对自己的目标负责，失去工作的使命感、责任心、热情和好奇心，必将不能达到自己的最佳境界。而一个企业如何能够成功营造一个环境，让每个个体尽量发挥到最佳境界，企业也会战无不胜。九、多点人文修养和审美情趣，看起来与工作不怎么相关，其实太相关了杰出成就的取得离不开对美的境界的追求，最伟大的科学发现，往往蕴涵着秩序、简洁和美。缺乏一点审美的追求，什么UGLY的事情都敢做、不择手段、凡事凑合，一点都不“高雅”，必将不能长久。十、“大家好，才是真的好”，关注人，帮助人，真诚待人，厚道做人快速发展的现代社会，由于媒体的作用，过分渲染了人与人之间日益冷漠、诡诈的关系，但实际的社会、社区可能真的不是那么回事，起码我来华为之前，对一个大企业中工作的人事关系开始还有点未知的恐惧，但实际上在这个集体中的感觉几乎人人都能开放、真诚相待，关系融洽和谐。所以关键是我们自己要能够真诚对待他人，在与他人互动中将心比心。当然，工作中的冲突是不可避免的，实际上冲突也是没有必要去避免，甚至很多冲突对组织来讲，是大有益处的。就象夫妻吵一架后感情往往更好。只要我们掌握两大原则：1对事不对人。2与人为善。就肯定能把适度的冲突引导到对自己、对组织都有利的方向。十一、开放和分享的态度在一个高科技公司工作，如果报着保守和封闭的心态，成长肯定会受阻。十二、做好时间管理在华为工作十年，3650天，工作日3000天左右，这些时间是不是花在最重要的事情上了，有效的、有产出的工作时间究竟有多少，实在值得怀疑。时间管理是我在华为工作当中最大的教训之一，可能也是公司整体性的问题，工作缺乏计划，经常是面临不断的被打断;或者是不断去打断同事下属;或者是不断的会议、讨论，占去绝大部分的时间;或者是被自己的兴趣所牵引，花大量时间搞一些不着边际的事情;或者是花很多时间在一些细枝末节的事情上，把很难很重要的事情一直拖到非解决不可的地步然后被迫仓促行事。现在回想，如果真的能管理好这十年时间，我觉得成就应该大很多。为什么员工做事的热情没有像以前一样高涨？为什么员工做事没有像以前一样动力十足？为什么员工做事没有责任心？为什么员工做事不能自动自发？主要原因是老板不懂的设计利益驱动、诚信契约、优胜劣汰的机制！如何设计？", "life/反省零碎.md": "TOC教孩子智慧做法：试错+启发教育1.接受缺点，且短期内不会有改善2.允许犯错，犯错是机会3.分析问题，找出根源4.告别说教，有计划方案来纠错启发式教育当孩子犯错时，以“该怎么做呢？”引导式提问代替“为什么会这样？”式质问生活、学习中，不要直接给出答案，要启发式的提问来引导孩子思考潜移默化的身教长期的讲故事，来引导长期一起做某件事，比如：练字、下棋细节决定完美生活中各种细节：吃饭、写字等等。做好榜样，行动教育成为孩子的朋友，成为孩子的求助对象不要让孩子独自面对压力，更不能制造压力，如：你没考100分，收拾你。多赞美、多鼓励赞美和鼓励才能让孩子积极主动、积极动脑", "life/四个技巧（步骤）让你掌握谈话主动权.md": "每日拆书.10《说话的力量》简评：本书是我读的沟通领域的第一本中国人写的书。出乎意料的是，本书写得极其好。主要表现在层级架构非常合理，分为三个部分。同时，内容的逻辑性也很强，从基础到技巧，从理论到应用，从知识到练习，都恰如其分地平衡了。本书涵盖了日常生活与正式场合的沟通，两部分都有详细的解释。相比之前拆的书大都只注重一个方面，的确有一定优势。总而言之，如果你想从基础打起，清楚各个场景的沟通要素及对应办法，本书值得一读。内容：!_v_images/20191118222657.png本书分为三个部分，简述如下：第一部分将沟通分为了八个基本场景――讲述、叙述、表达、讨论、回报、陈述、解释、回应，并剖析了各个场景的基本组成和对应技巧或要素。这部分类似于基本功；第二部分讲解了沟通的四个技巧――垫子、迎合、制约以及主导，分别解释了各个技巧的目的和作用，并指出了各自的应用场景，使之可以迅速运用在沟通之中。这部分可以理解为进阶。第三部分则列举了两个练习说话的方法，扑克牌法和看图说话。通过这两种方式来提高自己的表达能力。这部分则相当于练习场。拆书整理思维导图时，重点放在了一二部分，对个别部分稍加整理。正文：本书讲述了四个说话技巧，可以让我们一步步主导话语权，最终达到目标。分列如下：一、垫子――创造一来一往舒适的谈话氛围垫子起到的是缓冲作用。在我们谈话的开始，基本都是从问答开始的，这时候为了避免陷入一问一答的紧张状态，则需要垫子来缓和气氛，建立起双方的初步信任，为进一步的沟通做好准备。垫子的类型主要分为三种：1、赞扬问问题的人，简单说就是夸他问题问得好。对方问了一个问题，如果仅仅是回答这一问题，无论是否符合对方预期，都会陷入尴尬――符合，没下文；不符合，关系僵化。而赞扬了对方，则一方面可以缓和情绪，另一方面留下了充足的空间和时间，使对方提供更多信息，这就为接下来的谈话做好了铺垫。2、说他的问题很普遍，具有代表性。这个垫子的功效是将问题普遍化，则对方的心理就会有所松懈，同时还觉得自己问得有水平。这也就缓和了紧张的氛围。3、回答之前，讲述自己的处境。这个垫子的核心在于示弱，可以赢得对方好感，并降低对方对答案的质疑。当然，示弱并不代表自己弱小，只有强大的人才会承认自己的弱小。放低姿态可以降低期许，这样当你做出好的回答时，则会使对方出乎意料。这样就将自己放在了一个优势地位。二、迎合――用共情创造共振的场迎合不是溜须拍马，而是通过表达对对方的理解，以获得对方的喜欢和认同。或者也可以将之称为，换位思考。在对方提出问题之后，首先迎合以降低他的心理戒备，同时使对方放下情绪，进入理性沟通。迎合的方式分为三种：1、给观点找事实就是说当对方表现出一种看法、观点时，恰如其分地提供相应的事实以表达赞同。很容易就会获得对方的信任。2、给事实找观点与上同理。3、补充细节在事实和观点都有的情况下，则可以补充细节，表达感同身受，创造出一种你们是同类的感觉。三、制约――赢得无与伦比的优势地位“制”可以理解为制度，也可以理解为控制。在沟通时，主动划定一个范围来约束，就是制约。可以迅速获得谈话的优势地位，为主导谈话做好准备。为了达到制约的目的，首先要做到的是准确预测谈话的走势。否则不按对方的预期走，反而会引起对方的戒备和不信任。制约主要可以分为三种方式：1、提前说出最差的可能性丑话说在前头，会降低对方预期。在你做好之后对方反而会非常满意。这一点与垫子中的“表述处境”有异曲同工之妙。2、给对方一个选择当你给出一个选择时，对方既能感受到你的尊重，又会忽略其他的选项。这时，你就全面掌握了谈话的进程了。3、表现得比对方更希望实现他的想法这是延伸并强化了对方的期待，于是对方接下来的要求就会有所缓和，情绪也会降低。这时就可以引导对方进入理性对话的阶段了。四、主导――把主动权牢牢掌握在手中在对话中，自然而然地控制主题和节奏，以及谈话的趋势和走向，会令沟通的效果增加数倍。主导对话的前提是明确自己的目的。只有牢记目的，才能时时注意自己的行为，以调整战术来控制节奏，最终实现目的。主导对话有三个技巧：1、凡事都有多种解决方式交谈时，考虑对方的出发点，然后将范围扩大。多种角度来回应对方的问题，就可以完全吸引对方，此时你就占据了主动。2、借助权威的力量人们对权威的迷信和盲从是极其普遍的（这一点我们在拆《影响力》一书时略有提及），所以搬出专家来证明自己的言论，无疑具有极高的说服力。3、超越现有话题，升华至更高层面我们针对同一事物进行讨论时，一方将话题提升至更高的层面，来表述自己的看法，对方的格局自然会相形见绌，此时主动权也就转移至你的身上了。以上四个技巧，同时也是四个步骤――垫子、迎合、制约、主导，全面地讲解了我们如何从开始的平等对话（或者处于弱势）到最终主导对话。当然，技巧也只是技巧，只有多加练习，才能真正提升你的谈话水平，助你熟练主导对话。PS:写了三十天，深觉读书至少，所以自今天始，专注于某个领域刷书。每天一本，持续21天，并做思维导图和读书笔记。为什么要说刷书呢？因为每天一本书无法做到认真研读，加之非严肃科学类的领域，市面上的书籍大都具有互补性，刷书比读书获取的信息量更大更快；PPS:第一次主题就定为“沟通交流”，提升自己沟通技巧，也权作初步练习；PPPS:明天拆《看入人里，看出人外》。1/30/16", "life/基金.md": "基金定投常识定投基金适合长期投资，所以，最好选择有后端收费的基金，一般有后端收费的基金，大部分都是要求持有五年以上，也有三年的，但较少。定投基金可以根据自己的资金情况，定投一到两支就可以了。另外，定投基金适合选择股票型、指数型基金，因为它们波动大，可有效摊低成本，其它类型的基金不是不可以定投，主要是因为它们的走势不如上面那两类型基金波动大，只有波动大，才可以摊低成本。定投基金，关键是要坚持长期，不要因为亏损了，就想停投了，也不要因为它赚钱了，就想赎回等。最好还是坚持到五年以上（如果你这几年可以继续坚持的情况下）。定投的几点小建议，也是我回答别的朋友的，你看一下。基金有两种收费方式：一是前端收费，默认的就是这种，就是在每月买入时就要按比例交手续费的，增加了定投的成本。如果在银行柜台买，手续费是1.5％，在网上银行买，手续费，是六－八折，在基金公司网站上买，手续费最低是四折。赎回时还有0.250.5％不等的赎回费。还有一种是后端收费，就是在每月买入时没有手续费，但持有时间要达到基金公司所规定的时间（3－10年不等）后再赎回，也没有手续费，长期下来可以省去一笔不少的手续费。所以，定投基金最好选择有后端收费的基金。不是所有的基金都有后端的。二是，把现金分红更改为红利再投资，这样如果基金公司分红，所是的现金会自动再买入该基金，买入的这部分基金也没有手续费。三是，如果你这个月没有钱定投或者大盘涨的很高，基金价格也很高，再或者你这个月的资金紧张，你也可以停投一到两个月，不影响以后定投，但不要连续停投三个月，如果是连续停投三个月，定投就会自动停止。四是，股市在牛市时，基金也涨的多，这时可以适当减少投资，若股市在熊市，可以适当增加投资，以增加基金份额。基金定投手续费有两种收费方式：一、是前端收费。默认的方式就是这种，就是在每月买入时就要按比例交纳基金定投手续费，增加了定投的成本。如果在银行柜台购买，则手续费一般为1.21.5%，而在网上银行购买的话，手续费是六八折，在基金公司网站上买，手续费最低可到四折。二、是后端收费（需该基金支持后端收费模式）。就是在每月买入时不收取基金定投手续费，在赎回时根据持有时间不同，收取不同费率申购费。为了鼓励长期投资，当后端收费模式下持有时间达到基金公司规定的时间（310年不等）后再赎回，这种情况也不收取手续费，长期下来可以省去一笔不少的基金定投手续费。此外，基金赎回时还有0.250.5%不等的赎回费用，赎回费一般由基金持有时间的增长而递减甚至可能为零。基金手续费如何计算基金涉及的费用主要包含认购费、申购费、赎回费、管理费、托管费和销售服务费。其中，认购费、申购费和赎回费是投资者进行相应交易时收取的。管理费、托管费和销售服务费则是从整个基金资产中按日进行计提的，基金公布的净值里已计提了管理费、托管费和销售服务费。每一只基金均会在其招募说明书、基金合同等文件中明确规定相应的认购费率、申购费率、赎回费率、管理费年费率、托管费年费率和销售服务费年费率。其中，销售服务费只有部分基金会收取，以每只基金的招募说明书等文件为准。一、认购费的计算认购费在发生认购交易时按笔收取。（一）基金场外认购一般采用“金额认购”的方式，认购费计算如下：净认购金额＝认购金额/（1＋认购费率）认购费用＝认购金额－净认购金额举例：某投资人投资30万元认购某基金，假设其对应的认购费率为1.20%，则其认购费用为：净认购金额＝300,000/（1+1.20%）＝296,442.69元认购费用＝300,000－296,442.69＝3,557.31元即投资人投资30万元认购该基金，其认购费为3,557.31元。（二）基金场内认购一般采用“份额认购”的方式，认购费计算如下：净认购金额＝挂牌价格×认购份额认购费用＝挂牌价格×认购份额×认购费率举例：某投资者投资通过场内认购50,000份某基金，假设对应的认购费率为1%，则其认购费用为：净认购金额＝1.00×50,000＝50,000元认购费用＝50,000×1%=500元即投资人认购5万份该基金，其认购费为500元。二、申购费的计算基金申购一般采用“金额申购”的方式，申购费计算如下：净申购金额=申购金额/（1+申购费率）申购费用=申购金额净申购金额举例：某投资者通过场外投资10,000元申购该基金，对应的申购费率为0.80%，则其申购费为：净申购金额=10,000/（1+0.80%）=9,920.63（元）申购费用=10,0009,920.63=79.37（元）三、赎回费的计算基金赎回一般采用“份额赎回”的方式，赎回价格以T日的基金份额净值为基准进行计算，赎回费计算如下：赎回总金额=赎回份额×T日基金份额净值赎回费用=赎回总金额×赎回费率举例：某投资者通过场外赎回某基金10,000份，假定赎回当日基金份额净值为1.110元，持有期限为25天，对应的赎回费率为0.10%，则其可得到的赎回费为：赎回总金额=10,000×1.110=11,100（元）赎回费用=11,100×0.10%=11.10（元）四、管理费的计算基金管理费由基金管理人收取，一般按前一日基金资产净值计提当日的管理费，管理费计算如下：H＝E×管理费年费率÷当年天数H为每日应计提的基金管理费E为前一日的基金资产净值基金管理费每日计算，逐日累计，定期支付。五、托管费的计算基金托管费由基金托管人收取，一般按前一日基金资产净值计提当日的托管费，托管费计算如下：H＝E×托管费年费率÷当年天数H为每日应计提的基金托管费E为前一日的基金资产净值基金托管费每日计算，逐日累计，定期支付。六、销售服务费的计算基金销售服务费用于支付销售机构佣金、基金的营销费用以及基金份额持有人服务费等。一般货币型基金、债券型基金的C类份额（不收取认/申购费）会收取一定销售服务费。基金销售服务费一般按前一日基金资产净值计提，销售服务费计算如下：H＝E×销售服务费年费率÷当年天数H为每日应计提的基金销售服务费E为前一日的基金资产净值基金销售服务费每日计算，逐日累计，定期支付。", "life/如何快速学习.md": "读一本书边读边记录关键字，关键字按层次分成几列温习:将关键字用线连起来，形成一张思维导图，留存学习一个专题1.写出题目2.假设用自己的语言来向别人解释这个问题，如果卡壳，转入下一步，继续学习3.查阅书籍，网络，提问等各种方式来学习这个专题4.第2，3步往复循环解释最好的办法是用思维导图经过思考的知识才是真正的知识向别人解释得清的知识才是真正掌握放下身段，脚踏实地确定自己的目标，制定计划，将计划分解成一个一个的小任务每天最多完成一件任务写日记反省技术必须去实践，多做helloworld走大家都走的大道，没人走的路坑多", "life/如何积累工作和生活的经验.md": "信息收集与处理信息收集与处理是一种能力信息处理的过程是能力提升的过程整理、归类、思考的信息才是自己的知识收集与处理的过程比文字结果重要学而习之书上的、老师讲的都不是自己的思考过、练习过的才是自己重复的练习才能发生量变到质变模仿、重复、熟练、效率、创新做出好菜需要天天炒菜基本功很重要做别人做不了的，别人做得了的，要别人快。什么是生产力？冬吴相对论速度才是成功关键，你只需要比他人快一点职业分析与规划分析自己的性格、兴趣分析行业情况确定自己的职业方向你能计划出自己的未来吗复杂的生活简单过，简单的事情重复做复杂的生活简单过工作清晰的工作目标和计划利用好工作时间下班充电教育儿子爱自由规则监督培养阅读与习惯夫妻关系分担家务赞赏表扬和谐性爱父母常问候父母节假日礼物主动赡养简单的事情重复做总结确定你的职业方向狂练基本功编写行业的分析报告在一个地方好好沉淀", "life/如何高效学习，强烈推荐，十分受用.md": "如何高效学习有效的学习方法胜过题海战术，高效的学习思维便可事半功倍。学生也好、职员也罢，无论从事哪个行业、做什么样的工作，都要秉承着“空杯”的心态学习更多的知识，死记硬背是最傻的方法，大家都不提倡。今天小编就带微友们感受一下《如何高效学习》的作者斯科特・扬（Scott・Young）分享的高效学习方法文章很长，十分受用，小编强烈推荐，请耐心看完【关于斯科特・扬】一年之内，完成了传说中的麻省理工学院（MIT）计算机科学课程表的全部33门课，从线性代数到计算理论。所有科目皆为自学，以此进度，完全掌握一门课程大概只需要1.5个星期【轻松驾驭课程】Scott・Young：我老想着学快一点，再快一点，并为此兴奋不已。掌握那些重要的学问吧，专业知识与娴熟技艺将是你的职业资本，帮你赚取金钱与享受生活。如果过得好是你的目标，学问能引你到向往之地。尽管学得更快有很多好处，但大多数人并不愿意学习“如何学习”。大概是因为我们不肯相信有这种好事，在我们看来，学习的速度只取决于好基因与天赋。确实总有些人身怀天赋本钱，但研究表明你的学习方法也很重要。更深层次的知识加工，与时而反复的温故知新，在某些情况下会加倍你的学习效率。是的，“刻意练习”方面的研究表明，没有正确的方法，学习将永远停滞。今天，我想分享一下学习策略，看看我如何在12个月内完成4年MIT计算机科学的课程。这套策略历经33门课的锤炼，试图弄清楚学得更快的窍门，哪些方法有用，哪些没用。为什么临时抱佛脚没用？很多学生可能嘲笑我，妄想只花1年的时间学会4年的课程。毕竟，我总可以临时抱佛脚，什么都不懂还能顺利通过考试，不是吗？很可惜，这个策略在MIT行不通。首先，MIT的考试苛求解决问题的技巧，还经常出些没见过的题型。其次，MIT的课程讲究循序渐进，就算你能死记硬背侥幸通过一次考试，同系列课程的第七课可能就跟不上了。除了死记硬背，我不得不另辟蹊径，加速理解过程。你能加速理解吗？“啊哈！”当我们终于想通了，都曾经这样恍然大悟地欢呼过。问题是，大多数人都没有系统地思考。经典的学生求学之路，就是听讲座，读书；如果还不懂，只好枯燥地做大量习题（题海）或重看笔记。没有系统的方法，想更快地理解似乎是天方夜谭。毕竟，顿悟的心理机制，还全然不知。更糟的是，理解本身，很难称得上是一种开关。它像洋葱的层层表皮，从最肤浅的领会到深层次的理解，逐层巩固对科学革命的认知。给这样的洋葱剥皮，则是常人知之甚少、易被忽略的理解过程。加速学习的第一步，就是揭秘这个过程。如何洞悉问题，加深你的理解，取决于两个因素：1.建立知识联系；2.自我调试排错。知识联系很重要，因为它们是了解一个想法的接入点。我曾纠结于傅里叶变换，直至我意识到它将压强转化为音高、或将辐射转化为颜色。这些见解，常在你懂的和你不懂的之间建立联系。调试排错也同样重要，因为你常常犯错，这些错误究根到底，还是知识残缺，胸无成竹。贫瘠的理解，恰似一个错漏百出的软件程序。如果你能高效地自我调试，必将大大提速学习进程。建立准确的知识联系与调试排错，就足够形成了深刻的问题见解。而机械化技能与死记硬背，通常也只在你对问题的本质有了肯定的直觉以后，才有所裨益。【钻研：你学得更快】经年累月，我完善了一个方法，可以加速逐层增进理解的过程。这个方法至今已被我用于各科目的课题，包括数学、生物学、物理学、经济学与工程学。只需些许修改，它对掌握实用技能也效果很好，比如编程、设计或语言。这个方法的基本结构是：知识面、练习、自省。我将解释每个阶段，让你了解如何尽可能有效率地执行它们，同时给出详细的例子，展示我是怎么应用在实际课程的。第一阶段：知识面覆盖如果你连一张地形图都没有，你不可能组织一场进攻。因此，深入研习的第一步，就是对你需要学习的内容有个大致印象。若在课堂上，这意味着你要看讲义或读课本；若是自学，你可能要多读几本同主题的书，相互考证。学生们常犯的一个错误，就是认为这个阶段是最重要的。从很多方面来讲，这个阶段却是效率最低的，因为你每单位时间的投入只换来了最少量的知识回报。我常常加速完成这个阶段，很有好处，这样，我就可以投入更多时间到后面两个阶段。如果你在看课程讲座的视频，最好是调到1.5x或2x倍速快进。这很容易做到，只要你下载好视频，然后使用播放器的“调速”功能。我用这法子两天内看完了一学期的课程视频。如果你在读一本书，我建议你不要花时间去高亮文本。这样只会让你的知识理解停留在低层次，而从长远来看，也使学习效率低下。更好的方法是，阅读时只偶尔做做笔记，或在读过每个主要章节后写一段落的总结。第二阶段：练习做练习题，能极大地促进你的知识理解。但是，如果你不小心，可能会落入两个效率陷阱：没有获得即时的反馈：研究表明，如果你想更好地学习，你需要即时的反馈。因此，做题时最好是答案在手，天下我有，每做完一题就对答案，自我审查。没有反馈或反馈迟来的练习，只会严重牵制学习效率；题海战术：正如有人以为学习是始于教室终于教室，一些学生也认为大多数的知识理解产自练习题。是的，你总能通过题海战术最终搭起知识框架，但过程缓慢、效率低下。练习题，应该能凸显你需要建立更好直觉的知识领域。一些技巧，比如我将会谈到的费曼技巧（theFeynmantechnique），对此则相当有效。对于非技术类学科，它更多的是要求你掌握概念而不是解决问题，所以，你常常只需要完成最少量的习题。对这些科目，你最好花更多的时间在第三阶段，形成学科的洞察力。第三阶段：自省知识面覆盖，与做练习题，是为了让你知道你还有什么不懂。这并不像听上去那么容易，毕竟知之为知之，不知为不知，难矣。你以为你都懂了，其实不是，所以老犯错；或者，你对某综合性学科心里没底，但又看不确切还有哪里不懂。“费曼技巧”将帮助你查漏补缺，在求知路上走得更远。当你能准确识别出你不懂的知识点时，这个技巧助你填补知识的缺口，尤其是那些最难以填补的巨大缺口。这个技巧还能两用。即使你真的理解了某个想法，它也能让你关联更多的想法，于是，你可以继续钻研，深化理解。【费曼技巧】这个技巧的灵感，源于诺贝尔物理奖获得者，理查德・费曼（RichardFeynman）。在他的自传里，他提到曾纠结于某篇艰深的研究论文。他的办法是，仔细审阅这篇论文的辅助材料（supportingmaterial），直到他掌握了相关的知识基础、足以理解其中的艰深想法为止。费曼技巧，亦同此理。对付一个知识枝节繁杂如发丝、富有内涵的想法，应该分而化之，切成小知识块，再逐个对付，你最终能填补所有的知识缺口，否则，这些缺口将阻挠你理解这个想法。费曼技巧很简单：1.拿张白纸；2.在白纸顶部写上你想理解的某想法或某过程；3.用你自己的话解释它，就像你在教给别人这个想法。最要紧的是，对一个想法分而化之，虽然可能重复解释某些已经弄懂的知识点。但你最终会到达一个临界点，无法再解释清楚。那里正是你需要填补的知识缺口。为了填补这个缺口，你可以查课本、问老师、或到互联网搜寻答案。通常来说，一旦你精准地定义了你的不解或误解，找到确切的答案则相对而言更轻松。我已经使用过这个费曼技巧有数百次，确信它能应付各种各样的学习情境。然而，由于学习情境各有特点，它需要灵活变通，似乎显得难以入门，所以，我将尝试举些不同的例子。对付你完全摸不着头脑的概念对此，我仍坚持使用费曼技巧，但翻开课本，找到解释这个概念的章节。我先浏览一遍作者的解释，然后仔细地摹仿它，并也试着用自己的思维详述和阐明它。如此一来，当你不能用自己的话写下任何解释时，“引导式”费曼技巧很有用处。对付各种过程你也能通过费曼技巧去了解一个你需要用到的过程。审视所有的步骤，不光解释每一步在干什么，还要清楚它是怎么执行的。我常这样理解数学的证明过程、化学的方程式、与生物学的糖酵解过程。对付各种公式公式，应该被理解，而不只是死记硬背。因此，当你看到一个公式，却无法理解它的运作机理时，试着用费曼技巧分而化之。对付需要记忆的内容费曼技巧，也可以帮你自查是否掌握非技术类学科那些博大精深的知识概念。对于某个主题，如果你能顺利应用费曼技巧，而无需参考原始材料（讲义、课本等），就证明你已经理解和记住它。【形成更深刻的直觉】结合做习题，费曼技巧能帮你剥开知识理解的浅层表皮。但它也能帮你钻研下去，走得更远，不只是浅层的理解，而是形成深刻的知识直觉。直观地理解一个想法，并非易事。它看似有些许神秘，但这不是它的本相。一个想法的多数直觉，可作以下归类：类比、可视化、简化>类比：你理解一个想法，是通过确认它与某个更易理解的想法之间的重要相似点；>可视化：抽象概念也常成为有用的直觉，只要我们能在脑海为它们构筑画面，即使这个画面只是一个更大更多样化想法的不完全表达；>简化：一位著名的科学家曾说过，如果你不能给你的祖母解释一样东西，说明你还没有完全理解它。简化是一门艺术，它加强了基础概念与复杂想法之间的思维联系。你可以用费曼技巧去激发这些直觉。对于某个想法，一旦你有了大致的理解，下一步就是深入分析，看能不能用以上三种直觉来阐释它。期间，就算是借用已有的意象喻义，也是情有可原的。例如，把复数放到二维空间里理解，很难称得上是新颖的，但它能让你很好地可视化这个概念，让概念在脑海中构图成型。DNA复制，被想象成拉开一条单向拉链，这也不是一个完美的类比，但只要你心里清楚其中的异同，它会变得有用。学得更快的策略在这篇文章里，我描述了学习的三个阶段：知识面、练习、与自省。但这可能让你误解，错以为它们总在不同的时期被各自执行，从不重叠或反复。实际上，随着不断地深入理解知识，你可能会周而复始地经历这些阶段。你刚开始读一个章节，只能有个大概的肤浅印象，但做过练习题和建立了直觉以后，你再回过来重新阅读，又会有更深刻的理解，即温故而知新。钻研吧，即便你不是学生这个过程不只是适用于学生，也同样有助于学习复杂技能或积累某话题的专业知识。学习像编程或设计的技能，大多数人遵循前两个阶段。他们阅读一本相关的基础书籍，然后在一个项目里历练。然而，你能运用费曼技巧更进一步，更好地锁定与清晰表述你的深刻见解。积累某话题的专业知识，亦同此理；唯一的差别是，你在建立知识面以前，需要搜集一些学习材料，包括相关的研究文章、书籍等。无论如何，只要你弄清楚了想掌握的知识领域，你就钻研下去，深入学习它。", "life/孩子教育.md": "英语杜老师8725282821:12:401）从此刻起：我要多鼓励、赞美孩子，而不是批评、指责、埋怨孩子。因为我知道只有鼓励和赞美才能带给孩子自信和力量，批评、指责、埋怨只是在发泄我的情绪，伤害孩子的心灵；2）从此刻起：我要用行动去影响孩子，而不是用言语去说教孩子。因为我知道孩子的行为不是被教导而成，而是被影响和模仿而成；3）从此刻起：我要多聆听孩子的心声，而不是急于评断孩子。因为我知道聆听才是最好的沟通；4）从此刻起：我要无条件的去爱孩子本来的样子，而不是去爱我要求的样子；因为我知道那是我的自私和自我；5）从此刻起：我要学会蹲下来与孩子平等沟通，而不是居高临下的指使孩子。因为我知道强制打压只会带来孩子更强烈的叛逆和反抗；6）从此刻起：我要用心去陪伴孩子，而不是心不在焉的敷衍孩子。因为我知道只有真正的陪伴才能让孩子感受到爱的温暖；7）从此刻起：我要控制自己的情绪，和孩子一起安静和平的处理好每一个当下。因为我知道脾气和暴力只代表我的无能和对孩子的伤害；8）从此刻起：我要积极主动的处理好与爱人的关系，创造一个和谐的家庭环境，绝不让夫妻矛盾影响和伤害到孩子，因为我知道只有夫妻关系和睦才是对孩子最大的爱；9）从此刻起：我要让孩子长成他要长成的样子，而不是我期待的样子。因为我知道孩子并不属于我，他只是经由我来到这个世界，去完成他自己的梦想和使命。10）从此刻起：我要多为孩子种善因，行善事。因为我知道种善因，方能结善果，积善之家必有余庆，积恶之家必有余秧；11）从此刻起：我要通过孩子的问题，找出我自己的问题，修正我自己，因为我知道孩子所有的问题都是我的问题，我是一切的根源；12）从此刻起：我要成为孩子生命中最好的朋友，最亲密的伙伴，最慈爱的爸爸（妈妈）。转自：搜狐教育======================================爸爸妈妈们请对孩子说：1.“孩子，不管发生什么，我都会和你在一起，我永远爱你!”安全感2.“你是独一无二的，走你的路，做你自己!”价值感3.“也许你是对的，我只是建议，决定权在你。”尊严与自我负责4.“相信你能处理好自己的事情，如果需要，我会和你一起面对，尽我的力量陪伴你。”自信与支持5.“你无论做得怎么样，表现如何，你是我亲爱的孩子，我依然爱你。”接纳与鼓励6.“我喜欢你这种行为，不喜欢你那种行为。这不表示我是对的，你是错的。但一切都必须自己体验并承担。”个人化与自我负责这个世界按照自己的方向流动，每粒种子按照原本的样子成长，每个孩子生来就是圆满具足，如其所是，带着对生命无比的信任和祝福，轻轻地对孩子说滋养心性的语言!转自网络", "life/小学中学考察.md": "小学毕业总结（五年级）从当初找小学到现在儿子上五年级，即将小学毕业了，面临小升初，对小学择校的总结：1、小学要找一个好点学校，太差。2、班主任一定要找一个严厉点、责任心强的。3、如果不考虑顶级的高中，对口摇号的小学还是不错；如果想上479等高中，摇号上的初中很难考上这些高中，所以还得要通过考试来选择初中，特别是私立初中。4、上顶级高中上顶级大学的比较靠谱途径：上初升高重点率很高的初中（中考分数能达到630以上，私立把握更大），中考进入479等名校，这些名校上顶级大学比例还是不错的。2012年幼升小小学考察sichuan.eol.cn/cdysx_11638/20120328/t20120328_759441.shtmlsc.sina.com.cn/edu/info/yey/20120329/095719862.html老五朵金花：泡桐树小学、龙江路小学、成都市实验小学、升平街小学、东城根小学。新五朵金花公办：高新实验小学、成华小学、草堂小学、石笋街小学、双林小学。新五朵金花民办：龙江路小学―南区、成外附小、成都师范银都小学、双流棠湖中学外语实验学校小学部、成都七中实验学校小学部。五朵小花。实验小学、泡桐树小学、成师附小、龙江路小学、盐道街小学可考虑的好小学：老五朵金花：泡桐树小学、东城根小学新五朵金花公办：草堂小学、石笋街小学次考虑：成都市实验小学、升平街小学（已搬迁到东三环）成都市实验小学西御河沿街、西二巷、九思巷、人民中路一段（后子门）东城根街小学招生范围：东城根下街、鹦哥巷、羊市巷、羊市街、横东城根街、老东城根街、青龙街、羊市北巷、东门街、槐树街、西马棚街、上半节巷、东二道街、西二道街、竹叶巷、焦家巷、西半节巷、过街楼街、横过街楼街、三道街、四道街、横四道街、红墙巷、西大街南侧、长顺下街、上同仁路、观音阁、西屠场街、石笋街（青羊区）石室联合中学、石室联中（蜀华）、树德实验联合中学、树德实验联合中学（东区）、青羊实验联合中学、十一中泡桐树小学泡小的街道有：商业街、多子巷、实业街（青羊区这边）和泡桐树街等。胜西小学方池街、蜀华街、冰岛路、横小南街、蜀都大道（少城路南侧、金河街南侧、通惠门南侧）、半节巷、祠堂街、小南街（包家巷以北）、包家巷、后包家巷石笋街小学招生范围：石笋街、南巷子、石灰街、西月城街、上饮马河街137号、江源巷、席草田街、观音阁后街、王家巷、西林巷、协和村、南熏巷、一环路北一段内侧（西门车站路口金沙路口单号1129号）、花牌坊街、花牌坊北街、乡农寺后街、乡农寺街（双号28以前含28号，单号27以前含27号）、回回坟、卧牛台、林巷子、新一巷、都司巷、永安巷、水井巷、丁家巷、坛神巷、马河湾、交通巷、一环路西三段内侧（108208西门车站至羊西路口）、金仙桥路、筒车巷、卧牛巷、马家花园路、永陵路（双号）三洞桥、观音阁前街、西屠场街、抚林巷、抚琴东北路、抚琴东巷、抚琴北巷、三道河巷。对口中学：十八中、二十中、通锦中学、金牛实验中学；树德实验中学（东区）泡小西区招生范围：三环路以东、瑞南街以西、瑞联路以南至清水河、清水河以北、东坡路（瑞南街以西段）、东坡北路一路、东坡北二路、东坡北三路、清影路、绿杨路、玉宇路、琼楼路、瑞南街西侧、瑞联路南侧招生计划：9个班对口小区：西子香荷、碧水湾、碧华邻xuexiao.51sxue.com/detail/id_8354.htmlcomment金沙小学三环路以东、青羊大道以西、磨底河以南、成温路以北、金泽璐、金沙遗址路、金阳路、金鹏街、金栖街、金欧路、金凤路、蜀源路、蜀金路、蜀辉路（部分）、金祥路、蜀凤路石人公园（白果林）西雅苑小学、中学都多，交通方便、2号线房价8500成都实验小学分校/四川师范大学计算机科学实验小学/白果林小学/成都十八中金琴路/石室联合中学西区/成都市石人中学/金牛实验中学外光华（苏坡）光华大道附近房子，价格便宜小学较多，中学有37中，树德中学；交通不方便楼盘有：兴城融域，元益花园，锦绣光华，培风小区（正读实小）富诗特成都实验小学西区分校、培风小学、苏坡地区小学、苏坡地区中心小学校府南新区可以去看看，交通方便，320到红光，801到天府新谷有几所小学，可能川大实外附小最好吧成都市实验小学战旗分校/川师大实外小学部/石室联合中学西区贝森：这附近的房子还算能买得起楼盘：二十一世纪花园，瑞通凯域成都市青羊实验中学附属小学/泡桐树小学西子香荷校区成都市青羊实验中学/bbs.eduu.com/thread150381211.html金牛区茶店子小学茶店子东街、健康巷、茶店子南街、茶店子北街、茶店子正街、茶店子横街、育苗路、茶店子北二巷、安居巷、茶店子北三巷、育才路、育苗路、育苗南路、育卉街、安蓉路、安蓉西路、蜀光路、育秀路、育仁路、育仁东路、育仁南路、育仁西路、育仁北路、金牛吧路（1、3、4号）、蜀汉路（289371号单号）、一品天下大街（1399号单号）、蜀兴西街185号、营康西路（469号（含）以上单号，468号（含）以上双号）二手房标准：1、总价80W以下，70W最佳；单价不高于8500，最好8000以下2、正读茶小3、房龄510年，免营业税4、最好离地铁口近5、最好套三6、公摊、物业费低", "life/小学生必读书.md": "新华字典小学生必读书目如下：www.fantizi5.com/bidu/xiaoxue/教育部推荐的小学生必读书目blog.sina.com.cn/s/blog_61042acd0100smu7.html老师推荐文章：把孩子培养成普通而幸福的人：www.houxue.com/news174561/父母应是孩子心目中的“第一求助人”：wzp.0831.blog.163.com/blog/static/43438492201310792432850/教育孩子的七个大于号：edu.sina.com.cn/zxx/20120218/1104327735.shtml母亲情绪的平和，是对孩子最伟大的教育：blog.sina.com.cn/s/blog_b00d15a30101jzuh.html坐在路边鼓掌的人：www.lz13.cn/lizhijiaoyu/6980.html老师推荐书籍：拯救男孩爱的教育有mp3窗边的小豆豆有mp3，pdf如何说孩子才会听，怎么听孩子才肯说有pdf好孩子是夸出来的太多版本少年儿童研究家教版没找到孩子你慢慢来有pdf，mobi===========================================================================“我爱书，我常常站在书架前，这时我觉得我面前展开了一个广阔的世界，一个浩瀚的海洋，一个苍茫的宇宙。”――刘白羽“书籍是青年人不可分离的生命伴侣和导师。”――高尔基读书是最不挑剔时间场合的，只要你手头有书。古人可于马上、枕上读书，还可负薪读书，挂角攻书，甚或囊萤映雪、凿壁偷光。如此说来，还有什么时候、什么地方不可读书呢？夏日读书，洒脱自在。更妙的是那种读而静、静而凉的难得境界。在夏日阳光灿烂的时光里，我们品一壶芬芳的玫瑰花茶，在几棵高大的梧桐树下，撑着阴凉，坐在石凳上上静静地看书，渐入佳境，读书读到妙处，早已不觉炎热，但觉清凉自心底涌起，心灵的土地上仿佛也铺满了一地阴凉儿。那份闲适随意，恬淡和轻松是何等的惬意。下面是学而思语文必读书目推荐，仅供参考~pao11~ps：这是针对不同年级的书目推荐，目的在于给家长和孩子一些指导，当然大家还可以一块补充。如果能够介绍一下书中相关情节和人物就最好了！~pao16~一年级必读书目序号名著作者出版社1《中国古代寓言故事》邶笪钟编写北京人民文学出版社2《中外神话传说》田新利选编北京人民文学出版社3《十万个为什么》卢嘉锡主编少年儿童出版社4《与鸟儿一起飞翔》郑作新著湖南少儿出版社5《海底两万里》法凡尔纳北京教育出版社6《汉字的故事》梅子涵著上海科普出版社7《安徒生童话选集》丹麦安徒生著叶君健译译林出版社二年级必读书目序号名著作者出版社1《克雷洛夫寓言全集》俄克雷洛夫著,裴家勤译译林出版社2《拉封丹寓言》法拉封丹著，倪海曙译上海译文出版社3《格林童话全集》（德雅各布.格林威廉.格林著译林出版社4《科学王国里的故事》王会等主编河北少年儿童出版社5《神奇的符号》苏步清著湖南少儿出版社6《诗词中的科学》唐鲁峰等江苏人民出版社7《中国古代科幻故事集》杨鹏、刘道远中国少年儿童出版社8《阿凡提的故事》赵世杰编译中国少年儿童出版社9《三毛流浪记》张乐平少年儿童出版社10《宝葫芦的秘密》张天翼农村读物出版社11《今年你七岁》刘健屏中国少年儿童出版社12《荒漠奇踪》严阵中国少年儿童出版社三年级必读书目序号名著作者出版社1《伊索寓言》希腊伊索中国妇女出版社2《宫泽贤治童话》（日）宫泽贤治著周龙梅少年儿童出版社3《列那狐的故事》法玛.阿希.季诺著北京教育出版社4《天方夜谭》郅涛浩等译译林出版社5《130个科学游戏》德汉斯.普雷斯著，吴衡康编译中国少儿出版社6《东周列国志故事》郭平、陈咏超改编江苏少年儿童出版社7《成语故事365》帆女阿雪等国际文化出版公司8《一百个中国孩子的梦》董宏猷21世纪出版社9《我们的母亲叫中国》苏叔阳中国少年儿童出版社10《小兵张嘎》徐光耀中国少年儿童出版社11《30天环游中国》郑平等中国少年儿童出版社12《三寄小读者》冰心少年儿童出版社13《皮皮鲁传》郑渊洁学苑出版社14《肚皮上的塞子》周锐春风文艺出版社15《乌丢丢的奇遇》金波江苏少年儿童出版社16《我要做个好孩子》黄蓓佳江苏少年儿童出版社17《灵性的王国》张香桐著湖南少儿出版社18《爱的教育》意亚米契斯著，马默译浙江少年儿童出版社四年级必读书目序号名著作者出版社1《稻草人》和其他童话叶圣陶中国少年儿童出版社2《中国当代儿童诗歌选》张继楼，彭斯远四川少年儿童出版社3《外国儿童诗选》文成英，李融编选四川少年儿童出版社4《科学家故事100个》叶永烈少年儿童出版社5《中外探险故事精选》伊明选编中国少年儿童出版社6《无尽的追问》王淦昌著湖南少儿出版社7《昆虫记》法法布尔著，言小山译人教社大百科全书8《我的野生动物朋友》法蒂皮.德格雷，黄天源译云南教育出版社9《中外战争的故事》张鸿海等中国少年儿童出版社10《做人与做事》卢勤接力出版社11《30天环游中国》郑平等中国少年儿童出版社12《草房子》曹文轩江苏少年儿童出版社9《第三军团》张之路中国少年儿童出版社10《巫师的沉船》班马21世纪出版社11《糊涂大头鬼》管家琪浙江少儿出版社12《木偶奇遇记》意卡洛.科洛迪著，杨建民译上海科技教育版社13《格列佛游记》英乔纳森.斯威夫特著，杨吴成译人教、译林版14《福尔摩斯探案全集》（英）柯南道尔，丁锦华译，远流公司1988年15《顽皮捣蛋鬼》（德）威廉.布什湖北少儿出版社16《七彩的分光》王大珩著湖南少儿出版社17《悠长的岁月》贾兰坡著湖南少儿出版社18《写给小读者》晓玲玎当新疆青少年出版社五年级必读书目序号名著作者出版社1《圣经神话故事》陈静选编中国少年儿童出版社2《严文井童话选》严文井四川少年儿童出版社3《普希金童话》俄普希金著，亢甫，正成译浙江少年儿童出版社4《王尔德童话》英王尔德著，唐讪辉译中国连环画出版社5《中外动物故事选》伊明选编中国少年儿童出版社6《中外经典科普故事》伍钚编中国少年儿童出版社7《中外网络故事》伍钚编中国少年儿童出版社8《科学改变人类生活的100个瞬间》路甬祥主编浙江少儿出版社9《水陆两栖人》苏阿历山大.别利亚耶夫，善诚译科学普及出版社10《中外艺术家的故事》江钥含编中国少年儿童出版社11《国际知识问答》中国少年儿童出版社编中国少年儿童出版社12《上下五千年》林汉达曹余章著上海少年儿童出版社13《马燕日记：一个感动世界的现代童话》（法）韩石华夏出版社14《中华经典诵读本》徐含之选编苏州大学出版社15《漂亮老师和坏小子》杨红樱作家出版社16《幻城》郭敬明春风文艺出版社17《鲁滨逊飘流记》英笛福著，王泉根译北京少年儿童出版社18《魔法师的帽子》芬杨松著，任溶溶译纺织工业出版社19《金银岛》英史蒂文生著，单蓓蕾译北京出版社20《吹牛大王奇游记》德埃.拉斯伯刘浩译少年儿童出版社21《淘气包艾米尔》瑞典阿.林格伦著，高锋红译中国少儿出版社22《童年》（俄）高尔基著上海译文出版社23《做一个快乐的少年人》邓碧霞译三联书店", "life/尹建莉：世上最没用的三种教育方法.md": "尹建莉：世上最没用的三种教育方法，就是讲道理、发脾气、刻意感动作为父母，如果我们留给孩子的只是一些消耗性的财富，是不可靠的；只有给孩子留下一些生产性的财富，才是真正对他们负责。――尹建莉小时候听过一个“手端银碗讨饭吃”的故事：有三位父亲经常到庙里为儿子祈福，天长日久感动了菩萨。有一天他们同时被菩萨请去，允许他们从众多的宝物中每人挑一样，回去送给儿子。第一位父亲挑了一只镶嵌着宝石的银碗，第二位父亲挑了一辆包满黄金的马车，第三位父亲挑了一付铁铸的弓箭。得了银碗的儿子每天热衷于吃喝，得了金马车的儿子喜欢在街市上招摇，得了弓箭的儿子整天在山间狩猎。多年后，三位父亲去世，爱吃喝的儿子坐吃山空，把碗上的宝石抠下来变卖，最后不得不手端银碗讨饭吃；爱招摇的儿子每天从金马车上剥点金子，换回粮食辛苦度日；会打猎的儿子练就了一身狩猎好功夫，经常扛着猎物回来，一家人有吃有穿。这个民间故事有着深刻寓意：`作为父母，如果我们留给孩子的只是一些消耗性的财富，是不可靠的；只有给孩子留下一些生产性的财富，才是真正对他们负责。`那么到了今天，什么是我们能送给孩子、可保障他们一生幸福健康的礼物呢？第一件礼物是阅读`阅读可塑造孩子的智力、品质`JJ我相信，虽然家长对孩子的具体期望各不相同，但共同的地方也很多，那就是孩子一生健康、幸福――这种大目标，通过“教育”所能实现的就是：`第一给孩子良好的智力，第二给孩子良好的心理品质。`JJ人在智力方面可能有一些先天差异，但塑造智力的空间也很大。发展智力最重要的手段就是阅读，这一点已被现代心理学研究证实。一个人的智力水平与其阅读量呈正比：阅读可拓宽见识，让人获得超越日常生活的知识。前苏联教育家苏霍姆林斯基说：“一个不阅读的孩子，就是一个学习上潜在的差生。”这是他多年在教学一线研究和观察后得出的重要结论。JJ`阅读不但可以塑造一个孩子的智力，还可以塑造孩子的品质。`任何一部书，只要是一本好书，往往都充满真善美的情怀，其核心价值观也是正面的。这些东西会对孩子形成潜移默化的影响。一个从阅读中经历了丰富的生活，倾听了众多的智慧，分享了无数思考成果的孩子，其思想会更成熟，人生境界会更美好。JJ很多道德和意识问题，从根本上讲，都可以说是智力问题：有智力才有思考和反思的能力。由此也可以得出阅读的第三层功效――修复心理创伤。一般来说，人们多少都带有某种童年时代的心理创伤，只是轻重程度不一样。父母和老师都可能会在无意中伤害我们，生活和命运也可能对我们不公。有的人能战胜这些伤害，有的人则在阴影中伤痛一生。`一个从小建立了阅读兴趣的人，会有更好的自我治疗的能力。`这一点，也是基于前面提及的阅读带来的智力和心理两方面良好的基础。JJ当然，阅读的功能不可能强大到解决所有的教育问题。拆一座房子可能只需一把镐头，而盖一座房子则需要动用许多工具和手段。教育孩子也一样，阅读虽然非常重要，但还需要其它要素来配合。第二件礼物是自由`给孩子选择权、尝试权与犯错误权`JJ每当我谈到给儿童自由的时候，总会遭遇质疑。质疑者一般都把自由理解为“放任自流”或“无法无天”。它显示了我们对自由的理解尚处于一个幼稚的阶段。JJ`给孩子自由，不是对孩子放任不管，而是意味着你需要给孩子“三权”：选择权、尝试权、犯错误权。`怕孩子犯错误，凡事都要孩子按自己的想法来做，孩子一旦失败就大加指责，这样的家长，就是强权家长，他们对孩子“关心和付出”越多，对其自由意志的剥夺就越多。JJ自由和尊重是一个硬币的两面，全社会都在谈“尊重孩子”，却在“自由”的观念上出现盲区，尊重也就变成了空话。哲学家弗洛姆说：“如果没有尊重，爱就很容易堕落为统治和占有。”一个被管制太多的孩子，他失去了探索和认识世界的机会，也就失去了自我认识和调整的信心。JJ`一个人，首先是个自由的人，才可能成为一个自觉的人。`自由的同义词不是放纵，而是选择力和判断力。那些真正幸福快乐的孩子，是那些真正获得了自由的孩子，他们更清楚行为的界限在什么地方。而一个无法无天的孩子，其行为只是放纵，而非自由。放纵是压抑的后果，是选择功能的失效。这样的孩子内心软弱无力，因为他丧失了对自己的掌控力。JJ能否给孩子自由，是成人能否有分寸地表达关爱、有质量地去教育孩子的一块试金石。成人只有首先解放自己的心态，理解了自由意志在教育中具有何等价值，才能把“自由”这个无价之宝送给孩子。第三件礼物是身教`家长的行动比语言更有说服力`JJ我常收到家长来信，说自己的孩子跟小朋友玩时，老打别人，讲道理没用，揍一顿也没用。还有人问，如何才能改掉孩子的坏脾气？其实，这些家长只看到孩子的不是，却看不到自己给了孩子一个生气就打人、爱发脾气的坏榜样。而家长用行动告诉孩子的，远比言语告诉得多。JJ思想家卢梭说过，世上最没用的三种教育方法就是：讲道理、发脾气、刻意感动。`这三种方法恰恰是当下许多家长和教师最热衷运用的。`古人说得多好，“言传不如身教”，这六个字无人不晓，但有多少人会以此为镜，真正践行身教？JJ`活在虚荣中的家长不可能教给孩子踏实，刻薄的教师也不可能教会孩子宽容。`为孩子做出表率，不仅是你在外人面前是什么样子，更重要的是你和孩子相处时是什么面貌――这是最直接有效的教材，你教给孩子的，全写在这里面了。JJ父母和孩子，是生命中最亲密的一种关系。现在大家已基本形成共识：给孩子好的教育就等于给孩子最可靠的财富。但到底给孩子的“教育”是什么，家长之间差别巨大。这个差别，主要不是理念、身份、地位或文化程度的差别，而是教育手段的差别。这些会决定你给孩子的到底是银碗、金马车还是良弓。JJ无论都市或乡村，贫穷或富有，高官或平民，你都可以把最好的教育送给孩子――培养孩子的阅读兴趣、给孩子自由成长的空间、亲自做出良好的表率――这是每位父母都有能力送给孩子的财富，也是孩子生命中得到的最美馈赠。", "life/工作生活处事之道.md": "1.目标清晰短期目标不能超过2个前一晚准备好任务清单，列出两三个重要任务即可2.专注与坚持清除掉与短期目标不相干的任何事情，只专注一两件事孤独寂寞使你成长3.充分利用好8小时先工作后学习从工作中学习，扩展自己分享是一种动力调整工作与休息，实现效果最大化（久坐不好，适当地站起身，走一走）4.使用Notebook记录点点滴滴接触东西多，匆匆而过，不记录，就遗忘将好的想法和感悟记录下来要整理和总结5.解决工作碰到的每一个问题最好的学习方式深度、广度的取舍6.自省读书、读人、读事每天抽1一个小时静下来想事情，反省7.注重细节一、优雅、从容、不慌张。二、不争胜>高处俯视。1）可挑起话题，但不不可认为“老子的看法最权威、最正确”，不可否定其他看法。2）对待不同的看法：1求同存异，谈论相同的部分；2开放式提问式来引导对方（动脑）；3沉默；3）不莽撞的发表看法，通过谈话来观察别人的个性。4）多听多采纳：5）善断：该自己拿主意时，少犹豫或协商。6）补救而非责难：对待别人犯错，不是抱怨或责难，而是想一个男人样的去补救。7）不吝惜表扬。三、多接触人，总结相处之道。四、谦虚，发自内心的。五、抬头走、看目标而不是问题。六、藏住话与情绪。1）教育好于批评。对卓卓，看到玩具乱放，不要脱口就批评，应该事后，冷静下来，想出更好的方式来教育。2）容忍好于批评。对于老婆/老妈，一些生活习惯无法改了，应该多多包容，事后补救也能改善自己的心情。七、关于教育1）身教好于言传。2）诲人不倦。教育人要有耐性，且和颜悦色。1、如果你不喜欢现在的工作，要么辞职不干，要么就闭嘴不言。初出茅庐，往往眼高手低，心高气傲，大事做不了，小事不愿做。不要养成挑三拣四的习惯。不要雨天烦打伞，不带伞又怕淋雨，处处表现出不满的情绪。记住，不做则已，要做就要做好。2、每一个人都有孤独的时候。要学会忍受孤独，这样才会成熟起来。到了一个陌生的环境，面对形形色色的人和事，一下子不知所措起来，有时连一个可以倾心说话的地方也没有。这时，千万别浮躁，学会静心，学会忍受孤独。在孤独中思考，在思考中成熟，在成熟中升华。不要因为寂寞而乱了方寸，而去做无聊无益的事情，白白浪费了宝贵的时间。3、不要像玻璃那样脆弱。有的人眼睛总盯着自己，所以长不高看不远；总喜欢怨天尤人，也是别人无比厌烦。没有苦中苦，哪来甜中甜？不要像玻璃那样脆弱，而应像水晶一样透明，太阳一样辉煌，腊梅一样坚强。既然睁开眼睛享受风的清凉，就不要埋怨风中细小的沙粒。4、关注自己的嘴巴。不要谈论自己，更不要议论别人。谈论自己往往会自大虚伪，在名不副实中失去自己。议论别人往往陷入鸡毛蒜皮的事费口舌中纠缠不清。每天下班以后和你的那些同事朋友喝酒聊天可不是一件好事，因为，这中间往往把议论同事、朋友当做话题。背后议论人总是不好的，尤其是议论别人的短处，这些会降低你的人格。5、机会从不会”失掉“。你失掉了，自有别人会得到。不要凡事在天，守株待兔，更不要寄希望于”机会“。机会只不过是相对于充分准备而又善于创造机会的人而言的。也许，你正为失去一个机会而懊悔、埋怨的时候。机会正被你对面那个同样的”倒霉鬼“给抓住了。没有机会，就要创造机会，有了机会，就要巧妙地抓住。6、若电话老是不响，你该打出去。很多时候，电话会给你带来意想不到的收获，他不是花瓶，仅仅成为一种摆设。交了新朋友，别忘老朋友，朋友多了路好走。交际的一大诀窍就是主动。好的人缘好的口碑，往往助你事业更上一个台阶。8、写出你一生要做的事情，把单子放在皮夹里，经常拿出来看。人生要有目标，要有计划，要有提醒，要有紧迫感。一个又一个小目标串起来，就成了你一生的大目标。生活富足了，环境改善了，不要忘了皮夹里哪张看似薄薄的单子。十做第一要迈好关键第一步（Milestonezero）第二百分之百集中在你的目标（Stay100%focusedonyourGOALS）第三成为一个公认的专家（BeaGOTOperson）第四面对现实（Getreal）第五保持自信Confident第六有的放矢（Choosetherightbattletofight）第七保持心情愉快（Behappy）第八使别人更成功（Makeothersmoresuccessful）第九使自己的工作让人家知道Makeyourworkvisible第十磨快锯子（Sharpenthesaw十不做第一不要发牢骚Donotwhining第二不要怕说“不”（Donotafraidofsaying67NO?）第三不要怕失败（Don’tworryaboutfailures）第四不要忘记说“谢谢”（Donotforgetsay“thankyou”）第五不要和别人攀比（Donotcomparetoothers）第六不要自己单独吃饭（“NeverEatAlone”）第七不要只报告问题不提解决办法（Donotonlyreportaproblemwithoutsolutions）第八不要忘记“计划每一天”Donotforget“planyourday”第九不要太“安静”（Donotbetooquiet）第十不要负面思维（Nonegativethinking）八项原则:*设定目标,不忘目标*要事第一,抛开琐碎*保持斗志,谨防懒惰*勤于思考,勇于行动*精益求精,慎终如始*放低姿态,汇纳百川*与人帮助,吃亏是福*友胜己者,分享双赢一些其它为人处事的准则:*冒险是成功的捷径*说不如听,后发先至*不言之教,无为之事*图难于易,为大于细*自伐无功,自矜不长*不患无位,患所以立*不舍不得,多惑少得*凡事预则立,不预则利万物而不争，处众人之所恶居善地，心善渊，与善仁，言善信，正善治，动善时慢说思考式倾听换位思考：积极的沉默重复的力量", "life/怎样锻炼孩子的毅力和永不放弃的精神.md": "在培养孩子的恒心和毅力的具体操作方面，除了自己带头以身作则之外，还要特别注意以下几点：一、从小培养孩子从头至尾完成一件事情的能力和习惯。在学习或生活中的任何一件该做的事情，我们都严格要求孩子有始有终地按预定计划完成，绝不允许半途而废。这种能力必须从小培养，长大之后，拖延成了习惯，就难以更改了。完成能力和习惯是一项很重要的品质。现实生活中有很多缺乏恒心和毅力的人，做事往往半途而废。因为从小没有严格要求，做任何事情一遇到困难就没有坚持下来的习惯，达到很小的高度就心满意足。这是读书成才的大忌，这种人永远达不到高的档次。二、培养责任感。做什么事情都必须让孩子负责任。不用负责任的事情，不可能有恒心和毅力去完成它。因为反正没有责任，对他来说就不存在紧迫感。现在很多家长都对孩子这么说：“书读得好不好是你自己的事，与我们无关，读得不好你自己没前途，将来吃苦头。”其实这种说法很不好，是把孩子的心给推远了。我们必须让孩子明白，书读得好，不仅是对自己负责，也是对父母负责，更是对社会对国家负责。这是从小培养孩子做人的责任感。在责任感的驱使下，孩子才会有恒心和毅力去完成他的学业，才会在漫长的成才路上坚持到底。三、有了伟大的目标，你就会把艰苦的劳动视若等闲。伟大而明确的目的性是产生恒心和毅力的根本基础。如果读书的目的性尚不明确，何来恒心和毅力去忍受二十多年的寒窗之苦？因此，必须把整个人生过程的影像放大放清楚，让孩子知道读书在其中处在怎样的位置上，使他懂得读书对人生是何等的重要，特别是当今的高科技社会，如果没有把书读好，将来就没有你的位置。四、在引导孩子读书成才的过程中，千万不能让孩子有被迫的感觉，要处处培养孩子的主动性。任何被迫的感觉都会使孩子产生逆反心理，造成一种可怕的恶性循环。在逆反心理驱使下，非但没有恒心和毅力可言，就连眼前的积极性会也受到抑制。在商量任何事情时，特别是学习方面的事情，都要尽量引导孩子自己得出结论，然后让孩子自己主动去做。五、欲获得强大的毅力，要多与有毅力的人接近。尽量避开那些意志消沉的人。遇事不要和态度消极的人商量。这些人总是提出许多负面的理由，促使你后退，甚至提出“高明”的见解来否定你的追求，使你变得动摇起来，最后化解了你的恒心和毅力。若遇到困难曲折，你就可能被拖下水。六、让孩子长期坚持某项体育活动或洗冷水澡，最好自己带头，一年四季春夏秋冬从不间断，每天按时进行，不得以任何借口改变。这不仅可以锻炼身体，而且能够磨炼意志、培养毅力。七、立志和自信是恒心和毅力的前提，胸无大志或缺乏自信的人不可能有强大的恒心和毅力。这些非智力素质是相互牵连、相辅相成的，必须同时予以关注。美国《成功学》的创始人希尔・拿破仑说：“自然经常是先给某些人重重的一击，让他们倒伏在地，看谁能爬起来再投入人生的战场，那些毅力强大的勇敢者，就被选择为命运的主人。”", "life/有感《冬吴相对论》.md": "TOC冬吴提到的书稻盛和夫《活法》《秘密》梭罗《瓦尔登湖》杜鲁克《》科维《七个习惯》盖乐普《发现你的优势》点错成金!_v_images/20191118213334.png", "life/游戏改变世界.md": "!_v_images/20191118221753.png本书的两个感悟点游戏的四大特征目标、规则、反馈系统、自愿参与这让我想到，怎样提供工作和学习的效果，并且自愿参与，不觉厌烦。我为了儿子制作了周任务卡，没有设定主任务（相当于老王或boss），设定每天可能任务（一般任务），供孩子选择，每完成一项任务，按照规则加分，获得荣誉加分（游戏中的奖励），各种犯规要扣分（被小怪给打了）。!_v_images/20191118221811.png在工作中，制定目标一定要可度量，所以类似燃尽图很重要，可以看任务进展，实时反馈。游戏与社交微信仅只是聊天，就能汇集那么多人。游戏的诱惑比聊天大得多，可以想象用游戏把你的亲朋好友联系在一起。你可以远方的父母一起玩麻将、斗地主，你们可以比积分，是多么美妙。但是目前还没有这样的游戏。", "life/理论与实践.md": "TOC理论VS实践脱离实践的理论，一般是实践用处不大的理论，学习它也是浪费生命，不学也罢。<u>学会一种理论，必须仔细分析它的应用场景。当讲到某一种理论的时候，“*例如*”这个关键词必须紧随其后。</u>例如：计算机算法理论对一个做UI设计的人用处不大。一个人如果能将少数的几条理论用于实践，那么他/她就应该有所成就。而现实情况是，大多数人被灌输太多的理论，而很少用于实践，理论根本没有起到指导实践的作用。知道的理论越多，越不去细细咀嚼，越见怪不怪，鸡汤吃多了也腻啊。归纳总结VS演绎推理归纳总结就是从若干零散的现象中总结一个一般性规律，是从特殊到一般。演绎推理一般性规律应用到现实中去，去推测其它没被考察过的同类现象的性质特点。先有归纳推理再有演绎推理。知行合一知和行有几种现象：1.不知理论，但是知道怎么做事处事2.由知到行。知道了一个道理，反复咀嚼，应用到实际的做事为人上3.知行交融。理论能应用于实践，由实践能推理出更新的理论，知行循环往复。这个是一个较高境界。对平凡的大众来说，学习再多也是为了改进自己、改进社会，最后的落脚点是更好的做事为人，那么行为实践比理论更重要。我们不一定要知道太多的理论，但是我们知道怎样正确做事做人。更进一步，应该做到朝闻道，夕改进。如果自己的经验和智慧能惠及后人，则要做到知行交融。以上三种现象和“<fontcolor=red>**立功立德立言**</font>”有一定的对应关系，首先要立功，就事论事的做好身边的每一件事；其次立德，让自己行为符合于道与德，成为一个榜样，影响他人；再次立言，知行交融，让自己经验和智慧得以流传，惠及他人。", "life/知乎9.6万高赞回答：如何长时间高效学习？.md": "知乎9.6万高赞回答：如何长时间高效学习？功能介绍猎聘网订阅号为您提供有趣、有用、有品的职场内容，推荐高薪职位，炫酷雇主等招聘信息，订阅职位后即可一键投递简历。点击上方蓝字关注猎聘网有趣有用有品的职场内容1时间如果你想要在某个知识领域成为thebestofthebest，你必须要花至少10000小时实实在在的练习和学习。然而，JoshKaufman却推翻了这些观念，提出了你只需要20小时就能不错的掌握一个全新的知识和技能。如果我们能在最初的20小时内熬过初学阶段的不适感和挫败感，我们其实能很轻松地掌握一个全新的领域。哈！20个小时＝2个沉睡的夜晚＝1周娱乐时间的总合，听起来的确很不错。`嗯，我的意思是用20小时学习一门大学教材。`2案例`高效利用时间的案例：学更多更多的知识，做更多更多的事情。简直是知识、精神双饱满！！斯考特・杨（ScottYoung）12个月之内，自学完成了传说中的MIT计算机科学课程表的全部33门课，从线性代数到计算理论。`按照他的进度，读完一门课程大概只需要1.5个星期。这是我见过的大学生里在学习方面活得最充实的人。关于他的学习方法，warfalcon评价如是：>1、`每天学习10小时，10天左右就要考试一次，并通过，这个学习效率非常高，更不用说重复了33次`。在学习一门新的知识时短时间集中注意力不难，但持续一段时间之后，如果做不到很好的放松，只要持续二、三个月左右就会达到一个瓶颈，理解能力和心理状态无法继续，这个瓶颈会重复出现，就象考研时很多人前几个月都能坚持下去，但到6、8月之后就无法坚持。重复三次左右会面临一个临界点，度过这后就很容易继续了。>2、`刻意练习没有“寓教于乐”这个概念。曾经有个著名小提琴家说过，如果你是练习手指，你可以练一整天；可是如果你是练习脑子，你每天能练两个小时就不错了`。高手的练习每次最多1到1.5小时，每天最多4到5小时。没人受得了更多。一般女球迷可能认为贝克汉姆那样的球星很可爱，她们可能不知道的是很少有球员能完成贝克汉姆的训练强度，因为太苦了。3可实施性“在学习一门新的知识时，短时间集中注意力不难”+“（刻意练习）高手的练习每次最多1到1.5小时，每天最多4到5小时。没人受得了更多”――结合我们20小时学一门教材的目标，可以得出一个结论：`“我们进行的不是严格意义刻意练习，我们的强度也没有那个国外小子那么高，而且一轮下来只要20小时，即便是用刻意练习的方式进行，也是可以接受的。”`学完一科，我们可以进行休整放松，不用严打紧逼。而且就我个人而言，一天高效学习时间安排在八个小时左右，是可以执行的。但是，要保证利用好八个小时的高效时间。4如何保证高效利用好时间`学习仪式感：人，藉由这种仪式带来的仪式感，来给自己一种强烈的自我暗示这种自我暗示能够使自我变革，把自己的专注力、反应能力、运动能力迅速提升。`为了保证高效时段得到利用，我把每一次学习当成月考甚至高考一样的对待。为了高考你会提前准备什么？物质准备：吃饱穿暖精神准备：考前睡眠充足知识储备：复习再复习在高考之前，脑海里，我们已经把在考场上的表现重复了多遍。再来看看，我是怎么为一次高效学习进行仪式感建立的：>物质：水、巧克力、计算器、文具。在正式学习之前，我会在桌上一字排开，以防临时需要某些东西时手忙脚乱去到处翻。>精神：在前一天晚上，我就想好第二天又要进行高效学习了，所以我会安心睡去，而且如果你已经在前一天高效学好的话，会在一种满足感和新的期待中睡去。>时间：比如，八点是我的正式学习时间，我会保证八点之前提前赶到那里，坐在椅子上调整出最舒服的学习姿态。提前半个小时到达学习现场，我会做以下工作来建立仪式感：仪式第一步：启动1.把准备好的物品摆在桌上。2.深呼吸一口气，然后做眼保健操。3.闭着眼按摩太阳穴一个八拍。注：眼保健操的第三个八拍和第四个八拍互换，多年的眼保健操经验告诉我，原本第四个八拍（轮刮眼眶）做完之后，眼睛睁开是会一片模糊感，眼液汪汪，十分不舒服。（ps.重新排版此文的时候我才发现，对于眼保健操我也是蛮有见解的嘛！！！哈哈哈仪式第二步：预热翻看即将在要来到的两个小时之内需要学习的内容，心里有个大概。我会多浏览几遍某些重要的概念以及例题，但是我不会把这个活动当做是我的正式学习的过程。就好像你考试之前翻书，多看几遍重难点考点只是为了考试更好的发挥，而不能把这个过程计入考试本身一样。我现在做的活动，只是为了等一下正式学习更好的强化效果。仪式最后一步：静心在八点之前的一分钟，我会盖上书本。静静等着一分钟的流逝，八点钟一到，就带着喜悦感平静地翻开书本。因为有了那么多前戏的酝酿，你都不知道我多么的期待这么一次高效的学习的来临啊。`大学学习的方法千差万别，比如，有人有能耐能泡老师透到题，或者被老师泡也能泡到题，这种做法我认为是最高效的，有了考试题目就只需要锁定知识点夺取高分。`这种做法我十分欣赏，但只有一点我不喜欢，那就是逃避了学习过程，没错，我也要考高分，但我只想踏踏实实的通过正常的学习完成这个过程。不过，我的踏踏实实要是和很多人一样一章一节的看下去，那就是侮辱我自己了，因为那样我会看不到最后，就止不住困倒在书上了。我个人的方法就是对这个踏实过程的一次优化，让自己在持续反馈之中达成纯20小时高效学习一门学科的目的。5正式高效率学习1.1第A步第一遍阅读>1、看目录：知道这一章重点在哪一节，这一节大概用来解决什么问题；>2、看章后习题，圈出术语：这个术语基本上就是本章的知识点了；>3、根据术语去书中划概念和术语解释：如果有些术语不能理解，请使用网络搜索术语名词解释；>4、术语理解后带着术语去理解书中的图表和例题以及案例。为什么不首先直接去阅读文字呢？`对此，我还当真有些个人的强烈认知:理工科的书在我看来是不能谈「理解」这个词的，尤其是工科的书，我认为就是一份份的说明书`，讲机械那就是机械的说明书，讲制图那就是制图的说明书，这些说明书和商品说明书没有本质区别，只是它们通过系统化的学术语言衔接成书、成册――但本质上一本说明书的集合。洗衣机说明书有什么作用？那就是告诉购买者如何操作、如何保养、注意事项。平时我们会嘲笑某些人看不懂说明书，其实不是对方理解力有问题，而是我们市面上多少说明书简直垃圾，写的不够明确、简洁，导致阅读者操作困难。同样，我也认为我们的教科书并不都是一本本优秀的说明书合集，因为它们的书写内容是由个人写就，说明的操作细节根据他个人的智识水平书写，他并不曾统计所写的每一句话是不是让读者看起来更加容易形象的理解。`我是说，不好的说明书才需要额外的理解，好的说明书只需要我们按着步骤流程一步一步操作就可以达到目的，只有书写不明的说明书才考验读者额外的理解能力。`从某个意义上来说，你学习某一本书，如果看不进去，可能不是你理解有问题，你应该换一本书。我们什么时候讲理解能力？中文阅读理解，英文阅读理解，文学作品，“我爱你，你懂我心吗？”，那是中文，英文。感性表达的时候需要你的理解，文人思维表达的时候需要你的理解，读哈姆雷特的时候需要你的理解，需要一千个读者有一千个哈姆雷特的理解。讲机械机构的时候如果你说不理解，那多半是书本表达的问题，不是你理解力有问题。可以长高宽表达的东西，你说你理解它干嘛？难道某个机械结构脉脉含情的给你传达某种信号，需要你理解她的弦外之音！？以上是对教科书的微词。我意思是这样的，大学本科教材有可能的话去换几本看看，可能有比较容易“理解”的书呢？中国大学教材烂，这也是为什么国外大学教材受欢迎的原因。但是，对于多数人而言，外文教材好啊好啊，其实都是喊在嘴巴上，看我这篇文章你都嫌长，你绕个远道去看外文教材？网上的公开课也比中国教授讲的好呀，推荐者万万众，实践者几几人！更何况，多数人外文的书是看不懂的，那么，就踏踏实实的看你们学校的教材，照样可以学好，此时才显得我的这个建议之有含量。（在重新排版的时候，我请额外圈出一句话：推荐者万万众，实践者几几人！――这句话太好了，且做我的名言2号。）这个建议是这样：`看书看不进，就牢牢抓住书本的例题、案例、图表。因为例题讲具体情境、图表具有可视化、案例就是讲具体的运用――这些都比理解文字描述容易的多。`而且，例题里面包含了对关键知识点的运用，案例和图表其实都是为了辅助你理解正文文字内容的。`所以，只要我们配合最少量的文字看懂了案例、图表，就达到了对知识的了解，接着我们再去看例题就知道了知识运用场景，之后，我们再反复地做题目，从而达到了对知识点的掌握。`这里还给你明确指明了什么叫了解、知道、掌握，课本往往会有学习要求，比如本节达到“掌握”的程度，而第二节只要“了解”就够了。那什么是“了解”、“知道”、“掌握”呢？光看这几个词汇，你是不是感觉在学习过程中，还是难以把握好“理解”等词汇的度？从刚刚前段的描述中，其实已经给你活生生明确了呀：>1、“配合最少量的文字看懂了案例、图表，就达到了对知识的了解”。>2、“接着我们再去看例题就知道了知识运用的场景”。当然，这里的知道是对于“知识运用场景”的知道，如果是“知道某种知识”，那我给的定义是:当我提起某专有术语名词、某理论的时候，你能想得起来有那么一回事。>比如我说到隔壁小王出轨了，你说“哦，那个小王八啊，我知道”那你就真的知道了，也许对于这种男女之事，你知道的还要更多，可能已经达到了解的程度。在这个男女例子的场景中，你表现的是一个好学生的角色――主动掌握的东西不由自主地就比“课标要求”的多得多。>3、“我们再反复地做题目，从而达到了对知识点的掌握”。>4、如果我们用所学知识去解释问题、或者直接体现在实际操作中，那就是运用了。以上就是我们需要尽量弱化教材文字阅读的原因。学习请以一章为单位，因为拉长战线会拉长反馈周期，对于学习实际效果不利。如述进行完以上的步骤，读完一章后，可以轻松休息片刻。（小绿人来陪你中场休息，来和我左三圈右三圈吧~）在知乎一篇回答中，我提到，我会在这种休息间隙做俯卧撑：>有没有人认为健身必要但同时觉得浪费时间？工作间歇、课间休息期间，眼看四下无人，哗哗哗，30个俯卧撑一两分钟内已经完毕，我擦，不仅劳逸结合，三头肌一个月内爆结实！！！放心：男孩子的话，这30个俯卧撑放心做好了。虽然方法是我提供的，但是我不向你要30个俯卧撑的版权！`这是我要提的另一个重点：身体能量和情绪能量`>学习过程中，比如在图书馆学习，我见到很多人在学习过程中是没有补充能量的，当然也有人吃些小吃和零食，但这个和我所说的能量没有屁毛的关系呀，多数人正式的能量补充时间是中午时段的午餐，在我看来，对于一个有志于高效学习的学习者，只有午餐一个常规性能量补充时段，显然是严重不够的。能量补充：>1、身体能量。精深练习的人最多达到1个小时1.5个小时，这是很累的，也就是说，会消耗大量的能量。所以，你得需要及时补充能量。两个小时的高效学习期间，分为两段，一段五十分钟左右，中间休息，这个时候就可以补充能量。>所以，巧克力就派上用场了。人和人千差万别，原因之一就在于人与人吃的方式不一样。身体的直接能量是葡萄糖，它把葡萄糖当资金一样运用。当身体能量不足时，首先剥夺的是心智能量，这时补充一些糖类（功能性饮料、奶昔、蜜水、果汁都是很好的能量来源），就会精力高涨，恢复冒险精神以及能够进行更加冷静的思考。所以，巧克力是我个人选择。为了防止做广告，我绝不会告诉你是只是高力士牌而已……>2、情绪能量。很多人不知道情绪也是一种能量吧？一对夫妻，两个在公司都拼命工作，但一回到家里就经常吵架，是他们脾气不好喽？另外有对夫妻，下班很早，夫妻两个经常甜蜜去逛街么么哒，他们的脾气就好了？可是，这时候我告诉你，他们其实就是同一对夫妻，你又怎想？为什么这样？这是――因为拼命工作不仅仅需要物质能量，而且繁杂的工作在白天还消耗了他们大量的情绪能量，老板多给你任务，你心里不满意，你能表现吗？是不是没有表现出来呀？对呀，你没有表现出来，你压抑了心中的不满。压抑这个不满的情绪用什么？答案的确是物质能量因为身体时时刻刻都要消耗它，但是还不够。因为还有一个事实：压制某一刻某一时的不满情绪，其实主要消耗的是情绪能量。那这样导致情绪能力下降，导致自控力下降，回家失控可不就吵起喽？是的，情绪能量需要补充。`平时还有这样的例子，比如我决定跑步，开始信心满满要跑一个月，结果没有几天就懈怠了，不是累了，而是情绪上感到疲劳了，产生厌倦感了。`这时候，解决情绪疲劳，有一个方法:那就是放松。听音乐吧，听好听的音乐，在这里，我要提一个建议：在经济条件能承受的范围内，尽量买一根质量超好的耳机。羞涩的说，我有一根了，音效超级棒！同样，有可能就买一台超棒的音箱……这是和丁元英学习的。（《遥远的救世主》的男主，电视剧是个人超级推荐的，个人认为是一部比原著好看的老电视剧。）前面我也说了，还可以做运动。我看到某些办公室里面有健身器材，相当羡慕，不过作为学生，我只能四下下无人，那一段看来还得再引用一遍，反正是我自己的版权：>俯卧撑>有没有人认为健身必要但同时觉得浪费时间？工作间歇、课间休息期间，眼看四下无人，哗哗哗，30个俯卧撑一两分钟内已经完毕，我擦，不仅劳逸结合，三头肌一个月内爆结实！俯卧撑随便做，不收费！解决厌倦感，我也有一个办法：`那就是，完成规定任务量之后，在某一个热情高涨的时候索性中断学习。这边的需要强调一下，是完成规定任务量之后――中断这个动作是发生在整个学习的后期，而不是你学得一高兴就中断，你要是这么蠢，只能嫁给我了！！！`村上春树跑步几十年，我最喜欢他的一点，是他会在跑步感觉良好的时候主动结束，这样他就会对第二天的跑步充满期待。因为人们对一些事情，总是能够清晰的记得事件的开头和结尾部分，在此基础上，我还要重点提醒的是。`当时间一长，我们能记住关于一件事物的主要部分其实是事物留给我们的感觉而不是事件本身。`村上春树以充满愉悦感的时候作为结束点，跑步对他来说自然会是一种“愉悦感”能隔天连续的体验。这是很智慧的。更多的例子我不想举例了，比如长篇写作中有许多作家也往往用这样的方法，比如写到高潮达到部分主动停下来，因为高潮情绪很强烈，在第二天接着创作是，就容易找回感觉，从而继续写下去。`事物的原因是一致的。所以，请你在晚上时段，即最后一个高效学习时段之后，接着再学习一段时间，正当感到愉悦、感到收获满满、感觉到学习仍然高效的时候――立刻中断你的学习，收拾书本滚回家找对象玩耍吧。`这么做的原因在于：理论上，你一天的高效学习已经接近极限了，这只不过是高效学习的余温而已，所谓的高效更可能是感觉上的高效，再继续进行下去只会让热情从峰值递减。如果你在对学习感到糟糕的时候结束一天的学习，我想说，你真是愚蠢，总是竭尽全力的消耗完自己。你的确是拼命学到乏力的程度了，没错，确实可以承认你真的很拼很努力。如果学习只是一次性交易的话，你这种努力就值得嘉奖；可惜，学习它是一个长期的过程。每一次，当你学到无力时才恋恋不舍地结束，你用“精疲力竭”给一天的学习画上了句号，很令人感动。但是，你可知道，你每一天学习的最后体验点就是“累”！今天你是通过竭尽全力的方式学到很多东西，可是，当“明天”来临的时候，你对于“今天”关于学习的最后印象只会是“累”。“后天”、“大后天”......每一天都以“累”的感觉最为结尾点那么这个“累”就是你带给每一个“明天”的学习痛苦感。这种”累“的感觉会累积变浓，因为每一天关于学习最后的那个感觉都会留下来，积累在你潜意识情绪认知里面。你因为一次次过度学习，从而导致了一次对学习的厌恶感的积累。――可笑你得不偿失！`而这正是多数人的做法：趁着精力十足拼命学习，学得无休无止，直到精疲力竭才罢休。`哇塞，今天他妈的好有成就感，我学了满满一天，好有收获！――看到没，这种人很快会懈怠下来。你看到他第二天，第三天可能就去看电影去玩耍了，他说，那是劳逸结合，他说有学就要有玩……从我独特的角度来看，此人每次如此耗尽一天“彻底”学习的后果是，在他潜意识印象中，会不断累积对学习的厌恶感，因为他总是在学习达到疲劳低谷点的时候才结束，自然有一种“学习使人疲累”的累积印象。所以，他的那种学习方法不长久，因为一个人如果不是经过科学合理的调节，自然而然做到一个“精力旺盛”+“想要学习”的每一天，那是很少见的。当然，有时候他也会精力状态，但没有合理利用起来，居然还被他一次性刷爆了！再者，他所谓的“收获满满”如果有一天遭受到打击，比如，现实证明他所学一无是处的时候，他心中就会倍加懊悔，懊悔当初那些拼命学习的付出是否值得，而这个懊悔的对象无疑是「学习」，他以为无用的学习使得他之所学无用武之地，在抱怨学错知识内容的同时不可避免的是他也会对「学习」行为本身产生一度的怀疑。你看，一个人对学习的厌恶，对学习的恐惧，就是如此积累而来的。现在，你说，一个人对学习的厌恶是自然由来的吗？人是不爱学习的吗？人是可以热爱学习的，但是需要方法，需要遵从人的心理特点。当我说到这里的时候，请你听从我的建议:无论是什么学习，如果有这件事情来说对你重要，也有必要，但是你却讨厌它，那么请你在讨厌的时候立马去学习它，学到你喜欢它的时候立刻中断它。`因为人都是追求快乐的，你学到情绪快乐的时候就中断，你的情绪就会带领你再来领略一次那种似曾相识的快乐，即便你的情绪不会主动带你来，也不要紧，因为你至少不会在心理上抗拒了。`当你看到以上的观念的时候，可以按赞和关注我了，因为我第一次在这里说这个东西，有幸，你也看到了。所以，是缘分，我谢谢我自己，这是一个多么好的观念呀，不敢说你在别的地方有没有见过，但是，在我的认知范围内，把这个观念用于学习，真是一种创造！6正式高效率学习1.2第B步：回顾看完一章之后，这一步简直轻松，一页一页翻过去，对主要知识点、概念，脑子里有一个回顾，知道这一章有讲什么内容。第C步：做题a计划：找例题，做例题>（1）不看答案，能做多少就做多少，做完对答案，紧接着完整抄一遍标准答案>（2）去章后看看有没有会做的题目，有会做的就做下去>（3）没有就跳回来看第二个例题，方法一样――如此循环往复以上流程，如果五个例题抄完仍然没有头绪，那么太好了，说明你还没有理解教材，或者你的基础不扎实，这个就更好解决了:进行b计划b计划：遇到这种阶段性的困难，只能加强对教材的针对性理解。在例题解答答案步骤中圈出那些重复出现的关键词以及章后题目含有的术语，再进一步去阅读相关知识点的概念、案例、图表。接着回来做题。如果不行，更加简单了:进行c计划c计划：能让你进行到b步骤的书，我有理由相信那应该是类似《固体物理》一类的教材了，其他弱弱的学科如电工等等等等，基本上不会让你做了五个例题、抄了五个例题，你连一点头绪都没有。所以，你的操作如下:放下书本，去热爱生活吧。另外，我在送你一个礼物:当一本教材用如上的方式进行完毕，请你及时从网上寻找一份有详细答案的试卷做一次测试！如果成绩达不到你心中的目标，请自觉决定安排时间重新学习、巩固、提高。这是对于自己有高要求的学霸说的。这个测试建议实际上对渣渣具有更多现实意义:如果在测试中不及格，你需要重新加强课本的学习。以此，拯救了一大片期末会挂科的渣渣们。你总不至于在看到这个特意提醒的时候，还清醒而且坚定的要和期末考做一锤子买卖吧！？要讲的话讲完了，前前后后花了好多是时间修改文字。另外在补充一下我按这个方法进行时的一般作息。作息：1.我一般6点30分醒来，写晨间日记。上面会写……A：心态准备我现在心情有点糟糕，还想睡觉，但是八点需要良好的心态来进行正式高效学习，所以，我必须振奋起来，加油！B：行动准备为了确保八点正式高效的学习，我应该吃好早餐，天不冷的话，应该小跑一会儿，太冷的话，那就神伸懒腰好了，总之，要让心情愉悦起来~C：物质准备应该去买水、巧克力……”写着写着，就清醒了过来。我不确定刚刚起床要不要再床上像猫一样的坐着不动停留几秒，听说有利健康，不错，很有利健康，我的尝试是这样的：为什么坐着？躺在不是更舒服吗？――没错，我又睡了几个小时！这就是好处吧吧吧。反正就是此类日记记录每天重复差不多的唠叨，长时间的进行。我发现，这对于我来说，最大的作用应该是暗示的作用――或者说，我有意于使它培养出一种条件反射。我喜欢这样，因为我喜欢――简单的勾勒，不是很长。我把笔记本放在床头，一起来，就里面写第一个字，“2015年……”之后就自然起来了，朋友，记住一条简单的惯性定律:静止的倾向于静止，运动的倾向于运动。不知道一件事情怎么开始才合适？先去做10分钟。不知道怎么和女孩搭讪？立马过去说一声:“你好！……”后面的你自然会接着说。动起来，运动的倾向于运动。我真喜欢这句话。2.我也有睡过头的时候。我看到有人因为一次计划的中断他就放弃了整个项目，我觉得他实在是愚蠢啊。比如我昨天打算早起学习的，可是济南雾太浓（刚刚接到济南大雾黄色预警，不妙啊），我以为是天没亮，结果晚起了两个小时。我难道不学了？对的，很多人正是这样做的。如果他在睡过头到中午才起来，他就很懊恼，麻痹，一天就这样悔了，算了，算了，今天下午还是好好玩吧，明天一定要早起！――这真是愚蠢啊。你没想到吧？第二天还是一样哎！长时间这样，效果很不好，你知道吗？当最后任务期限要截止的时候，你就焦躁不安了，你开始感叹时间他妈太快，自己不知不觉又荒废了这么多时间！……一连的情绪爆炸……哎。晚起了，就接着计划一天可利用的时间就行了嘛……有什么大不了？同样，长期的计划要是因为不得已有一天两天的中断也没有关系，接着进行就行了嘛！……有什么大不了？非要让一时的缺失造成长期的隐患？！3.能量值爆发期每个人的高能学习时间段可能不一样。但是我要强调一个词「预计」。观察自己长期的活动状态，我认为，预计自己能量爆发态出现在上午8~10，下午2~5点，晚上6：30~10点，一共八个半小时。所以，我会为了这八个小时做了很多额外准备，比如，中午午睡就是必要工作；下午5点40左右，我可能会眯一会，这也是必要的工作；休息间隙用牛逼的耳机听喜欢的音乐，是必要的工作；个人爱好，俯卧撑也是必要工作；巧克力也是……总之，都是为了保证这八个半小时的高效利用而准备（实际上达不到8个半，8~10点休息10分钟，下午2~5点休息10*2，晚上6：30到10点，10*2，因此学习纯时间是7小时40分钟）。因为里面提到下午5点40左右的小睡，那个时候并不困，是为了防止晚上三个半小时产生疲劳而提前进行的小睡眠的。在疲劳来临之前休息放松是最好的缓解疲劳的方法，你没有听说过吗？你听说过，所以，我再一次提醒你而已。ps.别以为这样学习苦逼，其实我是在极大愉悦度中进行的，伴随着强烈的仪式感，每一天都像朝圣之行。", "life/穷爸爸富爸爸.md": "从长期来看，重要的不是你挣了多少钱，而是要看你能留下多少钱，以及留住了多久。衡量财富的标准是你不工作时，你能活多久。知识才能解决问题并创造财富，不是凭借财务知识挣的钱很快会消失。“如果你想发财，就需要学习财务知识。”要让自己财富自动增值，增值的财富能供养你的生活。不要指望工作，社保来养活你。富人留下资产，穷人留下负债。发现资产，并买下它。会计是财务自由最重要的一门科学。读书不在于你读了多少，而在于你思考了多少，吸收了多少。", "life/穿着.md": "初章：心态一、引言可能有的同学要说，讲穿着就讲穿著，干嘛还故弄玄虚说什么心态。那么我要告诉您的是，让您的着装出现问题的最大原因，就在于您的心态，心态的调整不但是从学生角色调整到工作者角色的重要因素，同时也影响着您的价值观，影响着您的外在形象。二、从学生的着装到办公室的着装学生时代，我们的着装通常是随意的，随着每个人的经济状态和审美观点的不同，欢快的，酷酷的，懒散的，邋遢的，各种装束都可以让您在校园问心无愧，加上现代年轻人独特的个性心理，所以很多刚刚进入职场的学生，会对办公室里的同事们单调的工作着装不屑一顾，总想保持自己青春的形象。“我是刚毕业的大学生，我的地盘~我作主”。于是就出现了很多刚毕业的大学生，穿着牛仔裤，染着头发进出办公室的一幕，别人问到他，还趾高气扬的说“我这可是‘杰克.琼斯’的”。这样特立独行的着装，只会对您的职业生涯产生负面影响，让同事和领导对您产生不信任感，给人以办事不够沉稳可靠的印象，如果您不改变这一点，您将永远无法融入身边的工作环境。因此，调整着装的第一步，就是调整自己的心态，告诉自己“我已经不是学生”“我只是刚刚来这里的一个初哥”“我没有什么值得骄傲的东西，这里的每个人都比我经验丰富”“我要改变自己的形象”…..自身形象的改变，反过来同样有利于调整自身的工作心态，快速的适应工作环境和学校环境的落差，使周围的同事和领导对您产生信任感，对您快速融入新环境的能力从内心发出赞赏，从而为您今后的工作铺平道路。三、不要害怕刚刚完成形象改变的您，可能会面另其他方面的压力，您的同学，朋友，恋人，可能都没有办法立刻适应您的这种变化。兄弟可能说：“傻B，穿得个老头似的，哈哈哈”，女同学可能说：“哇，我都认不出来了，当老板了？”等等。这个时候的您，一定要把握好自己的心态，千万不要放弃。同时也可以在休闲场合，比如聚会，郊游的时候，穿回学生装。不同场合不同的穿着，这也是通常绝大部分人的选择。穿工作装到KTV被认为是搞笑的。第一章：知识普及一、什么是“正装”很多企业的工作守则中有一条：工作时间请穿着正装。那么什么是正装呢？对于很多刚刚毕业的同学来讲，可能是一个熟悉而又陌生的词汇，顾名思义，正装就是正式场合的装束，而非娱乐和居家环境的装束。具体而言，男士正装应当有以下5个特征女士详见：三色原则三色原则是在国外经典商务礼仪规范中被强调的，国内著名的礼仪专家也多次强调过这一原则，简单说来，就是男士身上的色系不应超过3种，很接近的色彩视为同一种。有领原则有领原则说的是，正装必须是有领的，无领的服装，比如T恤，运动衫一类不能成为正装。男士正装中的领通常体现为有领衬衫。钮扣原则绝大部分情况下，正装应当是钮扣式的服装，拉链服装通常不能称为正装，某些比较庄重的夹克事实上也不能成为正装皮带原则男士的长裤必须是系皮带的，通过弹性松紧穿着的运动裤不能成为正装，牛仔裤自然也不算。即便是西裤，如果不系腰带就能很规矩，那也说明这条西裤腰围不适合你。皮鞋原则正装离不开皮鞋，运动鞋和布鞋、拖鞋是不能成为正装的。最为经典的正装皮鞋是系带式的，不过随着潮流的改变，方便实用的懒式无带皮鞋也逐渐成为主流。二、常见的正装体现最常见的男士正装，是我们常常在白领们身上看到的“衬衫+西服+领带+西裤+皮鞋”，实际上，在夏天只穿着衬衫和西裤也是正装的体现，立领的中山装样式西服也属于正装范畴。也许您要说“我看见很多著名的企业家，连在电视上也是穿着休闲装，比如张朝阳，比如比尔盖茨~~~~”。你说的没错，但是不要忘记，本文的读者并不是针对他们这样的人群，如果您有一天也到达这样的地位，您尽可以按照您的想法章显个性。如果您依然是一个我们所说的初入职场的菜鸟，那您还是老老实实的穿着正装吧。第二章：衬衫一、关于衬衫衬衫是今天男士正装几乎不可缺少的组成部分，构成整个男士正装的亮色部分基本上依靠的是衬衫。有句俗话“白领男士没有一打以上的衬衫，根本无法出门”。虽然话有些夸张，带有些资产阶级奢侈腐朽色彩，但是也足以体现了衬衫的重要性。衬衫通常被分为休闲衬衫和正装衬衫，本文讨论的是后者。至于如何区别，请阅读接下来的内容。二、衬衫的面料衬衫的面料是决定衬衫档次和是否适合您的重要因素，通常在国内能够买到的衬衫，其面料分为以下几种：正规厂商的衬衫会在内部腰部的水洗标签上标明面料种类1：100%纯棉特点：穿着舒适，柔软，吸汗，极易皱，易变形，易染色或者变色。纯棉也分为普通的纯棉和高织纯棉，后者是使用高密度的织法生产的面料，具有一定的抗皱效果，但是依然易皱。在良好护理的状态下有很好的视觉质感。2：纯棉+涤纶按照一定比例混合特点：质感较硬，穿着不如纯棉舒适，不易变形，不易皱，不易染色或变色，按照棉和涤的比例不同，特点向纯棉或者纯涤纶的偏移。3：100%涤纶特点：质感硬，穿着不舒适，不易变形，不易皱，视觉质感效果差。属于低档面料。4：亚麻特点：穿着舒适，柔软，吸汗，极易皱，易变形，易染色或者变色。在良好护理的状态下有很好的视觉质感。衬衫面料中的贵族。5：羊毛特点：保暖，厚。易皱，易变形，易虫蛀，易缩水。视觉效果好。按照国际标准，上等的商务衬衫应当是亚麻或者纯棉面料的，各种网络上的文章也通常这么描述，这就给很多人造成了一种映像，只要是纯棉的就一定是好的。其实这是一种误导。高端商务衬衫的售价一般在100美元以上，国内售价也在500人民币以上，这类衬衫做工精良，而且含有某些高科技成分。但是即便如此，他们由于采用纯棉或者亚麻面料，也摆脱不了易皱易变形的特点。如果要保持刚刚买回来那样的笔挺效果，那必须要有良好的护理，比如干洗，手洗，而不能机洗，更重要的是每次洗涤之后都必须要经过熨烫。因为买得起这类衬衫的用户通常也花得起这样的成本，所以他们的衬衫总是光鲜亮丽笔挺。而我们的读者群体定位是在刚刚工作的学生朋友，口袋里没有太多的银子，通常只能购买相对低价的衬衫，而且也不可能干洗和熨烫，因此纯棉或亚麻衬衫很快就会皱的不成样子，不明事理者还照常穿着，实际上引人笑话。因此，笔者认为最适合您的，是第二种面料，即纯棉+涤纶混纺。而这其中又以棉涤比例为7：3到6：4之间的为最佳。这类面料，有着涤纶面料抗皱，免熨的特点，能够随便的机洗，同时也有着纯棉面料类似的良好的视觉质感。能够适应您需求一定的档次，而又希望维护简单的想法。至于羊毛衬衫，只有在冬季考虑保暖因素的时候，才建议您购买。因为他的护理比亚麻和纯棉更加麻烦。三、衬衫的衣领衬衫的衣领是衬衫最为重要的地方，穿着男式西服的时候，衣领是衬衫暴露给他人视线的黄金区域，因此衣领的款式，质量，直接决定的衬衫的好坏和穿着的效果。正装衬衫的衣领应当是整洁平顺笔挺的。衬衫的衣领分为很多款式，不同国家和地区有不同的称谓，方领衬衫已经过时，目前流行的是较短的八字大翻领，而尖长领的衬衫适合于不系领带的时候穿着。1.扣纽扣的衬衫领这是传统衬衫领中的经典，略有些预科生或名牌大学学生的气质。这种衬衫虽然不适合于特别正式的场合，但是日常在办公室中穿着效果非常好，因此人们现在普遍选择这种领子的衬衫。不过，这种衬衫对于双排扣西装来说还是显得有些太随便了。2.大翻领最考究的领子之一。它同双排扣西装十分相配。大翻领非常适合长脸或椭圆脸形的男性，不适合圆脸或矮胖的人。它突出水平线条，可以有效地调节过长的垂线。这种领子的衬衫在华尔街的男士中很流行，并且特别强调领子和袖口与外衣形成强烈的明暗对比。3.长尖领这种领子是圆脸男性和胖大绅士们的最佳选择。目前，托意大利著名设计师乔治61阿曼尼的福，长尖领正受到那些走在潮流尖端的年轻男士们的青睐。这种领子产生的效果与现在时髦的圆滑形象非常合拍。4.带托领这是一种集多种功能于一身，颇富英国乡村气息的款式，深受衣着讲究的传统男士喜爱。这种领子的领口处带有一个小环，可以托住领带，因此无需使用硬领就能够让领带结显得饱满挺括。领子本身的样子与翻领相似，显得非常正式。当它和袖口一起与外衣形成强烈的明暗对比时，给人一种整洁潇洒的感觉。需要注意的是，带扣的衣领一定要系上钮扣，特别是明扣衣领。而立领的衬衫通常让您显得与众不同，如果您有足够的自信，也可以选择。衬衫衣领通常是由几层材料粘合缝制而成，是考验生产厂商技术水平的地方，正规大厂生产的衬衫，在新买回来的时候，衣领上不可能出现线头，飞线。缝合的针线必须细而密做工精良的衬衫每英寸（2.54厘米）缝线至少应该有14针，靠近边缘的缝线一定是距离一致，没有走歪的现象。衣领在经过多次洗涤之后依然能保持良好的形态，不起皱，不起泡。而劣质的衬衫，通常在洗涤一两次之后就会暴露出来。穿着一件衣领起泡或者起皱的衬衫是令人尴尬的。四、衬衫的颜色经典正装衬衫一定是纯白色的，但是作为通常的上班环境以及年轻人的要求，我们也不用这么苛刻。通常建议选择浅色系的衬衫，视各人的喜好和实际情况而定，浅蓝色是永远不会出错的经典，浅粉红，浅黄则是时尚的颜色，皮肤较黑的人士可以选择颜色稍深的衬衫。条纹和花纹衬衫也可以选择，但是更讲究和西服与领带的搭配。但是过于花哨的衬衫在正装领域是不适合的，实际上正规的正装衬衫厂商也不会生产这样的产品。关于衬衫颜色和其他元素的搭配，参见本文后面的着装搭配部分。五、衬衫的钮扣衬衫的钮扣是容易被人们忽略但是却非常重要的部分，正规厂商的衬衫纽扣一定是X形缝制的，并且收针部分一定是在内侧有一个很短的线头。钮扣上的商标应当与衬衫的商标一致，不透明的贝壳质感比透明的塑料质感更显尊贵。带金属色的钮扣则要谨慎选择，容易让您显得过分张扬。六、短袖衬衫短袖衬衫原本是不能算在经典正装领域的，但是炎热的夏天如果办公室的空调开得不是很够，短袖衬衫也并不失格，不过要记住一点，短袖衬衫是不需要系领带的。七、衬衫的穿着和维护穿着衬衫一定要将下摆扎入裤内，这是最基本的要求。系领带前一定要将领部纽扣系上，保证领带结将钮扣部分遮住。有领尖扣的一定要扣上。如果不系领带，则必须将领口解开，而有领尖扣的仍然必须扣上。正规厂商生产的衬衫衣袖一定是有2粒可调节的袖口，按照您的手臂粗细选择，原则是不能让衣袖粗过您的手腕。当然如果不合适可以请裁缝改钉。袖口是必须扣的钮扣。勤换洗，这点非常重要，保证衣领袖口不能看到污渍，浅色衬衫应当一日一换，深色的可以23日但是不能超过3日。所以比较懒的你，必须配备多件衬衫才可以。已经穿着时间过长发黄变色的衬衫，衣领变形起泡甚至破损的衬衫，最好就留在家里当睡衣或者当抹布了。如果您有足够的时间，请使用手洗衬衫，如果能支出足够的成本，干洗当然是奢侈的选择。如果上述都没有，机洗也自然是我们大部分读者的选择。不管您选择的是什么衬衫，如果您有一支蒸汽熨斗能够时常熨烫，将使您的衬衫倍感出色。八、衬衫的品牌和选购著名的服装品牌通常都生产衬衫国外比如POLO，GUCCI等等，香港的G2000，中国大陆的雅戈尔，太平鸟，杉杉等中国是世界服装生产的中心，全球80%以上的衬衫都由中国制造，自然包括了国外那些著名的奢侈品牌，因此不要盲目迷信国外品牌。通常国外品牌的售价都是非常昂贵的，这些品牌产品的质量自然是一流，在各大商场都可以见到，这类品牌的售价一般都在人民币500元以上，这对我们的读者来说，通常是不划算的。也许有的BOY会想到通过一些其他渠道购买所谓的“外贸货”，“尾单”，“跟单”等东西。实际上国际品牌的产品控制是非常严格的，在中国加工的时候，面料，辅料都是严格控制的，不可能有这么多“转内销”“尾单”一类的东西，它们通常都是假冒伪劣产品的代言词。因为要在衬衫上绣上POLO，或者阿曼尼的商标，那是再简单不过了。因此，我给大家的建议是购买国内的大品牌衬衫。这些衬衫厂商生产的衬衫品质，绝对是世界一流，只是在最新的时尚设计前沿，稍微落后于国外。对于我们的读者人群来讲，是最佳的选择。国内的优秀品牌：1、雅戈尔，YOUNGOR质量，做工都是一流。超过很多国外品牌，在各大城市都有专卖店。缺点是在商场和专卖店的价格较贵，通常都是在300元以上，新款产品要卖到500700元左右。对于我们的读者群来讲，有点难以承受。但是该品牌常常打折，最低打到7080元左右，通常在100元以内买到就可谓相当划算。另外，也可以通过网络在ebay或者taobao上购买，比较放心，因为国产品牌很少有假货。2、杉杉同样是国内的品牌衬衫，做工一流，但是并不太好买到，价格和雅戈尔类似，但是很少见到打折。3、太平鸟专门的衬衫品牌，做工一流，价格低，在各个商场通常都有出售，即使不打折价格也不会超过200元，打折时最低甚至只要60元。4、G2000香港品牌，做工较好，设计时尚，紧跟潮流。但是以纯棉产品居多，价格在200元左右，打折时100以下。如果您有一支熨斗也有时间熨烫，它将是您的时尚选择。5、其他如开开、海螺、银湖、洛兹、天坛、虎豹ＨＵＢＡＯ、红豆、步森、等这些国产名牌衬衫的质量是值得信任的，通常建议在打折的时候购买，价格在200元以内应该比较适合本文读者，100元以下买到这些品牌都不该错过。不要购买一些没有名气的品牌衬衫，特别是一些号称某某意大利名牌，法国名牌，尤其是未打折时价格在100元以下的，打折到50元以下的衬衫。虽然以价格来衡量产品并不是太准确，但是一件做工精良的衬衫，的确有一定的成本，几乎不可能低到50元以下。低价产品的特点是做工粗糙，经不起考验，往往两三次的机洗就会彻底变形领部脱胶。优质衬衫的寿命应当在机洗100次以上，50次以内基本保持新购状态。也就是如果您只有3件衬衫天天穿天天换天天洗衣机猛洗，也能够穿1年。如果您有6件那就可以穿2年。当然这纯粹是数字上的计算。实际上，您不可能天天穿衬衫吧。所以优质衬衫是可以穿着两三年以上的，属于长期投资产品。九、衬衫的尺寸衬衫的尺寸在不同的国家会有不同的标准，不同的企业之间也会有一些差距。但是绝大部分正装衬衫是不能试穿的，因此您必须要了解衬衫的尺寸是否适合自己。以下为中国标准的衬衫尺寸对照表：型号165/84A170/88A175/92A175/96A175/100A180/104A180/108A领大38394041424344胸围106110114118122126128肩宽44.54647.24849.250.451.6袖长596162.562.562.56464身长70747676767878其中最为重要的也是常见的参考为“领围”，39代表39厘米，意思是衬衫衣领的长度为39厘米，通常以扣上领口还能够顺利地插入您的食指为合适，如果太紧则太小，如果太松则太大。另外“型号”参考也比较常用，170/88A指的是身高170，胸围88CM体型为A型瘦型的男性，如果偏旁的男性有的品牌还提供B型胖型以供选择。第三章：领带一、关于领带在当今社会环境下，男士的形象就是走向成功的第一步。文雅、沉稳、温情是文明社会对男士的形象要求。领带作为男士服饰的一部分，充分体现了领带作为服装饰品的丰富内涵，为男土独特而深沉的内心世界做了最好的形象注解。因此，领带在经历了服饰潮流的漫长考验的今天，随着人类文明的迅猛发展和审美时尚的不断更新，以它独有的灵魂和个性愈来愈受男士的青睐和推崇。二、领带的面料领带品质的优劣，从根本上来说并非取决于款式与品牌，面是取决于其材料的质地与做工的考究性。通常在国内常常见到的领带材质分为几种：1、色织真丝色织真丝通常是100%桑蚕丝产品，只是使用多种颜色的真丝混织而成，是领带面料中的上品，具有色彩润泽、柔和、手感细腻；，更重要的是做工优良的真丝领带，通常是防皱，防水的。2、真丝真丝通常是100%桑蚕丝产品，与色织真丝的区别在于使用单色丝线织成，然后再表面印刷花纹，因此也被称为印花真丝，其他的与色织真丝相同。3、仿真丝仿真丝通常采用的材料是PS即尼龙，具有和真丝类似的色泽和，色光发亮，跳眼，但是抗皱性不如真丝，质感也稍差。但是价格低廉，如果领带标签写的成份是“南韩丝”“法国丝”“ps丝”等，都属于仿真丝的材料。4、涤丝涤丝的材料是涤纶，颇色黯淡较沉、手感粗糙，是领带面料中的下品，自然价格低廉。领带的面料自然是以真丝为佳，如果觉得花大价钱购买一条领带划不来，仿真丝和涤丝也可选择，因为从实际情况来看，绝大部分人无法从视觉上直接分辨出领带的材质，因此即便你系一条10块钱的涤丝领带，他人也未必看的出。只不过，真丝领带不易皱，不易污损，的确是上佳选择。即便是本文的读者群中，笔者也建议选购真丝领带。三、领带的做工1、标准的领带是由三段拼接而成，总长度为145cM，角度为4561接位位。2，表面光洁，花型清晰，对称；3，背面拉缝垂直居中；4、拼接处的花纹的一致程度；5、整条短带面料色差的一致性与否。四、领带的花色领带的花色是男士正装唯一可以变化和体现个性的地方，因此领带花色的选择非常重要，个性特征也非常明显，每个人都有自己的喜好和偏爱，笔者在这里只介绍基本的原则。从色彩上讲，领带有单色、多色之分。单色领带适用于公务活动和隆重的社交场合，并以蓝色、灰色、黑色、棕色、白色、紫红色最受欢迎。多色领带一般不应超过三种色彩，可用于各类场合。色彩过于艳丽的领带用途并不广泛，只有在非正式的社交、休闲时，使用它才不会为人非议。如果是有图案的领带，用于正式场合，其图案应规则、传统，最常见的有斜条、横条、竖条、圆点、方格以及规则的碎花，它们多有一定的寓意。印有人物、动物、植物、花卉、房屋、景观、怪异神秘图案的领带，仅适用于非正式的场合。印有广告、团体标识、家族徽记的领带，最好不要乱用。从本文的读者来看，刚刚进入企业的学生，基本上很少有一来就做主管的，多半是底层的员工或者助理一类的职务，做这类职务切忌张扬，不可以让全公司的人都看到你系着一条抢眼的领带，风采胜过你的上司。因此，穿着低调是基本上需要遵守的原则，因为工作上的出众不应该靠穿着，而是靠自身工作的成绩。所以领带的选择要谨慎，尽量不要选择大红色，亮眼的黄色或者银白色，而是选择相对灰暗的颜色，比如蓝色，黑色。如果希望张显一些青春色彩，粉红色也是不错的选择。另外，花纹的搭配也是相当讲究的，比如穿着条纹的衬衫切忌搭配条纹的领带，穿着纯色的衬衫最好搭配有花纹的领带等等，在后面的服装搭配章节中会有介绍。五、领带的系法注：以下领带系法可以在baidu图片中搜索到，笔者就不在这里贴图了。1.亚伯特王子结01适用於浪漫扣领及尖领系列衬衫01搭配浪漫质料柔软的细款领带01正确打法是在宽边先预留较长的空间01并在绕第二圈时尽量贴合在一起01即可完成此一完美结型2.浪漫结01浪漫是一种完美的结型01故适合用於各种浪漫系列的领口及衬衫01完成後将领结下方之宽边压以绉摺可缩小其结型01窄边亦可将它往左右移动使其小部份出现於宽边领带3.温莎结01此种结形因其宽度较一般结形宽01故十分适合使用在意大利式领口（八字领）01的浪漫系列衬衫上01最适合与浪漫细致的丝质领带相互搭配4.简式结（马车夫结）01适用於质料较厚的领带01最适合打在标准式及扣式领口之衬衫01将其宽边以180度由上往下翻转01并将折叠处隐藏於後方01待完成後可再调整其领带长度01是最常见的一种结形5.十字结半温莎结01此款结型十分优雅及罕见01其打法亦较复杂01使用细款领带较容易上手01最适合搭配在浪漫的尖领及标准式领口系列衬衫穿着西装系领带时，流行的做法是不使用领带夹，只有在单穿长袖衬衫系领带时，才需要领带夹。系领带时，领带的大头下垂不得遮住皮带扣，小头下垂不得超过大头的长度。六、领带的品牌和选购基本上来说，很少有著名的品牌专门生产领带，国外顶级手工作坊除外。因此，绝大部分的男装正装厂商都在生产领带。所以，尽管很多考究的人士讲究领带的品牌，但是对于我们的读者群来说，这个东西的意义并不大。真正重要的，是如何选择一条优质的领带。由于领带的生产工艺相对简单，因此影响领带质量最重要的因素，就是面料，我们在前面已经讲过，上乘的领带面料应该是真丝的，但是领带的品牌繁多，假冒伪劣也非常严重，一些中小品牌的厂商，常常在一些涤纶或者仿真丝的领带上标称100%SILK，蒙骗消费者，那么我们应该如何去识别一条领带的面料呢？１、价格，真丝领带的价格通常不可能在５０元以下，品牌产品的价格可以标的非常离谱，几百，几千甚至上万都有可能。不过大家要明白，全球８０％以上的领带都在中国制造，而中国制造的领带８０％以上都是在浙江嵊州生产，那里有中国领带城的称号。一条上等真丝领带的出厂成本大约是在５０－１００元之间。所以商场和专柜中虚高的领带价格里面都是暴利。而过低的价格对应的肯定不是好产品。建议本文的读者采购的领带价格在５０－１００元之间。２、品牌、通常著名品牌的领带，他的标称面料和真实面料都是一致的，不会有什么折扣。３、手感、对于没有听过的品牌，只能用手感来判断其面料，真丝面料柔软光滑，不易皱，如果对于这个概念没有明确的感觉。可以到名牌领带的真丝款摸摸看。而涤丝的往往硬梆梆，粗糙，不光鲜亮丽。４、测试，用手将领带揉成一团，用力捏挤下，展开之后依然平顺如初的，为真丝，否则为涤丝或仿真丝。用手蘸一些水，撒在领带表面，水珠流下的为真丝，渗入面料中的为非真丝。只要掌握这些技巧，多对比下自然就会有经验，买到称心如意的领带。通常，穿正装上班的ＢＯＹ需要３到５条领带。如果资金充裕，不妨直接购买品牌产品，如果要节省开支，可以等待打折或者在非品牌货中仔细挑选。实际上，家乐福销售的２０元一条的涤丝领带和专柜３０００一条的真丝产品，在系上之后的视觉效果，除非是讲究的行家，其实一般人并不能看出太大区别。七、领带的维护１、使用注意开车系安全带时，勿将领带绑于安全带内，以免产生皱折。戴完领带后，请立即解开领结，并轻轻拿下领带――因为用力拉扯，领带表布及内衬的纤维容易断裂，并造成永久性的皱折。然后将领带用领带架挂起来（请留意置放处是否平滑，以免刮伤领带），让它在通风的情况下自然舒展地吹干汗水。处理结口皱纹，请以蒸气熨斗低温烫平；水洗及高温熨烫容易造成变形而使领带受损。同一条领带戴完一次，请隔几天再戴。局部的污垢可用去渍油擦拭，然后晾干或熨干。２、洗涤领带因质地不同，洗的方法也不同，有的可水洗，有的则必须干洗。但总的而言，领带宜干洗，且不可过多的洗涤，以防褪色。（1）水洗混纺、合成纤维质地的领带可水洗。用有清洁剂的刷子轻轻将污垢刷去，然后用清水冲洗即可。领带晾晒需在阴凉通风处，切忌在阳光下暴晒，以防泛黄、走色。（2）干洗丝绸质地的领带须干洗，一般的干洗店都可以做到。甚至很多是免费的。３、熨烫熨烫领带时，温度不宜过高，以70度为佳。熨烫速度应快且均，以防出现“极光”和“黄斑”。熨烫后，用衣架挂起来，套上袋，以防灰尘。４、收藏存放领带要保持干燥，不要放樟脑丸防蛀。收藏前，最好先熨烫一下以杀虫、灭菌、防蛀。还要注意：丝质的领带要挂起来，而非丝质的领带则该平放或者卷起。第四章：西服一、关于西服西服的定义：用同一种面料做成的上装和裤子有时还包括背心。100多年以来，西服的概念一直就是这样的。可是在100多年前的数百年里，男人们穿的西服却多半不是这样的。那时的上装、背心和裤子并不是用同一种面料做的。实际上，西服是由西方中世纪服装逐渐演变而来的产物，在今天西方文化统治全球的前提下，西服成为了国际男士正装的代名词。二、西服的款式可以被称为正装西服的西服通常有两种款式：单排扣西服和双排扣西服。单排扣西服一般都只有三颗扣子，当然也有４颗扣子的，而且只扣其中最上面的两颗或３颗。双排扣西服则有4颗或者6颗扣子，而最上面的一对扣子总是只起装饰作用的从来也不扣上。在开衩的问题上，西服的上装有三种选择：在两个侧面各开一个衩，被称为“双开叉”，或者只在后面的中部开一个衩，被称为“单开叉”，也可以根本不开衩。单排扣西服可以选择其中的任何一种，而双排扣西服则只能在两个侧面各开一个衩，或者干脆不开衩。目前比较适合年轻人的，通常是单排扣的西服，双排扣则更适合中老年人。单排扣的西服中，双开叉西服显得更为正式，而单开叉的略带休闲风格。所以建议本文的读者选择单排扣西服，如果你过分瘦高，可以考虑４粒纽扣的，普通身材自然是３粒纽扣最为标准。西服成套的裤子裤腰的前面可以打褶，也可以不打褶。有的裤子钉有穿皮带用的套圈儿；有的裤子则钉有小搭扣，以便对裤腰的大小进行调节。这种裤子还钉有扣裤子背带用的扣子。你是否喜欢裤腰前面打褶的裤子，这完全取决于你的审美观。不过，裤腰前面不打褶的裤子只有肚子扁平的人穿起来才好看。今天，西服裤子一般都缝有穿皮带用的套圈儿，因为只有少数男士愿意穿带背带的裤子。三、西服的面料西服的面料是决定西服档次的重要标志之一，当然，并非唯一标志。通常我们在市场上看到的西服面料分为以下几种，而且与领带不同的是，通常的西服内侧水洗标上标明的面料成份，与真实的成份不会有太大差距，即便是中小品牌也如此。１、纯羊毛精纺面料１００％羊毛，大多质地较薄，呢面光滑，纹路清晰。光泽自然柔和，有漂光。身骨挺括，手感柔软而弹性丰富。紧握呢料后松开，基本无皱折，既使有轻微折痕也可在很短时间内消失。属于西服面料中的上等面料，通常用于春夏季西服。容易起球，不耐磨损，易虫蛀，发霉。２、纯羊毛粗纺面料１００％羊毛，大多质地厚实，呢面丰满，色光柔和而瞟光足。呢面和绒面类不露纹底。纹面类织纹清晰而丰富。手感温和，挺括而富有弹性。属于西服面料中的上等面料，通常用于秋冬季西服。容易起球，不耐磨损，易虫蛀，发霉。３、羊毛与涤纶混纺面料阳光下表面有闪光点，缺乏纯羊毛面料柔和的柔润感。毛涤（涤毛）面料挺括但有板硬感，并随涤纶含量的增加而明显突出。弹性较纯毛面料要好，但手感不及纯毛和毛晴混纺面料。紧握呢料后松开，几乎无折痕。属于比较常见的中档西服面料。４、羊毛与粘胶或棉混纺面料光泽较暗淡。精纺类手感较疲软，粗纺类则手感松散。这类面料的弹性和挺括感不及纯羊毛和毛涤、毛晴混纺面料。但是价格比较低廉，维护简单，穿着也比较舒适。属于比较常见的中档西服面料５、聚酯纤维与人造丝混仿面料属于近年出现的西服面料，质地较薄，表面光滑有质感，易成形不易皱，轻便潇洒，维护简单。缺点是保暖性差，属于纯化纤面料，适用于春夏季西服。在一些时尚品牌为年轻人设计西服上常见，属于中档西服面料。６、纯化纤仿毛面料这是传统以粘胶、人造毛纤维为原料的仿毛面料，光泽暗淡，手感疲软，缺乏挺括感。由于弹性较差，极易出现皱折，且不易消退。从面料中抽出的纱线湿水后的强度比干态时有明显下降，这是鉴别粘胶类面料的有效方法。此外，这类仿毛面料浸湿后发硬变厚。属于西服面料中的低档产品。按照传统的标准，西服面料中羊毛的含量越高，代表着面料的档次越高，纯羊毛的面料当然是最佳选择。但是近年来，随着化纤技术的不断进步和发展，纯羊毛的面料在一些领域也暴露出它的不足，比如笨重，容易起球，不耐磨损，在衣柜挂放稍不注意会被虫蛀，发霉等等。维护成本高昂。因此本文的读者作为年轻人，选购西服时，也不必拘泥于必需要纯毛的，或者高含毛的产品。笔者建议，选购保暖性好的秋冬季西服时，可以考虑纯毛或者高含毛的厚实面料，而春夏季西服则可以考虑聚酯纤维与人造丝这样的化纤混纺面料，轻薄时尚，维护简单，也不失为年轻人的风格。四、西服的板型西服的版型对于很多人来讲是一个陌生的概念，事实上，市场上的西服通常有意大利板型、日本板型、国际板型和欧美板型之分，其中意大利板型较为浪漫自由，国际和欧美版型肩宽袖长，日本版型则是相对含蓄。目前在中国市场的西服，通常已经由各个厂商按照自己的想法进行了重新设计，并不能具体的归纳到某一个板型中，不过从大部分品牌来看，结合意大利版型和国际版型的款式最受欢迎，有着意大利版型原有的时尚并结合中国人的特色进行了修正，适合中国男性穿着。什么样的西服穿起来最漂亮？几件不同的西服都能合适的上身，但是效果却大不相同，什么样版型的西服穿起来最好看？这是绝大部分读者关心的问题，实际上，男装西服穿着美观的最大要点在于收腰效果。完美的男子体型应当是一个倒立的三角，西服在衬托了男性宽阔平坦的肩膀之后，腰部应当自然内收，才能体现男性特有的魅力。这特别对于年轻人尤为重要。当然已经挺着大肚子的中年领导们，不在我们的讨论范围内。裁剪精良的西服，可以很自然的做到这个效果，而一些裁剪设计粗糙的西服，或者与您身材不合的西服，穿上之后犹如套上了一个水桶，上下一样粗细，那就很失格了。五、西服的颜色和纹样男士正装西服可以选择的颜色余地很少，经典的正装西服只有深灰色和藏青色，黑色西服是出席婚礼、葬礼和重要场合的穿着。而现代的西服颜色稍微多了一些，但是依然以深色调为主。浅色:色泽亮丽清爽,给人赏心悦目之感。中性色:深浅适度,适应面广,可以适合不同年龄、不同季节穿着。深色:庄重深沉、严肃、凝重,适应于深冬或春寒料峭的季节和庄重的场面穿着。蓝色：给人以幽深，宁静的感觉，穿着富贵、高雅。灰色：成熟而又典雅，稳重而不失大方，充分体现个人的成就感和优越感，展现男人的成熟魅力。带条纹的西服是近年年轻男性的时尚选择，作为本文的读者，如果你希望选购您的第一套西服，不妨尝试选购一套黑底或者深灰底带有暗条纹的西服，注意条纹越不明显越好，越是只有仔细看才能看出来的，越显示您的品味，千万别穿一件条纹明显如斑马状的西服。而藏青色和铁灰色也是值得选择的。纯黑的西服过于正式，您可能没有多少机会穿着，过于浅色的西服又会使您太过惹眼，纯白的西服是明星和领导人物的专利，您就别瞎掺乎了。如果希望章显时尚，可以考虑由一些大的暗方格面料西服，或者有一些独特设计的西服，比如挑袋边的，某个口袋缝制一个独特的拉链的等等，不过西服的时尚始终有一个限度，只能从少量的细节中去表现，如果整件衣服变得花里唿哨那就成了怪物。六、西裤西裤通常是和西服配套销售的，当然，也可以购买到单独的西裤。不过单独购买的西裤往往不能合您的西服搭配，而只能搭配衬衫，单件西服或者其他的上衣。西裤的搭配至关重要。长短适宜，不能过长，过长会影响视觉效果，行动也不方便；也不能过短，否则高个子会显得重心不稳，矮个子更是雪上加霜，显得更矮。其标准是在西裤收脚之后，自然站立状态下，西裤长度不能遮住皮鞋跟，也不能露出袜子，在这个范围内就属正常。裤裆不能过大，否则会给人不够整洁的感觉。西裤的面料目前都以垂性好、不起皱的为最佳、手感柔软，颜色淡雅，轻松飘逸。另外，近两年出现了前面无褶设计的西裤，是年轻人的时尚选择，适合腰围较小的年轻人穿着。如果您比较胖，还是选择传统的有褶款式吧。七、单件西服单件西服指的是没有配套西裤的西服，单件西服在传统意义上不能属于正装西服，因此采用的面料有更多的选择，棉，麻等都在其内。浅色的单件西服可以搭配深色的西裤或者同色的西裤，但是不能搭配更浅色的西裤。如果设计过于花哨，那就只能归于休闲装的行列了。单件西服可以在通常的工作环境中穿着，但是不宜在比较正式的场合穿着。八、西服的穿着和维护西服的穿着者，在不同的场合和不同的活动有不同的要求。我们以３粒单排扣西服为例，在室内直立行走时，出席重要场合时，拍照时，应当系上３粒扣中的上面２粒。坐下工作或用餐时，小步奔跑时，户外活动时，可以解开衣扣。穿着西服不允许卷起衣袖，西服不允许与衬衫之外的其他内衣搭配。西服通常要求和配套的西裤搭配，不要将不成套的西服和西裤混穿，尤其不要穿着深色西服搭配浅色西裤。这会使您显得头重脚轻。另外，穿着深色西服出门时，别忘了清除衣服上沾有的白色毛屑，一卷粘胶带也许能帮上您的大忙，当然，专用的工具自然更好。无论什么面料的西服，通常都是不能机洗的，即便它标明了可以水洗。如果你希望你的西服保持良好的造型的话，建议您还是送去干洗。一次图简单的机洗，往往会毁掉你的西服。干洗店会将你的西服进行比较专业的重新熨烫，能够对西服造型起到维持的作用。如果您自己有一支蒸汽熨斗，但是并没有专业的熨烫经验，请不要尝试自行熨烫西服。胸前的胸袋是装饰性的，不要剪开。衣袖上的商标在离开商场时就应当剪掉了。九、西服的品牌和选购著名的服装品牌通常都生产西服国外比如ARMANI，GUCCI，BOSS等等，香港的G2000，中国大陆的雅戈尔，报喜鸟杉杉等。中国是世界服装生产的中心，全球70%以上的西服都由中国制造，自然包括了国外那些著名的奢侈品牌，因此不要盲目迷信国外品牌。通常国外品牌的售价都是非常昂贵的，这些品牌产品的质量自然是一流，在各大商场都可以见到，这类品牌的售价一般都在人民币20005000元以上，甚至上万元，这对我们的读者来说，通常是不划算的。也许有的BOY会想到通过一些其他渠道购买所谓的“外贸货”，“尾单”，“跟单”等东西。实际上国际品牌的产品控制是非常严格的，在中国加工的时候，面料，辅料都是严格控制的，不可能有这么多“转内销”“尾单”一类的东西，它们通常都是假冒伪劣产品的代言词。因为要在西服商标上绣上ARMANI，或者BOSS的商标，那是再简单不过了。我在外贸店看到的所谓的BOSS尾单，连内衬的线头都没有剪干净，做工质量也就是200元的地摊质量，却要卖到“特价580”。因此，我给大家的建议是购买国内的大品牌西服。这些西服厂商生产的西服品质，绝对是世界一流，只是在最新的时尚设计前沿，稍微落后于国外。对于我们的读者人群来讲，是最佳的选择。国内的优秀品牌：雅戈尔和衬衫一样，在西服领域，雅戈尔品牌也是国内的领头羊，其设计生产的西服，不但质量一流，而且近年来创新不断，紧跟时代潮流，已经初显国际大品牌的风范。雅戈尔西服套装的正装售价如果是非纯毛面料，一般是在10002000元之间，纯毛面料则可以达到18005000之间。这个价格已经与国外品牌差距不大了，对于我们的大部分读者来说，是无法承受的，毕竟花掉一个月薪水买一件西服是很心疼的。然而幸运的是，雅戈尔品牌的西服常常出现大幅打折，纯毛套装可以打折到700元左右，而非纯毛套装和单件则可以打折到400500之间。以这个价格采购，自然非常超值。如果在当地没有遇到打折，也可以在ebay或者taobao的网店采购，该品牌通常是没有假货的。比较放心。香港的优秀品牌：G2000G2000是来自于香港的品牌，以生产和设计年轻人穿着的正装而知命。作为香港的普通品牌虽然和国际大品牌相比质量上还有差距，但是对于我们的读者定位却是很适合的。G2000西服的设计通常是针对年轻男性，而且针对身材比较匀称的男性，裁剪设计非常漂亮，只要您的身材适合他的产品，将有良好的穿着视觉效果，如果你比较胖那则比较遗憾，可能不会有你要的尺码。G2000产品的价格通常是套装15002000之间，单件8001200左右，也是在打折时购买比较划算，G2000套装的折扣同样可以打到500左右甚至以下。如果在当地没有遇到打折，也可以在ebay或者taobao的网店采购，该品牌通常也是没有假货的。比较放心。其他国产品牌，如报喜鸟、观奇、杉杉、利郎等，都具有良好的设计和一流的品质，只是笔者很少看到他们打折，一套西服上千的价格，恐怕绝大部分本文的读者都会难以承受，因为毕竟西服不是只有一套就可以，也不是一套可以穿一辈子。如果您发现一套知名品牌的西服价格打折到了500左右，而且您也很合身很喜欢，那就赶快把它买下来吧。如果是纯毛的，价格在800左右也值得考虑。当然，如果您觉得我说的这个价格太低，您衣柜中的衣服比我说的这些高档很多，那我只能抱歉的说，我要照顾的是本文所针对的特定的读者群，满足他们的需求。请不要考虑购买正价在800以内，折扣价在300以内的西服，因为一套做工精良的西服售价应该在这个以上。如果您没有充足的经验，廉价的西服从外观来看和优质的西服区别不大。其实除了面料上的差距以外，廉价的西服通常裁剪粗糙，穿着效果不好，最要命的是在洗涤几次之后很容易变形，起皱。男士正装讲究的是细节，领口，袖口，尾摆上的一点瑕疵，足以让您的服装格调掉几个档次。西服的寿命比衬衫长很多，只要维护得当，一套西服穿上5年不成问题比电脑用的久，一套品质优良的西服，也许会伴随您走过事业发展的黄金时期。所以在西服上面的投资是值得的。属于长线投资。十、西服的尺寸比起衬衫来说，西服的尺寸就复杂很多，尽管国家制定了类似于衬衫的西服尺寸表，但是不同的版型和样式以及生产厂商的原因，两款尺码完全相同的产品也许尺寸差异很大。不过我们还是来看看尺寸对照表。体型分类代号净胸围与净腰围差值体型A1612cm正常B117cm偏胖C63cm肥胖西服尺码西服A版西服B版尺码型号尺码型号44A165/84A44B165/88B46A170/88A46B170/92B48A175/92A48B175/96B50A180/96A50B180/100B52A185/100A52B185/104B54A190/104A54B190/108B56A195/108A56B195/112B西裤尺码尺码（腰围）号型裤长尺码（腰围）号型裤长厘米英寸市寸厘米英寸市寸70282.1160/70A90342.7175/90B73292.2165/74A93352.8180/94B76302.3165/76A98362.95180/98B80312.4170/80A103383.1185/104C83322.5170/82A108403.25185/108C86332.6175/86A170/88A代表身高170CM胸围88CM体型为偏瘦。实际上您会发现雅戈尔的170/88A与杉杉的170/88A有很大差距。而同样腰围的西裤裤管粗细也会不同。因此，西服和西裤的选购，最好是请自上身式穿，否则很难适合。如果一个品牌没有适合你的尺码，不妨尝试另外一个品牌，西服合身的标准为：1、双手自然下垂，袖长距离手虎口2CM左右，不能到达虎口，也不能露出手腕。2、扣上前扣，可以从衣领轻松的放入一个拳头。无法扣拢不行，空隙太大也不行3、双手握拳放于胸前，双肘可轻松举起到水平状，背部感到一定拉力，但是并不过分紧绷。西裤一般只要腰围合适能够方便的穿脱即可。量身定制的西服尺码一定是最佳的。第五章：皮鞋一、关于皮鞋这里的男士皮鞋指的是和正装搭配的单鞋，运动鞋，陆战靴一类的鞋不适合于正装搭配。休闲鞋与正装鞋之间只有一步之遥，不过还是有一些一般规则可供遵循。正装皮鞋不应该选择明亮颜色的。标准的正装皮鞋都是黑色、棕色和科尔多瓦皮革色的。系带皮鞋仍然是高品位的象征。图为登喜路系带正装皮鞋二、皮鞋的面料皮鞋的面料，很自然应该是皮革的，通常在市场上能够见到的皮鞋面料有以下几种　　1、头层牛皮头层牛皮有明显的皮革花纹，毛孔，柔软舒适有质感，但是并不是很光亮。通常头层牛皮会被加工成“荔枝纹”表面的皮鞋，此类产品是牛皮中的上品。　　2、二、三层牛皮现在的皮革加工技术可以将牛皮揭开为很多层，头层以下的我们归为此类，此类牛皮没有明显的皮肤表面纹路和毛孔，厂商在涂漆之后使皮革光亮如镜。此类皮革光洁度高，容易擦得很亮，但是硬度偏硬舒适度差，容易产生明显折痕。3、猪皮，猪皮是相对低档的真皮面料，也是被大部分皮鞋厂商采用的最多的，猪皮的柔韧性不如牛皮，但总体上来讲和牛皮比较接近。属于中档面料。猪皮同样分为头层和下层。　　3、羊皮羊皮质地比牛皮更加柔软，光泽度和强度不如牛皮，通常在正装男鞋上比较少见，而是在女鞋上比较多见。穿着舒适，属于皮鞋用料中的上品　　4、蟒蛇皮、鳄鱼皮这两样都是贵族皮鞋的象征，不知道有没有恐龙皮阿~~呵呵。价格昂贵，至于特性嘛自然就比牛皮还好咯，笔者可没有买过。　　5、南韩皮、PU皮、法国皮此类均属于人造皮革，并非真皮。人造皮革近年来技术不断发展，很多特性已经与真正的皮革不相上下，但是依然有透气性不够，耐久度不够等缺点。但是价格相对低廉。皮鞋是否为真皮，这一直是困扰国人的一个话题，真皮之所以昂贵在于其的天然，内在物性和原材料的不易取得，而仿皮以它的价格，表面效果的变化以及某一方面的特殊物性而拥有市场。在一些讲究内在物性的行业，如制鞋，成衣，真皮比仿皮有优势：但一些对内在物性要求不高的行业，如皮具手袋，家具沙发等，仿皮的市场比较大，笔者对某些假冒伪劣产品用假皮制鞋然后打真皮的牌子的做法很鄙视，这样一来穿着不舒服，不透气，二来物性不好，容易坏。目前的市场上有很多的皮鞋，为了降低成本，一般都会用部份真皮和部分仿皮拼在一起做，或者用二层覆膜（在二层皮上用PU做一层假面，这样一来透气性就差很多了）来取代真皮，如果不用在主要部位应该没所谓。如果是完全的真皮鞋，因为真皮的天然性，在主要部分用好一点的没有伤残的来做，在一些次要部位（如鞋舌等不受力的部位），会用一些差一点的伤残较多一点的来做，这是很正常的，也是鉴别真皮与假皮产品的一个很好的办法，毕竟你不能把人家的鞋子割开来看是否有绒面来鉴别吧！以目前的市场价位，在一般城市的大多数的鞋店里面，在人民币150元以上就可以买到真皮的皮鞋了，而低于这个价位，又不是在正规的鞋店里面，就要小心了，特别是那些露天小商贩叫卖的便宜货，如果你不是专业人士（就算是专业人士也要小心，千万别贪小便宜，那9成9是骗人的。在一般正规的鞋店里面，150元左右可以买到一双二层皮的皮鞋（即表面有磨过，并且经过重涂饰的皮革，透气性不好），150元到300元可以买到一双头层猪皮的鞋，300元以上就可以买到一双比较高档一般用小牛头层皮等做的鞋了。总的来说，识别面料是否为真皮，的确没有简单明确的方法，靠的是经验，品牌。三、皮鞋的款式简单的说，男士正装单鞋分为系带式和简便式，系带式是经典的正装款式，近年来简便的松紧式皮鞋也成为了正装的选择。无论是系带式还是简便式，目前的主流是不尖不圆也不扁的合适造型，皮面不能过于光洁亮眼，最好是头层牛皮的亚光质感，如果光洁如漆惹人眼目反而是失格的。正装皮鞋一定是有跟的，正装男鞋的高品质鞋跟应当是木制的，当然，底部衬有橡胶耐磨层。木制鞋更轻便结实不易变形。只需要用手指甲轻轻敲打即可分辨，木质鞋跟坚硬，发出塔塔声，而塑料鞋跟质软，敲打质感明显不同。图为金利来简便式男士正装皮鞋。正装皮鞋上不宜有太多装饰品，当然标明皮鞋身份的商标例外。而悬垂的金属链条，饰品和花饰则会让您显得像一个马戏团的小丑。四、皮鞋的穿着正装皮鞋的穿着非常简单，需要注意的是皮鞋应当保持洁净，有条件的情况，您应当随身携带一些纸巾以便擦除皮鞋上的灰尘。五、皮鞋的品牌与选购中国是皮鞋生产大国，全球的皮鞋几乎都被中国所垄断。即便是那些世界名牌产品，其出厂地往往也在中国温州的某个工厂里。对于本文的读者来说，摆在大商场柜台中的世界名牌，Dunhill，GUCCI太过昂贵，通常售价是在人民币1000元以上。谁会轻松的用自己一个月或者办个月的薪水去购买一双皮鞋呢？通过一些其他渠道购买所谓的“外贸货”，“尾单”，“跟单”等东西。它们通常都是假冒伪劣产品的代言词。因为要在皮鞋上钉上Playboy，或者BOSS的商标，那是再简单不过了。而来自国内或者香港的一些优秀品牌，具有和国际品牌同样的品质乃至设计，才是我们应当选择的对象。中国大陆的优秀品牌：森达、康耐、红蜻蜓国产名牌皮鞋具有一流的做工，坚固耐用，货真价实。售后服务良好，以上三个品牌在各大城市均有销售，通常价格在350500元左右，高档皮面可能会卖的更贵。打折的时候一般会低到200以下，这个时候购买就非常划算了，当然你也可以在ebay或者taobao上寻找折扣店。通常是没有什么假货的。香港的优秀品牌：金利来，卡迪乐鳄鱼金利来，男人的世界。金利来男装和皮鞋在中国消费者心目中有着很高的位置，事实上金利来皮鞋也一直以优质著称，并且价格并不像大家想象的那么贵。卡迪乐鳄鱼是和法国鳄鱼并列的著名品牌，商标上两个鳄鱼的嘴巴朝向不同。这俩个品牌的普通档次产品都在500多左右，低档一些的3400之间。折扣价也在200以下，如果你没有遇到折扣，也可以在ebay或者taobao上寻找折扣店。通常也是没有什么假货的。总之，一双知名品牌的正装男鞋零售价应当是在150元以上，如果您在200元以下买到就应当是相当实惠了。不要在不值得信任的商店购买零售价在100元以下号称真皮的皮鞋，尤其是低于50元的，这类皮鞋的寿命一般不会超过一个月。但是在大型超市销售的价格接近100元的皮鞋，品质还是比较过的去。如果您有两双优质的皮鞋换着穿，他们可能会有一年半到两年的寿命，如果你还穿着运动鞋和其他鞋，他们的寿命会更长，当然免不了一些小的修补。这类皮鞋的损坏通常是鞋跟和鞋底的磨损造成的，鞋身本身并不易坏。这类皮鞋只要送到专业的皮鞋美容店更换一下鞋底的耐磨层，就可以延长半年到一年的寿命，因此如果比较节俭，一双皮鞋穿3年没有问题。所以你可以衡量你的投资其实并不算大。第六章、配件一、皮带皮带是男士正装必需要的配件，虽然皮带绝大部分时间隐藏在您的西服下，但是常常也会显露出来。如果全身上下光鲜亮丽，而系着一根破旧的皮带，将会使您显得非常失格。皮带的品质和品位是由皮带的材质，带扣和工艺决定。通常皮带的材质有多种，猪革、牛皮、羊皮、鳄鱼皮，仿皮以及休闲的帆布等。从实用的角度来讲，皮带要承受较大的张力，尤其是带扣的地方，常常会受到磨损，因此通常的男士正装皮带，以坚固耐用的牛皮为佳，鳄鱼皮当然更是极品。无论如何，男士正装皮带不能是仿皮，因为目前的各种非真皮材料，在强度和耐久度上依然无法和真皮相比，寿命短是他们的特征。帆布等材质是不能作为正装皮带使用的。真皮皮带的售价通常在人民币50元以上，品牌产品价格可以高的离谱。如何识别皮带是否为真皮呢？通常我们见到的皮带有两种形式　　1、单层皮带由一层皮革制成，取下带扣观察皮带的截面即可看出，此类皮带只要价格没有低的离谱，通常都是真皮产品。另外，也可通过测试的方法来鉴别。真皮皮带用力弯折之后，折痕不明显，而且短时间就可以恢复，而仿皮革则没有这个效果，低劣的甚至会破损。　　2、两层或多层皮带此类皮带是由2层或3层皮革缝合而成，取下带扣观察皮带的截面即可看出，此类皮带是最容易被制造商作假的，通常的做法是采用一层3层皮和一层PU皮，有的甚至中间还有海绵状填充物。测试方法和单层皮带类似，同时也可以在截面处用指甲试图剥离皮带表面的颜色层，如果能剥离开，则证明是仿皮无异。皮带的材质颜色和花纹，各种质地的皮带由于加工鞣制过程不同，而呈现出多样的风格。猪皮和羊皮经剥离分层后，更为柔软?r牛皮有种身骨硬挺的感觉?r鳄鱼皮则是档次较高的选择。皮带上的压纹和肌理效果，使其更具魅力和特色。通常的正装男士皮带一律应该是黑色的，而且必须封边。咖啡色的皮带很少能够搭配像样的正装。皮带的带扣是体现皮带档次和品牌含量的地方，著名厂商的设计师们设计了各种各样的带扣，纯金的钩扣时常是同高贵、优雅一类的词联系在一起?r铜质的钩扣则让人领略到男性的阳刚和力量。另外，钩扣的造型、大小也表现出男人的魅力。宽大的“回”形带扣充分显露出男人的刚毅?r椭圆形带扣展示了男人们的成熟?r方形代表着品味。而这些带扣的品牌亦成为男性身份的象征。一如金利来带来的成功?r一如Gucci是优良质量的标志。对于本文的读者来说，购买纯金的带扣似乎不是很现实。因此，我们通常所购买的皮带带扣是不锈钢或者铸铁材料+电镀表层。对于这类带扣，记住一个原则，带扣上的塑料含量越少越好，金色永远比银色容易退色，粗糙的边缘和拐角也许会划伤你自己或者你的朋友。因此，选购一款拥有良好带扣的皮带，是您信心的保证。系皮带时应注意几个细节。首先，皮带的装饰性是第一，所以不能携挂过多的物品。简洁、干练才是男人的特征。其次，皮带的长度是不应忽视的，系好后的皮带，尾端应介于第一和第二裤绊之间。第三，皮带的宽瘦应保持在三厘米。太窄，会失去男性阳刚之气?r太宽只适合于休闲、牛仔风格的装束。目前皮带和钱包一样，是皮具市场假货最为泛滥的产品，如果你希望购买真正的品牌产品，最好还是到信得过的大型商场，别忘了检查商品的800防伪识别码。这些产品的售价一般在200300人民币以上，国外品牌则是在500800人民币以上。拥有世上潮流设计的新款则可以卖到上千元。本文的读者如果希望图实惠，精仿的制品其实也是不错的选择。比如您发现了一款漂亮的金利来皮带，也确认它是真皮品质，包装精美只是没有防伪码一类的东西，但是价格只需要100元或者80元。拿这就是我们说的精仿品无异。这类产品其实也是值得选购的，具有实用性。二、公文包公文包是男士上班族不可缺少的伴侣，即使您并没有什么重要的东西需要家里和公司之间带来带去，两手空空的上班，始终让人感觉少了什么。公文包通常应当是真皮制作的，猪皮，牛皮，羊皮均可。而且，如果是刚刚入职的菜鸟，拎上一个黑色帆布制作的笔记本电脑包也并不失格。幸运的是，公文包同皮带比起来，假冒真皮的现象少了很多，因为体积大，皮面广，容易识别。近年来，各大品牌的公文包设计都简约、轻便。体现了质轻、结实、使用方便、易于提携等特点，即使是双格款式也没有层层叠叠的外观，整体设计倾向于既可上班又可上街的轻盈精巧型。质料方面，具有高雅感觉的柔软小牛皮和特种帆布是首选。　另外，公文包的内部机构更加完善且风格日趋多元化。比如专为公务出差用的旅行包配公文包，包括独特两用设计，包内公文包可单独使用；主体包有一个文件袋，公文包则设计别致而实用，主分隔区内有存放文件和留言便笺的小分隔区。除传统造型的公文包之外，还有一些是为年轻人设计的款式。一种是粗纹牛皮挎包，包体外侧备有插笔袋及各种大小规格的贴袋，可用来装手机、名片等物件，方便时髦，用途广泛。另外一种是为年轻时尚一族设计的提篮式公文包，造型简洁、个性十足。对于本文的读者来说，笔者推荐没有固定背带的横式公文包，大小不宜太大，背带会使您情不自禁的将公文包跨在肩膀上，这样的做法会损坏您西服的造型。记住穿着正装时，公文包应该是拎在手上，不是跨在肩上。不要把爸爸的旧公文包拎到公司，而是让你新买的公文包随着您的阅历一起变旧。制作良好的真皮公文包通常售价都在250人民币以上，知名品牌会在500800元以上，国外品牌则会更高，至于上过杂志的时尚设计，没有几千九拿不下来了。对于本文的读者来说，选购公文包您可以遵循上面所说的选购皮带的原则。由于公文包通常只需要配备一个，建议您选择黑色。三、袜子袜子只有一个原则，选择和您的皮鞋颜色接近的纯棉袜子。如果您的皮鞋和西裤是黑色的，那您的袜子一定要是黑色的，如果您穿了一双白袜子，那可就犯了大忌。四、手表现在人们都习惯了使用手机来获取时间，事实上男士正装的精典搭配应当是一块手表。男士手表是昂贵的产品，当然如果您不想购买手表，那也是无所谓的。男士正装所搭配的手表，应当是金属质感十足的，切忌不可是时尚的塑料材质，笔者曾经见到有某君一身正装，做手上戴着一块蓝色时装表，一问才知道是女朋友送的情侣对。此君还非常得意，我这可是“TIMEZONE”。记住一点，漂亮的时装表只能和女士的时装搭配，不能搭配男士正装。男士的手表应当是怀旧的金属表，您的手表越时尚，越具有太空色彩，在别人眼里您的品味也就越低。金属质感的手表来说，机械表好过石英表，手动上铉的机械表好过飞摆自动上铉的机械表，如果您有一块瑞士手工制作的机械表，那自然是顶级的选择。优质的名牌手表都是昂贵的，对于本文的读者来说，欧洲制造的手表几乎是天价。而日本制造的产品相对还可以接受。无论是欧米加，西铁城还是精工，都有1000元以下的款式。当然作为年轻人，选购一块外观过的去的石英手表也是不错的选择，这样的手表可以在500元以内买到。不要购买300元以内的机械表，150元以内的石英表，他们的寿命短的可怕。年轻人不要购买金色的手表，最好是银色。第七章：服饰搭配一、颜色知识记住三种颜色：白色、黑色、米色这三种颜色被称为“百搭色”。也就是说他们和任意的颜色搭配都是合理的，因此购买服饰的时候如果不知道什么颜色好，那么着种颜色将不会出错。男士正装的色彩应该是深色系的。二、正装的合身正装讲究合身，衣长应过于臀部，标准的尺寸是从脖子到地面的1／2长；袖子长度以袖子下端到拇指11cm最为合适；衬衫领口略高于西装领口；裤长不露袜子，以到鞋跟处为准；裤腰前低而后高，裤型可根据潮流选择，裤边不能卷边；这些均是穿着西装的基本搭配，体现正装的规范性。三、以领带为核心的搭配衬衫和领带的搭配是一门学问，若搭配不妥，有可能破坏整体的感觉，但是如果搭配得巧妙，则能抓住众人的眼光，而且显得自己别出心裁。领带永远是起主导作用的，因为它是服装中最抢眼的部分。一般说，应该首先把注意力集中在领带与西服上衣的搭配上。以比较讲究的观点看，上衣的颜色应该成为领带的基础色。白色衬衫穿在每个男人身上都非常出色，适用于各场合，且不会过时，所以每个男人至少应该准备一件可换洗的白衬衫，它和各种活泼的颜色或花样大胆的领带搭配都不错。永恒的时尚搭配是白色或浅蓝色衬衫配单色或有明亮图案的领带。这是永不过时的搭配。在服装搭配之道中，简单永远讨好。如果你对自己选择领带的品位不那么自信，就不要企图标新立异。要知道，多数男人对于图案的感觉都不怎么样。不仅如此，你永远不知道自己“与众不同”的品位可能会引起什么人的反感。衬衫与领带的搭配在某种程度上还反映着你为人处世的老练程度。每位男士都应该至少有一件白色或浅蓝色的领部扣扣衬衫。在领带方面，至少有一条纯藏蓝色或葡萄酒红色的领带供白天使用，还应该有一条丝质织花领带或纯黑色领带以备在参加正式晚宴时代替领花使用。一般从颜色搭配的角度讲，主要应注意以下几点：1.黑色西服，穿以白色为主的衬衫和浅色衬衫，配灰、蓝、绿等与衬衫色彩协调的领带。　　2.灰西服，可配灰、绿、黄和砖色领带，穿白色为主的淡色衬衫。　　3.暗蓝色西服，可以配蓝、胭脂红和橙黄色领带，穿白色和明亮蓝色的衬衫。　　4.蓝色西服，可以配暗蓝、灰、胭脂、黄和砖色领带，穿粉红、乳黄、银灰和明亮蓝色的衬衫。　　5.褐色西服，可以配暗褐、灰、绿和黄色领带，穿白、灰、银色和明亮的褐色衬衫。　　6.绿色西服，可以配黄、服脂、褐色和砖色领带，穿明亮的银灰、蓝色、褐色和银灰色衬衫。除颜色搭配外，还应特别注意领带与衬衫领口的搭配：领带有多种常用系扎方法（详见领带一节），那么在日常生活中，到底该用哪种好呢？一般情况下，除受流行因素的影响外（如西服驳头的宽窄影响到领带的宽窄，进而影响到领带结的大小，主要是根据所穿衬衫领子的形状领尖夹角的大小来选择的，现在市场上的男衬衫，从领形上分，有以下几种在前面的衬衫一节中间讲过：　　1.标准领regularcoIlar，由于领型普通，所以最容易搭配，无论什么领带都可以尝试与之搭配，而且还不必挑剔领带的图案。　　　　2.宽角领wide一spreadcollar，也叫温莎领这种领形适合系温莎结形的领带，而且一般与英国式的西服相搭配。是当年温莎公爵带头兴起的。但近年敞角领的衬衫流行与打得稍小的半温莎领结相配，这种搭配能于复古中反映近年来精致的现代思潮。　　　　3.带扣尖领button一downcollar，这种领形的领尖夹角一般等于或小于标准领形，因此适合系单温莎结或普通结。　　4.有襻领tadcollar，这种领形因夹角较小，所以一般系普通结。　　5.针孔领pinhole　colIar，适合系普通结。　　6.小方领shrotpointcoIlar，一般系小温莎结或普通结。　　7.冀形领wingcollar，一般系蝴蝶结而不系普通领带。　　8.立领standupcollar，通常不系领带四、以衬衫为核心的搭配纯色衬衫永不败无论你是何种体型，纯色衬衫尤其是白衬衫毋庸置疑是绝对必需品，搭配任何颜色之西装，都能有压倒性的效果，也容易给人朝气、干净之感，因此，一次购买数件白色衬衫是无罪的。尤其男性又特别容易汗流浃背，衬衫的寿命自然缩短，一旦衬衫发黄，便回天乏术了。条纹衫较保险一般而言，只要线与线之间的间距不要过大，线条不致于过粗，都是可以接受的。最安全的条纹尺度，其条纹间的间距小于1厘米，并以规则的距离排列，线条宽度极细，有如自动铅笔划过之线条，即为不易出错的样式，值得推荐。格子衫要慎穿就如同条纹衬衫一般，格子的面积若是呈微小保守的细格子，大致没啥问题，但若格子的面积甚大，休闲味道便浓厚，此时就不适宜于工作等正式场合穿着，因为无法传达出庄重之惑，而在平常假日休闲时刻，倒是很不错的打扮。衬衫与体型的搭配如果你是虎背熊腰型，那么过于明显的条纹、格子图案就不适合你：如果你是中等型，挺度与厚度较高之布料衬衫，可以和你配合；如果你是下盘稳重或是长脚高个儿型，条纹、格子衬衫跟你很速配；如果你是矮胖型，素色是你唯一的选择。颜色搭配通常，衬衫的颜色应该与领带上次要颜色中的一种相配。一般而言，领带上的图案应该比衬衫上的更显眼。有时，可以选择图案都很鲜明的衬衫和领带。但是，千万不要让衬衫上的图案压过领带上的。如今，在衣着上十分流行色调一致的单色搭配。如果你想时髦一把，不妨试试同一色调的衬衫和领带。在这种搭配中，领带的颜色应该比衬衫的颜色暗，但它们也可以是完全相同的颜色。经典搭配永恒的时尚搭配是白色或浅蓝色衬衫配单色或有明亮图案的领带。这是永不过时的搭配，而且适合任何场合。五、以西服为核心的搭配鲜艳颜色的西服宜配灰色、黑色、白色或同类色高明度的衬衫；暗色西装内宜衬浅色衬衫；单色西装视礼仪性场合的气氛配穿花色或条纹格类衬衫。01纯色的西服适合搭配条纹的衬衫+纯色或小图案领带01条纹西服适合搭配纯色衬衫+小图案领带01深色西服搭配浅色衬衫和深色领带01浅色西服搭配深色衬衫和浅色领带西服、衬衫、领带不能够颜色过于接近，比如全黑，全蓝，都是错误的搭配。如果穿了一件黑色西服+深色衬衫，那么你呢领带一定需要是浅色的。反过来亦然。在服装搭配之道中，简单永远讨好。如果你对自己选择领带的品位不那么自信，就不要企图标新立异。要知道，多数男人对于图案的感觉都不怎么样。不仅如此，你永远不知道自己“与众不同”的品位可能会引起什么人的反感。总的来说西服、衬衫与领带的搭配在某种程度上还反映着你为人处世的老练程度。六、整体与配件整体搭配的三色原则在这里需要再次强调三色原则是在国外经典商务礼仪规范中被强调的，国内著名的礼仪专家也多次强调过这一原则，简单说来，就是男士身上的色系不应超过3种，很接近的色彩视为同一种。对于附件来说，您的皮带，皮鞋和公文包，应当保持同一个颜色。黑色是这些皮具的最佳选择。不能穿着深色的西服+浅色的皮鞋。但是浅色的西服搭配深色的皮鞋并不失格。袜子一定要和西裤与皮鞋溶于一体，不能“阁外耀眼”。七、头发穿着正装的工作男士应当是干净的短发，在中国的审美观看来，男士不可染发。除非您是从事娱乐和艺术行业。==============================八、休闲裤UKSN优卡绅休闲男装品牌潮流时尚：杰克琼斯，GXG，卡宾，antszone，诠渡良品等等。成熟商务：九牧王，七匹狼，红豆，与狼共舞，圣得西等等。2012休闲裤排名是：第一：柒牌第二：劲霸第三：九牧王第四：七匹狼第五：长城鹿。===================================夹克外套品牌夹克外套是人们休闲生活中一类比较常见的服装外套，特别是男性朋友，在衣服选择的广度上远低于女性，因此夹克外套就成为了男士们休闲生活种最常见的春秋季外套。那么男士夹克品牌有哪些?怎样才能买到自己满意的男士夹克品牌衫呢?在普通人的观念中，夹克的款式比较单一，其实随着夹克的进步，男士夹克品牌不同款式的夹克也应运而生，传统款、西装款和军装风款夹克比比皆是，这些夹克造型轻便，非常富有朝气，是男士们春秋季节的最佳外套。夹克和西装是男士服装主打外套，从趋势上看，夹克已超越西装，成为更多男士的服装的首选，这里介绍一个比较权威的男士夹克品牌排行榜，品牌不是一天炼成，它有一个长期的综合的积累，要在多方面做到优秀是不容易的，品牌树立起来后，就有了一个标竿，代表了时尚潮流和品味，代表了盛誉，代表了品质，代表了标准，网上购买服装不比在商店里，因为不能看、不能摸，也不能试，你没办法知道即将寄给你的服装质量怎么样，做工是否精细，手感是否舒适，面料是否流行，尺寸是否准确，只听卖家说还不能完全放心，那怎么办，那就只有相信品牌了。一般来说，卖家不能完全相信，但好的品牌是不会骗你的，这里把十大男士休闲服品牌给你列出。目前十大男士夹克品牌有1.劲霸中国驰名商标,中国名牌,一线品牌/牌子,十大男装品牌2.柒牌中国驰名商标,中国名牌,十大男装品牌3.七匹狼中国驰名商标,中国名牌,一线品牌/牌子,十大男装品牌4.利郎中国名牌,一线品牌/牌子,十大男装品牌5.虎都中国驰名商标,中国名牌,十大男装品牌6.九牧王中国驰名商标,中国名牌,一线品牌/牌子,十大男装品牌7.才子中国驰名商标,中国名牌,一线品牌/牌子,十大男装品牌8.太子龙中国驰名商标,十大男装品牌,知名品牌9.Boss波士HugoBoss创于1923年德国,中国驰名商标,十大男装品牌10.Dior迪奥Christiandior始于1946年法国,十大男装品牌其他男士夹克品牌我没穿过，但七匹狼的夹克我穿过，劲霸夹克我买过给我父亲，七匹狼的夹克和劲霸夹克的价格是差不多的,但是七皮狼的衣服比较适合中年人!而劲霸是适合年轻人穿多一点!选劲霸，场面，而且不贵，劲霸应该说是夹克中的NO.1", "life/篮球、跑步中悟道.md": "篮球中悟道1.不要因为别人的能力不够而批评他一个机会合适的投篮，即使不进篮框，也不应该埋怨、批评或给脸色看。他也许很渴望进这个球。一个人经常因为能力不够，做事总出错，那么要宽容他的错误，不要劈头盖脸的批评他。这有几种情况，第一，他可能很尽心尽责，但是确实是能力不行，而非有意，此时批评，容易招致怨恨。第二，他可能是无意犯错，此时批评，容易打击他的积极性。第三，他可能是粗心大意，那么他该被批评，但是如果宽容了他，他会更用心做事。2.不要作意气之争在球场上队友或对手经常会有意或无意说一些不正当或挑衅的话，不要被这些话激怒，不要去想着在言语上争个上风，一切意气之争都无助于比赛的胜利。君子无所争。人们平时的分歧、争执或矛盾，多是意气之争，只是想在言语上使对方屈服，到了最后分歧意见的本身被忽略了，只要有口头上快感和对别人屈服一刹快感就可以了。跑步中悟道1.选择合适自己的步伐每一个人的体能和意志都不一样，要想跑的更远，跑的更长，我们必须选择合适自己的步伐。不能太快，也不能太慢。太快了，体能消耗太快，可能才跑了一两圈，就被别人甩掉。太慢了，慢慢的自己也没有信心，最终可能自己放弃。人生就想长跑，谁能不停的跑，不论他的速度是快是慢，他最终能跑出自己的一片天空。一时高兴和冲动，可能开始时干得很起劲，刚做的厕所只有三天香，过了三天就放弃了。而总是不慢不紧，悠闲自得，会慢慢失去激情，最终不了了之。乌龟为什么胜了兔子，就在于此啊。2.坚持自己的个性与方式在长跑锻炼身体时，跑道上，有人在超越你，有人被你甩掉。不要看到跑得比起你快的人，就加速跟随；也不要看到比你跑得慢的人，就觉得自己已经领先，骄傲满足而沾沾自喜，从而放慢自己的步伐。跟随比你快的人，你会被托跨，看齐比你慢的人，你的动力和意志最终会被消耗掉。不为物喜，不为己悲。看到别人取得成就，觉得自己应该按照他的方式来，那样会扰乱自己的计划和进度。看到别人不如你，就做起兔子来，消耗自己动力和意志，最终一事无成。3.不断激励自己长跑时，选择最内的跑道，而不选择靠外的跑道。同样的体能，选择圈最小的跑得，就会跑更多圈。每一个肯定更喜欢说自己跑了6圈，而不是4圈，尽管6圈不一定比4圈长。当你能轻松的跑6圈时，要尝试跑7圈；当你觉得你可以加快你的步伐而不会很累，那么跑快一点吧，只要你能坚持。在做一件事时，首先要选择一点而发力，这一点要能很容易使你取得成绩，而能给予你信心；不要一开始就选择最难啃的骨头，啃不下去时，自己可能失去信心而放弃，这就是半途而废了。不断挑战更大难度和更高的高度，使自己能不断的提升。", "life/职业规划.md": "TOC做一个技术管理型的技术总监。技术不是拿来炫耀的，也没有高下之分，不能解决问题的技术都是无用，脚踏实地的解决工作中各种问题。从以下四个方面提升自己：研发管理团队建设：精通如何建立一个团队、培养一个团队。团队行事制度：需求、设计、实现、测试、发布、运维各个环节标准和规范，以及各个阶段的衔接。产品规划规划一个产品很难，需要对行业和业务特别熟悉，也需要机会。将一个产品细化，让开发人员能实现，这个是业界最缺少的。编程架构基础的常用的技术一定搞透，要精通不能一知半解，比如：linux、mysql、redis、activiti等。紧随前沿技术，不一定精通，但一定不能一无所知。搜集各种技术架构案例。为人处事改掉急躁的性格，一些话藏在心里不能说出来。改强势不能苟且。逻辑清晰的表达能力。协作：为他人查漏补缺，顺势而为。", "life/评论- 如何阅读一本书.md": "每一个接受正规教育的人，从古至今，没有一个能脱离阅读的。阅读的对象既可以是美好的，又可以是丑恶的；既可能是健康的，也可能是霉变的，既可能是艰深的，又可能是肤浅的。但是无论如何，通过阅读，自己的心灵和外部世界、和古典先贤、和社会各个层面、和知识各个层次产生了联系。这种联系，将雕刻出不同的灵魂塑像。阅读，在今天已经有了更多的形式，比如网络，比如电视等传媒。阅读就是传播与接收的互动。无论是什么形态，阅读几乎可以说是一种本能了，从人类进入信史或者说，人类进入文明史之后，直到今天，依然是。古，但不老。在当前色彩斑斓的世界里，阅读依然是一项基本的人生技能。特别提醒：这份文字以下部分属于读书笔记，摘录的东西比较多，因此，如果没有兴趣读下去的兄弟姐妹们，请到此为止。读书挺多年，自己是否真的知道如何读书呢？要解决自己的问题包括：昏昏欲睡问题，东一榔头，西一棒棰问题，记忆问题，横向掌握问题等等。“伟大的作者经常也是伟大的读者，但这并不是说他们阅读所有的书。只是在我们的生活中，阅读是不可或缺的。在许多例子中，他们所阅读的书比我们在大学念的书还要少，但是他们读得很精。因为他们精通自己所阅读的书，他们的程度就可以跟作者相匹敌。他们有权被称作权威人士。在这种状况下，很自然地，一个好学生通常会变成老师，而一位好的读者也会变成作者。”发现了一本目前感觉伟大的书《如何阅读一本书》，有一个一野心：让自己成为一个伟大的读者。根据莫提默・J.艾德勒（1902－2001）――学者、教育家、编辑等多重面貌享有盛名。除了主编《西方世界德经典》，担任1974年第十五版《大英百科全书》的编辑指导――所作《如何阅读一本书》的论述，读书可以分为四个层次：基础阅读，检视阅读，分析阅读，主题阅读。一、基础阅读是：大致可以分为四个阶段――第一个阶段――阅读准备阶段――相当于学前教育或幼稚园的学习经验。第二阶段――认字――相当于一年级学生典型的学习经验（尽管相当多正常的孩子在某方面来说并非都很“典型，'）。这个阶段的成果是，孩子学会了我们称之为第二阶段的阅读技巧，或是一年级的阅读能力，或最初级的读写能力。第三个阶段――字汇的增长及对课文的运用――通常是（但非全面性，就算正常孩子也一样）在四年级结束时就学会的方法，这个阶段的成果可以称作是“四年级读写能力\"fourthgradeliteracy或是“功能性读写能力\"functionalliteracy也就是有能力很轻易地阅读交通号志，或图片说明，填写政府的有关简单表格等等。第四个阶段，也就是最后一个阶段，到这个时期，学生要从小学或初中毕业了。这个阶段有时候称之为八年级、九年级或十年级的读写能力。在某方面来说，这个孩子已经是一个“成熟”的阅读者，他几乎可以阅读所有的读物了，但是却还不够老练。简单来说，他的成熟度是可以上高中的课程了。　　无论如何，他还不是“成熟的”阅读者。但他已经精通第一层次的阅读，如此而已。他可以自己阅读，也准备好要学习更多的阅读技巧。但是他还是不清楚要如何超越基础阅读，做更进一步的阅读。一般来说，基础阅读的四个阶段都有一位老师在旁指导，回答问题，消除在这个阶段会出现的难题。只有当一个孩子精通了基础阅读的四个阶段，才是他准备好往更高层次的阅读迈进的时候。只有当他能自己阅读时，才能够自己开始学习。也只有这样，他才能变成一个真正优秀的阅读者。二、阅读的第二个层次称为检视阅读：检视阅读，才算是真正进人阅读的层次。检视阅读又分为两种情况：有系统的略读或粗读和粗浅的阅读。（一）所谓“有系统的略读或粗读”是指：在――第一，你并不知道自己想不想读这本书。你也不知道这本书是否值得做分析阅读。但你觉得，或只要你能挖掘出来，书中的资讯及观点就起码会对你有用处；其次，让我们假设―常会有这样的状况―你想要发掘所有的东西，但时间却很有限――的情况下，做“略读”（skim）整本书，或是有人说成是粗读preread。略读或粗读是检视阅读的第一个子层次。你脑中的目标是要发现这本书值不值得多花时间仔细阅读。其次，就算你决定了不再多花时间仔细阅读这本书，略读也能告诉你许多跟这本书有关的事。当你浏览过后，你可能会发现这本书仅只是对你目前有用而已。这本书的价值不过如此而已。但至少你知道作者重要的主张是什么了，或是他到底写的是怎样的一本书。因此，你花在略读这本书上的时间绝没有浪费。对于这种阅读状态，作者的建议是1先看书名页，然后如果有序就先看序。要很快地看过去。特别注意副标题，或其他的相关说明或宗旨，或是作者写作本书的特殊角度。在完成这个步骤之前，你对这本书的主题已经有概念了。如果你愿意，你会暂停一下，在你脑海中将这本书归类为某个特定的类型。而在那个类型中，已经包含了哪些书。2研究目录页，对这本书的基本架构做概括性的理解。这就像是在出发旅行之前，要先看一下地图一样。3如果书中附有索引，也要检阅一下―大多数论说类的书籍都会有索引。快速评估一下这本书涵盖了哪些议题的范围，以及所提到的书籍种类与作者等等。如果你发现列举出来的哪一条词汇很重要，至少要看一下引用到这个词目的某几页内文。你所阅读的段落很可能就是个要点―这本书的关键点―或是关系到作者意图与态度的新方法。4如果那是本包着书衣的新书，不妨读一下出版者的介绍。许多人对广告文案的印象无非是些吹牛夸张的文字。但这往往失之偏颇，尤其是一些论说性的作品更是如此，大致来说，许多书的宣传文案都是作者在出版公司企宣部门的协助下亲自写就的。这些作者尽力将书中的主旨正确地摘要出来，已经不是稀奇的事了。这些努力不应该被忽视。当然，如果宣传文案什么重点也没写到，只是在瞎吹牛，你也可以很容易看穿。不过，这也有助于你对这本书多一点了解，或许这本书根本没什么重要的东西可谈―而这也正是他们宣传文案一无可取的原因。完成这四个步骤，你对一本书已经有足够的资讯，让你判断是想要更仔细地读这本书，还是根本不想读下去了。不管是哪一种情况，现在你都可能会先将这本书放在一边一阵子。如果不是的话，现在你就准备好要真正地略读一本书了。5从你对一本书的目录很概略，甚至有点模糊的印象当中，开始挑几个看来跟主题息息相关的篇章来看。如果这些篇章在开头或结尾有摘要说明（很多会有），就要仔细地阅读这些说明。6最后一步，把书打开来，东翻翻西翻翻，念个一两段．有时候连续读几页，但不要太多。就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。最重要的是，不要忽略最后的两三页。就算最后有后记，一本书最后结尾的两三页也还是不可忽视的。很少有作者能拒绝这样的诱惑，而不在结尾几页将自己认为既新又重要的观点重新整理一遍的。虽然有时候作者自己的看法不一定正确，但你不应该错过这个部分。现在你已经很有系统地略读过一本书了。你已经完成了第一种型态的检视阅读。现在，在花了几分钟，最多不过一小时的时间里，你对这本书已经了解很多了。尤其，你应该了解这本书是否包含你还想继续挖掘下去的内容，是否值得你再继续投下时间与注意？你也应该比以前更清楚，在脑海中这本书该归类为哪一个种类，以便将来有需要时好作参考。附带一提的是，这是一种非常主动的阅读。一个人如果不够灵活，不能够集中精神来阅读，就没法进行检视阅读。有多少次你在看一本好书的时候，翻了好几页，脑海却陷入了白日梦的状态中，等清醒过来，竟完全不明白自己刚看的那几页在说些什么？如果你跟随着我们提议的步骤来做，就绝不会发生这样的事―因为你始终有一个可以依循作者思路的系统了。你可以把自己想成是一个侦探，在找寻一本书的主题或思想的线索。随时保持敏感，就很容易让一切状况清楚。留意我们所提出的建议，会帮助你保持这样的态度。你会很惊讶地发现自己节省了更多时间，高兴自己掌握了更多重点，然后轻松地发现原来阅读是比想像中还更要简单的一件事。我觉得这种类型的阅读就是发现一本书的过程：简单地说，就是利用书本提供的一切可以提供书本内容的信息来读书――目录，序，索引，书籍广告，以至于书本主体一些段落，和书本的结论，这样，书的基本轮廓，架构就掌握在自己手中了。在此，我觉得还可以加上一些书评，让别人帮助自己来完成阅读和其咀嚼过程。即使是略读，也坚持一个较好的阅读习惯，这样，就可以抓住整条鱼，而不是通常意义上的一鳞半爪。（二）粗浅的阅读只要找到对的方向，不论是多难读的书，只要原来就是想写给大众读者看的，那就不该有望之却步的理由。对的方向？答案是一个很简单、但很重要又有帮助的阅读规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不要停下来查询或思索。如果你容许自己被某个顽固的段落绑住了，你就是被打败了。在大多数情况里，你一旦和它纠缠，就很难脱困而出。在读第二遍的时候，你对那个地方的了解可能会多一些，但是在那之前，你必须至少将这本书先从头到尾读一遍才行。在这里，我发现中国、美国的教育界都是一样的：碰到不懂的地方，一定要查资料，问老师，弄明白再说。可是在这本怎样读书中却指出了一个非常重要的论述：如果时候不到就做这些事，却只会妨碍我们的阅读，而非帮助。因为，这种折磨人的程序首先会剥夺阅读的快乐（有点像中学时学习鲁迅的作品）。其次是，过多的纠缠于细节，那么就会错过一些清楚的大原则。样你在任何层次的阅读都不可能很好。在这个层次中，需要注意的问题有：1、阅读的速度：人们可以读得更快，但是对于书籍阅读来说，速度是根据需要而变化的――天龙八部里，王语嫣听到慕容复练习打狗棒法一味求快就特别着急，应该就是这个道理。2、逗留与倒退：影响速度，浪费脑力3、理解问题：4、做一个自我要求的阅读者：阅读时昏昏欲睡是非常容易的。但是很多人可以秉烛夜读，不应该简单的解释为他们非常人。（估计苏秦张仪悬梁刺股式的学习并非是一个好习惯，而凿壁偷光才真正可以说是个主动的阅读者吧？）在阅读的时候想要保持清醒，或昏昏入睡，主要看你的阅读目标是什么。如果你的阅读目标是获得利益―不论是心灵或精神上的成长―你就得保持清醒。这也意味着在阅读时要尽可能地保持主动，同时还要做一番努力。读书不是娱乐性，而是从中获得利益。只要是超越基础阅读的阅读层次，阅读的艺术就是要以适当的顺序提出适当的问题。关于一本书，你一定要提出四个主要的问题。1整体来说，这本书到底在谈些什么？你一定要想办法找出这本书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。2作者细部说了什么，怎么说的？你一定要想办法找出主要的想法、声明与论点。这些组合成作者想要传达的特殊讯息。3本书说得有道理吗？是全部有道理，还是部分有道理？除非你能回答前两个问题，否则你没法回答这个问题。在你判断这本书是否有道理之前，你必须先了解整本书在说些什么才行。然而，等你了解了一本书，如果你又读得很认真的话，你会觉得有责任为这本书做个自己的判断。光是知道作者的想法是不够的。4这本书跟你有什么关系？如果这本书给了你一些资讯，你一定要问问这些资讯有什么意义。为什么这位作者会认为知道这件事很重要？你真的有必要去了解吗？如果这本书不只提供了资讯，还启发了你，就更有必要找出其他相关的、更深的含意或建议，以获得更多的启示。我觉得这四个问题的关键就是在理解作者的基础上，把自己和书籍之间搭建起一个桥梁，联系。5、如何让一本书真正属于你自己藏书章仅仅是代表在纸张上的拥有，而不是智力上的拥有。如果你有读书时提出问题的习惯，那就要比没有这种习惯更能成为一个好的阅读者。但是，就像我们所强调的，仅仅提出问题还不够。你还要试着去回答问题。而这个回答问题的过程可能在大脑中就完成了，但是如果能够用笔完成――而我现在是在用键盘――就更好了。中国古语中有“微言大义”的说法。据说半本论语可以治理天下。那么如何把字面后的东东读出来，而且能够写出来，才真正把图书变成了自己的一部分，真正完成了对图书的拥有。⑴在书上做笔记之所以不可获取，是因为：第一，那会让你保持清醒―不只是不昏睡，还是非常清醒。其次，阅读，如果是主动的，就是一种思考，而思考倾向于用语言表达出来―不管是用讲的还是写的。一个人如果说他知道他在想些什么，却说不出来，通常是他其实并不知道自己在想些什么。第三，将你的感想写下来，能帮助你记住作者的思想。以下是几个可以采用的方法：1画底线―在主要的重点，或重要又有力量的句子下画线。2在画底线处的栏外再加画一道线―把你已经画线的部分再强调一遍，或是某一段很重要，但要画底线太长了，便在这一整段外加上一个记号。3在空白处做星号或其他符号―要慎用，只用来强调书中十来个最重要的声明或段落即可。你可能想要将做过这样记号的地方每页折一个角，或是夹一张书签，这样你随时从书架上拿起这本书，打开你做记号的地方，就能唤醒你的记忆。4在空白处编号―作者的某个论点发展出一连串的重要陈述时，可以做顺序编号。5在空白处记下其他的页码―强调作者在书中其他部分也有过同样的论点，或相关的要点，或是与此处观点不同的地方。这样做能让散布全书的想法统一集中起来。许多读者会用Cf这样的记号，表示比较或参照的意思。6将关键字或句子圈出来―这跟画底线是同样的功能。在书页的空白处做笔记―在阅读某一章节时，你可能会有些问题（或答案），在空白处记下来，这样可以帮你回想起你的问题或答案。你也可以将复杂的论点简化说明在书页的空白处。或是记下全书所有主要论点的发展顺序。书中最后一页可以用来作为个人的索引页，将作者的主要观点依序记下来。三种做笔记的方法在读一本书时，你可能会有三种不同的观点，因此做笔记时也会有三种不同的方式。你会用哪一种方式做笔记，完全依你阅读的层次而定。A、在检视阅读中，要回答的问题是：第一，这是什么样的一本书？第二，整本书在谈的是什么？第三，作者是借着怎样的整体架构，来发展他的观点或陈述他对这个主题的理解？你应该做一下笔记，把这些问题的答案写下来。尤其如果你知道终有一天，或许是几天或几个月之后，你会重新拿起这本书做分析阅读时，就更该将问题与答案先写下来。要做这些笔记最好的地方是目录页，或是书名页，这些是我们前面所提的笔记方式中没有用到的页数。在这里要注意的是，这些笔记主要的重点是全书的架构，而不是内容―至少不是细节。因此我们称这样的笔记为结构（structuralnotemaking）。B、结构笔记与概念笔记conceptualnotemaking是截然不同的。而当你同时在读好几本书，在做主题阅读―就同一个主题，阅读许多不同的书时，你要做的又是什么样的笔记呢？同样的，这样的笔记也应该是概念性的。你在书中空白处所记下的页码不只是本书的页码，也会有其他几本书的页码。C、对一个已经熟练同时读好几本相同主题书籍的专业阅读者来说，还有一个更高层次的记笔记的方法。那就是针对一场讨论情境的笔记一这场讨论是由许多作者所共同参与的，而且他们可能根本没有常察自己的参与。我们喜欢称这样的笔记为辩证笔记dialecticalnotemaking。因为这是从好多本书中摘要出来的，而不只是一本，因而通常需要用单独的一张纸来记载。这时，我们会再用上概念的结构―就一个单一主题，把所有相关的陈述和疑问顺序而列。6、培养阅读的习惯所谓艺术或技巧，只属于那个能养成习惯，而且能依照规则来运作的人。这也是艺术家或任何领域的工匠与众不同之处。要养成习惯，除了不断地运作练习之外，别无他法。知道一项艺术的规则，跟养成习惯是不同的。我们谈到一个有技术的人时，并不是在说他知道该如何去做那件事，而是他已经养成去做那件事的习惯了。当然，对于规则是否了解得够清楚，是能不能拥有技巧的关键。如果你不知道规则是什么，就根本不可能照规则来行事了。而你不能照规则来做，就不可能养成一种艺术，或任何技能的习惯。艺术就跟其他有规则可循的事一样，是可以学习、运作的。就跟养成其他事情的习惯一样，只要照着规则练习，就可以培养出习惯来。由许多规则中养成一个习惯对于阅读，也如同其他任何复杂的运动项目一样，也要通过一个个分解动作――对一个个规则的由知道，到实践，到反复实践以至于熟练，再将一个个规则统一到一个整体，形成一个完整、流畅的阅读习惯。第三个层次：分析阅读分析阅读的第一阶段：找出一本书在谈些什么的四个规则：第一规则：对书籍进行分类，你一定要知道自己在读的是哪一类书，而且要越早知道越好。最好早在你开始阅读之前就先知道。――分析阅读的第一个规则，虽然适用于所有的书籍，却特别适合用来阅读非小说，论说性的书。举例：从一本书的书名中你能学到什么――1859年，达尔文（CharlesDarwin）出版的是《物种起源》》（TheOriginofSpecies），而非《人种起源》（TheOriginoftheSpecies）；《罗马帝国衰亡史》而非《罗马帝国兴亡史》分类方法：主要的分类法，一种是虚构的小说类，另一种是传达知识，说明性的论说类。在论说性的书籍中，我们可以更进一步将历史从哲学中分类出来，也可以将这二者从科学与数学中区分出来。一个基本的分类原则，这个原则适用于所有的论说性作品。这也就是用来区分理论性与实用性作品的原则。首先，你要学习去怀疑一切。在书籍分类上，你要有怀疑心。我们强调过经济学的书基本上通常是实用性的书，但仍然有些经济学的书是纯理论的。同样的，虽然谈理解力的书基本上通常是理论性的书，仍然有些书（大部分都很恐怖）却要教你“如何思想”。你也会发现很多作者分不清理论与实用的区别，就像一个小说家搞不清楚什么是虚构故事，什么是社会学。你也会发现一本书有一部分是这一类，另一部分却是别一类，斯宾诺莎的《伦理学》（Ethics）就是这样。然而，这些都在提醒你身为一个读者的优势，透过这个优势，你可以发现作者是如何面对他要处理的问题。理论性作品的分类照传统的分法，理论性的作品会被分类为历史、科学和哲学等等。所有的人都约略知道其间的差异性。但是，如果你要作更仔细的划分与更精确的区隔时，困难就来了。有一个判断依据我们认为永远有效，不过你可能要把一本书的内容读了相当多之后才能应用。如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书。否则就是一本哲学的书。（记住，这只适用于科学或哲学的书，而不适用于其他类型的书。）分类的作用：书本所要传达给我们的知识不同，对我们的指导方式也会不同。如果我们要跟随这些书本的指导，那就应该学习以适当的态度来阅读不同的书。分析阅读的第二个规则是：使用一个单一的句子，或最多几句话（一小段文字）来叙述整本书的内容。首先，一位作者，特别是好的作者，会经常想要帮助你整理出他书中的重点。尽管如此，当你要求读者择要说出一本书的重点时，大多数人都会一脸茫然。一个原因是今天的人们普遍不会用简明的语言表达自己，另一个原因，则是他们忽视了阅读的这一条规则。当然，这也说明太多读者根本就不注意作者的前言，也不注意书名，才会有这样的结果。其次，是要小心，书的重点摘要可能不只有一个，通常没有绝对又惟一的说明。一本书的整体精神可以有各种不同的诠释，没有哪一种一定对。当然，某些诠释因为够精简、准确、容易理解，就是比另一些诠释好。不过，也有些南辕北辙的诠释，不是高明得不相上下，就是烂得不相上下。但，这也不是说就可以爱怎么说就怎么说。虽然读者不同，书的本身还是一样的，不论是谁作摘要，还是有一个客观的标准来检验其正确与真实性。第三个规则可以说成是：将书中重要篇章列举出来，说明它们如何按照顺序组成一个整体的架构。可读性最高的作品是作者达到了建筑学上最完整的整体架构。最好的书都有最睿智的架构。虽然他们通常比一些差一点的书要复杂一些，但他们的复杂也是一种单纯，因为他们的各个部分都组织得更完善，也更统一。简单的公式：将内容大纲排列如下：1作者将全书分成五个部分，第一部分谈的是什么，第二部分谈的是什么，第三部分谈的是别的事，第四部分则是另外的观点，第五部分又是另一些事。2第一个主要的部分又分成三个段落，第一段落为X，第二段落为Y，第三段落为Z。3在第一部分的第一阶段，作者有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。就算你已经很熟练阅读技巧了，你也不一定读每本书都要用上同样的力气。你会发现在某些书上运用这些技巧是个浪费。就是最优秀的阅读者也只会选少数相关的几本书，依照这个规则的要求做出近似的大纲来。第四个规则可以说是：发现作者的意图，找出作者要问的问题。一本书的作者在开始写作时，都是有一个问题或一连串的问题，而这本书的内容就是一个答案，或许多答案。知道这前四个规则是有整体性，有同一个目标的。这四个规则在一起，能提供读者对一本书架构的认识。当你运用这四个规则来阅读一本书，或任何又长又难读的书时，你就完成了分析阅读的第一个阶段。分析阅读的第二阶段：找出一本书到底在说什么的规则（诠释一本书的内容）：第一个规则，我们简称为“找出共通的词义”。简略来说就是：你必须抓住书中重要的单字，搞清楚作者是如何使用这个单字的。不过我们可以说得更精确又优雅一些：找出重要单字，透过它们与作者达成共识。要注意到这个规则共分两个部分，第一个部分是找出重要单字，那些举足轻重的单字。第二部分是确认这些单字在使用时的最精确的意义。规则，目标不是列出一本书的架构纲要，而是诠释内容与讯息。词义的模糊阻碍了沟通，作者与读者之间无法在阅读中实现思想的交互作用。排除这些障碍，就是这条规则所作的。第二个规则：从最重要的句子中抓出作者的重要主旨。第三个规则：找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。第四个规则：确定作者已经解决了哪些问题，还有哪些是未解决的。在未解决的问题中，确定哪些是作者认为自己无法解决的问题。分析阅读的第三个阶段：说明的是批评式阅读的条件，而在这样的阅读中，读者应该能够与作者“辩论”。第一：要求读者先完整地了解一本书，不要急着开始批评。第二：恳请读者不要争强好辩或盲目反对。第三：将知识上的不同意见看作是大体上可以解决的问题。这个规则再进一步的话，就是要求读者要为自己不同的意见找到理论基础，这样这个议题才不只是被说出来，而且会解释清楚。只有这样，才有希望解决这个问题。", "life/醋泡三宝.md": "醋泡花生早晚各5颗建议早晨空腹服用，在吃早饭之前空腹吃花生米对胃是有好处的，对胃胀、胃酸效果显著。醋泡红皮花生米吃对高血压降压有好处。将带红衣的生花生米半碗用米醋浸泡约一周后，每日早、晚各吃10粒。在服用过程中，注意观察血压下降情况。血压比较稳定后，可每隔2～3日服用一次。但是这种食疗方法仅限于辅助治疗，平日里还是要按时吃降压药物。适量的服用，如果有高血压的话，及时的监测。生的比熟的好，泡710天醋泡黑豆醋泡黑豆是中医治疗肾虚的黄金验方1，醋泡黑豆具有美容、减肥、补肾、明目、乌发功能，有效改善便秘、高血压、高血脂、腰酸腿痛、糖尿病、前列腺病、白发、冠心病和看电脑、电视时间长引起的视力下降、眼睛疼痛、干涩、头晕、头痛。同时醋泡黑豆对于改善近视等眼部疾病都有很好的作用。这类食物并不是适合所有的人，比如对植物蛋白过敏的人就不能吃；胃肠功能低下者，特别是胃不好的人，吃了会胀气不消化，而很多中老年人肠胃都不好，吃了反而就有害了。因为醋在人体内代谢后呈碱性，所以痛风患者和酸性疾病有关的患者能够食用。做法：黑豆100克，糙米醋300毫升做法：将黑豆放在平底锅内，以中火将黑豆煮至表皮爆开，再以慢火煮大约10分钟。把煮熟了的黑豆放入密实瓶内，加入糙米醋，两者所占的分量大约是1/3及2/3。变凉后将瓶盖封好，待黑豆吸收了醋，膨胀之后便可食用。时间久了醋上面会长膜，可将膜扔掉，如醋浑浊，重新换醋。放置阴凉处或冰箱冷藏保存10天后即可食用。可早晚都吃，也可以只在晚上吃晚上吃的话最好68点这个时间段，饭前或者饭后1小时吃每次1020粒黑豆，再喝10ML左右泡豆的原香醋。黑豆的最佳使用时间在每晚57点肾经最旺的时候吃，一般吃25颗左右。如此常服可补肾强肾，让白发转黑。醋泡姜醋泡生姜具有养胃、减肥、防脱发，防止慢性病，提升人体阳气的功效。原料：生姜一块（最好选用鲜姜）米醋或陈醋一瓶做法：1、生姜切片2、把切好的姜片放到一个罐子里，倒入米醋或陈醋。3、醋倒满，没过生姜。4、取一小块保鲜膜，折叠成一小块。5、把叠好的保鲜膜包裹在罐子口上。6、盖上盖子，密封结实。放到冰箱里一个星期后就可以吃了。食用方法：每天24片，早晨吃最好，长期食用效果最好。", "life/阅读技巧.md": "略读注意点：在纸上列出几个问题，带着问题阅读，提高注意力和兴趣点。精研目录，了解书的内容结构，并挑选一些敢兴趣章节阅读。粗浅的通读非常重要，此时，不要深究，不要停顿。在第一次阅读一本难读的书时，不要企图了解每一个字句。精读：读经典；间隔一段时间反复的读思维导图附：一些阅读技巧下面一些技巧主要有三个方面：第一、**选择性重点阅读**。包括1、3、4。明确自己需要阅读什么，以目录为纲，选择自己需要的信息来阅读，重要的地方，多读几分钟，不必要的地方，略过。第二、**随时随地惜时阅读**。包括2、5。随时随地读书，不同场合读不同的书，书签能让你迅速的进入阅读状态。第三、**页面笔记**和**重要程度标记**。包括6、7。用小贴纸或页面空白做笔记，用不同颜色线标出重要或此重要信息，用不同的符号标出重要页或非重要页。1.选择性阅读，而非精读全册。只要阅读自己所需信息的那几页，阅读书本的目的即已算达到了。明确你自己到底是查找什么资料，最好在纸上写下具体目标，不要大概目标。找到那几页，开展重点式阅读法。带着疑问去读书。认为某一本书现在很流行，就在无心之下阅读，可能会在毫无目的中浪费时间。对读书来说，最重要的并非阅读的时间，而是一种敏锐的判断力，知道应该熟读哪一部分，应该放弃哪一部分，那就要求明确地知道，你想知道一些什么？如果在不知自己的需求之下，从头到尾读完一本书，那还不如花十分钟只熟读必要的地方，效果要来得好些。2.不同的时间地点场合读不同的书刊。例如，在早晨上班的车厢里，可阅读从早报“撕下来”的消息，到了工作场所，可阅读涉及本身工作的各种资料书本与外国的社会法等，回家后则阅读一些轻松性的小品，或者涉及象棋、围棋之类的书本……。因为，这些书都属消遣性质，阅读速度相当地快。3.目录是有效阅读的向导。先看目录，发现不必要的地方可以避开，重要的部分则多耗费一些时间阅读。不必拘泥于书本的章节，可以从刊登你需要信息的那章阅读就行了。有时甚至可以从最后一章阅读。实际上，在阅读各种企业方面的书籍时，往往从最后一章开始阅读。因为有一些作者在前面说了一大堆不怎么重要的话，到了最后才确切的揭示出秘诀。4.重要之处，可以多读十分钟或二十分钟最重要的事情，并非在短时间之内“读完”一本书，而是在短时间内获得自己所需要的“信息”。只要把握住自己所需要的信息，其他的页数不看，也算是达到了目的。不过，在阅读重要的地方时，一页往往要耗费十到二十分钟。5.书签能提高读书的效率要想在上下班时、休息时、就寝前、坐车时和等人时，这样短暂的时间内读书，使用书签能让你迅速的进入阅读状态。一本书可以粘贴多个书签来记录不同的位置。6.与其一面阅读、一面记笔记，不如直接写在书上比较方便完美的笔记需要花很多时间，有点得不偿失惑买椟还珠。可以把笔记和注解写在小贴纸上，然后贴在树上。也可以写在页面空白处。最重要的部分使用红笔画线，次要者使用蓝笔画线，参考程度则使用绿笔画线。如果只使用红笔画线，则每一页都是红线，叫人分不清楚哪儿最重要？哪儿比较不重要？7.书页上角打上“□”、“○”、“△”等重要度标志以方便重读及检查发现重要处，都会打上“□”，认为尚重要者会打上“○”，如果只能做为参考资料则打上“△”，至于不必要者，一律打上×", "life\\多空转折一手抓/前言.md": "前言唯有量价关系才是所有指标的最先行指标。商品的涨跌都是市场主力作量作价的结果。“随势操作善设停损，多头看支撑，空头看压力，严格执行停损才能小赔出场。反之，达设定的涨跌幅满足，则波段获利了结，以达大赚小赔的目的。”操作不要急躁，行情是等来的，当机会来时胆大心细，如台北股市即使一年才出现一次大多头买进时机或大空头放空时机，只要掌握住一两次就够了。“滚石不生苔，短线不聚财”。从基础到进阶，除了研读历史外，还要不断累积实务经验。我坚守的操作方法是“严设停损，资金控管，波段随势操作”。波段操作是以长线为基础，时间短至数月，长至数年。既然是波段操作，当然就是尽量使用半年以上的日线或周线来做趋势上的判断，当型态上的结构有机会到达转折时，小时线或五分钟线便是掌握先机的重要参考指标，所以看五分钟线或小时线并不是为了要作短线，而是因为判断长线的趋势，即将出现转折的时候，可利用较短的五分钟线或小时线，抢得先机作积极的介入。而此时的五分钟线或小时线，也大多是拉长至两三个月来看量价变化是否出现契机，例如K线型态上作出约三个月的底部。当来到上缘颈线量缩关前整理判断时机已成熟时，一旦五分钟线或小时线带量突破颈线，便作积极介入同时设好停损即可，主要看的还是波段的大利润。历史线图的型态与量价结构所产生的变化是绝对要研读。", "life\\证券/证券投资.md": "13交易系统的思路有了，就是按照“森林法则”去考虑“买什么，什么时候买，买了之后怎么办”三个问题。“买什么”就是选择自己熟悉的“小姑娘”来买。“什么时候买”，左侧交易是觉得股票属低估时候买入，右则交易是自己觉得确认大盘或个股形成底部形态时买入。“买了之后怎么办”是考虑卖出的问题：止损时卖出，股票高估时卖出，大盘或个股形成顶部形态时卖出。重在执行。请大家讨论、批判。教材中“牛市结束，长线资金离场，这也是判断牛熊的另一个辅助手段。”请问周老师，长线资金离场是用什么指标表示的?在哪里可以看得出来长线资金离场?有没有具体判断标准？谢谢长线资金离场，一般是大盘指数总体亏损20%。或是个股总体亏损20%。我理解的交易系统，就是在技术分析的基础上，用来克服解决“买”和“卖”的随意性、盲目性的操作纪律守则。如何建立交易系统，老师已经讲得很清楚了。之所以很多同学还感觉茫然，无从入手，是因为还没学习到技术分析的部分。不用着急，老师的技术分析部分讲得很精彩，特别是“看图说话”部分，可以从中学习到很多思路和方法。美国大盘是从0开始涨到现在这么高，我想中国大盘也应该如此，一句话，在熊市选准被低估的股票，然后安心，等待牛市的到来，不是说了21世纪是中国的世纪，什么叫中国的世纪，说白了，还是经济，股市又是经济的晴雨表，相信中国，还有一句话，是《三国演义》学来的，原话：古话云，天下大势，分久必合，合久必分……借用一个，沪深股势，涨久必跌，跌久必涨，牛久必熊，熊久必牛，现在处于一个熊市，我们正好可以做三件事，第一，听一下周老师的课，算是取经；第二，补一点股市、经济、金融的基本知识；第三，学习之后，希望通过周老师帮助下，选到几支被低估的股票，在关注中，在被窝中，等待牛市的到来，说的非常棒。我们苦练杀敌本领，一方面是投资技术，一方面是情绪管理，把这些东西都做好，一定可以获得稳定的投资收益，最终实现财务自由。", "management/01-2018企业文化建设目标.md": "塑文化、立标准、强队伍、推翻三座大山一、塑文化我们要塑造工程师文化。1.不要等人来管你，我们自己管理自己思考做一个能思考的人，不能事事等别人告诉你怎么做，但必须遵循公司的要求。积极主动积极主动发现问题、解决问题，不能自扫门前雪。主动反馈任务完成情况2.我们是一个团队协助赠人玫瑰，手留余香。在帮助他人中成长。帮助同事解决技术问题。在别人忙的时候搭把手。活在当下，扩大自己的影响圈不盲目追求技术，解决自己项目的问题，优化代码。3.建立学习型公司公司成长需要大家的成长教会他人促进自己vs教会徒弟饿死师傅二、立标准1.建立两大组织产品组开发组2.建立规范的、高效的开发流程产品需求分析与设计流程功能验收流程3.建立质量标准代码质量功能质量三、强队伍内部人员能力增强校招应届生长线培养不定期内部技术分享建立技术博客四、推翻三座大山生产管理系统MES安全监控系统SIS企业资源规划ERP", "management/01-JavaWeb人员培养方案.md": "原则制定严格的学习计划，可量化的考核标准；20%知识点学习，80%实践练习；基于实例来学习，需完成教材上指定的所有实例；培养全栈工程师，所学内容包括Web页面开发、Java编程、RMDB三个部分培养路线培养分为两个阶段：Web页面开发和JavaWeb开发两个阶段。第一阶段：Web页面开发简介本阶段是所有前端、后端工程师都必须学习的阶段。本阶段结束后，有志于更深层次的前端开发，可以选择走前端工程师培养路线；而希望走JavaWeb开发方向，可以选择JavaWeb开发。本阶段学习时间大约在2个月左右，需要学习内容包括：HTML、CSS、JS、jQuery、EasyUI等。学习内容学习教材是《网页开发手记.HTML.CSS.JavaScript实战详解》和《jQueryEasyUI教程》，培养对象需要完成指定章节的所有实例开发。《网页开发手记.HTML.CSS.JavaScript实战详解》包括四个篇章，分别为：HTML基本知识、CSS样式控制、JavaScript编程、综合实战。《jQueryEasyUI教程》主要是实例讲解。考核方式在培养期间，培养对象需要按周提交自己编写的教材中的实例；培养期结束，提供所有实例。现场考核：在脱网的情况下，完成一个网站开发，可自选题目，也可选择《网页开发手记》中的综合实例（个人网站、门户网站）。现场考核：在脱网的情况下，完成一个基于EasyUI的CRUD程序（数据通过JSON模拟）。考核对象需要在8小时内完成现场考核。学习进度快者，可以提前考核。进度安排第1周：完成HTML基本知识学习。第2周：完成CSS样式表学习。第3、4周：完成JavaScript学习。第5周：完成个人网站开发。第6周：完成门户网站开发。第7、8周：完成EasyUI技术学习。第二阶段：JavaWeb开发简介在完成Web页面开发培训阶段后，方可进入本阶段学习。本阶段学习时间大约在2个月左右，需要学习内容包括：Java常用开发技术、数据库SQL。本阶段需要完成一个实验项目开发。学习内容Java常用开发技术教材为《Java经典实例第三版》节选，主要内容是Java基础知识，培养对象需要完成节选章节的所有实例开发。数据库SQL教材为《SQL必知必会第4版》，包括全书的所有内容，培养对象需要熟练掌握书中所有实例。基于Spring的数据库编程，本部分主要参考本公司的项目实例，公司会安排导师讲解培训。【任务跟踪管理系统】实验项目开发。考核方式在培养期间，培养对象需要按周提交自己编写的教材中的实例；培养期结束，提供所有实例。完成实验项目开发，根据完成情况打分。现场考核：在脱网的情况下，完成从《Java经典实例第三版》选取4道题目和一个Java编程题目，以及2道综合的SQL题目。现场考核：基于公司的框架完成一个简单CRUD应用，前端要求使用EasyUI。考核对象需要在8小时内完成现场考核。进度安排第1周：完成《Java经典实例》字符串、数字处理两部分学习。第2周：完成《Java经典实例》日期时间、结构化数据两部分学习。第3周：完成《SQL必知必会第4版》前14章关于DQL学习。第4周：完成《SQL必知必会第4版》后8章学习。第5周：完成基于Spring的公司框架demo讲解，并完成demo开发。第6、7周：独立完成【任务跟踪管理系统】实验项目开发。", "management/01-人员招聘.md": "TOCJava人员面试考察点一般开发人员面试时，需要考察三个基本方面：java、db、spring。高层次人员在次基础上，增加一些随机即时性问题。而java、db、spring以考察使用为主，原理为辅。Java**使用**StringBuilderVS字符串相加如何在循环遍历过程中，删除list中一个元素？涉及到钱数时，为什么不能用float或double？应该用什么类型？**原理**ArrayList与数组的差异？ArrayList的add怎么实现？equals、hashCode相关的问题HashMap的实现原理DB**使用****原理**介绍一下左右链接、内外链接数据库的四种隔离级别？脏读怎么产生的？Spring**使用**你知道的Spring注解有哪些？怎样注入一个成员变量？**原理**如何在Springbean实例化后运行一段代码？Spring的事务机制如何实现的？事务传播机制有几种？JD职位描述Java工程师工作职责：1、参与产品设计规划、需求分析与讨论、理解软件功能；2、负责软件开发，单元测试和维护等工作，确保项目的进度和质量；3、参与软件概要设计、详细设计说明书、数据库设计等技术文档编写；任职要求：1、扎实的JAVA基础知识，精通面向对象编程；2、熟悉Spring等框架使用，了解其运行原理；3、熟悉SQL编写，熟练掌握至少一种常用数据库（Oracle、MySql）；4、掌握一般的JS、HTML页面开发，熟悉easyui优先；5、工作积极主动，乐于沟通，热爱学习。初级前端工程师1、岗位描述：1）负责前端界面的前端构建，各类交互设计与实现；2）前端样式和脚本的模块设计及优化；3）配合后台开发人员完成项目；2、任职要求：1）熟练掌握HTML5、CSS等网页制作技术，熟悉页面架构和布局；2）熟练掌握JavaScript、Ajax、DOM等前端技术，掌握面向对象编程思想；3）对js框架应用（如jQuery/layUI/Vue.js等）有一定的经验；4）对css/JavaScript性能优化、解决多浏览器兼容性问题有一定的经验；5）对用户体验、交互操作流程、及用户需求有深入理解；6）有强烈的上进心和求知欲，善于学习和运用新知识，善于沟通和逻辑表达，有强烈的团队意识和执行力。项目经理任职条件：1、全日制本科毕业，软件工程或相关专业毕业，具备3年以上的IT项目管理经验。2、从事过3年以上编码工作，熟悉Java、Spring、MyBatis、Oracle、MySQL等语言或技术；3、具备良好的交流、沟通能力、书面表达能力、团队协作精神。4、具备较强的逻辑分析和需求问题梳理能力，熟悉软件文档编写及管理。5、良好的责任感与抗压性，快速的学习能力。6、有敏捷项目管理、或PMP等认证者优先考虑；岗位职责：1、项目经理对项目的实施和管理，制定项目实施项目计划并跟踪执行；2、管理客户各种问题和需求，维护和客户的良好关系，持续发展业务；3、协调公司内的开发人员的工作安排；4、对已上线产品的进行维护，对需求变更进行开发；5、完成需求文档、实施文档、培训文档、验收文档等项目文档编写；", "management/02-团队结构与岗位职责.md": "TOC团队结构|产品|产品及测试组|开发组|备注||:|:|:|:||生产管理|詹勇、杜骞、肖海燕||||物资合同|詹勇、谢丹、肖海燕|||产品经理职责产品需求定义。职责市场需求调研、旧有系统研究。需求文档编写、原型制作、数据库设计。产出物需求说明文档原型文档实体关系图产品迭代规划。职责产品发布规划。产品迭代规划，和开发小组一起制定开发计划。产出物产品功能清单（树形）迭代任务清单（列表）产品功能测试。职责制定业务流程的测试方案。负责产品主要业务流程的验收测试。安排测试人员完成更细节的测试。产出物常规测试的CheckList业务流程的测试方案产品交付。编写用户手册。系统现场部署支持。收集客户使用反馈。", "management/02-管理过程.md": "!assets/00/2017111882ed70ff.pngTOC编制迭代功能清单列出单周期内需要完成的功能清单标明优先级、工时估计迭代计划会制定迭代任务清单任务标明优先级、工时估计功能需求宣讲、答疑任务领取或分配将bug修复纳入开发计划每日立会每人说明三件事：昨天完成了什么？今天计划做什么？遇到什么问题或障碍？不超过10分钟，站立开会拉动故事墙（无bug方算完成）产品和程序设计由需求人员、设计人员、开发人员共同讨论、设计产品UI、功能设计代码结构设计、接口定义技术难点解决编码开发功能分解成任务（包括功能任务、非功能任务）和需求人员讨论需求，和设计人员讨论设计按验收标准自测，自测完毕交付给测试人员CodeReview代码规范检查代码用法检查、知识传递发现Bug抽象共通组件测试需求人员按照验收标准进行功能验收，不符合项超过3条打回自测部署系统，测试人员细化丰富验收标准，并进行测试，登记Bug测试人员将细化后的验收标准做出checklist，逐条打钩确认出具纸质的checklist方能发布验收测试按照《需求定义》中的验收标准，一旦超过3条，打回开发人员自测有需求人员、设计人员来验收反思总结会总结本迭代的好的经验、失败的教训制定改进措施风险管理建立风险跟踪表，实时跟踪技术风险：及时了解、记录跟踪、解决风险业务风险：需求不清、产品设计不合理客户风险：客户及时配合、客户印象风险管理风险：工程和管理过程不合理、开发人员情绪不积极其他风险：项目组周报项目进展下周计划风险管理", "management/03-工作风气问题反思.md": "事件2018/1/29中午午休时间我走进办公室，有玩游戏的、有看电视的、有睡觉的、有在编码的。我看到李永星在看dubbo、python等内容。问题再哪里？不够积极主动的做事、不够专注的工作；缺乏激情、缺乏对未知的好奇心；没有对能力追求、没有对品质的追求。keephungry,keepfoolish.求知若饥，虚心若愚不够专注自己的工作并非针对玩游戏，是精神风貌出了问题。胡寒的故事（他中午玩游戏，但是他总是能发现项目中各种问题，并去解决）。不能自律的人，难以获得信任（我不敢让胡寒带开发队伍）。又玩游戏，事情又做得一团糟，你真的在解决问题吗？办公室玩游戏、看电视对公司文化是一种伤害，它让大家觉得我们很松懈，我们的工作无关紧要。对自己的任务精心打磨，还是糊弄了事，然后把头埋在沙子里？心里惦记的是程序还是游戏？是否想去打磨自己的代码或任务？编程是一个思维连续性的工作，中间不能被打断。你有过编程时忘记时间流逝的经历吗？如果每天中午都是玩游戏，能说明什么？（12点之前是否在解决问题？911点多少时间在解决问题？）选择一项任务，在列出要解决的问题，一口气解决掉。你对整个系统的业务了解多少？它业务设计是否合理？你对整个程序架构了解多少？它技术架构可以改进吗？做完这个项目，你能成长多少？做完这个项目，你是否能成为业务专家，或技术架构，或项目经理？又或是原地踏步？上班全力工作，空闲时间休息养精蓄锐，下班后学习提高。积极主动的发现问题、解决问题积极主动是我认为最重要的能力，技术和业务能力都远远比不了，积极主动是一颗宝石。周发宣的故事。明年我们也会从应届生中挑选积极主动的人。你在推动工作事情执行，还是在等待客户或领导发现问题？别人发现你做的不好，是怎样的一种评价？对于别人的批评你感觉如何？我自己开发applet的经历：我的技术比较好些，做事快而糙，不断被挑出bug，情绪接近奔溃；和我同组另一个同事，虽然做的慢，但是非常耐心的打磨自己程序，问题反而更少。主动研究技术解决问题，主动寻求同事的帮助解决问题，推动事情向前走。高中生覃泽的故事。你知道你的任务或项目还存在哪些问题吗？你有解决它的冲动吗？你还有激情吗？解决潜在的问题需要哪些技术？你有对未知的好奇心吗？SQL和PB都过时了，我不想去了解这些垃圾？那个什么技术又太难了，我不想去搞？我能从解决问题中收获什么？行业业务、系统性思维、业务架构、技术架构、编程能力客户的认可和依赖、领导的信任和肯定、同事的钦佩和友谊如果我不解决这些问题，客户或领导会怎么想？如果我解决了这些问题，客户和领导会怎么想？我们是一个初创的公司，遍地都是机会和实验场。一切对公司有益的事情和技术，你都可以去尝试。比如：jenkins、持续集成、业务分析....,没有比这还要好的学习尝试机会，大公司一切都稳定了，你只需要做一颗螺丝钉。你做得好，必定能获得广阔的职业机会。明后年我们业务会井喷，我们需要大量的业务分析、技术架构、项目管理人员，你们不能成长，我们只能招聘。关于成长你是否想提升自己？你真的想吗？你有多想？你仅仅是想想，而不想行动？你既想提升自己，也想玩好游戏或其他？我只想说，不疯魔不成活。让自己疯狂吧，少年！如何提高成长？其他公司在搞Hadoop？我同学在用python搞人工智能？........眼花缭乱！无所适从！技术发展是连续而非跳跃的，基础是万术之源，是创新之源，是你的免疫力，是你能走多远的内核动力。网络、进程、线程、JVM、SQL、Spring原理、ORM原理、缓存、面向对象......在工作中学习，在解决问题中成长。用你的技术解决工作中问题，在解决问题过程中提升自己技术和能力。用技术解决产品的问题，在产品实现过程中实现技术的提升。杨铁权的买书故事。（发布项目时，不知道怎么写脚本，自己买了本【实战gradle】；不懂Java8语法，买了本【Java8实战】；spring原理不懂，买了本【SpringInAction】）", "management/03-开发过程.md": "开发过程!assets/00/20171227b2e49d4c.png需求评审需求文档中每一个功能必须有【验收测试】部分每一个功能的需求必须经过评审后方能开发交付测试的标准CodeReview通过（符合【编程手册】要求）验收测试通过（超过3个验收条件不满足，打回自测）验收条件包括两部分：常见测试用例checklist、需求文档中验收条件系统测试按照业务流程场景进行测试", "management/05-产品规划.md": "产品命名命名规则由两位字母加三位数字组成，第一个字母为D代表本公司，第二个字幕代表业务领域A代表自动化I代表信息化E代表嵌入式C代表数据中心三位数字，可以使用100、200、600、800、900四种，100代表基础板块，不作对外产品命名为便于项目的内部辨识，可在在命名后加项目缩写，如：DI200EM，项目缩写长度为24为信息化DI100：平台等基础组件DI200：生产系统相关DI200EMS设备管理系统（EquipmentManagementSystem）DI200MES生产运行系统（ManufacturingExecutionSystems）DI600：企业资源规划（ERP）相关DI600MMS物资管理系统（MaterialsManagementSystem）自动化DA200：SIS相关DA200SIS厂级监控系统（SupervisorInformationSystem）", "management/06-2018年度计划.md": "TOC2018总体计划|开始时间|结束时间|任务|参与人员|||||||2018/5/15|2018/6/15|珠海、宁波生产系统上线|廖伟、李永星、陈正阳、陈芊||2018/6/15|2018/8/1|深能手机App开发|陈正阳、陈芊||2018/6/15|2018/8/30|中华水电生产系统迁移预演|陈芊、廖伟、李永星||2018/9/1|2018/9/30|中华水电生产系统迁移|陈芊、廖伟、李永星||2018/3/1|2018/7/30|物资合同开发|姚建波、谢丹、徐捷、马德桂||2018/8/1|2018/8/30|物资合同珠海、宁波上线|姚建波、谢丹、徐捷、马德桂||2018/10/1|2018/12/30|存储过程转换成Java代码|所有人员|PS：任务的开始、结束时间不准确，根据项目的实际情况调整。珠海、宁波生产系统上线参与人员及工作分配廖伟、李永星负责主要的开发工作陈芊将SIS相关工作传授给陈正阳陈正阳负责SIS系统的开发、安装及现成实施支持李永星需要熟悉软件环境安装配置（需要学习Linux常用操作）詹勇完成生产系统用户手册编写任务详情人员、组织、权限，业务流程配置软件、硬件安装配置（需要提前演练）与DCS厂家联调，sis系统安装上线上线培训及bug修改，系统完善，报表开发深能手机App开发参与人员及工作分配此任务由陈芊总体负责陈芊完成后端接口的设计（最好在张地在成都期间完成设计,6.15日之前完成）陈正阳负责生产接口开发物资小组需要提供一个人员来完成物资相关接口开发App开发人员待定任务详情后端涉及生产、物资两块，提供接口和部分HTML5页面（需求深圳团队提供支持）中华水电生产系统迁移预演参与人员及工作分配由陈芊先期研究中华水电生产系统的数据库结构廖伟、李永星后期加入协助任务详情研究中华水电生产系统的数据库结构研究深能系统的数据库结构制定迁移方案迁移预演中华水电生产系统迁移参与人员及工作分配以陈芊为主，廖伟、李永星协助任务详情物资合同开发参与人员及工作分配詹勇完成需求、设计编写、UI原型詹勇对功能进行验收，验收后方能测试姚建波、谢丹、徐捷、马德桂负责开发任务详情物资合同珠海、宁波上线参与人员及工作分配姚建波、谢丹、徐捷、马德桂任务详情存储过程转换成Java代码参与人员及工作分配任务详情", "management/DY-2018初外包公司工作风气问题反思.md": "事件2018/1/29中午午休时间我走进办公室，有玩游戏的、有看电视的、有睡觉的、有在编码的。我看到李永星在看dubbo、python等内容。问题再哪里？不够积极主动的做事、不够专注的工作；缺乏激情、缺乏对未知的好奇心；没有对能力追求、没有对品质的追求。keephungry,keepfoolish.求知若饥，虚心若愚不够专注自己的工作并非针对玩游戏，是精神风貌出了问题。胡寒的故事（他中午玩游戏，但是他总是能发现项目中各种问题，并去解决）。不能自律的人，难以获得信任（我不敢让胡寒带开发队伍）。又玩游戏，事情又做得一团糟，你真的在解决问题吗？办公室玩游戏、看电视对公司文化是一种伤害，它让大家觉得我们很松懈，我们的工作无关紧要。对自己的任务精心打磨，还是糊弄了事，然后把头埋在沙子里？心里惦记的是程序还是游戏？是否想去打磨自己的代码或任务？编程是一个思维连续性的工作，中间不能被打断。你有过编程时忘记时间流逝的经历吗？如果每天中午都是玩游戏，能说明什么？（12点之前是否在解决问题？911点多少时间在解决问题？）选择一项任务，在列出要解决的问题，一口气解决掉。你对整个系统的业务了解多少？它业务设计是否合理？你对整个程序架构了解多少？它技术架构可以改进吗？做完这个项目，你能成长多少？做完这个项目，你是否能成为业务专家，或技术架构，或项目经理？又或是原地踏步？上班全力工作，空闲时间休息养精蓄锐，下班后学习提高。积极主动的发现问题、解决问题积极主动是我认为最重要的能力，技术和业务能力都远远比不了，积极主动是一颗宝石。周发宣的故事。明年我们也会从应届生中挑选积极主动的人。你在推动工作事情执行，还是在等待客户或领导发现问题？别人发现你做的不好，是怎样的一种评价？对于别人的批评你感觉如何？我自己开发applet的经历：我的技术比较好些，做事快而糙，不断被挑出bug，情绪接近奔溃；和我同组另一个同事，虽然做的慢，但是非常耐心的打磨自己程序，问题反而更少。主动研究技术解决问题，主动寻求同事的帮助解决问题，推动事情向前走。高中生覃泽的故事。你知道你的任务或项目还存在哪些问题吗？你有解决它的冲动吗？你还有激情吗？解决潜在的问题需要哪些技术？你有对未知的好奇心吗？SQL和PB都过时了，我不想去了解这些垃圾？那个什么技术又太难了，我不想去搞？我能从解决问题中收获什么？行业业务、系统性思维、业务架构、技术架构、编程能力客户的认可和依赖、领导的信任和肯定、同事的钦佩和友谊如果我不解决这些问题，客户或领导会怎么想？如果我解决了这些问题，客户和领导会怎么想？我们是一个初创的公司，遍地都是机会和实验场。一切对公司有益的事情和技术，你都可以去尝试。比如：jenkins、持续集成、业务分析....,没有比这还要好的学习尝试机会，大公司一切都稳定了，你只需要做一颗螺丝钉。你做得好，必定能获得广阔的职业机会。明后年我们业务会井喷，我们需要大量的业务分析、技术架构、项目管理人员，你们不能成长，我们只能招聘。关于成长你是否想提升自己？你真的想吗？你有多想？你仅仅是想想，而不想行动？你既想提升自己，也想玩好游戏或其他？我只想说，不疯魔不成活。让自己疯狂吧，少年！如何提高成长？其他公司在搞Hadoop？我同学在用python搞人工智能？........眼花缭乱！无所适从！技术发展是连续而非跳跃的，基础是万术之源，是创新之源，是你的免疫力，是你能走多远的内核动力。网络、进程、线程、JVM、SQL、Spring原理、ORM原理、缓存、面向对象......在工作中学习，在解决问题中成长。用你的技术解决工作中问题，在解决问题过程中提升自己技术和能力。用技术解决产品的问题，在产品实现过程中实现技术的提升。杨铁权的买书故事。（发布项目时，不知道怎么写脚本，自己买了本【实战gradle】；不懂Java8语法，买了本【Java8实战】；spring原理不懂，买了本【SpringInAction】）", "management/DY-2018外包前四个月总结.md": "前四个月的工作我们做得好不多，所以下面总结多是自我批评，有批评才有进步。这个四个月做得不好，我本人有承担大部分责任，我们在光芒呆的时间太长了，也太安逸放松了，就像温水里的青蛙忘记了我们的跳跃的本能。首先、在工程管理、产品设计、技术、团队等方面，我只是口头上说希望大家怎么做，没有监督大家的执行，有时说的事情也没有去做，这可能是主要原因。第二、我们团队成员到岗不足。我、廖伟和樊经理都没能全力参与到项目中去，不能实时为大家解决问题，无论是产品设计，还是技术实现都是现有人员自己解决，受限于经验，未必是最优方案。第三、能力不足。据我了解，现有成员很多都没做过类似ERP项目或大型项目，大型项目技术固然有难点，但是业务理解才是最难的，工作经验丰富与否，也决定于业务理解和业务实现模式；而我们的小伙好像对技术更感兴趣，但业务理解和设计能力才是井口之外的天空（这个话题太深，有机会再聊），毕竟就Java技术来说，学56年你还没学通，那你可能不适合干这行了，而职业生涯那么长，没有更长远的打算吗？第四、对工作重视不够。我自己对产品这块没有给于足够的重视，总认为照着CS做就行，没有深入设计产品。对工作流工作细节没去梳理，没去跟踪，导致工作流拖的时间太长。詹勇前期对产品设计有点片面，有些问题没考虑到，导致后期任务和bug总是无法结束。开发人员前期对项目重视不够，总感觉在做demo，不够严谨，导致后期bug丛生。对easyui的学习，前后端人员都不够重视，我认为你们最少要把easyui官方文档全部看一遍，官方那些demo要全部试用或研究一遍吧（至少我一般都这么学习的），但是我知道很多人到现在也没有去看一遍，都不知道easyui有些什么，我们选择easyui就是为了少写高难度的js，但是我们项目的js我都看不懂。下面是我对各项工作细节的总结：管理产品对产品设计目前只是移（抄）植（袭）CS系统和郑州的系统，没有我们对产品的理解，下阶段我们要加强，毕竟是我们自己的产品，不是外包项目，完全就丢弃；必须有思想有内涵。只求有这个功能，而深入思考产品设计是否合理、用户体验是否好。有的页面标题加上各种横幅要占2/5屏幕，搜索栏再占用一部分，留下可用面积很少，差不多只能显示45条数据。页面整体风格不好看。easyui缺省的风格还差强人意，而我们产品现在的风格确实谈不上好看，我感觉郑州的系统都比我们的系统好看点。有的页面图标不统一，比如树，这看起来完全就是一个练手工程，不像一个产品。菜单分类不合理。有的下面只有一个子菜单，而另一同一级菜单下面有十几个子菜单，完全是三长两短。页面上各种低级Bug。对产品的质量要求不够，每一个开发人员要以测试人员的标准来要求自己，我们是在做一个产品，不是一个demo。对需求的理解不够，功能只完成部分，而在bug修复期来完成剩下的。我们的功能验收测试流程没有执行，说是做完的功能亦无人检查。需求文档无人关注，多数人只看UI就开干。一个完整的需求包括三部分：UIDemo、业务流程和规则说明、实体关系说明（ER图），只关注UI，那是前端人员的逻辑，我们需要关注业务整体流程，关注业务模块之间的联系，把表单的数据存储到DB中，那只是刚刚开始。技术团队", "management/Java实习人员培养方案.md": "TOCJavaWeb人员培养原则培养对象有一定的Html/CSS、Java编程基础；制定严格的学习计划，可量化的考核标准；20%知识点学习，80%实践练习，以实例练习为主；内容包括Web页面开发、Java编程、RMDB三个部分。第一阶段：Web页面开发简介本阶段是所有前端、后端工程师都必须学习的阶段。本阶段结束后，有志于更深层次的前端开发，可以选择走前端工程师培养路线；而希望走JavaWeb开发方向，可以选择JavaWeb开发。本阶段学习时间大约在2个月左右，需要学习内容包括：HTML、CSS、JS、jQuery、EasyUI等。学习内容学习教材是《网页开发手记.HTML.CSS.JavaScript实战详解》和《jQueryEasyUI教程》，培养对象需要完成指定章节的所有实例开发。《网页开发手记.HTML.CSS.JavaScript实战详解》包括四个篇章，分别为：HTML基本知识、CSS样式控制、JavaScript编程、综合实战。《jQueryEasyUI教程》主要是实例讲解。考核方式在培养期间，培养对象需要按周提交自己编写的教材中的实例；培养期结束，提供所有实例。现场考核：在脱网的情况下，完成一个网站开发，可自选题目，也可选择《网页开发手记》中的综合实例（个人网站、门户网站）。现场考核：在脱网的情况下，完成一个基于EasyUI的CRUD程序（数据通过JSON模拟）。考核对象需要在8小时内完成现场考核。学习进度快者，可以提前考核。进度安排第1周：完成HTML基本知识学习。第2周：完成CSS样式表学习。第3、4周：完成JavaScript学习。第5周：完成个人网站开发。第6周：完成门户网站开发。第7、8周：完成EasyUI技术学习。第二阶段：JavaWeb开发简介在完成Web页面开发培训阶段后，方可进入本阶段学习。本阶段学习时间大约在2个月左右，需要学习内容包括：Java常用开发技术、数据库SQL。本阶段需要完成一个实验项目开发。学习内容Java常用开发技术教材为《Java经典实例第三版》节选，主要内容是Java基础知识，培养对象需要完成节选章节的所有实例开发。数据库SQL教材为《SQL必知必会第4版》，包括全书的所有内容，培养对象需要熟练掌握书中所有实例。基于Spring的数据库编程，本部分主要参考本公司的项目实例，公司会安排导师讲解培训。【任务跟踪管理系统】实验项目开发。考核方式在培养期间，培养对象需要按周提交自己编写的教材中的实例；培养期结束，提供所有实例。完成实验项目开发，根据完成情况打分。现场考核：在脱网的情况下，完成从《Java经典实例第三版》选取4道题目和一个Java编程题目，以及2道综合的SQL题目。现场考核：基于公司的框架完成一个简单CRUD应用，前端要求使用EasyUI。考核对象需要在8小时内完成现场考核。进度安排第1周：完成《Java经典实例》字符串、数字处理两部分学习。第2周：完成《Java经典实例》日期时间、结构化数据两部分学习。第3周：完成《SQL必知必会第4版》前14章关于DQL学习。第4周：完成《SQL必知必会第4版》后8章学习。第5周：完成基于Spring的公司框架demo讲解，并完成demo开发。第6、7周：独立完成【任务跟踪管理系统】实验项目开发。任务安排要求：注册一个网络笔记app。记录在查询资料中遇到各种问题和答案。每遇到的问题，多问几个为什么。任务01、tomcat优化及性能测试编写一个简单的javaweb程序。使用servlet或SpringMVC都行。在CentOS上安装tomcat，并运行此web应用。调试tomcat配置参数使其并发性能达到最优。使用并发性能测试工具（如：ab，JMeter等）测试此应用，给出测试数据。", "management/《一分钟经理人》.md": "www.bilibili.com/video/BV1qA411N7CNwww.bilibili.com/video/BV1qA411H7uD一分钟目标和员工一起制定目标清晰定义20%重要的目标（写在纸上）步骤目标内容完成标准完成期限一分钟称赞立即表扬，用心诚恳多称赞做得对的地方三步1、前半分钟，称赞他哪里做得对，以及对团队的正向贡献。2、停顿一下，让员工消化吸收。3、后半分钟，鼓励他继续这样做。一分钟更正反模式：批评，自己替员工干，秋后算账。三步：1、错在何处。他的错对团队的影响，以及自己的感受。对事不对人。2、停顿一下，让员工消化吸收。3、鼓励改进。告诉他的能力比这次表现更强，你对他任然有信心。", "management/《硝烟中的Scrum和XP》笔记.md": "《硝烟中的Scrum和XP》笔记ProductBacklog产品backlog是Scrum的核心，也是一切的起源。从根本上说，它就是一个需求、或故事、或特性等组成的列表，按照重要性的级别进行了排序。它包括：id，名称，重要性，初始估算、如何演示、备注等属性。通常，我们会把backlog存放在共享的Excel文档里面（是为了多个用户可以同时编辑它）。Sprint计划准备：在sprint计划会议之前，要确保产品backlog的井然有序。即：1、必须有产品Backlog，且只有一个2、有一个产品经理3、故事的优先级被评定过4、产品经理应当理解每一个故事的含义。制定Sprint计划：团队一起在Sprint计划会议上制作Sprint计划。Sprint计划会议成果如下：1、明确sprint目标。（确定实现哪些故事点）2、团队成员名单（以及他们的投入程度，如果不是100%的话）。3、sprintbacklog（即sprint中包括的故事列表）。4、确定好sprint演示日期。5、确定好时间地点，供举行每日scrum会议。**产品负责人一定要参加Sprint计划会议（确定范围、重要性、交付日期等）。**会前准备会议日程（时间表）。**使用索引卡：在大多数sprint计划会议上，大家都会讨论产品backlog中的故事细节。对故事进行估算、重定优先级、进一步确认细节、拆分，等等都会在会议上完成。**重要事项：Sprint计划会议结束后，我们的Scrummaster会手工更新Excel中的产品backlog，以反映故事索引卡中发生的变化。**把故事拆分成任务，时间估算更精确。把团队分成不同的二人组，让他们每组同时各自拆分一个故事。用即时贴将任务贴在每个故事的下方，每张即时贴表示这个故事中的一个任务。**定义“完成”：大家（产品经理、开发人员、测试人员）认可。**使用计划纸牌做时间估算：通常每个成员都会参与所有故事的估算。**把故事拆分成更小的故事**故事是可以交付的东西，是产品负责人所关心的。任务是不可交付的东西，产品负责人对它也不关心。例如：查询用户的故事，可分为以下任务：弄清需求、写TestCase、设计GUI、研究报表工具、实现用户列表、实现查询表单、集成测试、重构等。**技术故事：安装持续构建服务器、编写系统设计概览、重构DAO层、升级Jira。（抛弃、融入其他故事中、单独处理）。发布Sprint信息页：让公司了解我们在干什么。编写SprintBacklog：SprintBacklog形式：Excel、JIRA、墙（任务板）任务的状态：Unplanned、Planning、Ongoing、Done等。Burndown图：警示标记每日例会1、更新任务板2、记录风险、障碍3、处理迟到、“不知道干什么”Sprint回顾Sprint演示：**所有的sprint都结束于演示Sprint回顾：1、会议、轮流发言2、目标：“我们怎样才能在下个sprint中做的更好”。3、做得好的、可改进的。4、在团队间传播经验怎样制定发布计划，处理固定价格的合同1、定义你的验收标准：产品负责人从合同的角度将产品backlog中的条目的重要性级别进行了简单分类（红、黄、绿+分值）2、对最重要的条目进行时间估算：这是产品负责人和团队协作共同完成的――团队进行估算。（只是粗略估算，而不是承诺）3、估算每一个Sprint的平均生产率：要确定团队的投入程度，估算在一个Sprint内团队能多少个故事点。4、统计一切因素，生成发布计划：的把产品backlog拆到sprints中，计算要花几个Sprint；预留较多的缓冲时间。5、调整发布计划：根据实际生产率、故事工作量，调整并更新发布计划。组合使用Scrum和XP**Scrum注重的是管理和组织实践，而XP关注的是实际的编程实践。这就是为什么它们可以很好地协同工作――它们解决的是不同领域的问题，可以互为补充，相得益彰。1、结对编程2、TDD（最重要）3、增量设计4、持续集成5、代码集体所有权管理多个Scrum团队1、衡量团队的个数和团队的人数（59）2、同步多个团队的Sprint3、创建跨职能的Scrum团队4、ScrumofScrums会议（团队、产品两类）5、交错的每日例会6、救火Scrum团队（物理分离）7、产品经理和产品Backlog的个数（三种情况）8、团队回顾（Sprint演示完后，各自回顾）9、代码分支问题", "management/光芒研发的问题和建议.md": "各位领导，就UI的问题，我说一下我的浅见，有则改之无则加勉吧。首先，我建议我们成立业务分析和产品设计团队，简称产品团队。个人认为，UI可视化风格落伍这个问题只是我们在需求分析和产品设计上缺失的一个方面，如果单针对这一点采取措施，即使这次我们在某一个项目上UI有改进，也难以改进我们所有产品UI风格。我们的信息化软件开发还在做完（满足客户功能需求）这个层面上挣扎，而在产品质量（如UI）上的要求远未涉及。功能和质量是一体两面的问题，我们要解决UI的问题，必须解决功能的问题。个人认为，需求分析和产品设计是我们信息化最大的瓶颈，也是产品进度、质量出现问题最大原因（下面细说）。我们的开发过程VS业界开发过程我们的软件开发过程是，需求人员去市场调研，从用户那里获取了一些需求意向，当决定开始做这个项目时，直接将这些**意向**告知给开发人员（大多数时候无文档，有时有文档，但很难看懂），设计出数据库表，至于功能设计、界面设计、程序结构由开发人员看着办，可以想象开发人员能设计出什么样的东西。在现如今的中国，以互联网企业为代表，软件团队必不可少有产品团队和架构师团队两个团队，他们主要解决产品设计和程序架构的问题。他们的开发过程是这样的，调研到需求后，充分的分析（往往以文档和原型图记录，这是一个思考过程，重点不是文档），写出设计稿，然后对设计稿进行广泛的讨论，确定设计稿中的各项功能必要性和正确性，确定之后，将这些功能细化为能独立开发功能，而项目管理人员需要根据这份细化的功能清单制作开发计划。他们基本做到无细化的功能需求不进行开发。现阶段的问题**项目leader兼职需求分析。**需求是一件繁琐的工作，身兼两职的leader通常会顾此失彼。从需求方面来看，没有足够的时间研究需求，必然导致需求质量不好，直接导致产品质量不好。比如：上周黄圣波出差两周，据我了解他们组的成员，想找他了解需求都没办法。从项目管理角度来看，一个经常出差调研需求的项目经理，对项目进度控制必然不够好。**需求分析和产品设计粗糙。**面对粗糙的需求意向，开发人员在刚开始开发时会迷茫，开发过程中因为需求不清而犹豫，开发完成后会因为偏离需求，需要不停的返工，这就是目前我们进度滞后的主要原因。**需求传达到开发人员效果极差。**这可能是我们需求丢失最严重的环节。开始开发后，leader往往口头告诉开发人员大概要做一个什么东西，再给一个表设计就没有其他东西了。然后，开发人员理解他的工作就是一些表的增删查改，而详细需求和业务目的他们不清楚，至于UI设计就变成他们常用table了（开发人员是没有UI设计能力的）。**对需求的开发结果验证缺失。**可能因为出差、管理项目等等多种事情太多，需求分析人员很少去确认被开发出来的东西是不是客户想要的，然后直接给客户，客户直面需求不符合项、bug等等问题。**产品的客户互动和反馈缺失。**如果一个经过6个月开发完产品，只在开发完给客户看一次，客户提了意见我们再修改（客户一般不能一次性就能把意见提完、提对），一般需要修改2个月以上（有时修改时间甚至超过6个月），这个成本太高，周期太长，真是新三年，旧三年，缝缝补补又三年。解决办法基于以上问题，我建议我们成立业务分析和产品设计团队。团队职责产品团队的职责是需求调研、需求分析、产品设计等三项工作。禁止产品团队成员（暂称为BA）兼职项目leader、开发人员，BA可以兼顾多个子产品，应对多个开发团队，让BA专注于需求分析和产品设计。也只有BA专注于产品设计，他们看问题的角度才会发生改变，对软件功能、UI界面的看法和其他人会完全不一样，这UI才会得到真正的改进。这也是目前大多数互联网和软件企业BA人员的定义。组成人员目前，只需将我们现有的系统分析师组合成一个团队，设置总负责人，团队中的BA负责各个项目的需求和产品设计，团队成员需要对产品设计充分讨论，以免失于片面。具体事务产品团队负责公司整个信息化产品体系规划与设计，结合市场、与项目经理一起制定产品发布计划。每一个BA需要在团队内分享调研结果，并融入产品体系。BA需要为其他BA提供严格的、切实有效的同行评审（或两个共同负责）。只有在BA给出具体的需求清单后，才能制定详细的开发计划（非产品发布计划）。在开发之初，BA需要给开发团队讲解需求，在开发过程中，及时释疑。在开发完成后BA需要在交付测试组前及时正式的验收测试。建立长效的客户反馈机制（一月一次？客服部是否参与？），定期给客户展示我们的产品，获取反馈，改进产品。", "management/光芒研发的问题和建议2.md": "1.建立需求分析与设计团队（产品团队）现阶段的问题客户需求不能有效分享和利用。现在的需求调研，一般是根据不同项目需要，派某个系统分析师去调研，调研完成之后，所获得的信息未充分的消化吸收，转化为我们整个产品线成果，成为系统分析师个人或所在项目组的知识，未纳入产品设计体系，对改进产品的作用微弱，也经常导致需求疏漏。以上周郑州调研为例，需求分析师带回来很多客户反映的问题，我们做出了一些应对措施，但是更应该把一些问题归纳为我们整个产品线都应该遵守的准则，形成文案，并告知所有需求分析师、架构师、开发人员、测试人员。当然，这只是其中一个方面，我想说明的关键一点是，我们应该不断的获取客户的要求，充分的去分析这些需求，消化吸收，并采取相应的措施，并将这些措施或准则作为我们整个产品设计团队、开发团队原则或理念。产品需求与设计不成体系。系统分析师去做需求调研，都是针对某一个项目被动去了解需求，没有事前的产品细节规划。获取回来的需求没有考虑怎样纳入光芒的产品体系，只是解决了项目的某个问题，应该从产品设计角度，来确定哪些需求纳入产品，哪些作为自定义开发，以及产品设计、系统架构方便要做哪些考虑。不能只针对单个项目闭门造车。我们有对产品的顶层设计，都是更应该对这些顶层设计每一个部分进行细化，这份细化的蓝图就好像是可以不断下钻的地图，不同比例尺有不同的东西展示，把这份地图摆出了，看看我们还差哪些部分内容，然后针对这些缺失的内容，我们再去调研、设计产品、开发产品，掌握产品的主动权，才能更好的响应市场的需求。需求分析和产品设计粗糙。我们的软件开发过程是，需求人员去市场调研，从用户那里获取了一些需求意向，当决定开始做这个项目时，直接将这些意向告知给开发人员（有时有文档，但很难看懂），设计出数据库表，至于功能设计、界面设计、程序结构由开发人员看着办，可以想象开发人员能设计出什么样的东西。在现如今的中国，以互联网企业为代表，软件团队必不可少有产品团队和架构师团队两个团队，他们主要解决产品设计和程序架构的问题。他们的开发过程是这样的，调研到需求后，充分的分析（往往以文档和原型图记录，这是一个思考过程，重点不是文档），写出设计稿，然后对设计稿进行广泛的讨论，确定设计稿中的各项功能必要性和正确性，确定之后，将这些功能细化为能独立开发功能，而项目管理人员需要根据这份细化的功能清单制作开发计划。需求分析和产品设计是我们对产品的第一次思考、第一次构建，它非常重要，它对产品的各个方面的实现细节进行了构思和验证，它决定开发进度，决定产品质量，决定项目成败。粗糙的需求分析和产品设计已经成为我们产品开发最大的瓶颈，开发人员刚得到粗糙需求时迷茫，开发过程中因为需求不清而犹豫，开发完成后，因为不能完全意会需求人员的意图，需要不停的返工，在没有棘手的技术难题情况下，这些是我们进度滞后、质量低下的最大原因。分析和设计最最基本的产出物是简明的足够细分的树型的需求说明文档、界面原型、实体关系图，这是最精简的东西，不能再减了，否则我们无法把产品的意图完整告知给开发人员。好在我们在这方面已经在改进，但是还不够，我们应该更加重视，做到无需求不开发。目前我们的情况是，需求分析是项目进度和质量的瓶颈，没有足够细需求条目，就没有足够细的项目计划，就没有足够清晰的开发目标；不能细化需求，就不能快速迭代发布，测试人员、客户都不能更早的看到我们的产品。清晰需求条目应该作为启动开发的先决条件。需求传达到开发人员效果极差。这可能是我们需求丢失最严重的环节，我们经常是，客户对我们提出一个功能，到了我们开发人员那里变成了一个与业务毫无关联的数据库表的增删查改，甚至连有业务关联的表都置之不理，最后造成数据不一致。在项目启动开发前，需求分析人员需要对开发人员进行正式的需求宣讲（项目启动会之后），讲为啥要开发这个功能，业务相互之间有啥关系，具体业务逻辑，界面有什么要求等。除宣讲外，开发人员和需求人员需要积极沟通、确认。对需求的开发结果验证缺失。我们现在需求人员很少或基本没有去验证开发人员开发出来的东西是否符合需求要求，往往是直接丢给客户，让客户来评判，从客户到需求分析师，从需求分析师到开发人员，每一个环节都有可能造成信息的遗漏，如果不严格地严重开发结果是否符合需求要求，可想而知，我们从客户那里能得到什么。开发结果的验证要注重三个方面：第一、开发过程中，需求人员主动地查看开发人员开发出来的东西是否有偏差，及时纠正。第二、在一个功能开发完，应该正式（或非正式）的安排验收工作，不符合要求的，尽早返工。第三、测试人员及早验证，测试不仅是发现bug，更重要是保证开发人员对需求理解的正确性。产品的客户互动和反馈缺失。我们应该缩短产品的发布（非技品部的发布）周期，最差最差一个月要发布一次，并尽早把做出来的东西给客户看看，最少一个月得到客户反馈一次（驻场开发更佳）。如果一个经过6个月开发完产品，只在开发完给客户看一次，客户提了意见我们再修改（客户一般不能一次性就能把意见提完、提对），一般需要修改2个月以上（有时修改时间甚至超过6个月），这个成本太高，周期太长，真是新三年，旧三年，缝缝补补又三年。客户反馈是我们产品的根基，产品的一切依存于此，我们应该建立一种长效机制及时获取客户的反馈。解决办法如果我们建立一个产品团队，负责需求调研、收集、分析，产品设计、功能传达，功能验收、客户反馈等工作。只需将我们现有的系统分析师组合成一个团队，设置负责人（此人必须积极负责），团队一起制定产品体系及细节，一起分享客户需求，组内对每一个产品需求和设计进行充分的讨论。软件开发有两次构建，一次是需求及产品的设计，一次是开发实现。第一次构建比第二次更重要，也更难，做好第一次构建，项目基本很难失败。所以，需求和产品需要讨论再讨论，不能闭门造车，再优秀的产品设计师有时也难免有失偏颇，何况我们都是一般人。除了产品团队组内，每一个系统分析师还是要负责到各自的项目中，产品团队成员为其他项目提供需求及产品设计的同行评审，同时团队每一人都应该把各自项目的情况反馈到产品体系中。总之，好的产品需要讨论、传达、反馈，缺那个都不行；产品设计需要多人的团队设计，最忌闭门造车；产品需要体系、需要行业整体解决方案，我们有体系规划，但是落地不好。所以，成立产品团队是解决我们信息化目前困境当务之急。2.采用迭代或增量生命周期模型现阶段的问题瀑布模型的问题。我不想说瀑布模型有多坏，因为10年前人们都说过了。但是提到瀑布模型，只会让人想到项目延期、质量失控、范围一缩再缩，即使如此，项目最好的结果也不会太好。瀑布模型对项目管理能力要求奇高无比，有点像玩杂技，要成功必须每一个项目过程的环节控制精准无误，稍有差错，就会垮下来。瀑布模型抗变化能力弱，稍稍偏离计划，困难和成本代价高昂，12两个月的小项目还能控制，大了就不行，其根源源于人类对未知事物的预见性差，我们不能看到或预测到更远的未来。开发过程的问题。瀑布模型对需求、设计、开发、测试、发布有严格的要求，如果我们能严格的去做也能避免许多风险。但是我们没有，我们没有需求文档可以去开发，我们的产品可以不测试或少测试就能发往现场，我们的开发人员可以自己随意决定如何实现而不考虑全局，一切都太随意。我不是要说我们同事有多不负责责任，我想说的是这就是瀑布模型原罪，不失进度，就失质量，不失质量，就失进度或范围，没几个人搞得好瀑布模型。早在510年前先锋的软件企业就抛弃了它。CMMI的问题。我所了解的CMMI3及企业，大多重文档规范、重标准流程，而轻软件工程过程，不知哪些该裁剪，哪些能精简，最后的结果就是搞一套很僵化流程，弄的人人别扭，多人反感。对于CMMI来说，我个人认为软件工程过程解决办法3.稳定的小团队现阶段的问题解决办法", "management/关于架构团队的思考.md": "我个人认为架构组的主要职责有以下几点：提供技术培训。这一点在我们公司尤为重要。首先、培养前端开发人员。公司人员流动相对稳定，而前端开发人员不好招聘，如果我们自己来培养应届毕业生，花费13个月完全可以培养出比较好的前端开发人员的，而招聘前端人员基本是招不到。第二、实施CodeReview，提高大家的编码能力。我们公司开发人员学习技术热情太低，必须培养学习热情。我自己刚毕业那会，一个月都要看一两本技术书，但是公司大部分开发人员桌子上没有书，也不见大家一起讨论技术问题。第三、主办技术论坛。每12周一个技术专题分享和讨论。建立学习机制、提高员工的能力能提高团队的开发能力、能提高员工对公司的向心力。长远的技术储备能使得项目技术难题变少。我很渴望将自己的经验和技术知识传递给大家。平台规划与实现。主要负责应用架构、基础设施架构、信息安全架构，核心代码实现，但不应该是所有代码实现。我的优势是我的经验、我的架构设计能力，其他我并不占优势，而现在我的角色也就是一个普通开发人员，这对我个人或公司都是浪费。技术前瞻性研究。如果我们没有做这项工作，那么当业务市场、产品需要某种技术时，只能抓瞎，比如：大数据技术我们一年前就说研究（2016年计划里面我就写了），现在PHM项目需要大数据技术，我们没有储备，这种风险太大，项目基本不可能成功。在比如：机器人项目虽然在9月份以后才会考虑监控中心开发，但是里面技术很多都是以前信息化这边没有涉及的，如果不提前准备，想要年底出一个原型，那么风险也是巨大的。难点攻关。现在即使有难点攻关，大家找到我，我也只能发表一下意见，没时间去研究。所以技术难题有两种结果：第一被置之不理；第二项目组人自己研究。项目组自己研究首先会拖慢项目进度，其次是他们经验毕竟有限，不会有很好解决方案。比如：6C浏览器播放图片速度慢的问题，樊经理找过我，但是真的没时间，从去年到现在一直项目组自己研究，但他们又能做什么？业务产品的架构与实践。产品架构设计。我们的产品开发过程一般是直接从需求到实现，一般都没有设计人员参与，导致可能结果是产品需要设计上进行重构，比如：去年我主导的设备建模与设备管理DB设计，这都是不改不行了，而这种基础改动都是伤筋动骨的，代价高昂。仅仅去年一个多月去搞这个产品架构设计的事，我不知道我们的产品还有多少这种设计不合理的。开发实践改进。比如：前后端分离的开发方式，对业务的代码如何测试问题。为了摆脱一般性琐碎任务的干扰，完成我们的主要目标，**架构组这边急需人员组成团队，没有高级的，初级也凑活，即使应届生也比没有强**。如果长期这种一个人，也做不了什么，对我自己是浪费时间，对公司也是浪费成本。", "management/前端人员的培训方案.md": "2019年Web前端入门的自学路线www.cnblogs.com/qianguyihao/p/8776837.htmlHTML/CSS/JS语法下面这个资料非常全，也简洁：github.com/qianguyihao/Webgithub.com/helloqingfeng/AwsomeFrontEndlearningresourceJavaScript30天30题github.com/wesbos/JavaScript30github.com/soyaine/JavaScript30www.bilibili.com/video/av74601251?p=20JS常用框架jQueryVue及ElementUI", "management/前端人员面试.md": "前端开发面试题<aname='preface'>前言</a>只看问题点这里markyun.github.io/2015/FrontendDeveloperQuestions/\"Questions\"看全部问题和答案点这里github.com/markyun/Myblog/tree/master/FrontendDeveloperQuestions/QuestionsandAnswers\"QuestionsandAnswers\"本文由我收集总结了一些前端面试题，初学者阅后也要用心钻研其中的原理，重要知识需要系统学习、透彻学习，形成自己的知识链。万不可投机取巧，临时抱佛脚只求面试侥幸混过关是错误的！也是不可能的！不可能的！不可能的！前端还是一个年轻的行业，新的行业标准，框架，库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。最近也收到许多微博私信的鼓励和更正题目信息，后面会经常更新题目和答案到github博客markyun.github.io/。希望前端er达到既能使用也会表达，对理论知识有自己的理解。可根据下面的知识点一个一个去进阶学习，形成自己的职业技能链。**面试有几点需注意：来源寒冬winterweibo.com/wintercn\"微博：寒冬winter\"老师，github:@wintercn**1.面试题目：根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。1.题目类型：理论知识、算法、项目细节、技术视野、开放性题、工作案例。1.细节追问：可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。1.回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲6101010101010307206101010101010306）1.资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。**前端开发所需掌握知识点概要：**HTML&CSS：对Web标准的理解（结构、表现、行为）、浏览器内核、渲染原理、依赖管理、兼容性、CSS语法、层次关系，常用属性、布局、选择器、权重、盒模型、Hack、CSS预处理器、CSS3、Flexbox、CSSModules、Documentflow、BFC、HTML5（离线&存储、Histoy,多媒体、WebGL\\SVG\\Canvas）；JavaScript：数据类型、运算、对象、Function、继承、闭包、作用域、事件、Prototype、RegExp、JSON、Ajax、DOM、BOM、内存泄漏、跨域、异步请求、模板引擎、模块化、Flux、同构、算法、ECMAScript6、Nodejs、HTTP、其他：主流MVVM框架React\\Vue\\Angular、HybridApp\\ReactNative\\Weex、TypeScript、RESTFul、WEB安全、前端工程化、依赖管理、性能优化、重构、团队协作、可维护、易用性、SEO、UED、前端技术选型、快速学习能力等；作为一名前端工程师，**无论工作年头长短都应该掌握的知识点**：此条由王子墨发表在攻城师的实验室lab.yuanwai.wang/1、DOM结构――两个节点之间可能存在哪些关系以及如何在节点之间任意移动。2、DOM操作――如何添加、移除、移动、复制、创建和查找节点等。3、事件――如何使用事件，以及IE和标准DOM事件模型之间存在的差别。4、XMLHttpRequest――这是什么、怎样完整地执行一次GET请求、怎样检测错误。5、严格模式与混杂模式――如何触发这两种模式，区分它们有何意义。6、盒模型――外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型7、块级元素与行内元素――怎么用CSS控制它们、以及如何合理的使用它们8、浮动元素――怎么使用它们、它们有什么问题以及怎么解决这些问题。9、HTML与XHTML――二者有什么区别，你觉得应该使用哪一个并说出理由。10、JSON――作用、用途、设计结构。**备注：**根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。更新记录：20180114：公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；20161020：更新一些已被发现的问题。20160325：新增ECMAScript6相关问题<aname='html'>HTML</a>Doctype作用？标准模式与兼容模式各有什么区别?（1）、<!DOCTYPE>声明位于HTML文档中的第一行，处于<html>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。（2）、标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。HTML5为什么只需要写`<!DOCTYPEHTML>`？HTML5不基于SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。行内元素有哪些？块级元素有哪些？空void元素有那些？首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。（1）行内元素有：abspanimginputselectstrong（强调的语气）（2）块级元素有：divulollidldtddh1h2h3h4…p（3）常见的空元素：<br><hr><img><input><link><meta>鲜为人知的是：<area><base><col><command><embed><keygen><param><source><track><wbr>不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异参考:stackoverflow.com/questions/6867254/browsersdefaultcssforhtmlelements页面导入样式时，使用link和@import有什么区别？（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;（3）import是CSS2.1提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;4link支持使用js控制DOM去改变样式，而@import不支持;介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎layoutengineer或RenderingEngine和JS引擎。渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎则：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。常见的浏览器内核有哪些？Trident内核：IE,MaxThon,TT,TheWorld,360,搜狗浏览器等。又称MSHTMLGecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等Presto内核：Opera7及以上。Opera内核原为：Presto，现为：Blink;Webkit内核：Safari,Chrome等。Chrome的：Blink（WebKit的分支）详细文章：浏览器内核的解析和对比www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.htmlhtml5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5？*HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加。绘画canvas;用于媒介回放的video和audio元素;本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除;语意化更好的内容元素，比如article、footer、header、nav、section;表单控件，calendar、date、time、email、url、search;新的技术webworker,websocket,Geolocation;移除的元素：纯表现的元素：basefont，big，center，font,s，strike，tt，u;对可用性产生负面影响的元素：frame，frameset，noframes；*支持HTML5新标签：IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim;<!ifltIE9><script>src=\"html5shim.googlecode.com/svn/trunk/html5.js\"</script><!endif>*如何区分HTML5：DOCTYPE声明\\新增的结构元素\\功能元素简述一下你对HTML语义化的理解？用正确的标签做正确的事情。html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。HTML5的离线储存怎么使用，工作原理能不能解释一下？在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制不是存储技术，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。如何使用：1、页面头部像下面一样加入一个manifest的属性；2、在cache.manifest文件的编写离线存储的资源；CACHEMANIFESTv0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK://offline.html3、在离线状态时，操作window.applicationCache进行需求实现。详细的使用请参考：HTML5离线缓存manifest简介yanhaijing.com/html/2014/12/28/html5manifest/有趣的HTML5：离线存储segmentfault.com/a/1190000000732617浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。离线的情况下，浏览器就直接使用离线存储的资源。详细请参考：有趣的HTML5：离线存储segmentfault.com/a/1190000000732617请描述一下cookies，sessionStorage和localStorage的区别？cookie是网站为了标示用户身份而储存在用户本地终端（ClientSide）上的数据（通常经过加密）。cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。存储大小：cookie数据大小不能超过4k。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。有期时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除。cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭iframe有那些缺点？*iframe会阻塞主页面的Onload事件；*搜索引擎的检索程序无法解读这种页面，不利于SEO;*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题。Label的作用是什么？是怎么用的？label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<labelfor=\"Name\">Number:</label><inputtype=“text“name=\"Name\"id=\"Name\"/><label>Date:<inputtype=\"text\"name=\"B\"/></label>HTML5的form如何关闭自动完成功能？给不想要提示的form或某个input设置为autocomplete=off。如何实现浏览器内多个标签页之间的通信?阿里WebSocket、SharedWorker；也可以调用localstorge、cookies等本地存储方式；localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；注意quirks：Safari在无痕模式下设置localstorge值时会抛出QuotaExceededError的异常；webSocket如何兼容低浏览器？阿里AdobeFlashSocket、ActiveXHTMLFileIE、基于multipart编码发送XHR、基于长轮询的XHR页面可见性（PageVisibilityAPI）可以有哪些用途？通过visibilityState的值检测页面当前是否可见，以及打开网页的时间等;在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；如何在页面上实现一个圆形的可点击区域？1、map+area或者svg2、borderradius3、纯js实现需要求一个点在不在圆上简单算法、获取鼠标坐标等等实现不使用border画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。<divstyle=\"height:1px;overflow:hidden;background:red\"></div>网页验证码是干嘛的，是为了解决什么安全问题。区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<B>是展示强调内容。i内容展示为斜体，em表示强调的文本；PhysicalStyleElements自然样式标签b,i,u,s,preSemanticStyleElements语义样式标签strong,em,ins,del,code应该准确使用语义样式标签,但不能滥用,如果不能确定时首选使用自然样式标签。<aname='css'>CSS</a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？（1）有两种，IE盒子模型、W3C盒子模型；（2）盒模型：内容content、填充padding、边界margin、边框border；（3）区别：IE的content部分把border和padding计算了进去;CSS选择符有哪些？哪些属性可以继承？*1.id选择器（myid）2.类选择器（.myclassname）3.标签选择器（div,h1,p）4.相邻选择器（h1+p）5.子选择器（ul>li）6.后代选择器（lia）7.通配符选择器（*）8.属性选择器（arel=\"external\"）9.伪类选择器（a:hover,li:nthchild）*可继承的样式：fontsizefontfamilycolor,ULLIDLDDDT;*不可继承的样式：borderpaddingmarginwidthheight;CSS优先级算法如何计算？*优先级就近原则，同权重情况下样式定义最近者为准;*载入样式以最后载入的定位为准;优先级为:同权重:内联样式表（标签内部）>嵌入样式表（当前文件中）>外部样式表（外部文件中）。!important>id>class>tagimportant比内联优先级高CSS3新增伪类有那些？举例：p:firstoftype选择属于其父元素的首个<p>元素的每个<p>元素。p:lastoftype选择属于其父元素的最后<p>元素的每个<p>元素。p:onlyoftype选择属于其父元素唯一的<p>元素的每个<p>元素。p:onlychild选择属于其父元素的唯一子元素的每个<p>元素。p:nthchild2选择属于其父元素的第二个子元素的每个<p>元素。::after在元素之前添加内容,也可以用来做清除浮动。::before在元素之后添加内容:enabled:disabled控制表单控件的禁用状态。:checked单选框或复选框被选中。如何居中div？*水平居中：给div设置一个宽度，然后添加margin:0auto属性div{width:200px;margin:0auto;}*让绝对定位的div居中div{position:absolute;width:300px;height:300px;margin:auto;top:0;left:0;bottom:0;right:0;backgroundcolor:pink;/*方便看效果*/}*水平垂直居中一确定容器的宽高宽500高300的层设置层的外边距div{position:relative;/*相对定位或绝对定位均可*/width:500px;height:300px;top:50%;left:50%;margin:150px00250px;/*外边距为自身宽高的一半*/backgroundcolor:pink;/*方便看效果*/}*水平垂直居中二未知容器的宽高，利用`transform`属性div{position:absolute;/*相对定位或绝对定位均可*/width:500px;height:300px;top:50%;left:50%;transform:translate50%,50%;backgroundcolor:pink;/*方便看效果*/}*水平垂直居中三利用flex布局实际使用时应考虑兼容性.container{display:flex;alignitems:center;/*垂直居中*/justifycontent:center;/*水平居中*/}.containerdiv{width:100px;height:100px;backgroundcolor:pink;/*方便看效果*/}display有哪些值？说明他们的作用。block块类型。默认宽度为父元素宽度，可设置宽高，换行显示。none元素不显示，并从文档流中移除。inline行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。inlineblock默认宽度为内容宽度，可以设置宽高，同行显示。listitem象块类型元素一样显示，并添加样式列表标记。table此元素会作为块级表格来显示。inherit规定应该从父元素继承display属性的值。position的值relative和absolute定位原点是？absolute生成绝对定位的元素，相对于值不为static的第一个父元素进行定位。fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。relative生成相对定位的元素，相对于其正常位置进行定位。static默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,rightzindex声明）。inherit规定从父元素继承position属性的值。CSS3有哪些新特性？新增各种CSS选择器（:not.input：所有class不是“input”的节点）圆角（borderradius:8px）多列布局（multicolumnlayout）阴影和反射（Shadow\\Reflect）文字特效（textshadow、）文字渲染（Textdecoration）线性渐变（gradient）旋转（transform）缩放,定位,倾斜,动画,多背景例如:transform:\\scale0.85,0.90\\translate0px,30px\\skew9deg,0deg\\Animation:请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。较为复杂的布局还可以通过嵌套一个伸缩容器（flexcontainer）来实现。采用Flex布局的元素，称为Flex容器（flexcontainer），简称\"容器\"。它的所有子元素自动成为容器成员，称为Flex项目（flexitem），简称\"项目\"。常规布局是基于块和内联流方向，而Flex布局是基于flexflow流可以很方便的用来做局中，能对不同屏幕大小自适应。在布局上有了比以前更加灵活的空间。具体：www.w3cplus.com/css3/flexboxbasics.html用纯CSS创建一个三角形的原理是什么？把上、左、右三条边隐藏掉（颜色设为transparent）demo{width:0;height:0;borderwidth:20px;borderstyle:solid;bordercolor:transparenttransparentredtransparent;}一个满屏品字布局如何设计?简单的方式：上面的div宽100%，下面的两个div分别宽50%，然后用float或者inline使其不换行即可css多列等高如何实现？利用paddingbottom|marginbottom正负值相抵；设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定paddingbottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的paddingbottom补偿这部分高度差。经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧？*png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.*浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。*IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离box{float:left;width:10px;margin:000100px;}这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入――_display:inline;将其转化为行内属性。_这个符号只有ie6会识别渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。css.bb{backgroundcolor:red;/*所有识别*/backgroundcolor:00deff\\9;/*IE6、7、8识别*/+backgroundcolor:a200ff;/*IE6、7识别*/_backgroundcolor:1e0bd1;/*IE6识别*/}*IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute获取自定义属性;Firefox下,只能使用getAttribute获取自定义属性。解决方法:统一通过getAttribute获取自定义属性。*IE下,even对象有x,y属性,但是没有pageX,pageY属性;Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。*解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。*Chrome中文界面下默认会将小于12px的文本强制按照12px显示,可通过加入CSS属性webkittextsizeadjust:none;解决。超链接访问过后hover样式就不出现了被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:LVHA:a:link{}a:visited{}a:hover{}a:active{}li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。为什么要初始化CSS样式。因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。最简单的初始化方法：*{padding:0;margin:0;}（强烈不建议）淘宝的样式初始化代码：body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,pre,form,fieldset,legend,button,input,textarea,th,td{margin:0;padding:0;}body,button,input,select,textarea{font:12px/1.5tahoma,arial,\\5b8b\\4f53;}h1,h2,h3,h4,h5,h6{fontsize:100%;}address,cite,dfn,em,var{fontstyle:normal;}code,kbd,pre,samp{fontfamily:couriernew,courier,monospace;}small{fontsize:12px;}ul,ol{liststyle:none;}a{textdecoration:none;}a:hover{textdecoration:underline;}sup{verticalalign:texttop;}sub{verticalalign:textbottom;}legend{color:000;}fieldset,img{border:0;}button,input,select,textarea{fontsize:100%;}table{bordercollapse:collapse;borderspacing:0;}absolute的containingblock容器块计算方式跟正常流有什么不同？无论属于哪种，都要先找到其祖先元素中最近的position值不为static的元素，然后再判断：1、若此元素为inline元素，则containingblock为能够包含这个元素生成的第一个和最后一个inlinebox的paddingbox除margin,border外的区域的最小矩形；2、否则,则由这个祖先元素的paddingbox构成。如果都找不到，则为initialcontainingblock。补充：1.static默认的/relative：简单说就是它的父元素的内容框（即去掉padding的部分）2.absolute:向上找最近的定位为absolute/relative的元素3.fixed:它的containingblock一律为根元素html/body，根元素也是initialcontainingblockCSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间.position跟display、margincollapse、overflow、float这些特性相互叠加后会怎么样？如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inlineblock属性的元素,margin不会和垂直方向上的其他元素margin折叠.对BFC规范块级格式化上下文：blockformattingcontext的理解？（W3CCSS2.1规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）一个页面是由很多个Box组成的,元素的类型和display属性,决定了这个Box的类型。不同类型的Box,会参与不同的FormattingContext（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。css定义的权重以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：/*权重为1*/div{}/*权重为10*/.class1{}/*权重为100*/id1{}/*权重为100+1=101*/id1div{}/*权重为10+1=11*/.class1div{}/*权重为10+10+1=21*/.class1.class2div{}如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现请解释一下为什么需要清除浮动？清除浮动的方式清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。1、父级div定义height；2、父级div也一起浮动；3、常规的使用一个class；.clearfix::before,.clearfix::after{content:\"\";display:table;}.clearfix::after{clear:both;}.clearfix{*zoom:1;}4、SASS编译的时候，浮动元素的父级div定义伪类:after&::after,&::before{content:\"\";visibility:hidden;display:block;height:0;clear:both;}解析原理：1display:block使生成的元素以块级元素显示,占满剩余空间;2height:0避免生成内容破坏原有布局的高度。3visibility:hidden使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;4）通过content:\".\"生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的content:\".\",有些版本可能content里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0content:”\"仍然会产生额外的空隙；5）zoom：1触发IEhasLayout。通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有fontsize：0，lineheight：0。什么是外边距合并？外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。w3school介绍网址：www.w3school.com.cn/css/css_margin_collapsing.aspzoom:1的清除浮动原理?清除浮动，触发hasLayout；Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。来龙去脉大概如下：当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在CSS3.0规范草案中。目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？可以通过css3里面的动画属性scale进行缩放。移动端的布局用过媒体查询吗？假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法<!link元素中的CSS媒体查询>当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，<link>标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。<linkrel=\"stylesheet\"media=\"maxwidth:800px\"href=\"example.css\"/><!样式表中的CSS媒体查询>包含了一个媒体类型和至少一个使用宽度、高度和颜色等媒体属性来限制样式表范围的表达式。CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。<style>@mediaminwidth:700pxandorientation:landscape{.sidebar{display:none;}}</style>使用CSS预处理器吗？喜欢那个？SASSSASS、LESS没有本质区别，只因为团队前端都是用的SASSCSS优化、提高性能的方法有哪些？关键选择器（keyselector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）；浏览器是怎样解析CSS选择器的？样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。在网页中的应该使用奇数还是偶数的字体？为什么呢？margin和padding分别适合什么场景使用？margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段抽离样式模块怎么写，说出思路，有无实践经验？阿里航旅的面试题元素竖向的百分比设定是相对于容器的高度吗？全屏滚动的原理是什么？用到了CSS的那些属性？什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？）::before和:after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用。单冒号:用于CSS3伪类，双冒号::用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:firstline、:firstletter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上如何修改chrome记住密码后自动填充表单的黄色背景？input:webkitautofill,textarea:webkitautofill,select:webkitautofill{backgroundcolor:rgb250,255,189;/*FAFFBD;*/backgroundimage:none;color:rgb0,0,0;}你对lineheight是如何理解的？设置元素浮动后，该元素的display值是多少？自动变成了display:block怎么让Chrome支持小于12px的文字？1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置webkittextsizeadjust:none，做到最大兼容考虑。4、使用12px以上字体：为了兼容、为了代码更简单从新考虑权重下兼容性。让页面里的字体变清晰，变细用CSS怎么做？webkitfontsmoothing:antialiased;fontstyle属性可以让它赋值为“oblique”oblique是什么意思？倾斜的字体样式position:fixed;在android下无效怎么处理？fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，原来的网页还好好的在那，fixed的内容也没有变过位置，所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。<metaname=\"viewport\"content=\"width=devicewidth,initialscale=1.0,maximumscale=1.0,minimumscale=1.0,userscalable=no\"/>如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms＝16.7msdisplay:inlineblock什么时候会显示间隙？携程移除空格、使用margin负值、使用fontsize:0、letterspacing、wordspacingoverflow:scroll时不能平滑滚动的问题怎么处理？有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。png、jpg、gif这些图片格式解释一下，分别什么时候用。有没有了解过webp？什么是Cookie隔离？（或者说：请求资源的时候不要让它带cookie怎么做）如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的http请求的解析速度。style标签写在body后与body前有什么区别？什么是CSS预处理器/后处理器？预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。rem布局的优缺点<aname='js'>JavaScript</a>介绍js的基本数据类型。Undefined、Null、Boolean、Number、String、ECMAScript2015新增:Symbol创建后独一无二且不可变的数据类型介绍js有哪些内置对象？Object是JavaScript中所有对象的父对象数据封装类对象：Object、Array、Boolean、Number和String其他对象：Function、Arguments、Math、Date、RegExp、Error参考：www.ibm.com/developerworks/cn/web/waobjectsinjsv1b/index.html说几条写JavaScript的基本规范？1.不要在同一行声明多个变量。2.请使用===/!==来比较true/false或者数值3.使用对象字面量替代newArray这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.forin循环中的变量应该使用var关键字明确限定作用域，从而避免作用域污染。JavaScript原型，原型链?有什么特点？每个对象都会在其内部初始化一个属性，就是prototype原型，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。关系：instance.constructor.prototype=instance.__proto__特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，如果没有的话，就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到Object内建对象。functionFunc{}Func.prototype.name=\"Sean\";Func.prototype.getInfo=function{returnthis.name;}varperson=newFunc;//现在可以参考varperson=Object.createoldObject;console.logperson.getInfo;//它拥有了Func的属性和方法//\"Sean\"console.logFunc.prototype;//Func{name=\"Sean\",getInfo=function}JavaScript有几种类型的值？，你能画一下他们的内存图吗？栈：原始数据类型（Undefined，Null，Boolean，Number、String）堆：引用数据类型（对象、数组和函数）两种类型的区别是：存储位置不同；原始数据类型直接存储在栈stack中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆heap中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体!StatedClearlyImagewww.w3school.com.cn/i/ct_js_value.gif如何将字符串转化为数字，例如'12.3b'?*parseFloat'12.3b';*正则表达式，'12.3b'.match/\\d+\\.?\\d+/g0*1,但是这个不太靠谱，提供一种思路而已。如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』?functioncommafynum{returnnum&&num.toString.replace/\\d?=\\d{3}+\\./g,function$1,$2{return$2+',';};}如何实现数组的随机排序？方法一：vararr=1,2,3,4,5,6,7,8,9,10;functionrandSort1arr{forvari=0,len=arr.length;i<len;i++{varrand=parseIntMath.random*len;vartemp=arrrand;arrrand=arri;arri=temp;}returnarr;}console.lograndSort1arr;方法二：vararr=1,2,3,4,5,6,7,8,9,10;functionrandSort2arr{varmixedArray=;whilearr.length>0{varrandomIndex=parseIntMath.random*arr.length;mixedArray.pusharrrandomIndex;arr.splicerandomIndex,1;}returnmixedArray;}console.lograndSort2arr;方法三：vararr=1,2,3,4,5,6,7,8,9,10;arr.sortfunction{returnMath.random0.5;}console.logarr;Javascript如何实现继承？1、构造继承2、原型继承3、实例继承4、拷贝继承原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。functionParent{this.name='wang';}functionChild{this.age=28;}Child.prototype=newParent;//继承了Parent，通过原型vardemo=newChild;alertdemo.age;alertdemo.name;//得到被继承的属性JavaScript继承的几种实现方式？参考：构造函数的继承www.ruanyifeng.com/blog/2010/05/objectoriented_javascript_inheritance.html，非构造函数的继承www.ruanyifeng.com/blog/2010/05/objectoriented_javascript_inheritance_continued.html；javascript创建对象的几种方式？javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。1、对象字面量的方式person={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"};2、用function来模拟无参的构造函数functionPerson{}varperson=newPerson;//定义一个function，如果使用new\"实例化\",该function可以看作是一个Classperson.name=\"Mark\";person.age=\"25\";person.work=function{alertperson.name+\"hello...\";}person.work;3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）functionPetname,age,hobby{this.name=name;//this作用域：当前对象this.age=age;this.hobby=hobby;this.eat=function{alert\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\";}}varmaidou=newPet\"麦兜\",25,\"coding\";//实例化、创建对象maidou.eat;//调用eat方法4、用工厂方式来创建（内置对象）varwcDog=newObject;wcDog.name=\"旺财\";wcDog.age=3;wcDog.work=function{alert\"我是\"+wcDog.name+\",汪汪汪......\";}wcDog.work;5、用原型方式来创建functionDog{}Dog.prototype.name=\"旺财\";Dog.prototype.eat=function{alertthis.name+\"是个吃货\";}varwangcai=newDog;wangcai.eat;5、用混合方式来创建functionCarname,price{this.name=name;this.price=price;}Car.prototype.sell=function{alert\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\";}varcamry=newCar\"凯美瑞\",27;camry.sell;Javascript作用链域?全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域链。谈谈This对象的理解。```this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；```eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，varobj=eval''+str+'';什么是window对象?什么是document对象?window对象是指浏览器打开的窗口。document对象是Documentd对象（HTML文档对象）的一个只读引用，window对象的一个属性。null，undefined的区别？null表示一个对象是“没有值”的值，也就是值为“空”；undefined表示一个变量声明了没有初始化赋值；undefined不是一个有效的JSON，而null是；undefined的类型typeof是undefined；null的类型typeof是object；Javascript将未赋值的变量默认值设为undefined；Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。typeofundefined//\"undefined\"undefined:是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回undefined；例如变量被声明了，但没有赋值时，就等于undefinedtypeofnull//\"object\"null:是一个对象空对象,没有任何属性和方法；例如作为函数的参数，表示该函数的参数不是对象；注意：在验证null时，一定要使用　===，因为==无法分别null和　undefinednull==undefined//truenull===undefined//false再来一个例子：nullQ：有张三这个人么？A：有！Q：张三有房子么？A：没有！undefinedQ：有张三这个人么？A：有！Q:张三有多少岁？A:不知道（没有被告诉）参考阅读：undefined与null的区别www.ruanyifeng.com/blog/2014/03/undefinedvsnull.html写一个通用的事件侦听器函数。//event事件工具集，来源：github.com/markyunmarkyun.Event={//页面加载完成后readyEvent:functionfn{iffn==null{fn=document;}varoldonload=window.onload;iftypeofwindow.onload!='function'{window.onload=fn;}else{window.onload=function{oldonload;fn;};}},//视能力分别使用dom0||dom2||IE方式来绑定事件//参数：操作的元素,事件名称,事件处理程序addEvent:functionelement,type,handler{ifelement.addEventListener{//事件类型、需要执行的函数、是否捕捉element.addEventListenertype,handler,false;}elseifelement.attachEvent{element.attachEvent'on'+type,function{handler.callelement;};}else{element'on'+type=handler;}},//移除事件removeEvent:functionelement,type,handler{ifelement.removeEventListener{element.removeEventListenertype,handler,false;}elseifelement.datachEvent{element.detachEvent'on'+type,handler;}else{element'on'+type=null;}},//阻止事件主要是事件冒泡，因为IE不支持事件捕获stopPropagation:functionev{ifev.stopPropagation{ev.stopPropagation;}else{ev.cancelBubble=true;}},//取消事件的默认行为preventDefault:functionevent{ifevent.preventDefault{event.preventDefault;}else{event.returnValue=false;}},//获取事件目标getTarget:functionevent{returnevent.target||event.srcElement;},//获取event对象的引用，取到事件的所有信息，确保随时能使用event；getEvent:functione{varev=e||window.event;if!ev{varc=this.getEvent.caller;whilec{ev=c.arguments0;ifev&&Event==ev.constructor{break;}c=c.caller;}}returnev;}};\"1\",\"2\",\"3\".mapparseInt答案是多少？parseInt函数能解析一个字符串，并返回一个整数，需要两个参数val,radix，其中radix表示要解析的数字的基数。【该值介于2~36之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;但此处map传了3个element,index,array,我们重写parseInt函数测试一下是否符合上面的规则。functionparseIntstr,radix{returnstr+''+radix;};vara=\"1\",\"2\",\"3\";a.mapparseInt;//\"10\",\"21\",\"32\"不能大于radix因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN所以\"1\",\"2\",\"3\".mapparseInt答案也就是：1,NaN,NaN详细解析：blog.csdn.net/justjavac/article/details/19473199事件是？IE与火狐的事件机制有什么区别？如何阻止冒泡？1.我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被JavaScript侦测到的行为。2.事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件；3.ev.stopPropagation;（旧ie的方法ev.cancelBubble=true;）什么是闭包（closure），为什么要用它？闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。闭包的特性：1.函数内再嵌套函数2.内部函数可以引用外层的参数和变量3.参数和变量不会被垃圾回收机制回收//li节点的onclick事件都能正确的弹出当前被点击的li索引<ulid=\"testUL\"><li>index=0</li><li>index=1</li><li>index=2</li><li>index=3</li></ul><scripttype=\"text/javascript\">varnodes=document.getElementsByTagName\"li\";fori=0;i<nodes.length;i+=1{nodesi.onclick=functioni{returnfunction{console.logi;}//不用闭包的话，值每次都是4}i;}</script>执行say667后,say667闭包内部变量会存在,而闭包内部函数的内部变量不会存在使得Javascript的垃圾回收机制GC不会收回say667所占用的资源因为say667的内部函数的执行需要依赖say667中的变量这是对闭包作用的非常直白的描述functionsay667{//Localvariablethatendsupwithinclosurevarnum=666;varsayAlert=function{alertnum;}num++;returnsayAlert;}varsayAlert=say667;sayAlert//执行结果应该弹出的667javascript代码中的\"usestrict\";是什么意思?使用它区别是什么？usestrict是一种ECMAscript5添加的（严格）运行模式,这种模式使得Javascript在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值;全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用；消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同;提高编译器效率，增加运行速度；为未来新版本的Javascript标准化做铺垫。如何判断一个对象是否属于某个类？使用instanceof（待完善）ifainstanceofPerson{alert'yes';}new操作符具体干了什么呢?1、创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型。2、属性和方法被加入到this引用的对象中。3、新创建的对象由this所引用，并且最后隐式的返回this。varobj={};obj.__proto__=Base.prototype;Base.callobj;用原生JavaScript的实现过什么功能吗？Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？hasOwnPropertyjavaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。使用方法：object.hasOwnPropertyproName其中参数object是必选项。一个对象的实例。proName是必选项。一个属性名称的字符串值。如果object具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回true，反之则返回false。JSON的了解？JSONJavaScriptObjectNotation是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单,易于读写,占用带宽小如：{\"age\":\"12\",\"name\":\"back\"}JSON字符串转换为JSON对象:varobj=eval''+str+'';varobj=str.parseJSON;varobj=JSON.parsestr;JSON对象转换为JSON字符串：varlast=obj.toJSONString;varlast=JSON.stringifyobj;`.forEach.call$$\"*\",functiona{a.style.outline=\"1pxsolid\"+~~Math.random*1<<24.toString16}`能解释一下这段代码的意思吗？js延迟加载的方式有哪些？defer和async、动态创建DOM方式（用得最多）、按需异步载入jsAjax是什么?如何创建一个Ajax？ajax的全称：AsynchronousJavascriptAndXML。异步传输+js+xml。所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。1创建XMLHttpRequest对象,也就是创建一个异步调用对象2创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息3设置响应HTTP请求状态变化的函数4发送HTTP请求5获取异步调用返回的数据6使用JavaScript和DOM实现局部刷新Ajax解决浏览器缓存问题？1、在ajax发送请求前加上anyAjaxObj.setRequestHeader\"IfModifiedSince\",\"0\"。2、在ajax发送请求前加上anyAjaxObj.setRequestHeader\"CacheControl\",\"nocache\"。3、在URL后面加上一个随机数：\"fresh=\"+Math.random;。4、在URL后面加上时间戳：\"nowtime=\"+newDate.getTime;。5、如果是使用jQuery，直接这样就可以了$.ajaxSetup{cache:false}。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。同步和异步的区别?同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整通过阻塞,唤醒等方式.同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性.同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。（待完善）如何解决跨域问题?jsonp、iframe、window.name、window.postMessage、服务器上设置代理页面页面编码和被请求的资源编码如果不一致如何处理？服务器代理转发时，该如何处理cookie？nginx模块化开发怎么做？立即执行函数benalman.com/news/2010/11/immediatelyinvokedfunctionexpression/,不暴露私有成员varmodule1=function{　　　　var_count=0;　　　　varm1=function{　　　　　　//...　　　　};　　　　varm2=function{　　　　　　//...　　　　};　　　　return{　　　　　　m1:m1,　　　　　　m2:m2　　　　};　　};（待完善）AMD（Modules/AsynchronousDefinition）、CMD（CommonModuleDefinition）规范区别？>AMD规范在这里：github.com/amdjs/amdjsapi/wiki/AMD>CMD规范在这里：github.com/seajs/seajs/issues/242AsynchronousModuleDefinition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。区别：1.对于依赖的模块，AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD推崇aslazyaspossible.2.CMD推崇依赖就近，AMD推崇依赖前置。看代码：//CMDdefinefunctionrequire,exports,module{vara=require'./a'a.doSomething//此处略去100行varb=require'./b'//依赖可以就近书写b.doSomething//...}//AMD默认推荐define'./a','./b',functiona,b{//依赖必须一开始就写好a.doSomething//此处略去100行b.doSomething//...}requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？）参考：annn.me/howtorealizecmdloader/JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？谈一谈你对ECMAScript6的了解？ECMAScript6怎么写class么，为什么会出现class这种东西?异步加载JS的方式有哪些？1defer，只支持IE2async：3创建script，插入到DOM中，加载完毕后callBackdocumen.write和innerHTML的区别document.write只能重绘整个页面innerHTML可以重绘页面的一部分DOM操作――怎样添加、移除、移动、复制、创建和查找节点?（1）创建新节点createDocumentFragment//创建一个DOM片段createElement//创建一个具体的元素createTextNode//创建一个文本节点（2）添加、移除、替换、插入appendChildremoveChildreplaceChildinsertBefore//在已有的子节点前插入一个新的子节点（3）查找getElementsByTagName//通过标签名称getElementsByName//通过元素的Name属性的值IE容错能力较强，会得到一个数组，其中包括id等于name值的getElementById//通过元素Id，唯一性.call和.apply的区别？例子中用add来替换sub，add.callsub,3,1==add3,1，所以运行结果为：alert4;注意：js中的函数其实是对象，函数名是对Function对象的引用。functionadda,b{alerta+b;}functionsuba,b{alertab;}add.callsub,3,1;数组和对象有哪些原生方法，列举一下？JS怎么实现一个类。怎么实例化这个类JavaScript中的作用域与变量声明提升？如何编写高性能的Javascript？那些操作会造成内存泄漏？JQuery的源码看过吗？能不能简单概况一下它的实现原理？jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？jquery中如何将数组转化为json字符串，然后再转化回来？jQuery的属性拷贝extend的实现原理是什么，如何实现深拷贝？jquery.extend与jquery.fn.extend的区别？*jquery.extend为jquery类添加类方法，可以理解为添加静态方法*jquery.fn.extend:源码中jquery.fn=jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数使用：jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。jQuery的队列是如何实现的？队列可以用在哪些地方？谈一下Jquery中的bind,live,delegate,on的区别？JQuery一个对象可以同时绑定多个事件，这是如何实现的？是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？jQuery是通过哪个方法和Sizzle选择器结合的？（jQuery.fn.find进入Sizzle）针对jQuery性能的优化方法？Jquery与jQueryUI有啥区别？*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。*jQueryUI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等JQuery的源码看过吗？能不能简单说一下它的实现原理？jquery中如何将数组转化为json字符串，然后再转化回来？jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：$.fn.stringifyArray=functionarray{returnJSON.stringifyarray}$.fn.parseArray=functionarray{returnJSON.parsearray}然后调用：$\"\".stringifyArrayarrayjQuery和Zepto的区别？各自的使用场景？针对jQuery的优化方法？*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。比如：varstr=$\"a\".attr\"href\";*forvari=size;i<arr.length;i++{}for循环每一次循环都查找了数组arr的.length属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：forvari=size,length=arr.length;i<length;i++{}Zepto的点透问题如何解决？jQueryUI如何自定义组件?需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？如何判断当前脚本运行在浏览器还是node环境中？（阿里）this===window?'browser':'node';通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中移动端最小触控区域是多大？jQuery的slideUp动画，如果目标元素是被外部事件驱动,当鼠标快速地连续触发外部元素事件,动画会滞后的反复执行，该如何处理呢?jquerystop:如：$\"div\".stop.animate{width:\"100px\"},100;把Script标签放在页面的最底部的body封闭之前和封闭之后有什么区别？浏览器会如何解析它们？移动端的点击事件的有延迟，时间是多久，为什么会有？怎么解决这个延时？（click有300ms延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。）知道各种JS框架Angular,Backbone,Ember,React,Meteor,Knockout...么?能讲出他们各自的优点和缺点么?Underscore对哪些JS原生对象进行了扩展以及提供了哪些好用的函数方法？解释JavaScript中的作用域与变量声明提升？那些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。setTimeout的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）JQuery一个对象可以同时绑定多个事件，这是如何实现的？*多个事件同一个函数：$\"div\".on\"clickmouseover\",function{};*多个事件不同函数$\"div\".on{click:function{},mouseover:function{}};Node.js的适用场景？如果会用node知道route,middleware,cluster,nodemon,pm2,serversiderendering么?解释一下Backbone的MVC实现方式？什么是“前端路由”?什么时候适合使用“前端路由”?“前端路由”有哪些优点和缺点?知道什么是webkit么?知道怎么用浏览器的各种工具来调试和debug代码么?Chrome,Safari浏览器内核。如何测试前端代码么?知道BDD,TDD,UnitTest么?知道怎么测试你的前端工程么mocha,sinon,jasmin,qUnit..?前端templatingMustache,underscore,handlebars是干嘛的,怎么用?简述一下Handlebars的基本用法？简述一下Handlerbars的对模板的基本处理流程，如何编译的？如何缓存的？用js实现千位分隔符?来源：前端农民工div.io/topic/744，提示：正则+replace参考：www.tuicool.com/articles/ArQZfuifunctioncommafynum{returnnum&&num.toString.replace/\\d?=\\d{3}+\\./g,function$0,$1{return$1+\",\";};}console.logcommafy1234567.90;//1,234,567.90检测浏览器版本版本有哪些方式？功能检测、userAgent特征检测比如：navigator.userAgent//\"Mozilla/5.0Macintosh;IntelMacOSX10_10_2AppleWebKit/537.36KHTML,likeGeckoChrome/41.0.2272.101Safari/537.36\"WhatisaPolyfill?polyfill是“在旧版浏览器上复制标准API的JavaScript补充”,可以动态地加载JavaScript代码或库，在不支持这些标准API的浏览器中模拟它们。例如，geolocation（地理位置）polyfill可以在navigator对象上添加全局的geolocation对象，还能添加getCurrentPosition函数以及“坐标”回调对象，所有这些都是W3C地理位置API定义的对象和函数。因为polyfill模拟标准API，所以能够以一种面向所有浏览器未来的方式针对这些API进行开发，一旦对这些API的支持变成绝对大多数，则可以方便地去掉polyfill，无需做任何额外工作。做的项目中，有没有用过或自己实现一些polyfill方案（兼容性处理方案）？比如：html5shiv、Geolocation、Placeholder我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？使用JS实现获取文件扩展名？functiongetFileExtensionfilename{returnfilename.slicefilename.lastIndexOf\".\"1>>>0+2;}String.lastIndexOf方法返回指定值（本例中的'.'）在调用该方法的字符串中最后出现的位置，如果没找到则返回1。对于'filename'和'.hiddenfile'，lastIndexOf的返回值分别为0和1无符号右移操作符03>将1转换为4294967295，将2转换为4294967294，这个方法可以保证边缘情况时文件名不变。String.prototype.slice从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为\"\"。Webpack热更新实现原理?1.Webpack编译期，为需要热更新的entry注入热更新代码EventSource通信2.页面首次打开后，服务端与客户端通过EventSource建立通信渠道，把下一次的hash返回前端3.客户端获取到hash，这个hash将作为下一次请求服务端hotupdate.js和hotupdate.json的hash4.修改页面代码后，Webpack监听到文件修改后，开始编译，编译完成后，发送build消息给客户端5.客户端获取到hash，成功后客户端构造hotupdate.jsscript链接，然后插入主文档6.hotupdate.js插入成功后，执行hotAPI的createRecord和reload方法，获取到Vue组件的render方法，重新render组件，继而实现UI无刷新更新。请介绍一下JS之事件节流？什么是JS的函数防抖？<aname='other'>ECMAScript6相关</a>Object.is与原来的比较操作符“===”、“==”的区别？两等号判等，会在比较时进行类型转换；三等号判等判断严格，比较时不进行隐式类型转换,（类型不同则会返回false）；Object.is在三等号判等的基础上特别处理了NaN、0和+0，保证0和+0不再相同，但Object.isNaN,NaN会返回true.Object.is应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。ES6是如何实现编译成ES5的？cssloader的原理？<aname='other'>前端框架</a>React使用场景？逻辑复杂单页应用，偏中后台管理系统，纯展示性的UI页面不合适、描述一下React生命周期渲染过程调用到的生命周期函数，主要几个要知道；*constructor65*getInitialState65*getDefaultProps65*componentWillMount65*render65*componentDidMount65更新过程*componentWillReceiveProps65*shouldComponentUpdate65*componentWillUpdate65*render65*componentDidUpdate65卸载过程componentWillUnmount实现组件有哪些方式？React.createClass使用API来定义组件ReactES6classcomponent用ES6的class来定义组件Functionalstatelesscomponent通过函数定义无状态组件应该在React生命周期的什么阶段发出ajax请求，为什么？AJAX请求应在componentDidMount函数进行请求。shouldComponentUpdate函数有什么作用？shouldComponentUpdate是一个允许我们自行决定某些组件（以及他们的子组件）是否进行更新的生命周期函数，reconciliation的最终目的是尽可能以最有效的方式去根据新的state更新UI，如果你已经知道UI的哪些状态无需进行改变，就没必要去让React去判断它是否该改变。让shouldComponentUpdate返回falss,React就会让当前的组件和其子组件保持不变。当组件的setState函数被调用之后，发生了什么？React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，并且知道如何只通过必要的更新来最小化重渲染。为什么循环产生的组件中要利用上key这个特殊的prop？Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。React利用子元素的key在比较两棵树的时候，快速得知一个元素是新的还是刚刚被移除。没有keys，React也就不知道当前哪一个的item被移除了。Reactrouter路由的实现原理？说说ReactNative,Weex框架的实现原理？受控组件ControlledComponent与非受控组件UncontrolledComponent的区别refs是什么?Refs是能访问DOM元素或组件实例的一个函数；React为什么自己定义一套事件体系呢，与浏览器原生事件体系有什么关系？什么时候应该选择用class实现一个组件，什么时候用一个函数实现一个组件？组件用到了state或者用了生命周期函数，那么就该使用Classcomponent。其他情况下，应使用Functionalcomponent。什么是HoC（HigherOrderComponent）？适用于什么场景？高阶组件就是一个React组件包裹着另外一个React组件并不是父子关系的组件，如何实现相互的数据通信？使用父组件，通过props将变量传入子组件65（如通过refs，父组件获取一个子组件的方法，简单包装后，将包装后的方法通过props传入另一个子组件65）用过React技术栈中哪些数据流管理库？Redux\\DvaRedux是如何做到可预测呢？Redux将React组件划分为哪两种？Redux是如何将state注入到React组件上的？请描述一次完整的Redux数据流React的批量更新机制BatchUpdates？React与Vue，各自的组件更新进行对比，它们有哪些区别？<aname='other'>其他问题</a>原来公司工作流程是怎么样的，如何与其他人协作的？如何跨部门合作的？你遇到过比较难的技术问题是？你是如何解决的？设计模式知道什么是singleton,factory,strategy,decrator么?常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？页面重构怎么操作？网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。对于传统的网站来说重构通常是：表格table布局改为DIV+CSS使网站前端兼容于现代浏览器针对于不合规范的CSS、如对IE6有效的对于移动平台的优化针对于SEO进行优化深层次的网站重构应该考虑的方面减少代码间的耦合让代码保持弹性严格按规范编写代码设计可扩展的API代替旧有的框架、语言如VB增强用户体验通常来说对于速度的优化也包含在重构中压缩JS、CSS、image等前端资源通常是由服务器来解决程序的性能优化如数据读写采用CDN来加速资源加载对于JSDOM的优化HTTP服务器的文件缓存列举IE与其他浏览器不一样的特性？1、事件不同之处：触发事件的元素被认为是目标（target）。而在IE中，目标包含在event对象的srcElement属性；获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE的keyCode会返回字符代码（Unicode），DOM中按键的代码和字符是分离的，要获取字符代码，需要使用charCode属性；阻止某个事件的默认行为，IE中阻止某个事件的默认行为，必须将returnValue属性设置为false，Mozilla中，需要调用preventDefault方法；停止事件冒泡，IE中阻止事件进一步冒泡，需要设置cancelBubble为true，Mozzilla中，需要调用stopPropagation；99%的网站都需要被重构是那本书上写的？网站重构：应用web标准进行设计（第2版）什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。如：bordershadow渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。如：默认使用flash上传，但如果浏览器支持HTML5的文件上传功能，则使用HTML5实现更好的体验；是否了解公钥加密和私钥加密。一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。WEB应用从服务器主动推送Data到客户端有那些方式？html5提供的Websocket不可见的iframeWebSocket通过FlashXHR长时间连接XHRMultipartStreaming<script>标签的长时间连接可跨域对Node的优点和缺点提出了自己的看法？*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。你有用过哪些前端性能优化的方法？（1）减少http请求次数：CSSSprites,JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。（2）前端模板JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4）当需要设置的样式很多时设置className而不是直接操作style。（5）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6）避免使用CSSExpression（css表达式又称Dynamicproperties动态属性。（7）图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳。（8）避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。http状态码有那些？分别代表是什么意思？简单版100Continue继续，一般在发送post请求时，已发送了httpheader之后服务端将返回此信息，表示确认，之后发送具体参数信息200OK正常返回信息201Created请求成功并且服务器创建了新的资源202Accepted服务器已接受请求，但尚未处理301MovedPermanently请求的网页已永久移动到新位置。302Found临时性重定向。303SeeOther临时性重定向，且总是使用GET请求新的URI。304NotModified自从上次请求后，请求的网页未修改过。400BadRequest服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401Unauthorized请求未授权。403Forbidden禁止访问。404NotFound找不到如何与URI相匹配的资源。500InternalServerError最常见的服务器端错误。503ServiceUnavailable服务器端暂时无法处理请求（可能是过载或维护）。完整版1**信息类：表示接收到请求并且继续处理100――客户必须继续发出请求101――客户要求服务器根据请求转换HTTP协议版本2**响应成功：表示动作被成功接收、理解和接受200――表明该请求被成功地完成，所请求的资源发送回客户端201――提示知道新文件的URL202――接受和处理、但处理未完成203――返回信息不确定或不完整204――请求收到，但返回信息为空205――服务器完成了请求，用户代理必须复位当前已经浏览过的文件206――服务器已经完成了部分用户的GET请求3**重定向类：为了完成指定的动作，必须接受进一步处理300――请求的资源可在多处得到301――本网页被永久性转移到另一个URL302――请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。303――建议客户访问其他URL或访问方式304――自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用305――请求的资源必须从服务器指定的地址得到306――前一版本HTTP中使用的代码，现行版本中不再使用307――申明请求的资源临时性删除4**客户端错误类：请求包含错误语法或不能正确执行400――客户端请求有语法错误，不能被服务器所理解401――请求未经授权，这个状态代码必须和WWWAuthenticate报头域一起使用HTTP401.1未授权：登录失败　　HTTP401.2未授权：服务器配置问题导致登录失败　　HTTP401.3ACL禁止访问资源　　HTTP401.4未授权：授权被筛选器拒绝HTTP401.5未授权：ISAPI或CGI授权失败402――保留有效ChargeTo头响应403――禁止访问，服务器收到请求，但是拒绝提供服务HTTP403.1禁止访问：禁止可执行访问　　HTTP403.2禁止访问：禁止读访问　　HTTP403.3禁止访问：禁止写访问　　HTTP403.4禁止访问：要求SSL　　HTTP403.5禁止访问：要求SSL128　　HTTP403.6禁止访问：IP地址被拒绝　　HTTP403.7禁止访问：要求客户证书　　HTTP403.8禁止访问：禁止站点访问　　HTTP403.9禁止访问：连接的用户过多　　HTTP403.10禁止访问：配置无效　　HTTP403.11禁止访问：密码更改　　HTTP403.12禁止访问：映射器拒绝访问　　HTTP403.13禁止访问：客户证书已被吊销　　HTTP403.15禁止访问：客户访问许可过多　　HTTP403.16禁止访问：客户证书不可信或者无效HTTP403.17禁止访问：客户证书已经到期或者尚未生效404――一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL405――用户在RequestLine字段定义的方法不允许406――根据用户发送的Accept拖，请求资源不可访问407――类似401，用户必须首先在代理服务器上得到授权408――客户端没有在用户指定的饿时间内完成请求409――对当前资源状态，请求不能完成410――服务器上不再有此资源且无进一步的参考地址411――服务器拒绝用户定义的ContentLength属性请求412――一个或多个请求头字段在当前请求中错误413――请求的资源大于服务器允许的大小414――请求的资源URL长于服务器允许的长度415――请求资源不支持请求项目格式416――请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含IfRange请求头字段417――服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。5**服务端错误类：服务器不能正确执行一个正确的请求HTTP500服务器遇到错误，无法完成请求　　HTTP500.100内部服务器错误ASP错误　　HTTP50011服务器关闭　　HTTP50012应用程序重新启动　　HTTP50013服务器太忙　　HTTP50014应用程序无效　　HTTP50015不允许请求global.asa　　Error501未实现HTTP502网关错误HTTP503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常一个页面从输入URL到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JSAPI绑定等等；详细版：1、浏览器会开启一个线程来处理这个请求，对URL分析判断如果是http协议就按照Web方式来处理;2、调用浏览器内核中的对应方法，比如WebView中的loadUrl方法;3、通过DNS解析获取网址的IP地址，设置UA等信息发出第二个GET请求;4、进行HTTP协议会话，客户端发送报头请求报头;5、进入到web服务器上的WebServer，如Apache、Tomcat、Node.JS等服务器;6、进入部署好的后端应用，如PHP、Java、JavaScript、Python等，找到对应的请求处理;7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;8、浏览器开始下载html文档响应报头，状态码200，同时使用缓存;9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;10、页面开始渲染DOM，JS根据DOMAPI操作DOM,执行事件绑定等，页面显示完成。简洁版：浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；载入解析到的资源文件，渲染页面，完成。部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决?第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？localStorage除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？你用的得心应手用的熟练地编辑器&开发环境是什么样子？SublimeText3+插件Googlechrome查看页面UI、动画效果和交互功能，Firebug兼容测试和Node.js+webpackGit版本控制和CodeReview对前端工程师这个职位是怎么样理解的？它的前景会怎么样？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。1、实现界面交互2、提升用户体验3、有了Node.js，前端可以实现服务端的一些事情前端是最贴近用户的程序员，前端的能力就是能让产品从90分进化到100分，甚至更好，参与项目，快速高质量完成实现效果图，精确到1px；与团队成员，UI设计，产品经理的沟通；做好的页面结构，页面重构和用户体验；处理hack，兼容、写出优美的代码格式；针对服务器的优化、拥抱最新前端技术。你怎么看待WebApp、hybridApp、NativeApp？你移动端前端开发的理解？（和Web前端开发的主要区别是什么？）产品进行版本升级时，可能发生不兼容性问题，如何提前预防和解决？非覆盖式发布，API新增而不是在原来的上面修改；提前做好@Deprecated的版本提示；你对加班的看法？加班就像借钱，原则应当是救急不救穷平时如何管理你的项目？先期团队必须确定好全局样式（global.css），编码模式utf8等；编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；页面进行标注（例如页面模块开始和结束）；CSS跟HTML分文件夹并行存放，命名都得统一（例如style.css）；JS分文件夹存放命名以该JS功能为准的英文翻译。图片采用整合的images.pngpng8格式文件使用尽量整合在一起使用方便将来的管理如何设计突发大规模并发架构？当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？说说最近最流行的一些东西吧？常去哪些网站？ES6\\WebAssembly\\Node\\MVVM\\WebComponents\\React\\ReactNative\\Webpack组件化知道什么是SEO并且怎么优化么?知道各种metadata的含义么?移动端（AndroidIOS）怎么做好用户体验?清晰的视觉纵线、信息的分组、极致的减法、利用选择代替输入、标签及文字的排布方式、依靠明文确认密码、合理的键盘利用、简单描述一下你做过的移动APP项目研发流程？你在现在的团队处于什么样的角色，起到了什么明显的作用？你认为怎样才是全端工程师（FullStackdeveloper）？介绍一个你最得意的作品吧？你有自己的技术博客吗，用了哪些技术？对前端安全有什么看法？是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS和CSRF）了解到什么程度？项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。最近在学什么东西？你的优点是什么？缺点是什么？如何管理前端团队?最近在学什么？能谈谈你未来3，5年给自己的规划吗？<aname='web'>前端学习网站推荐</a>1.极客标签：www.gbtags.com/2.码农周刊：weekly.manong.io/issues/3.前端周刊：www.feweekly.com/issues4.慕课网：www.imooc.com/5.div.io：div.io6.HackerNews：news.ycombinator.com/news7.InfoQ：www.infoq.com/8.w3cplus：www.w3cplus.com/9.StackOverflow：stackoverflow.com/10.w3school：www.w3school.com.cn/11.mozilla：developer.mozilla.org/zhCN/docs/Web/JavaScript<aname='web'>文档推荐</a>1.jQuery基本原理docs.huihoo.com/jquery/jqueryfundamentals/zhcn/index.html\"jQuery基本原理\"2.JavaScript秘密花园bonsaiden.github.io/JavaScriptGarden/zh/3.CSS参考手册css.doyoe.com/4.JavaScript标准参考教程javascript.ruanyifeng.com/5.ECMAScript6入门es6.ruanyifeng.com/**备注：**根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。资料答案不够正确和全面，欢迎欢迎Star和提交issues。格式不断修改更新中。在github项目的右上角，有三个按钮,分别是watch、star、fork，新来的同学注意不要用错了，无休止的邮件提醒会给你造成不必要的信息干扰。当你选择Watching，表示你以后会关注这个项目的全部动态，以后只要这个项目发生变动，被别人提交了pullrequest、被发起了issue等情况你都会收到邮件通知。star相当于是点赞或收藏，方便以后查找。fork表示你想要补充完善这个项目的内容。更新记录：20180114：公司在招聘前端，使用react技术栈；借此机会更新一波前端框架相关的题目；20161020：更新一些已被发现的问题。20160325：新增ECMAScript6相关问题更新时间:20180114爱机车、爱骑行、爱旅行、爱摄影、爱阅读的前端开发攻城师。我的微博：weibo.com/920802999", "management/前端人员面试2.md": "道衍云算前端开发面试题HTMLHTML行内元素有哪些？块级元素有哪些？空void元素有那些？```首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。（1）行内元素有：abspanimginputselectstrong（强调的语气）（2）块级元素有：divulollidldtddh1h2h3h4…p（3）常见的空元素：<br><hr><img><input><link><meta>鲜为人知的是：<area><base><col><command><embed><keygen><param><source><track><wbr>不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异参考:stackoverflow.com/questions/6867254/browsersdefaultcssforhtmlelements```HTML5如何处理IE浏览器兼容问题？```IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim;<!ifltIE9><script>src=\"html5shim.googlecode.com/svn/trunk/html5.js\"</script><!endif>```webSocket如何兼容低浏览器？```AdobeFlashSocket、ActiveXHTMLFileIE、基于multipart编码发送XHR、基于长轮询的XHR```CSSCSS选择符有哪些？哪些属性可以继承？```*1.id选择器（myid）2.类选择器（.myclassname）3.标签选择器（div,h1,p）4.相邻选择器（h1+p）5.子选择器（ul>li）6.后代选择器（lia）7.通配符选择器（*）8.属性选择器（arel=\"external\"）9.伪类选择器（a:hover,li:nthchild）*可继承的样式：fontsizefontfamilycolor,ULLIDLDDDT;*不可继承的样式：borderpaddingmarginwidthheight;```margin和padding有什么区别，分别适合什么场景使用？```margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段```如何居中div？分别写出水平居中、让绝对定位的div居中、水平垂直居中。```css水平居中div{width:200px;margin:0auto;}让绝对定位的div居中div{position:absolute;width:300px;height:300px;margin:auto;top:0;left:0;bottom:0;right:0;backgroundcolor:pink;/*方便看效果*/}水平垂直居中div{position:relative;/*相对定位或绝对定位均可*/width:500px;height:300px;top:50%;left:50%;margin:150px00250px;/*外边距为自身宽高的一半*/backgroundcolor:pink;/*方便看效果*/}```JavaScriptJavaScript有几种类型？请画出它们的堆栈图，并说明堆和栈的区别。```栈：原始数据类型（Undefined，Null，Boolean，Number、String）堆：引用数据类型（对象、数组和函数）两种类型的区别是：存储位置不同；原始数据类型直接存储在栈stack中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；引用数据类型存储在堆heap中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体```如何解决跨域问题?请尽可能多列出解决方案。```jsonp、iframe、window.name、window.postMessage、服务器上设置代理页面```请编写两个jQuery的扩展将数组转化为json字符串，然后再转化回来？```js$.fn.stringifyArray=functionarray{returnJSON.stringifyarray}$.fn.parseArray=functionarray{returnJSON.parsearray}然后调用：$\"\".stringifyArrayarray```VUEvif和vshow有什么区别？```vshow仅仅控制元素的显示方式，将display属性在block和none来回切换；而vif会控制这个DOM节点的存在与否。当我们需要经常切换某个元素的显示/隐藏时，使用vshow会更加节省性能上的开销；当只需要一次显示或隐藏时，使用vif更加合理。```Vue中如何监控某个属性值的变化？比如监控data中，obj.a的变化。```jswatch:{obj:{handlernewValue,oldValue{console.log'objchanged'},deep:true}}//deep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改：watch:{'obj.a':{handlernewName,oldName{console.log'obj.achanged'}}}//还有一种方法，可以通过computed来实现，只需要：computed:{a1{returnthis.obj.a}}```请列出一些你经常访问的学习网站", "management/团队管理.md": "目标实现领导层、产品组的产品规划积累基础技术，提升平台的支撑能力提升员工的能力、成就感组织结构!_v_images/20191120201826.png研发分为基础开发组、业务开发组。基础组负责平台等共通组件开发，业务组负责业务产品开发。开发小组由TL、PO、PPQA共同领导，分别负责技术、业务、管理。每一个产品必须有一个PO，一个开发组可以负责多个产品开发实现。PPQA非传统PPQA，主要负责迭代过程监控与管理，具体包括开发流程的计划、评审、测试、发布、风险等关键节点的监控和管理。每一个业务开发组必须最少有一名基础组成员参与，主要负责共通组件开发，协助TL完成功能设计。在测试组人员允许的情况下，每个业务开发组最好有一名测试人员来负责每轮迭代的测试。关键流程!_v_images/20191120201846.png制定迭代功能清单制定迭代计划实时路线图（RoadMap）调整座位，准备环境整理现阶段的任务，制定下阶段（两周）的开发计划PPQA督促产品团队制定产品功能清单，发布计划，多轮迭代计划展望团队提升：三性产品提升：", "management/百度蜂巢广告Scrum团队.md": "20个人scrum在其中的业务，百度蜂巢广告发布频率：几乎每周都发布开发流程：需求。快速响应。需求池，每两周接受需求。产品经理直接找开发人员，加需求，影响进度。无法确定需求的优先级。》产品入口，只有一个产品经理小步快跑。设计。scrum。双周计划会（Sprint），任务估计不准确。每次都100%完成，表示效率低。只有完成详细设计后，估计才可能准确。角色：产品经理，开发团队，测试团队，PE团队（运维）来了一个需求，启动项目：有一个PM，PM组织人员对需求进行讨论。对功能列表进行review，淘宝拥抱变化：产品经理很强势，（只有一句话，要求去做），开发团队、test团队各自理解不一样。pm协调各方，保证需求沟通。双周估计：拍脑袋估计不准确。项目设计人员要求多人，一个人思维局限，多人能保证讨论。设计过程也要迭代，23人的设计团队，一个负责人。有一个初步想法，就可以进行讨论。架构师对设计进行review。当架构师、团队其他成员都认可，才算通过。PE也会对设计进行review。unittesting1、不要强推，自愿。容易形式化。2、不强求，但新写出的代码要有单元测试。3、BVTcase》开发完成后，要经过一个基本的测试。4、QA参与需求、设计。开发团队开始开发，QA就可是测试用例编写。5、BugFixcodereview1、很长时间才review，天书。2、80%bug是codereview发现的。ms花半年来codereview3、dailyreview。增量review。（看到好处，帮助环境建好，改变习惯）上线1、上线计划会。2、产品有验收。感受1、晨会。每一个只关心自己的事情。没有效果。人多时间会拉的很长。有人认为dailyreport，像检查工作。》报喜不报忧。主要是报忧，提出障碍。（可以先提出障碍）一般68人，每一个Scrum中工作是相关的。绝对不是dailyreport。通过观察事情是否延期，可以看出是否遇到障碍。及时发现问题。2、项目计划会估计是非常不准确。PM承诺的时间无法达到。新人、能力强弱不同，工作量不一样。新人可能是负值。一个复杂的项目很难估计日期。只能给出大概时间，慢慢的去校正。PM觉得每次给出的时间不靠谱。3、Codereview迭代、增量review。每一个人都希望自己代码写完有人帮助review一下。review工具使用简易。4、设计每一个的设计容易出现很大纰漏。能力弱造成的、大设计、大review很浪费工时。团队设计：23个人进行设计，一个负责人，真正负责人；其他两人发现设计的想法问题。架构师从架构角度给出一个好的建议。迭代的设计。5、项目总结会大boss在场，大家不方便说话。报喜不报忧。在团队内部一个小范围内。头痛医头，脚痛医脚。解决临时问题。改进过程：开发、测试过程。有好的过程，新人更容易适应。6、ScrumMaster一般开发工程师担任。Master70%担任开发任务。让大家领取自己喜欢的任务。抢自己感兴趣的东西。分配任务无法调动开发人员的积极性。新人还是分配任务好。问答：1、在淘宝，ScrumMaster开发任务偏重。ScrumMaster要有一个好的技术背景。无法估计准确的时间。2、分布式团队如何沟通？大项目。有一个项目经理负责多个Scrum，其中一个Scrummaster担任PM，协调各个Scrum。通过邮件的方式沟通进度。通过邮件使大家认可期限。", "management/给你一个技术团队，你能怎么管？.md": "给你一个技术团队，你能怎么管？正站在风口浪尖的移动互联网是一个变化非常快的行业，也越来越多地改变着我们的生活。正因为如此，一个靠谱的人大多不会被长期固定在一个岗位或一种事情上，因为公司的发展趋势迫切需要他承担更多。所以这样的人很容易临危受命或被委以重任，比如承担带领团队或者项目的责任。这个阶段是一个非常关键的转型期，有些过往熟悉的习惯和思路必须有意识的去改变。以下是我分享的几点体会：少干多说，解脱自己靠谱的工程师也许要表现为少说多干，但转型为管理者就不能再这样了。我经常看到的情形是“这事太轻车熟路了，等教完别人的时间我早干完了”。殊不知积少成多，如果小事都不培养和授权，那么很快就出现瓶颈，于是也慢慢没了思考的时间。所以一定要下意识把自己从日常例行事务中解脱出来，腾出时间去做一些更有价值的情，比如工作效率的提升，技术架构的研究、团队方向的思考，部门之间的交际改善等等。同时你的授权也是给团队成员的鼓励，有机会激发出更多的创新。少做紧急的事，多做重要的事有一个四象限法则（轻、重、缓、急）。尽管有这样那样的时间管理法则，但这仍然是时间管理的基础。从绝对数的层面也许无法很快减少紧急事件、紧急需求、紧急故障无法说不，但是可以把重要事情的比重调大，分解到每周计划，这样紧急的事情比重就低了。曾经有一段时间，我喜欢上了紧急事件的挑战，陷入了“兵来将挡，水来土掩。凡有来范，各个击破”的成就感。这很容易让团队陷入于被动，忽略了原本计划中最核心最重要的事情，而这些事情往往是最有价值，也是最应该坚持的。但重要事情往往需要成块连续的时间去思考和协调，而管理者的时间很容易被各种貌似紧急的事儿拍打成碎片。也许我们可以多从《卓有成效的管理者》中找到答案。提议两条能立马落地的，一是让你的Outlook由联机置为脱机，二是拎出几个日常事务落实到每周或每天的固定时段并公示出来。其实不用担心错过紧急事件，因为如果真正紧急，会有电话或人来摧的。这样我们就有了连续的时间思考，然后空下来再处理那些往常的貌似”紧急“的邮件。立规矩，盯执行软件工程师喜欢追求个人技能的提升。对TA而言，能埋头研究技术、难点可能是一种很舒适的状态。但是管理者就不能也这样一直扎下去，而是要跳出来，减少或离开单兵作战的依赖，而应该想法设法提高整个团队的知识沉淀和协作水平。管理者尤其要设法预见和规避问题，而这也依赖大家共同遵守的规则。我曾经给运维部门总结了一个三字经：`看图表，数日志，录报告`。经验表明绝大多数的故障都可以从监控图表和日志统计中找到原因或者线索，这就是我要求运维面对故障时要遵守的规则。花时间聊天和表扬有些开发工程师比较内敛，不大善于交际。当我们肩负带团队的责任时，必须要有意识的拿出大量时间与团队内外进行”伪交流“，比如打球、唱K、打牌、拼饭局等，这是增强信任和感情的必要方法。掌握思维突破的技巧我崇尚思路永远比技术更重要。逻辑清晰、做事条理这不仅是对管理者的要求，也同样是对工程师的要求。最后我想推荐的一本书是《领导者的优势――掌握思维突破点的5个技巧》，它很早就影响到我的职业，甚至也帮助到我的生活。这五个思维技巧是：`形势分析、原因分析、决策、计划和创新`。", "management/面试素质考查点.md": "参考：HR常问面试问题及考察点m.138job.com/Info/1107681、考察口头表达能力`注意应聘者的语言逻辑性、用语修辞度、口头禅、语言波幅等。`1.请您先用35分钟介绍一下自己。2.请介绍一下你上一份工作的主要工作内容。3.请介绍一下你最近的一个项目情况（项目是干什么的、清晰的项目内容结构）？2、考察灵活应变能力`这涉及到应聘者的工作态度与价值观。`1.您为何要离开目前服务的这家公司？这些离职原因你和你的主管沟通过吗？（待遇、成长空间、人际氛围等）2.您在选择工作中更看重的是什么？（成长空间、培训机会、发挥平台、薪酬等）3.你觉得你上一份工作，有哪些方面做得好？有哪些方面做得不足？是否有改善措施？3、考察兴趣爱好`这关系到应聘者的知识广博度和学习能力。`1.你觉得你在技术上有哪些需要补足的？最近你有没有很想去学习的技术或知识？为什么想学这些？2.您工作之余有哪些兴趣爱好？兴趣中有没有比较擅长的？4、考察情绪控制力`招聘时，应该尽量了解应聘者对压力的承受能力。`1.假如您的上司是一个严厉、手腕强硬，给您巨大压力的人，您觉得这种领导方式对您有何利、弊？2.您被布置了一项以前从未触及过的、或者非常困难的任务，你怎么处理？5、考察上进心与自信心1.说说您未来35年的职业规划。2.你最近在学习什么技术？为什么去学习此技术？你是怎么学习的。6、考察责任感与归属意识1.你上一家公司有什么你比较喜欢？有什么你比较反感？你跟这个公司的同事还有联系吗？2.假如你所在的项目组，你发现一个没人管的严重风险，如果你会怎么做？7、考察计划与控制能力1.你平常是凭着一股冲劲做事，还是按计划做事？说说你的怎样做工作计划的？2.假如你给别人布置一个任务，你觉得要给他说清哪些内容？（任务细节、完成时间、完成标准）", "product/6C检测监测.md": "系统角色车间计划执行及缺陷处置员检测计划执行、缺陷整改反馈缺陷分析员数据处理适配器、缺陷识别缺陷审核员缺陷整改延期审批、缺陷销号方案编制及处置结果核实员缺陷整改方案、缺陷整改核实查询统计员查询与统计、设备查询统计数据综合分析员数据综合分析基础信息管理员设备信息管理系统管理员系统管理供电段计划编制员检测计划编制计划审核员检测计划签收计划执行及缺陷处置员检测计划执行、缺陷整改反馈缺陷分析员Ftp上传客户端、数据处理适配器、缺陷识别、超限实时报警、缺陷审核员缺陷整改通知、缺陷整改延期审批、缺陷销号方案编制及处置结果核实员缺陷整改方案、缺陷整改核实查询统计员查询与统计、设备查询统计数据综合分析员数据综合分析基础信息管理员设备信息管理系统管理员系统管理铁路局级系统计划编制员转发1C检测计划、4C检测计划管理查询统计员查询与统计、设备查询统计数据综合分析员数据综合分析系统管理员系统管理总公司级系统计划编制员1C检测计划查询统计员查询与统计、设备查询统计数据综合分析员数据综合分析系统管理员系统管理", "product/ERP集团管理套件.md": "!_v_images/20191120204933.png", "product/GM系统集成资质申报.md": "高铁供电智慧运营管理云平台研发背景2014年广州、昆明等供电段提出建设统合段内众多部门综合信息化解决方案的要求，同时铁总的十三五规划也针对信息的整合提出要求。而现实的行业现状是快速扩充运输能力需要安全保障，如何保证如此高速、高密度、高复杂性的路网的运输与运营安全变得非常重要；铁路行业装备数量和水平迅速提高使得提高资产的利用率、降本增效势在必行；铁路行业缺乏企业化的运营，如何提高铁路运营效率，挖掘运输潜力，实现现代化的铁路运营管理也是十分急迫。这都反映出铁路供电行业对全行业业务整合的要求日渐强烈，用户对应用系统的业务集成、数据整合、性能等方面要求更高，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。简介按照公司领导的要求和设计理念，于2015年研发部开始调研及设计满足行业需求的信息化平台。和公司领导研讨决定，我们要打造“标准化、流程化、协同化、移动化”的综合管理信息平台――“四化平台”，在供电信息化行业形成“二个中心”――数据中心、业务中心。“四化平台”将以平台化建设基础、以流程整合为纽带、以生产运营为核心、以移动应用和门户整合为手段来建设，建立供电行业的数据存储、处理、分析利用的中心和各部门业务整合业务处理中心，改变数据不统一和数据孤岛现状，改变各部门业务孤立，系统众多的现状。主要功能DIP平台是光芒公司对铁路供电业务的深入调研，收集铁路总公司、路局以及供电段的多方需求，为支撑铁路供电业务的持续快速发展，提供一体化、全方位的信息化技术解决方案。DIP平台基于插件思想和SOA思想建设，提供应用集成、统一认证及授权、分布式流程管理器、服务容器、数据交换以及基础应用开发框架中间件等。总体结构如下图：!_v_images/20191120211915.png实现光芒自己的应用开发框架。Framework提供了全栈的开发支持，它包括高效ORM、基于扁平化的UI组件库、Web框架、代码生成工具等。Framework做到了轻量级，便于扩展，简单的编程模型，便于使用。ORM提供了一个通用的Dao层，简化数据库访问操作，使得业务代码编写集中在Service层，简化了编程模型。扁平化的UI组件库采用的是流行的扁平化的风格，方便使用，提高开发效率，提供了漂亮的界面设计。代码生成工具提供了生成单表的CRUD的代码，减少部分编码工作。实现基于插件思想的应用集成容器。插件容器是用于集成其他应用子系统和第三方系统。对应用插件子系统的集成提供完整的集成机制，同时应用插件子系统需要遵循插件容器的接入准则和规范，插件容器应用子系统提供统一认证及授权服务、分布式的流程管理支持、统一的门户界面集成等。基于插件思想的插件容器有以下优势：第一、将复杂的大系统切分成独立的插件子系统，独立开发、独立部署，降低复杂度，提高访问性能。第二、是各个子系统关注业务本身，而不用关注权限控制、流程管理、门户主界面等功能。插件的架构图如下：!_v_images/20191120211938.png实现了统一认证及授权。统一认证与授权为各个基于平台的子系统提供人员、组织、功能权限与数据权限管理，各子系统功能基于无状态来实现。它减轻了开发人员开发项目的工作量及时间，并且保证了权限系统的一致性，为供电段众多分散的子系统整合提供了整合基础。其架构图如下：!_v_images/20191120211952.png实现了分布式流程管理器。分布式流程管理器提供独立于应用的流程管理，它以服务的方式提供流程引擎的功能，可分布式部署，应用系统采用服务调用的方式管理流程。我们还开发了轻量级的流程设计器，支持常用浏览器,支持常用的流程控制节点，支持自动调用节点等。市面上多是嵌入式的流程引擎，独立的流程引擎只有大公司才有，它为复杂的企业化业务集成提供了整合支持。其架构图如下：!_v_images/20191120212056.png实现了服务容器。服务容器提供服务的注册（自动发现）、服务路由、服务的管理、服务运行监控等功能。服务容器思想来源于SOA架构的企业服务总线（即ESB），但比一般的ESB要轻量很多，它可分布式部署，支持负载均衡，为高并发提高了基础。除此之外，服务容器还提高了方便的分布式调用框架，便于和业务系统集成。服务容器是DIP平台的核心之一，它是SOA思想的体现，它将业务功能服务化，提供了业务功能级别的复用，降低业务系统的复杂度，便于系统的扩展与升级。其架构图如下：!_v_images/20191120212113.png实现了自定义流程中间件。自定义流程中间件提供简单业务流程的审批功能，用户可以根据自己的需要定义审批流程，并可以设置每一步的审批内容，可以提交每一步的审批意见。自定义流程中间件能简化一部分业务功能的开发，提高业务的开发效率。实现了扁平化UI组件库。UI组件库采用扁平化的设计规范，UI的组件外观设计非常清新和漂亮，兼顾组件的易用性，提供了界面上要用到的几乎所有组件。采用此UI组件库能非常容易的开发出精美的页面，且易于学习，极大的提高了页面的开发效率。实现了智能表单。智能表单是通过工具的配置，在不编写代码的情况下，读取数据库表的结构，生成数据库表与实体的映射关系、页面及后台代码，完成单表或多表的简单的操作功能。使用智能表单能极大的提高开发效率，降低开发成本，缩短开发周期，促使软件的尽快交付。实现了API网关。API网关主要用处是将外部请求反向路由到内部具体的服务上，屏蔽后台服务的复杂性，除此之外它还提供了API接口的安全认证和防爬虫、限流和容错功能、接口监控和日志等功能。API网关能为移动APP应用及第三方应用提供接口支持。技术特点平台采用基于SOA体系架构。是为了解决在网络环境下业务集成的需要，通过连接能完成特定任务的独立功能实体实现的一种软件系统架构。SOA是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。在本平台中，所有服务单元均遵循SOA设计方法，并通过服务组合完成一个具体的数据同步任务。平台使用简单。平台的开发模型足够简洁，各模块间是松耦合。平台的简单化保证了开发者和使用者在短时间内能够掌握，并且可以灵活扩展，降低调试难度，提供开发速度。此外，平台开发必须使用最常用的技术，各种封装接口必须简洁且丰富，并为封装的接口提供单元测试，使用者可以参照使用。平台的组件化设计。平台采用分层设计，各层中的功能设计遵循组件化的原则。保证各功能组件内部高内聚，外部松耦合，明确定义组件内部和外部的依赖关系，明确定义组件之间交互接口。并提供方便的组件组合机制，按需取用，保证各业务组件之间可以自由的组合使用。平台的扩展性。平台应能接入整合其他异构或同构的系统。平台提供统一的认证、功能整合、数据整合的机制，接入既有的系统。基于平台新开发的系统，遵循平台的接口规范，平台可以方便的部署和卸载这些系统。实时数据采集和数据交换中心研发背景简介数据交换平台是一个在异构的系统之间高速交换数据的工具，实现了在任意的内部系统、外部系统之间的数据交换。内部系统之间的数据交换包括：数据库数据交换、缓存数据交换、消息队列的数据交换、RPC服务数据交换已经文件系统文件交换。外部数据交换是通过接口的方式来进行交换，可支持多种数据协议格式。数据交换平台的结构图如下：!_v_images/20191120212151.png主要功能技术特点（1）高度灵活性：灵活的系统架构可以快速有效地响应业务逻辑的变化，操作人员可以通过修改系统配置来满足来自系统内部和外部的需求变化。（2）可维护性：以最小的代价满足业务的变化，系统使用了以下方法：系统基础结构和应用服务的分离；自成体系的独立的业务组件；数据，数据访问对象和业务对象的分离。（3）优化性能：系统设计时，根据各种技术的不同特点进行筛选以提高性能。例如PL/SQL被用来处理高容量的批处理工作，使用当代主流软/硬件技术如集群和负载平衡来确保稳定性。（4）系统安全性：针对各环节，采取必要的权限和内控机制，防范安全漏洞。统计分析的各项数据信息的准确性、安全性要求很高。为了保证系统的安全可靠，整个系统采用各种软硬件技术将系统核心的信息与用户操作界面进行有机的隔离和授权访问，达到有权者畅通无阻、无权者寸步难行的效果。（5）数据的准确性：监控系统内数据流，保证数据在各环节的一致。保证系统数据的准确性，一方面，在数据库设计层面，我们考虑使用数据的约束控制，如主、外键，另外，在数据之间的关系层面上，我们提供了必要的检测程序，再者，在流程实现层面，保证事务的一致性，即只有整个事务全面成功后才能提交整个事务等等。1、SOA：面向服务的体系结构（ServiceOrientedArchitecture，SOA）是为了解决在Internet环境下业务集成的需要，通过连接能完成特定任务的独立功能实体实现的一种软件系统架构。SOA是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。在本平台中，所有服务单元均遵循SOA设计方法，并通过服务组合完成一个具体的数据同步任务。2、支持同构和异构数据交换：平台允许数据交换的双方是异构和同构的。所谓同构是指源和目标系统之间是完全相同的，数据库表结构也是相同的；若为异构是指源和目标系统之间存在一定的差异性，数据库表结构也可能是不相同。3、支持全量同步：平台能实现针对数据源的全量同步，将源系统指定表中的数据一次性全部同步到目标系统；4、支持增量同步：平台会将源系统指定数据库表中所增加的数据，按照一定时间规则逐次同步到目标业务系统；5、支持复制方式同步：平台支持将源系统中的数据以全量或者增量的方式复制到目标业务系统，源系统中的数据保持不变；6、支持迁移方式同步：平台支持将源系统中的数据以全量或者增量的方式迁移到目标业务系统，但迁移成功后，源系统中的相应数据会被全部删除。这点是迁移方式和复制方式同步所存在的最根本性区别；7、同步报文规范：将同步业务功能统一制定成标准XML业务规范。规范主要由元数据和业务报文等两方面组成。元数据称为数据单元，是通过定义、标识、表示以及允许值等一系列属性描述的数据单元，在特定的语义环境中被认为是不可再分的最小数据单元。业务报文则是根据具体同步业务需求对数据元进行有机组合，从而形成一个具有特定业务含义的集合。8、内容过滤：本平台支持对交换的数据进行内容过滤，确保只有满足一定条件的数据才能够成功同步到目标系统。9、格式转换：当源和目标系统的数据库结构存在差异时，系统提供的格式转换功能会对表字段和内容进行转换。10、支持多种数据库：本平台目前主要支持主流的几种数据库，如Oracle、MySql、SqlServer等，其他数据库正在测试中；11、支持大字段类型交换：本平台支持对大字段型的数据表进行同步，如blob、clob等类型。12、同步交易记录：对平台处理的同步交易进行记录。平台将记录交易的处理时间、处理状态、报文内容等信息，为交易跟踪和分析统计提供数据依据；13、支持国际化：本平台支持语言国际化，目前已经有中文和英文两个版本；数据中心应用模式满足纵向和横向各部门之间的不同管理关系需求，支持集中和分级管理模式，实现“一个平台管理服务中心、多领域业务中心、部门节点”三层管理结构应用需求。平台提供多种部门节点数据和应用接入方式，即可采用前置机接入方式，亦可采用应用直接接入方式。平台提供一体化的应用桥接功能，无需单独部署部门独立的“桥接系统”，大大降低应用系统接入平台“最后一公里”的难度和成本。高灵活性和扩展性。平台采用了面向服务的架构SOA服务技术，由松藕合、图形化可配置的接口和数据处理服务组件构成的交换服务流程可灵活动态地改变，并适应节点应用系统不断升级改造和数据结构常变化的现实需求。支持多种数据传输方式（包括TCP、Http、MQ等），并结合不同传输方式的特点，充分利用不通传输方式的优势，提供可靠、健壮的传输实现。安全可靠的数据交换服务。平台提供安全可靠的数据传输能力，保证数据的完整性、一致性，使传输的数据不丢失、不重复，次序不乱，传且只传一次，并具备跨越多个网络环境，穿透多重防火墙的能力；除了采用一般的数据加密传输技术外，并采用SSL/TLS协议实现安全连接与传输，可与第三方认证授信机构进行数字证书的签发。数据交换平台功能结构图如下：!_v_images/20191120212220.png数据采集平台。数据采集平台作为数据中心信息来源，主要任务是对来自不同部门，不同类型的数据进行收集。数据采集平台提供统一的数据采集方式，方便不后台数据集成、数据存储平台信息通信。可以定义标准的数据采集模板，支持随时随地采集（在线、离线），支持标准的采集数据存储方式。在这种架构下，可以直接调用数据库接口倒入数据，也可以通过调用WebService向数据集成平台发请求。数据交换中心。数据交换中心实现数据中心的数据采集与分发，提供对被交换信息进行打包、解包、过滤、审核、装载入库等数据交换服务接口。一方面它负责从各分系统中提取采集来的数据，将其导入到数据中心中；另一方面，它负责将数据中心共享库中的数据根据分系统的需要，分发到它们的系统数据库中。数据交换中心实现了数据中心平台不各业务系统之间的数据交换、各业务部门各业务系统之间的统一信息交换，为各部门协同工作、协同办公、各种业务系统之间的业务整合提供支撑平台。数据交换中心在交换平台中，起到数据统一交换的作用：各应用发送到中心的数据，由交换中心根据预先配置的交换规则交换到目标系统中，传输内容可精确定制，包括全表和增量数据。数据交换适配器。数据交换适配器通过系统管理、数据压缩、加密、数据交换、路由解析、断点续传等技术保证各系统之间安全、准确的数据交换。一方面，数据交换适配器将采集中的数据提交给数据中心；另一方面，各业务系统通过它接收从数据中心分发过来的数据，进行转换，并存入相应的共享库中。适配器工作在应用系统端，负责该系统与其他应用系统的数据交换，支持实时、定时、状态触发等各种数据采集方式；支持多种数据源的数据采集，包括Oracle、DB2、SQLServer、Dbf、Access、Excel、TXT、XML、大对象数据、文件等多种形式，可定制开发特殊数据源。统一配置管理。统一配置管理包括交换基础信息配置和交换业务配置。交换基础信息配置是指交换节点、交换通道及网络拓扑配置。交换业务配置指所有的交换业务、交换规则、交换路径都在这里进行配置及管理。统一配置实现图形化的配置管理，实现交换流程设计，简捷的鼠标拖拽操作方式，交换流程的设计支持一对一、一对多、多对一、多对多等多种数据交换方式。统一监控管理。统一监控管理包括交换环境监控和交换业务数据监控。交换环境的监控主要是指各个交换节点以及整个交换网络的监控，通过之前在配置管理中配置好的一个交换网络拓扑图可以很清晰的监控到整个交换网络及网络中各交换节点的状态是否正常；当发现交换节点有异常的显示后，可以查看此交换节点详细的监控，包括交换服务器资源占用情况、交换服务器上各交换流程的运行情况等信息。交换业务数据监控指在数据交换中，用户最关心的是数据是否正确、完整的交换到指定的目的地，现有数据平台从多个角度去完成了数据交换的监控及告警。安全保障。在与业务无关的通讯中间件基础上，数据传输支持常用的多种加密技术，保证数据传输过程的安全，在数据传输过程中，提供数据缓冲和发送校验等多种技术保障，保证数据传输完整性。交大光芒GMPMOS铁路供电维修与运营管理系统软件基础业务软件平台：是以业务为导向和驱动的、可快速构建应用软件的软件平台。包括集成应用平台、开发体系。编写要点：侧重业务和应用功能，体现开发模式，强调在此之上可快速构建何类子系统或子功能等。内容还可细化：如数据库支持何种数据库，操作系统兼容何种操作系统，数据总线采用何种协议等。简介GMRPSMOS铁路供电维修与运营管理系统是针对铁路供电设备（尤其是接触网相关设备）的维修及运营而建立的资产管理与作业管理相结合的综合管理信息化系统，对铁路供电设备（尤其是接触网相关设备）进行全生命周期的资产设备管理，对铁路供电运营维修/检修作业进行通过作业计划系统进行合理有效调控；功能概述（参考【铁一院《铁路供电运营维护管理信息化方案研究报告20160307a》】）设备建模管理设备建模管理是整个设备管理的核心功能，利用设备实施源头的设计信息、厂家信息及采集信息，通过对所有供电专业设备及零部件的数据信息模型构建，能够非常方便的进行设备的动态及静态信息管理，从而实现对设备及零部件的全生命周期进行跟踪和维护，形成生态发展模式，推动设备管理由定期管理向寿命管理的转变。设备管理设备管理是针对接触网、变电及电力等专业中涉及到的公用性质数据信息的管理和维护，包括对铁路线别、站场区间、牵引变电所、电力变配电所、接触网、电力线路等信息。基础数据作为设备管理的基石，是构建完整设备数据信息不可分割的重要组成部分，也是实现设备级运行、检修、跟踪和维护的基础。计划管理计划管理是对接触网、变电及电力等专业设备在运行、检测及检修等活动时需要编制的计划信息进行维护管理，包括年、月、周、日及临时计划等。通过将相关的设备信息编入计划中，实现设备级的计划管理模式，从而帮助用户真正合理地制定出符合铁路供电信息化修程修制的设备管理模式，避免漏检漏修等问题的出现。作业管理作业管理包括日常巡视、工作票、检测检修过程等信息的管理，是整个检测检修过程的记录和维护。作业管理涉及到整个作业过程信息的收集和维护管理，包括作业前的出工准备、材料及工具准备、人员准备、作业过程安全卡控、作业完成及收工等信息。根据计划进行作业派工，包括工作票的填写、上报、审核，以及派工单、作业过程的登记、审核等操作，可以自动更新设备的状态，导出作业票、派工单等数据。设备缺陷管理对来自日常巡视、作业过程中发现的电化缺陷信息进行管理，缺陷来源多种多样，如：SCADA、6C等。作业规范管理作业规范是指在作业执行前和执行中的相关信息的配置，包括作业检测项、作业工具、作业材料，以及执行过程中的安全措施和规范信息等。知识库管理知识库中包括各种规章制度以及颁布的规范，还有所辖地区的文档设计资料和运维过程中记录和生成的经验案例。技术特点设备模型化抽象设备信息、建立设备全生命周期模型，将设备模型信息接入设备运营维护管理之中，形成从项目设计阶段到施工阶段直至运营维护管理阶段全过程的具有“一模多用”的全生命周期特性的设备信息库。设备建模技术有助于运维管理的设备信息编码统一，减少后期信息重复录入，提高信息精准度；有助于设计、施工和运维之间的信息互联互通，有助于运维单位在管理过程中全面、快捷地掌握设计及施工信息，减少故障分析所消耗的时间，提高运维管理水平；有助于运维管理指导设计、施工，实现工程预介入，减少运维成本，提高运维协作能力。功能模块化模块化设计需要模块本身具有通用性，且模块之间相对独立、并通过接口进行交互。本系统中各个模块的设计充分考虑了通用性，可以根据不同的业务需求选用不同的模块；而各模块又是非常独立的，所以方便了各个功能模块的开发与调试。模块化优点有：第一、模块的通用性使得模块可以更广泛的复用，大量利用已有的经过测试和使用的模块，可以降低产品研发的风险，提高产品的可靠性和质量；第二、使用经过实践验证的模块可以大大缩短研发周期，从而加快产品研发进度；第三、采用成熟的经过验证的模块，可以大大降低研发成本；第四、相对独立的模块划分，有利于企业研发团队分工，规范不同团队间的信息接口，进行更为深入的专业化研究和不同模块系统的并行开发。流程可定制在对各个供电段业务流程进行梳理后，我们形成一套相对标准的工作流程，并采用专业的流程引擎来管理流程，使得业务流程可以定制化。流程定制化兼顾各个供电段业务流程的差异性，能在较短的时间内通过流程的配置完成业务流程开发。通过在作业过程中引入智能终端和相关专业App的使用，帮助作业人员提高作业效率和规范作业过程，并为监控人员提供实时的作业信息和事后作业过程的回溯，从而为不断优化作业执行过程及效率提供了基础数据信息，实现作业流程可追溯，运维闭环管理。GIS可视化展示通过GIS地理信息系统实现对铁路沿线供电设备及周边地理信息的有效掌握，结合“一杆一档”、“一台一档”、设计图纸信息、设备信息、设备缺陷、天窗信息和巡检记录等数据库，在卫星地图中实现设备精准定位、联动设备基础信息，并可对巡检过程中的路线记录和设备遗漏进行集中反映。移动化办公支持提供对移动App支持，有以下优点：1）无论是车间或工区，不再需要电脑才能办公作业，只需通过移动App就可以完成作业工作。2）无论工作人员在哪儿，都可以及时处理自己相关的工作，可以提高工作的效率。3）加强了远程协作，通过移动App在远程提供业务支持。4）可以很方便对一些突发性事件的处理、应急性事件的部署。图形化展示本系统采用可视化技术，利用计算机图形学和图像处理技术,将将海量数据信息以直观、生动、高效地展示给相关操作使用人员的相关实现数据转换为图形或图像在屏幕上显示出来,并进行交互处理。多种数据库、多种操作系统支持本系统采用业界流程的开发技术，保证了系统对多种数据库（如：Oracle、SQLServer等）的支持，可以在各种不同的数据源之间平滑切换；同时系统基于Java技术体系，可以在各种流行的操作系统上运行，兼顾运行环境的多样性。架构!_v_images/20191120212323.png本系统架构如上图所示，系统建立在光芒公司信息化基础平台之上，提供多种操作系统、多种数据库的支持；系统充分考虑基础组件的通用性，将流程配置、设备建模、图形化展示、GIS可视化作为独立于业务的基础组件来构建，并在此基础上，建立整个系统的业务框架，并将各个业务模块建立在此业务框架之上，确保了核心业务模块的建设遵循模块化的原则。系统的核心业务有：计划管理、作业管理、缺陷管理、设备管理、设备履历管理、台帐管理、知识库、作业规范管理、查询统计等。系统提供两种用户界面：传统Web方式和移动App的方式。", "product/中科软应急指挥系统解决方案.md": "一、概述中科软应急指挥系统解决方案是一个充分利用现代网络技术、计算机技术和多媒体技术，以**资源数据库、方法库和知识库为基础，以地理信息系统、数据分析系统、信息表示系统**为手段，实现对**突发事件数据的收集、分析、对应急指挥的辅助决策、对应急资源的组织、协调和管理控制**等指挥功能。该系统在面对突发事件时，能够为指挥首长和参与指挥的业务人员和专家，提供各种通讯和信息服务，提供决策依据和分析手段以及指挥命令实施部署和监督方法，能及时、有效地调集各种资源，实施灾情控制和医疗救治工作，减轻突发事件对居民健康和生命安全造成威胁，用最有效的控制手段和小的资源投入，将损失控制在最小范围内。!_v_images/20191120213013.png**方案实现目标**在数据采集和信息处理方面，实现突发事件信息的采集、传输、存储、处理、分析、预案确定及启动全过程的信息化、自动化和网络化。在预警方面，建立分布式可逐级监测和处理突发事件信息管理网络，实现对突发事件的评估与预警触发启动；在会商方面，利用视频接收设备、通讯系统、数据库系统、地理信息系统等设施，为指挥首长、业务人员和专家提供大屏幕显示和信息服务，随时为首长决策提供各种有效而生动的辅助决策信息；在决策支持方面，形成一套具有实时监测、科学预测、及时有效发布和动态反馈评估等功能的辅助决策系统，实现对突发事件应急处理的决策支持。在资源调度方面，通过系统对应急资源的科学调度，充分保证对特定突发事件应急处理所需资源的配置。在公众信息发布方面，能及时向社会公众发布紧急救助信息服务和善后处理工作信息。**方案特色**中科软在监测、预警和应急领域提供“监测、预警、应急”一体化的应急决策指挥解决方案，实现系统“平战结合”的建设思想。基于我们丰富的监测系统设计经验，我们提供一套快速的监测系统开发和部署框架；以多样化、可扩展的可靠信息渠道解决应急指挥中必须的信息来源问题；基于数据仓库和数据挖掘技术，提供多类行业的数据分析和预警模型，实现监测与预警联动；融合门户技术和关键指标仪表盘设计技术，结合系统中丰富的系统分析模块，实现各种业务数据的显示界面集成，便于决策者快速、直观地了解信息、把握全局；以业界主流和开放的技术标准和设计模式，提供开放的、平台级的应用编程接口和管理工具，既满足各级政府部门快速拓展和实施系统，又便于保护投资，使系统长期健康发展。二、总体框架应急决策指挥系统涉及领域广，技术层次深，系统的构架也是比较复杂，总体来讲，其框架图如下：!_v_images/20191120213026.png根据北京市《应急指挥系统信息化技术支撑体系》，北京市的应急系统能够体系结构细化为下图：!_v_images/20191120213041.png中科软依据据北京市的总体框架，结合中科软多年应急系统的经验，进一步细化应用框架到可实施框架，从下向上依次是**基础设施层、数据中心层、资源整合层、应用支撑层、应用层、综合门户**，并有安全保障体系和运行维护与支持体系保障系统的正常运行。如下图所示：!_v_images/20191120213052.png基础设施层：整个系统的底层是信息系统的基础设施，这包括网络及通讯设施、主机服务器及存储系统、视频会议系统、大屏幕数据演示系统，以及操作系统、数据库管理系统及网络通讯基础设施等，这些是系统最基本的运行基础。数据中心：数据是整个系统的基础，基础数据经过采集、处理、标准化、传输、存储，形成系统资源库，为系统提供了高效的业务分析、决策、交换、共享的数据环境。主要包括以下数据库：模型数据库知识数据库方法数据库预案数据库人口基础数据库灾情数据库地理信息空间数据库基础字典数据库资源数据库资源整合层：应急指挥需要多部门、多系统联动配合，如果彼此孤立，不能实现信息共享，就会形成的“信息孤岛”。造成缺乏可比数据、缺乏分析、缺乏管理。难以获得全面的业务信息，就会影响业务和决策的效率和准确性。通过提供应用整合服务、业务整合服务、数据整合服务连接相关职能部门的系统、业务、数据，最大程度的解决信息孤岛，最大限度地利用现有的数据资源。应用支撑层：应用支撑层的设计直接影响系统的稳定性、安全性及可靠性等重要因素，中科软凭借多年的软件开发经验，采用低耦合，高内聚的设计思想，基于开放的标准在该层部署应用部件，为系统高效、可靠的运行提供保障。包括：决策支持系统业务支持系统GIS引擎工作流引擎全文检索消息中间件信息推送内容管理用户管理权限管理通用数据接口应用层中科软应急决策系统根据突发事件应急的特点，综合各种数据信息及处理软件，缺省提供了辅助会商决策系统、数据收集与管理系统、信息处理与分析系统、资源管理系统、信息发布系统等应用系统，并可根据需要，快速的扩展业务系统。综合门户综合门户系统建立了一个灵活、规范的信息组织管理平台和全网范围的网络协作环境，实现集成的信息采集、内容管理、信息搜索，能够直接组织各类共享信息和内部业务基础信息，面向不同使用对象，通过门户技术实现个性化服务，从而实现初步的信息整合；门户不同的用户提供个性化、服务，实现用户的统一认证、统一管理，提供实时信息访问及多系统协同工作。三、基础平台解决方案应急基础平台是基于先进信息技术、网络技术、GIS技术、通信技术和应急信息资源基础上的，充分利用现有资源，依托政府系统电子政务建设，建立统一应急指挥网络平台，实现紧急事件报警的统一接入与交换。根据突发公共事件突发性、区域性、持续性等特点，以及应急组织指挥机构及其职责、工作流程、应急响应、处置步骤、处置方案等应急业务的集成，应急指挥系统基础平台建设主要包括以下几个方面。1.音视频系统；2.会议系统；3.通信系统；4.后勤保障系统!_v_images/20191120213117.png音视频系统：音视频系统贯穿在整个应急指挥中心的日常工作、应急受理、指挥调度、管理系统等等各种活动中，是应急指挥系统最有效的信息获取、协调指挥的手段之一；是应急指挥系统与指挥人员人机交互的最主要的表现形式。包括但不限于下列子系统：音视频整合系统（将各种不同格式的音像信号整合后接入指挥中心）大屏幕显示系统远程视频监控视频点播系统综合指挥席会议系统：会议系统是应急指挥系统对于突发公共事件进行协调处理、信息分析、决策以及指令下达的重要工具，实现各级指挥部门直接交流，成为应急指挥系统最有效的信息获取，协调指挥的手段之一。包括但不限于下列子系统：数字会议系统电话会议系统视频会议系统通信系统通信系统是完成日常应急值守和确保各类突发公共事件处置的重要技术保障平台，是应急指挥系统协调指挥的主要途径。应急指挥中心的通信系统即要覆盖多个下级专项指挥部，同时又要保障与上级应急指挥中心的通信，实现在紧急状况下调度指挥和协调管理。包括但不限于下列子系统：有线通信系统无线通信系统后勤保障系统后勤保障系统的作用是确保应急指挥平台各种设备的可靠运行，确保各种应急数据的传输、存储及灾备，并为指挥中心内部人员提供安全和舒适的工作环境。包括但不限于下列子系统：机房建设（包括机房装修、配电、空调等）综合布线系统计算机网络系统数据存储系统异地灾备系统音、视频存储系统中央控制系统安防系统（含监控和门禁系统）不间断电源系统四、软件解决方案!_v_images/20191120213137.png突发事件监测功能突发公共事件的发生具有分散性、隐蔽性、积聚性和突发性的特点，因此根据这些特点建立了事件监测的机制，能从日常管理的系统数据中、日常管理作业流程中、各种监测数据及其他相关的应用系统通过数据的抽取发现突发公共事件隐患的功能，并利用各种数据挖掘工具，进行突发公共事件信息的挖掘分析，做到突发事件及早发现、消灭，提前预防、及时处理。突发事件预警功能根据坚持预防为主的原则，突发公共事件应急系统需要根据不同专业特点建立各种突发公共事件预测预警模型，日常管理系统不断为模型输入参数，一旦模型计算结果出现异常情况时，系统必须能够通过预先设定的途径进行报警，并自动通过电话、传真、Email、短信等方式提醒突发公共事件相关人员。事件信息上报处理本系统能够根据不同专业的突发事件的管理模式及报告制度，设定该专业的突发事件的报送流程。突发公共事件一旦发生，系统必须能够自动地根据已经配置好的报送流程，根据事件等级的不同，直接报送到不同的直报机构，同时，根据不同的事件等级将信息报送或抄送不同的应急指挥中心。资源管理与调度突发公共事件应急指挥部根据突发公共事件等级和预案对所涉应急资源集中管理和统一调度。由于各个专业应急指挥部涉及的不同专业的应急资源具有不同的调度权限，应急资源的调度指令的下达根据调度权限逐级下达。应急资源的现场调度情况，通过系统直接反馈到应急指挥部，指挥部根据现场情况及时进行预案的调整。并且系统具备应急资源分配功能，能够设置本专业应急资源的空间分布、资源属性以及分配和调度方式。内容管理与信息发布系统能及时向系统内用户发布专业信息，提供专业应急信息的服务功能；并能及时向公众发布事件发展情况、紧急救助信息服务和善后处理工作信息。在目录集成的基础上，实现了综合信息门户与外部网站的集成，能够对访问用户进行统一管理，同时根据安全权限开放信息，提供信息查询与浏览功能。在发布方式上，支持空间信息的Web发布。恢复重建管理灾情信息录入功能除了通过灾情数据采集模块及数据整合模块获得基础数据外，通过该功能能够对灾情信息进行补充（包括文字信息、数据信息、图片信息、录象信息、空间位置信息等），便于系统进行灾情分析，建立重建方案。灾情分布分析功能能够将各种灾情以空间信息为基础进行灾情分布分析，以地理信息系统为依托，显示各类灾情分布图。灾后清理功能辅助管理灾后清理工作，计算清理的工作量，专业人员，所需资源。并能调度各种灾后清理资源。恢复重建模型分析功能能够为不同专业的突发事件建立恢复重建的分析模型，评估模型。利用突发公共事件分析模型，系统对突发公共事件的危害进行分析，为恢复重建提供建设建议方案供选择。通过评估模型对各种重建方案作出评估，以便确定最优的恢复重建方案。平时信息管理系统平时管理功能是为满足应急指挥中心在非应急状态下的日常工作需要而实现的。通过对国内外灾害事件汇总分析、预警准备、突发事件管理、综合查询、预案管理、知识库管理、方法库管理、情报管理、日常办公、外事管理等功能的执行管理，达到预测、预防突发公共事件的目的。模拟培训功能系统应提供仿真演习的功能，能通过仿真演习对应急队伍进行培训和演练。系统能够通过统一的综合门户系统和外网门户，建立各个专业应急教育培训栏目，为应急指挥工作人员加强专业技能培训，广大的民众提供应对突发公共事件的基础知识。通过培训教育，提高工作人员指挥分析能力，提供广大民众应对突发公共事件的应对能力。数据交换与共享交换与共享系统是各类应用系统业务信息统一的数据交换和信息共享的平台，是多个应用系统实现信息整和的重要手段。数据交换系统采用多种模式与现有的系统有机集成，是信息系统统一中最为基础的部分，其建设目标是：提供一个标准的、可靠的数据交换系统，为各个应用系统提供数据交换的公共模块；简化、规范各个应用系统的开发；统一管理数据的流量监控，数据加密压缩处理等，使网络利用更高效；为各个应用系统之间、异构数据库之间、不同的网络系统之间的信息提供整和的手段；为内部系统与外部系统提供统一的、安全的、可靠的连接手段。地理信息（GIS）系统GIS应用划分成基于C/S结构的应用和基于B/S结构的应用两种。前一种结构适用于实现数据的采集、入库、编辑和复杂的空间分析、专题制图等应用，主要是面向数据维护人员和专业分析人员使用的，以及为领导和专家提供辅助决策和分析之用；而后一种结构比较适合于实现简单的地图发布、空间查询等应用，主要面向的是广大的Internet用户。由于这两种结构各有优缺点，而从指挥中心的总体角度来看，两种结构的应用都是不可缺少的。系统的总体结构将是一个同时包含了C/S和B/S两种结构的混合型、综合型结构。系统结构如下：!_v_images/20191120213209.png包括但不限于下列功能：空间数据维护以地理信息空间数据库和数据仓库的方式方便地统一管理地理空间数据和相应的属性数据，并能够对空间数据进行数据转载、转换、存储、更新等操作。GIS制图与输出基于地理信息系统平台，以多种比例的电子地图为基础，各种比例尺空间数据库能够无缝嵌套使用。图素的分专题图绘制图素的分层绘制图例、标注的绘制栅格数据的嵌入地图的硬拷贝输出GIS空间分析根据空间分析作用的数据性质不同，分为：①基于空间图形数据的分析运算；②基于非空间属性的数据运算；③空间和非空间数据的联合运算。解决所涉及到地理空间的实际问题，提取和传输地理空间信息，特别是隐含信息，以辅助决策空间专题分析空间专题分析的目的是解决某类与地理空间有关的问题，涉及多种空间分析操作的组合。空间专题分析的定制空间专题分析的存储空间专题分析的修改空间专题分析的扩展专题分析数据的输入专题分析数据的输出空间查询管理检索某类与地理空间有关的数据。", "product/从技术细节看美团架构.md": "编者按：本文是根据ArchSummit北京2015大会上美团网现任技术委员会主席夏华夏的演讲《从技术细节看美团架构》整理而成。很多人认为，电商都没有什么技术含量，电商没有什么门槛，入门的门槛并不高，电商很痛苦，需要不停地去扫街，不停地去拜访各个商家，要在用户和商家之间拉客接客。国内曾经出现的团购类网站有6400多家，到四年多以后的现在，美团已经是成为国内最大的本地生活服务平台，不管怎么说，现在美团在这些电商，至少团购类的电商里边是走的比较成功的，如果说电商真的是没有门槛，那难道说美团走到现在是因为幸运吗？那必然不是因为运气，如果大家知道王兴，美团的创始人，他在这个行业内有个非常响亮的外号，叫国内史上最倒霉的连环创业者。因为他之前做过像校内网，做过饭否，最后都是因为一些莫名其妙的原因就没有做起来，或者发生了很多问题。但是美团现在他做得非常好，那肯定不是因为运气。其实在我们内部，很多同学也在做思考总结，我们希望找出一些比较好的东西能留下来，然后以后继续保持，在这其中分析来分析去，其中有一部分很重要的原因，就是我们技术团队的努力。今天与大家分享的，就是在技术团队中，不断追求极致努力的一小部分经验。首先第一部分给大家介绍美团的技术架构，架构是如何演变的。第二部分讲一讲美团的业务架构，在业务方面如何做一些业务流程的优化。最后第三部分介绍O2O技术，如何实现线上和线下都用技术来做优化贯通的。第一部分首先讲一讲技术架构，其实在初期的时候，美团的技术架构非常简单，的确在最初2010年、2011年的时候，技术是没有门槛的，任何一个人都可以写一个电商的网站。这就是一个最初期的架构，一个比较典型的LAMP架构，前端加上Apache/PHP，后端是MySQL，当然我们会有一些运维的工作在里面。可能大家如果自己写个网站的话，一开始都是这种架构，这种架构一开始也很好用。然后慢慢的，当业务量大了之后，我们发现整个系统的性能跟不上。那时候我们也只是做一些简单的优化就够了，比如说一开始我们是在前端，就是在Nginx和Apache之间加一些Varnish的缓存，然后在后端，我们可能用Memcached来减少MySQL的压力，这些都是缓存，整个架构还是没有太大的变化，还是一个优化了的LAMP架构。然后到2011年的时候，我们开始做移动端，这时候架构还是没有太大的变化，只不过是在Apache这种已有服务的API前面，又包了一层。就是我们在提供给PC端的同时，我们也包了一层移动的API，这样我们可以继续给手机端的用户提供服务。这个时候其实也就是简单地把LAMP架构做了一点点扩展，但是已经可以支撑很多很多的用户，很多很多的容量了。我们在这种架构的前提下发展，直到我们想去做新的业务。美团一开始起步是个团购公司，后来我们去做一些新的，比如说酒店业务、电影业务，直到现在大家可能使用过的美团外卖的业务。当我们去做很多不同的业务的时候，我们发现做每一个业务似乎需要添加一些新的部分，这样一个部分、一个部分堆积，对很多技术的同学来说，这是不能容忍的，那我们怎么去改进它呢？我们希望把中间的很多的公共的东西，与业务无关的东西抽取出来，形成一些公共的技术的组件，这样可以为很多的不同的业务来使用，发展到现在，形成这样一个看起来稍微复杂的架构。在最底层会有云平台，对内对外都有服务，会有云主机、云存储、虚拟网络，包括一些负载均衡的东西。在云平台上面，我们会有一些基础的组件，这些基础组件跟业务的逻辑相隔比较远，它会有比如配置，队列中心，注册中心，包括一些SQL和NoSQL的存储等等，这些技术组件我们在所有的业务里都会使用，所以我们把它提取出来，作为我们的技术组件提供给业务能用。再往上，确实有一些东西是与业务结合比较多，比如说用户中心、支付、搜索、推荐、风险控制，以及建立用户的一些地理位置的库，这些东西是与业务是有交互的。但是我们去分析之后发现在不同的业务里面，这些组件还是差不多的，所以我们也是把它抽象出来，现在叫业务组件，这些业务组件在所有的业务之间也是共用。再往上才是我们各个不同的业务的，真正的比较独特的一些逻辑。在这些业务逻辑前面，是前端的接入，这个前端接入其实对不同的业务也是一样的，它会有前端的接入和转发，会有前端内容的过滤，就是一些防抓取，防攻击这样的内容过滤。比如说为了做用户访问性能的优化，我们会做大量的各种各样内容的缓存，包括CDN也好，包括我们内部不同层次之间，包括一些验证码的服务。所以在这种架构下面，当我们再要去做一个新的业务的时候，我们就关注在中间业务逻辑这一块就可以了，这样可以很快地去拓展新的业务逻辑，而且每一个人，每一个团队，只关注真正最有价值的那一部分的软件的开发。那当然两边会有我们的，运维的工作，安全的工作，是在每一层都会涉及的。但是整个这样一个逻辑发展到现在，我们是觉得最适合我们美团现在这个阶段的一套技术架构，那从一开始的最简单的LAMP，到现在可能我们分了很多很多个组件、很多很多层，这些架构看起来是非常非常不一样的。但是我们现在回想起来并不觉得说，原来的就不好，现在的就好。我们觉得在公司发展的不同的阶段，一开始就最适合那种最简单的情况，如果说我们一开始，比如说美团2010年成立的时候就上这种很复杂的架构的话，那可能我们2010年底才把软件开发完，那时候上线的时候，可能已经有五千多家团购网站在线上了，所以这是不切实际的。所以整体来说，我们觉得在整个技术架构的演变过程中，就是找当前真正能够满足我们业务需求的。另外一个特点，大家也可以看到，在我们的整个的架构里面，大量应用了一些开源的东西，从最初的LAMP架构的时候，包括MySQL、Apache，到现在我们一些很复杂的架构里面，比如说搜索，现在会用到Lucene，会用到Solr，在云主机、云平台这一块，我们会用到比如说OpenStack的一些个组件，包括比如存储的Swift等等，用到很多的开源的东西。开源产品拿过来当然会加速我们的这种开发的周期，但是开源产品我们也不仅仅是单单把它拿过来，因为任何一个开源的产品，如果你要拿到一个比较复杂的业务里，你就会发现它不是那么匹配的，它总是有些边边角角，比如说要与系统的集成，或者很多开源产品，它在大规模的情况下，高并发的情况下，考虑地并不是那么周到。所以我们在开源的基础上做了大量的优化，一方面能让我们的整个系统能做更好地水平的扩展、系统的扩展、系统的优化，同时也让整个的用户体验能够更好。总结下来，就是在技术架构方面，想跟大家分享这么几点，一个就是整个技术架构总是在不断地结合业务在不断地演化，还有就是至少从美团来说，我们是在开源软件的基础上，然后不断地做集成，不断地做优化，最后，软件开发的时候，不管是在对用户体验来说，还是对工程师自己的体验，我们总是在追求一些极致，这样的情况下，我们的技术架构就自然而然的在不断地演变了。第二部分分享一些业务架构方面，我们做的优化。点击放大图像这个图是一个比较复杂的图，我们也不去讲它的太多的细节，大概分析一下，上面这一块其实是刚才给大家看的，对用户访问端，它所涉及到的一些组件，一些部分。但是对于电商来说，其实它还有一个很复杂的生产系统，这个生产系统就是说我们怎么去跟生产商谈单，谈完之后，我们怎么把这个单子录到线上，怎么去编辑，怎么去审核等等，这个单子的生产我们叫生产系统。除此之外，还有整个公司的运营，一些市场的营销推广，我们怎么去拉动我们新的用户，怎么去拉动我们的新的商家等等，所以就涉及到很多的业务的模块。整个的这个框架，细节我们不关注，但是第一感觉肯定是非常复杂，这个复杂的业务架构有一个什么后果呢？一般来说，它会让整个流程非常复杂，当流程复杂了，那自然而然带来的整个效率低下，所以对于技术团队来说，我们一个努力就是在不断地去优化我们的业务架构，不断地让流程简单，让效率更高，那怎么来优化呢？我们有一些自己总结出来的方法论，就是让复杂的事情简单化。一个很复杂的业务架构，我们希望对它做很多理解和梳理，梳理的过程中，我们就会发现一部分步骤其实是不需要的，可以省略的，这是一种简化；还有一个就是，当我们梳理完了，发现每一个步骤都需要的时候，我们会尽量地把一个复杂的东西拆成很多比较小块的，易于把控的一些东西，这就是一个把复杂东西简单化的一个过程。当把一个复杂的东西拆成了简单的小的东西之后，我们就容易地去对这个简单的模块，简单的功能进行标准化。所谓的标准化，就是去制订一个标准，这个东西该怎么做，应该实现什么目的，做了之后我们怎么去衡量。所以这三个是非常重要，就是我要去做什么，我怎么做，然后怎么去衡量。如果把每一个简单的东西都处理好了之后，这个简单的东西就成了一个标准的东西，标准的东西在很多时候就比较容易去推广。这就是标准化的过程，如果整个的标准比较完善了，那我们就希望把这个标准固化下来，固化下来就是说整个的工作就会变成一个很简单的流程。招几个新的员工，然后给他们一个手册，告诉他们，照着这个手册一步一步，第一步做什么，第二步做什么，第三步做什么，这就是流程化的东西。如果发展到这个时候，其实复杂的东西已经可以比较高效地往下运作了。但是对于计算机来说，对于搞技术的同学来说，我们知道，其实计算机它最擅长的东西就是处理这种简单的流程，所以我们如果做到流程化，就有了一个自动化的基础，我们可以用计算机来把这些固化的流程完成，这样最终就把复杂的事情能够尽量地做到自动化。我来举一个简单的例子，尤其是后面流程化和自动化这个东西，大家可能不是那么理解。就是我们在上单，所谓上单就是一个单子，比如一个餐馆售卖的东西，就是本地服务的一个产品，我们叫一个单子。上单的时候，我们的销售同学和商家谈了一个问题，最终要上到我们的整个网站里边。我们今年上半年曾经做过一个很大的努力就是，上单的时候我们希望免审核、免写、免编辑，为什么要这么做呢？给大家介绍一下旧有的流程，在旧有的流程里边，销售团队可能从签订合同开始，还不算他一开始跟商家去谈私人关系，去一次一次的沟通，那时候可能要碰很多壁，即使是商家已经同意了要和你合作了，那销售的同学就可以和商家签订合同，从这个时候就进入我们生产流程，然后要到我们的审核团队去审核合同，看这个合同的价格，定价是不是合理，是不是偏高，或者偏低，因为偏高了损害用户的这个利益，偏低了之后美团要贴钱，所以要去审核，包括一些法律的东西，是不是合法，一些条款是不是合法，这是审核，如果审核不通过，要打回来，重新签，如果审核通过了，回到我们的编辑团队，那编辑的团队会干什么？会把合同里的东西输成文档变成文字，变成一个文本的描述，然后还包括编辑的同学，摄影师的团队，他们会去每个商家去拍很多菜品的照片，或者商家门头的照片等等，还要把这些照片再去剪切，包括打上防伪的美团的水印等等，这些就是我们编辑团队原来要做得，他要把所有的这些东西原材料变成一个网上的单子，上了单子之后，先在一个系统里给商家看，这是我要给用户展示的东西，这样行不行？商家说可以，我们就可以最终给用户来卖了，那在这个整个的流程，从签订合同开始，到最后用户能够看到这个单子，这之间的时间是7到10天，这是一个非常非常长的时间，因为7到10天就可以对对商家带来很多很多流量。我们现在每天的销售额是几亿人民币，如果我们每个单子都拖到7到10天的话是不可忍受的。那技术团队就会想怎么去优化这个流程。我们其实做了几件事情，第一个就是说把业务流程所有的东西尽量在线化，比如说离线运行的东西。有的编辑的同学他本来是去签一个纸质的合同，纸质的合同寄到我们编审那边，编审的同学要去一条一条的读这个纸质的合同，这个是很难容忍的，这个是没办法提升的。我们首先就把很多的，比如说合同，尽量在线上来填合同，还有摄影师拍的照片，尽量直接传到网上，不要通过一个其他的渠道，U盘等等来传。这样所有的东西在线上了以后，我们才有了所有用计算机处理的一个基础。还有一个就是，我们希望所有的数据结构化。举一个例子，对于一个餐馆来说，我们可能往往会有很多的条款，比如说他这个餐馆是几点到几点营业，这个单子是几点到几点可以用，用的条件包括你可以用包间，或者不可以用包间，以及是否提供停车位，还有一些菜单的东西，这些东西在最初的时候，就是我们编辑的同学一条一条对着那个合同把它用手录成一大段文字，这样不是结构化的东西。我们结构化的努力，就是我们把每一项条款都变成我们数据里的一个结构化的单元，比如说你的这个单子在什么时间可用，星期几，几点几分到几点几分可以用，这个本身就是一个数据存储的项目。当结构化之后，销售上单的时候，它就是一个表单，一个表格这么填写，最后生成的数据就不是一大段文字了，而是很多结构化的数据。这个数据有什么好处？比如说我们生成单子的时候，如果要改版，它很容易做一些改版，或者说我们商家要调整一个价格，就只把价格那个项目给商家来做调整就可以了。不用担心商家改的时候，把一些条款的其他东西改掉。然后还包括，比如说现在会在PC端和这个移动端同时显示同样的单子，其实因为显示器的差别，我们在PC端和移动端的显示肯定是不一样的。只有当我们把它结构化之后，我们才能自动地匹配不同的显示环境，这就是结构化的一个好处。再比如说，我们会把一切可量化的东西量化，就是价格我们不希望输入一个字符串的几块钱，因为这个东西计算机是不容易去理解的，我们希望如果它是数字的，比方说价格，你就填一个价格，如果进价是多少，我卖价是多少，还有可使用时间，就用时间的格式来填，这样的好处就是我们的审核就变得非常容易。我们的审核团队，它根本不需要人工的去读这个东西，只要我们把规则制订好了，那计算机就可以把这个量化的东西一条一条地过一下。所以当我们做了这些努力之后，我们新的流程变成什么样子了呢？销售团队同样还是要去填合同，但是他填写一个表格的数据，填写好后这个表格的数据，系统会自动地审查，自动地生成一个单子，然后立刻可以给商家做确认，商家确认之后，就可以上线给用户了。然后，做了这些努力之后，我们把中间的很多环节和步骤，包括人力都省掉了，我们不需要那么多编辑的同学，不需要那么多审核的同学，而且整个的流程会走地非常顺畅，非常快，便捷。给大家看一下收益是什么呢？这是从今年1月份到9月份的一个数据，蓝线是我们每个月的上单量，从今年1月份，除了2月份，2月份因为是春节，整个的上单量有所下降，其余几个月份上单量一直是非常快速的往上涨的，一直到现在，每个月我们美团上的单子有40多万单不同的消费单，这种单子做一个假设，如果有一个吃喝玩乐的达人，他每天去吃一单美团的单子的，那40万单够他吃一千年。假设我们这个单子能持续一千年，我们会提供非常非常丰富的单子给用户做选择，上这么多的单我们的单均成本，我们从原来的很高，现在已经降到了个位数。如果我们没有做刚才那些努力的话，我们是根本不可能实现这么多的上单量，我们的成本也不可能降下来。因为我们把成本压的很低，就可以为商家提供更好的服务，也给用户提供更好的优惠，这就是技术给我们带来的一些优势。最后第三点，给大家分享一下，在线上线下这两部分，技术都是可以去做的，我们说O2O，O2O是什么？就是Online+Offline，就是线下加线上。有一部分同学可能会有一些误解，可能技术只是在线上的，其实不是那样，技术它不分线上、线下，它在线上线下都是非常重要的，需要贯穿线上线下。我在这里给大家举两个例子，线上的就不举了，因为技术都是在优化线上的东西。给大家举两个例子，看我们怎么去用技术来优化线下的一些东西。第一个就是外卖单子这个流程中，我们做了一个外卖打印机。先给大家介绍一下背景，美团外卖整个下单是怎么样的？比如用户下单，在我们的网站上说，我要买一个砂锅饭，在哪个餐馆买，我要送到什么地方，我们就需要通知商家，通知商家的时候，要告诉他用户要买什么，他地址是什么，电话是什么，然后我们的商家的厨师去做菜，小二就要去送餐，用户完成消费。美团外卖是2013年的11月13号上线的，第一单的时候，最初的时候，我们怎么处理呢？那个时候真的很原始，当然我们一开始还是做了个手机的APP，用户在手机的APP上下单，我们会有美团的外卖的这个同学，包括一些客服的同学，也包括一些很多技术的同学也帮忙打电话，我们就打电话通知商家说，某某定了一个什么单子，然后他的地址是什么，电话是什么，告诉商家。商家怎么办？就只能用这个纸笔记下来，交给厨师，说你去做饭，厨师做完了，把小纸条给配送的同学，配送的同学就去给用户来送东西，这个里面过程是非常痛苦的。当然那时候大家做的很有热情，非常喜欢打电话，看到我们有用户进来，一天从一单十几单到几百单，大家打电话打得很兴奋。但是很快发现承受不了，因为打一单，对美团的开销是说，一单哪怕只需要一分钟去给商家打电话，几百单的时候还行。一天一个人8小时工作，哪怕你持续不停的给商家打电话，那一分钟打一个也就四百多单，你可以帮用户定四百多单。但是当这个单子增长很快的时候，我们就发现我们人力跟不上了，技术的同学都去打电话了，技术同学受不了。商家也很痛苦，因为打电话的时候，很多的信息是说不准确的，他要记电话号码，如果记不清的话，他还要再打过来问刚才那个单子电话是什么，包括地址，有些地址字还比较难写。我们为了解放，首先我们解放我们自己，我们不给商家打电话了，我们给商家开发一个APP，每个商家只要安装了这个APP，他在手机上就可以接到通知。一旦有用户下单，APP上就会有通知说谁谁下了一个单，这时候老板根据APP上的信息，拿张纸，找个笔，把它写下来，然后给厨师。这个时候你会发现说，至少美团的同学们这个工作就省下来了。但是商家的工作，他虽然抄得准确一点，不用从电话里抄，直接从APP上抄，但是还是要做大量的工作，包括这个小纸条传来传去，有的人写得笔迹不是那么清楚。后来我们再进一步，我们APP接到一个打印机上，这个APP有可能是一个手机的APP，也有可能是电脑上的一个应用程序，这个APP连着打印机，一旦用户下单，打印机就会打出一个小条来，他拿这个小条，这个信息就非常准确了。商家不用花时间去写了，这时候就可以给厨师去做菜，厨师做完了交给配送员去送菜，这个就比较方便了。后来我们还是发现这个也不是很好，一般这个APP总是在老板那里的，如果说好几个人拿着APP会出现问题，好几个人拿的话，比如老板和老板娘都拿着，他们可能都去打，一个定单可能打了两份；或者说，有时候说老板拿着这个APP，但是老板刚好不在，那他就打不了。有的店，他就不得不买一台电脑放在那，但是电脑对于很多小的外卖店，还是一笔额外的开销。因为现在手机上网的多，但是电脑上网的人已经很少了，还是对商家有很多不方便的地方。今年5月份的时候，我们的硬件的团队，他们就说我们自己来做一个云打印机。所谓云打印机就是它自己可以联网，联网的时候有很多联网的方式，比如说我可以插一个手机卡，通过手机的网络来联网，或者我也可以通过WiFi来联网，联网之后，手机下单的时候，我们的美团后台的服务器会把这个单子的信息直接推送到这个云打印机上，这个云打印机就像一个POS机那样，是一个很小的设备，会自动地打印出单子的信息，这样就大大得解放了我们美团的同学和商家的同学。这是一个我们用技术来优化商家端这边的流程的一个例子。接下来给大家举一个，我们怎么去用技术优化用户端的例子。我们在用户端也有很多线下的工作，其中一个工作就是用户运营。我们有一种需求叫“拉新”运营团队，他们的任务就是对一些已经注册了美团的帐号，但是过来逛了一圈，最后没买东西就走了，可能来逛了好几次，他还是没买，这时候美团就急了，美团急了怎么办呢？给你10块钱，你赶紧买一个吧。因为很多用户的确是这样，他没买可能是因为他不知道网上怎么支付。他支付流程没做通，或者说他可能就不太习惯，所以我们希望把这些用户转化成一个习惯于在网上消费的用户，让他体验一下，可能体验一下他觉得好，他可以以后接着买。给用户10块钱，20块钱，做一些优惠活动，吸引用户完成首次的购买。那其实我们这边的花销是真金实银的，我们是给用户很多免费，对于美团来说薄利多销，利很薄，所以我们希望少花钱，多办事，这个钱能少给就少给，能不给就不给，运营的团队，就跟我们技术的同学聊，问这个事情能不能优化？我们就去分析，先去分析这些用户到底是什么样的用户，发现用户有很多类，一类是有一些用户他虽然来逛了一圈，或者逛了几圈，他还没买，但是假以时日，可能再过几天，最后他还是会自动的转化，所以有一些用户的这种自动转化的可能性是比较高的。还有一些用户，他可能来了几次，他可能每次就是来逛逛，每次逛逛，就像逛街一样，虽然他不买，但是逛着也很爽，看着菜单他可能口水直流，也觉得挺爽。所以有些用户，就是你不给他刺激，他就完不成自动的转化。然后还有一些用户质量低，所谓质量低就是对美团的质量，我给他券的时候他就过来买个东西，比如我给他10块钱，他可以过来买个11块钱的东西，然后转身就跑了，我不给他券，他就半年不过来，美团又忍不住，又给他10块钱，他又过来看了看买了个9块钱的东西就走了。对这种用户不是说质量低，对美团来说当然我们希望尽量这种薅羊毛式的这种用户，他来当然我们也欢迎，但是不来我们也就不去拉拢了。还有一些用户就是，属于用户质量比较高的那些用户，如果我们一旦帮助他转化，就是越过了这个首次消费这个坎的话，他可能就成为一个很高频的，习惯于在美团消费的用户，我们叫高质量用户。对于美团来说，我们希望真正运营的对象，真正拉拢的对象就是在这些，我如果不给他刺激，他自己可能转化不了，然后同时如果他转化了，他对美团的销售额的贡献会比较大。这种用户，对其他三个象限，比如说第一象限里边，这部分用户我不需要给他发券了，发券就是对美团来说浪费钱了，我们叫浪费，当然也没浪费。对下面这两个象限呢，因为用户本身质量比较低，所以他来和不来至少对美团的最后的获利来说没有大的关系，那我们怎么去找出这部分用户？这是运营的同学给技术团队提出了一个要求，那我们怎么去做呢？做用户画像，在美团其实有大量的用户的数据。我们可以看到，他什么时候注册的美团，他从什么浏览器，从什么操作系统，然后包括说，他去看了哪些单子，浏览了什么单子，他做了什么搜索，他用的是什么手机，这些信息我们都有。有大量的数据，那我们从这些数据里面就给用户画像，我们会去判断用户的各种属性，这些属性有一些是，可能用户在注册的时候就会告诉我们了，比如说性别，年龄，包括邮箱，这些可能本身他注册的时候就会告诉我们，还有一些是需要我们去分析，比如说这个是否结婚了，他的职业是什么，然后包括他的地理位置，地理位置当然比较好拿，因为很多，现在我们绝大部分用户是在手机上的，他一旦在手机上做周边的这种搜索，我们就可以拿到他的地理位置，地理位置的话，我们就可以知道，比如说他是一个学校的用户，是学生，还是说一个工业园区的一个白领，还是一个比如金融街的一个比较高大上的一个这个金融界人士。邮箱也很重要，比如说我们发现用户是qq.com的这种用户，跟gmail.com的用户，他是两类不一样的用户，他所关注的东西，感兴趣的东西都不一样。我们也会去分析用户的收入水平和消费水平，收入水平就是我们可能根据他的职业，根据他的年龄的工作年限去判断，他是在一个高收入，还是低收入，然后消费水平相对来说，有可能他虽然收入很高，但是他过来看的单子都是一些比如打折打得很狠，比如吃一顿饭人均20块钱这种也有。所以收入水平和消费水平我们是分开来判断，然后会判断这个用户是倾向于最优惠的价格，他还是讲求比较高的质量，就是订酒店的时候是99块钱的酒店，还是说899的五星级酒店等等。我们会去做一些分析，我们根据用户他浏览的历史，他去看了哪些单子，他去做了什么搜索，我们就可以知道他的品类偏好，他到底是喜欢美食，还是喜欢去看电影，还是喜欢去唱卡拉OK，这种娱乐，这些也可以判断出来，再加上一些正常的统计的数据，比如说用户搜索了多少次了，然后他去浏览了多少次，就是来逛街逛了多少次了，他是不是有收藏一些他比较喜欢的一些单子等等，这些很多很多的属性加起来，我们就建了用户画像的这种数据库，然后有了这些属性，那我们接到运营同学的需求的时候，我们就会对用我们的用户画像里的数据先做特征的选择，做特征的提取，甚至有一些属性，比如说年龄这个属性，我们会做很多特征的离散化，就是把一个属性离散成几百个，甚至几万个这种属性，放到我们的机器学习的模型里面去训练一些模型，最后我们用一些分类模型去，其实最后我们选的是SVM，就是支持项连机这种机器学习的算法，训练出的模型，它的准确度相对来说，看起来没有那么高，但是效果已经很明显，沃勒准确率是75%，判断用户是不是真的在左上角那个象限里，准确度75%，召回率能达到68%。有了这个技术支撑，最后我们运营的单位成本，比如说我们拉新运营的单位成本就可以降低35%，总共的拉新运营开支就节省了30%。所以这个就是我们在技术，在线下的用户运营这边做的一个努力。大家可以看到刚才举了两个例子，一个是在商家端，一个是在用户端，其实不管怎么样，我们在线下技术可以做很多很多的优化，让我们线下的效率做很多的提升，那正是所有这些一个一个的优化，加起来就可以把美团的整个的生产效率提升上去，把我们的成本降下来，这样我们最后的获利就是美团越来越有竞争力。今天给大家分享的一些小的例子，最后总结一下，把它总结成几点。第一点，就是的确我们的技术架构是要随着业务的发展而不断地变化的，不一定一个复杂的的一个完善的架构就是好的，而是看，我们现在的公司是处在什么阶段，如果是一个初创的公司，那大家还是要小步快跑，一个简单有效的方案就行了。第二我们是随着业务发展，在一些开源软件的技术上不断的优化，业务流程我们也不断的做一些标准化，自动化，就是刚才给大家讲了我们四个原则，就是把复杂的东西简单化，简单的东西标准化，标准的东西流程化，流程的东西再自动化，这是我们在业务流程方面的一个优化的原则。第三个就是在技术上的，技术不仅仅对线上有用，在线下的每一个操作里，我们在不停地看我们能做一些什么样的优化。最后一句话就是，一个简单的事情，哪怕像美团这样，很多人觉得简单的事情要把它做到极致，就是真正做到极致，也会有足够多的这种技术挑战，足够高的门槛，所以我觉得现在很多O2O的创业的团队来说，他们做得事情看起来非常简单，但是只要大家不断地优化，不断地极致，不断地朝着极致去发展，你就可以在竞争中胜出。这个就是给大家分享的美团的技术团队，我们做的很多的努力。", "product/写给非数据人的数据世界入门指南.md": "写给非数据人的数据世界入门指南提交我的留言加载中已留言写给非数据人的数据世界入门指南20160425Heidi格物志人人都是产品经理人人都是产品经理人人都是产品经理微信号woshipm功能介绍产品经理不再是一个单纯的职位，而是一种思维方式，这种思维是所有互联网人必备的，做互联网的人不能不懂产品，关注产品，改变生活。因为我做过交互设计――会画DEMO；和PD接触时间长――多少知道PRD怎么写；又给分析师提过需求――知道数据大概怎么回事……所以，我就“随波逐流”成了数据产品的产品经理。插句后话，以后在晋升面试或者转岗面试时，当面试官问我怎么就突然从交互设计师转成数据产品经理时，最早我也是讲的随波逐流的故事……然后被挑战比较严重，后来换个说法：Whynot?有这个机会，大家都信任你，又不给你压力，又能学习到新领域的知识，和新的人打交道，同时还能继续沿用交互设计的技能知识，Whynot?然后对方就颔首了，所以讲故事的角度是多么重要。说点这段故事中，让我真正坚定起来的两句话：一个老大说：“给你机会去试错，错了大不了重头再来。”另一个老大说：“设计师盯着皮肤看，产品经理要了解整体的经络组织和骨骼，更重要的是要知道数据作为血液如何在流通。你有机会深入皮肤之下看一下，再回来看皮肤感觉又不一样了。”所以我是带着这个人体经络图的即视感忐忐忑忑接下了数据产品经理这个新的岗位的。不用别人说，我也知道有两座大山需要翻：1.数据2.产品经理。本文的目标不指导就业，不提供数据分析解决方案，不承诺对任何人都必要有效。根据个人仅有的经验、心得，我只能：1.面向对数据分析、数据产品有兴趣但是又有点畏惧的交互设计师、产品经理2.希望能够让你们“减少对于数据世界的恐惧”，使用数据的语言“顺畅沟通”。欢迎进入数据的世界还记得你学习游泳的经历吗？记得我当时就是怎么都不敢下水。我的教练告诉我的最有用的一句话是：你会憋气吧？你试试在浅水区里什么都不要做，松开栏杆，憋住气，让自己沉下去。如果你受不了了，反正你一站就站起来了。我一想，也对，反正浅水区嘛。于是第一次松开了栏杆。奇怪的事情发生了。我居然不会沉入水底耶~甚至透过泳镜看别人的脚扑腾扑腾！原来水里的世界没有那么的可怕！克服了这个对水的恐惧后，才开始慢慢学习各种动作，开始享受水的乐趣。数据的世界对于不了解它的人而言，正如这神秘的水一样。那么我提供的让你不怕“水”的心得有：两个词、一个立方体、一张流程图你准备好了吗？1两个词先复习一下你可能也听过的两句话：如果你无法量化，那就无法很好管理。无细分，不分析。第一句话来自管理大师彼得德鲁克，第二句话则是分析界的金玉良言了。这两句话里就隐含着我说的这两个词。接下来，再来看一句话：成交10亿人民币！肯定没有人单独说这样的话，一般情况，这句话前都要加上一些“定语”，比如“今年截至到7月份，全国蔬菜市场”，或“去年9月，女装市场”，或“过去N年，东三省猪肉市场”……等等。这些语境里，也隐含着这两个词。再来看一张图：这是刚入门时，为了追求PPT的好看，做的一张概念图。虽然当时还没有体会到两个词的重要，但是从感觉上，我画了以上的图，有位前辈说，维度还不够。哦，我后来才知道，中间的圈里，我大部分呈现的是度量，而下面的几个圈，我列了重要的一些维度。至于上面的几个圈里，应该是呈现的分析专题或功能。至于你平时有机会接触到的各种数据可视化，报表，也基本上脱离不了这两个词，比如，若你去客服部门分析客户来电量（下图仅供演示，非真实场景数据）你按时间趋势来看总体来电量。当你发现某个月或某周来电量波动较大，你就需要添加别的“角度”来进一步细分。你按热线来细分来电量，看看来电拨打的什么热线。当你发现某个热线来电量波动异常后，你又需要进一步细分，看看此热线的来电是被什么接起公司承接的……下面不卖关子了。有些人可能已经猜到了，我要分享的这两个词就是：维度+度量。下图中，我将重点放到大道至简几个字，以及维度+度量上，而维度和度量下面分别放了所在家族的一些其他常用词汇，我稍后会解释。我始终认为在这条路上，我有一个两词之师，当我比较迷茫的时候，他就像当时教我游泳的导师一样，告诉我：你不需要了解那么多，只要了解数据的世界没有那么复杂，知道有什么维度，看什么度量，然后怎么呈现出来即可。对，他没有时间教我别的，也没有分享过任何文档给我，只告诉了我这句话，但是让我受益至今，因为那一刻，就是恍然大悟。所以我现在也分享给你们。定义度量：即Metrics,指量化的数值。一般都有个名称，比如网页浏览次数，网页浏览时长，支付宝成交金额等等。平时，我们一般会叫成“指标”，但是在专业语境，你需要知道，指标和度量还是有些差异，比如某些场合，他们会用指标特指一些经过计算的度量结果，比如拿度量A（网站总浏览次数），除以度量B（网站总浏览人数），得到一个新的指标（网站人均浏览次数），用以衡量网站粘性。但是我建议你平时使用两者可以通用。维度：即Dimension。指我们平时看事物的角度。比如，同样是网站浏览次数（PV），我们可以从日期角度去看，也可以以流量来源去看（来自直接访问的、来自微博的、来自搜索的等），也可以以新老用户分群来看。更多的场景是同时以两个维度的组合去看，比如这样的图，就是同时结合了时间、来源两个维度对网站流量进行分析：两者你知道如何清楚区分吗？虽然从定义上，你可以看出明显不同，但是现实中，却还是有人喜欢乱用――把明明属于维度的东西写成“我要看什么指标”，或者喜欢用“我想从收藏人数这个维度去看”，虽然我属于强迫症，喜欢帮别人的需求纠错，被冠以扣字眼的“名号”，但是在这件事情，我一定要抠到底。而且，你抠清楚了，以后你的世界也清晰很多。区分的一个方法：维度，一定是有成员值的，且成员值是可以枚举出来的――不管它有多少，大不了你多花点时间去枚举，总之是一定可以枚举的，且会维持一定的稳定性。比如，日期这个维度，几月几号一定是有限的，一年也就365天，如果是年这个维度，也是一样的。城市这个维度更好理解了吧？其他你需要了解的度量：除了指标这个有着略略差异的俗称外，有时还会遇到衍生指标这个说法，比如拿指标A和指标B做运算得到的指标C就叫做衍生指标。此外，还要注意可累加以及不可累加的度量说法，比如网站UV（独立访问用户数），这个指标就是典型的不可累加的度量：某网站1月1日UV=100个，1月2日UV=200个，但是这两天的UV不等于300个，因为1月2日的独立用户数里可能包含了1月1日的用户，所以如果要得到2天的UV，需要重新计算而不能直接相加。而像成交类的金额，不涉及到去重的问题，就叫可累加的度量。维度维度的层次：即Level。有些维度是独立并列的关系，比如城市维度和时间维度。但是有些维度之间有层次关系，比如省份维度和城市维度，行业维度和类目维度，年级维度和班级维度等。有层次关系的维度，则可用于“钻取”场景中，先汇总到比较粗的维度，当有需要的时候，可以层层钻取到更加明细的维度，此时，也会把这些维度叫做某维度类型的不同“粒度”――比如会有一个虚拟的维度类型曰地区维度，而把省份、城市、区叫做地区维的粒度。维度的层次根据不同的需求，可能会钻取到很细（Details）,那就是通常我们说的\"明细数据\"了。比如分析成交金额时，从行业维度，细分到一级类目乃至叶子类目，最后，钻取到某个独立的商品ID（不能再细了），商品ID就是最细小的层次维度。这么说可能会把你绕晕，那么还是画个图吧（我真的适合当唐僧似的老师……os□to）如上图所示，左列也即维度，不管是国家、省份、城市，都是维度，但因为他们有层次关系，所以，有时会被描述为地区维度的不同粒度或层次（明白了吧）。而右侧就是每个维度的维度成员了，有时也被叫成维度值。在可累加的度量中，每一个维度值相加，应该等于上级维度的某成员值总和。比如若城市A只有三个区，这三个区的人口总数应该等于城市A的。维度的属性：用以描述维度的一些属性，比如上图中“城市”这个维度吧，它可能会有一些属性特征，比如城市类型：省会城市、地级市、县级市等，那么有一个分析需求，可能还会按不同城市类型汇总细分。这种情况，维度的属性会成为分析中的维度。这时，你可能会明白，平时为什么那么多表单要填写各种字段，这些字段，都可能是分析时的维度哦~码了这么多，休息一下，给你们放张图：当时小贝和马云一碰面，无论在阿里还是网络上，都出现了一个两难的问题：到底是选谁当老公呢？（能有这个问题的妹子，你真想多了……），其实这里仔细分析，无非也是涉及到维度和度量两词：维度：人啊。维度成员：马云、小贝度量：众位妹子和弟弟们无非就是按自己心目中的算法给两位成员计算颜值、财富，以及自己心目中的权重，衡量一个综合指数了……我可不敢随便填。最后，发现两难的选择，只能得到一个结论是：左边的当老公，右边的当爸爸。点评：做梦吧您。总结一下两个词的应用：无论你听怎么复杂的需求，以及无论你有多么复杂的需求，请有倾向地提炼这两个词，因为这是你做数据产品、数据分析或者可视化设计的基础的基础：翻了自己的电脑半天，终于翻出一个不敏感的文档，供参考，下图就是移动数据分析中的需求交付模版之一：左侧列举度量，右侧标注出此度量需要看的维度，有时还会注明维度之间是否要交叉组合查询。不展开。2一个立方体其实本文的精华就在两个词之间了。下面您看不看都成。立方体在数据的世界里叫做Cube。我想为何有立方体这个概念，应该是它很形象地能够表达出多维的概念，至少有3维，如上图所示，成交100亿的金额，是一个大立方体的总量。如果按季度、行业、地区三个维度来分析，我们可以清楚地知道第三季度A地区女装行业有多少――也即我用橙色标注的那一个切块的量，是吗？那如果是我要知道B地区女装行业四季度的成交总和呢？你怎么切给我？空间感好的同学已经知道怎么切了，你知道吗？这只是切块。我们还可以切片，比如我想要知道B地区所有行业的四个季度的成交总和，怎么切？我想要知道男装行业所有地区四个季度的成交总和怎么切？具体怎么切，你们自己意会吧，篇幅有限，不展开。现实分析场景中，恐怕不只三个维度，比如还要加上销售部门维度、销售渠道维度呢~那么立方体可就复杂了，空间感差一些的同学，就想想不出来这个立方体什么样子了吧，事实上，数据开发同学会用雪花模型或者星型模型去建设这些立方体。你只要有这个立方体的概念就可以了……数据分析就是像玩魔方一下，拨弄着这些立方体。在网上找了一个包含了我刚才说的钻取、汇总的概念的立方体再给你们感受下，想要详细学习的同学可以搜索“数据立方体”继续研究。我刚才举的那几个切块、切片的案例有毛用啊？现实生活中，你提需求的时候，不可能让你画个立方体吧？是的，我们是以表格的方式去看数据的，比如第一个切块，是什么表格呢?站在行业负责人，尤其是女装负责人的视角，可能是这样的一个报表：当然，如果是某地区销售经理，有可能是这样的：所以就有各种数据透视分析的视角。总结数据分析就是在拨弄各种数据立方体，你可以切片、切块、钻取、汇总，你所玩的魔方每一块，就是一个具体的度量值，是什么数字，则是多种维度交叉后的结果。工作实践中，数据产品经理会考虑做出更加方便易用的“立方体玩法”以供普通用户使用：如，在分析客户来电的自动语音导航服务中，我们就可以按不同的维度去对比看用户在导航菜单里按键量，下图所示是“按菜单对比”的界面，在“对比按”中可以进行切换其他对比视角。至于左侧的两个筛选，也即指筛选数据集合（切片或切块了），比如限定某几个热线和菜单去看。3一张图片了解了维度、度量两个词，又有了立方体之概念，让我们再来看数据是怎么产生，怎么被放到用户界面上供查询使用的。巧妇难为无米之炊。数据不是凭空产生的，当需求方提出想要什么样的数据分析的时候。首先要检视的是，TA需求中涉及到的维度是否确定被采集到？度量的计算成本是否高？比如若一个需求想要分析不同买家分层的留存，买家分层是一个新维度，需求方是按骨灰级、高级、新手等对买家进行分层。且什么叫骨灰级？系统里并未对买家进行打标记，且不同类目的骨灰级算法还不一样，加上算法定义本身也在磨合。这种情况下，我们应该和需求方一起推动业务系统完成打标，而不是自己接下这个需求，在数据仓库ETL环节完成。了解ETL：这个是做数据工作绕不开的术语，E抽取、清洗――T（转换）――L（装载），抽取是从各个业务系统中抽取所需的数据，然后完成语义层、逻辑层的转换，比如不同系统中记录销售渠道这个维度，有的叫做saleschannel，有的叫做channel，需要转化为同一个概念。装载，也可以理解成抽取、清洗、转换好了，装载到另外一个空间里，供多维查询服务应用调用。当然，则个领域，水很深，我只能简单描述一下，再深的也担心大家晕菜了――毕竟本文是写给非数据人的。（其实作者本人也讲不粗来了……哈哈）应用我说了，我无法教你具体复杂的数据分析案例。我希望能够借助本文和你分享下如何建立起比较专业的数据分析思路――数据产品经理本身也应该可以是优秀的数据分析师。1三部曲――建立分析框架1.建立分析框架：了解业务、以及业务想要什么（目标）。2.提交数据需求:根据你的访谈、梳理，得到业务流程、业务愿景以及目标，那么就可以和需求方共同确认“看什么”以及“怎么看”。好的数据产品经理或者数据分析师，永远不是坐等需求方提出他要看什么度量和维度，而是要引导对方看更合适的东西以回答他关于目标是否达成的问题。3.进行数据分析：使用多种维度，进行总体的、细分的、多维的分析，当发现问题时，能够使用这些维度的组合帮助用户找到影响原因。一切都基于你有多了解业务：下图是几年前的老图了，左侧是业务流程图，右侧是概念中的数字体系示意（可视化是为了更好和需求方沟通）。PPT里因为存在具体业务的案例，不便分享，到此为止吧。如果有时间的话，我还是会编脱离具体业务的案例的……这就是写博客的苦逼之处，工作中都是工作的案例，为了写篇博客，还得自己再编一套有板有眼的故事……2三部曲――提交数据需求故意放了张你可能看不清楚的图（os□to），所以别问我要大图了，谢谢~左侧就是度量分类和度量，从标注了颜色底色开始的就是维度了，标了颜色的也即此指标需要被计算到所需的维度，灰色的表示不需要，黄色和绿色（以及上面的数字1、2），表示优先级不同，黄色的当然是高优先级了。比如黄色上我写的数字应该是1,也即第一优先级。实际上，依据不同的场景，当然可以有很多简化，比如无需标注优先级之类的。此外，还需要单独提供维度和度量的详细口径定义说明表格，这时最好和分析师一起，详细进行确认。3三部曲――进行数据分析你提的需求不管是做成报表、还是做成具体可视化的界面，总之如果已经开发出来了，就来玩魔方吧。只是报表有可能你得导出来在EXCEL里玩魔方。（即使是可视化的界面，也依赖于对方设计得是否易用）最简单的分析是逐级钻取，如：复杂的则需要多维交叉：比如，当分析某个APP的Activeusers,当我已经锁定某个省份有问题的时候，我们既可以继续钻取到城市去明晓细节，又可以交叉到品牌，看不同省份间品牌偏好的问题。比如是否小城市中安卓品牌的人更加活跃。留点作业：要记得思考哦1.Detail页面的设计师被追责，怎么应对？某日，负责搜索结果页（LIST）的设计师来找商品详情页（Detail），他好容易做了LIST页面的改版，而且结果也确实喜人，从List页面到Detailye页面的转化率确实提升了（比如原来100万的人来到List页面，只有40万继续点击到Detail,改版后，变成了50万）。但是不幸的是，总体从L到订单的转化率却没有提升，反而下降了。请问，如果你是Detail的分析师，如何和List的分析师一起想办法分析什么原因？2.挂羊头卖狗肉的Banner，怎么用数据证明其反而有害无益？有时为了爆眼球效应，你的老板会要求你做个华而不实的banner,比如明明活动页（LandingPage）里都是一些潘坎品，却偏偏在banner上用潘康募鄹穹乓恍└叽笊系牟品图片。想要吸引人点击进去。而确实点击效果很好！过去放凤姐一晚，100个人里只有5个人点，现在放了林志玲一晚，100个人居然有99个人点击。老板很高兴，而且确实成交额似乎是比过去略微高那么一点点了。现在，除了用道德说辞说服老板不要这么做，还有别的方式吗？最后，分享给各位的心得是：你现在也知道，数据本身需要经过分析师的定义、数据源系统的采集、数据开发的开发以及展现设计，任何一个环节，可能会产出错误的数据，所以数据本身未必100%靠谱。此外，数据的解读，需要保持谨慎批判之心。比如同样是小明语文得了59分，如果你不了解上下文以及历史趋势的话，会认为小明没考好，有的人甚至会得出小明语文不好的结论。而要是了解他上个季度每次语文考试都只有30多分，又会得出小明虽然语文不好但是明显进步了。而要是了解到这个班级平均分数只有49分，你又会觉得小明简直太赞了！所以，单纯的一个数字本身没有任何意义，要窥一斑，更要知全貌。此外，数据会被有心计的故意利用，而向你呈现部分事实（他不是在弯曲事实，而是只呈现对他有利的一面），数据本身有那么多维度以及层次，导致解读的方式完全可以被利用。所以，要记得我本文的最后提点：对于产品经理和分析师来讲，最针对的是我们基于对于业务的深入理解而产生的直觉。不要盲目被数据拉着走。只有有较好的直觉，我们才能有更合理的假设，有了这个合理的假设，才能够更好解读数据以及提数据的需求。而不是在各种数据的海洋里玩数据的游戏而浪费时间。作者：Heidi格物志阅读原文精选留言该文章作者已设置需关注才可以留言写留言该文章作者已设置需关注才可以留言写留言加载中以上留言由公众号筛选后显示了解留言功能详情微信扫一扫关注该公众号", "product/平台创新总结.md": "2015年研发部系统组在信息化方面主要完成了分布式信息化集成平台设计与研发，以下简称DIP平台。2015这一年我们完成了DIP平台的前期调研、需求目标的确定、架构设计、开发实现以及DIP平台在信息化项目中的试用等工作，初步实现了一个可以用于生产环境的分布式信息化平台。DIP平台研发背景及目标建设背景2014年广州、昆明等供电段提出建设统合段内众多部门综合信息化解决方案的要求，同时铁总的十三五规划也针对信息的整合提出要求。而现实的行业现状是快速扩充运输能力需要安全保障，如何保证如此高速、高密度、高复杂性的路网的运输与运营安全变得非常重要；铁路行业装备数量和水平迅速提高使得提高资产的利用率、降本增效势在必行；铁路行业缺乏企业化的运营，如何提高铁路运营效率，挖掘运输潜力，实现现代化的铁路运营管理也是十分急迫。这都反映出铁路供电行业对全行业业务整合的要求日渐强烈，用户对应用系统的业务集成、数据整合、性能等方面要求更高，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。建设目标按照公司领导的要求和设计理念，于2015年研发部开始调研及设计满足行业需求的信息化平台。和公司领导研讨决定，我们要打造“标准化、流程化、协同化、移动化”的综合管理信息平台――“四化平台”，在供电信息化行业形成“二个中心”――数据中心、业务中心。“四化平台”将以平台化建设基础、以流程整合为纽带、以生产运营为核心、以移动应用和门户整合为手段来建设，建立供电行业的数据存储、处理、分析利用的中心和各部门业务整合业务处理中心，改变数据不统一和数据孤岛现状，改变各部门业务孤立，系统众多的现状。困难与挑战2015年年初，公司决定研发光芒信息化平台后，研发部系统组面临众多困难：DIP平台涉及到很多不熟悉的技术，技术攻关难度较大：插件式的系统集成，分布式流程引擎，分布式的服务容器等。人员短缺和流失。项目成立之初只有两人，中途还出现一人离职，DIP平台项目组一直是12个人状态，平时还要支持业务组一些工作。公司在分布式系统的架构和设计方面积累较少，学习曲线陡峭。开发周期较短，DIP平台真正开发时间在半年左右的时间，剩余的时间在做平台的测试与改进、平台对业务组的技术支持等工作。DIP平台成果DIP平台是光芒公司对铁路供电业务的深入调研，收集铁路总公司、路局以及供电段的多方需求，为支撑铁路供电业务的持续快速发展，提供一体化、全方位的信息化技术解决方案。DIP平台基于插件思想和SOA思想建设，提供应用集成、统一认证及授权、分布式流程管理器、服务容器、数据交换以及基础应用开发框架中间件等。实现光芒自己的应用开发框架。Framework提供了全栈的开发支持，它包括高效ORM、基于扁平化的UI组件库、Web框架、代码生成工具等。Framework做到了轻量级，便于扩展，简单的编程模型，便于使用。ORM提供了一个通用的Dao层，简化数据库访问操作，使得业务代码编写集中在Service层，简化了编程模型。扁平化的UI组件库采用的是流行的扁平化的风格，方便使用，提高开发效率，提供了漂亮的界面设计。代码生成工具提供了生成单表的CRUD的代码，减少部分编码工作。实现基于插件思想的应用集成容器。插件容器是用于集成其他应用子系统和第三方系统。对应用插件子系统的集成提供完整的集成机制，同时应用插件子系统需要遵循插件容器的接入准则和规范，插件容器应用子系统提供统一认证及授权服务、分布式的流程管理支持、统一的门户界面集成等。基于插件思想的插件容器有以下优势：第一、将复杂的大系统切分成独立的插件子系统，独立开发、独立部署，降低复杂度，提高访问性能。第二、是各个子系统关注业务本身，而不用关注权限控制、流程管理、门户主界面等功能。实现了统一认证及授权。统一认证与授权为各个基于平台的子系统提供人员、组织、功能权限与数据权限管理，各子系统功能基于无状态来实现。它减轻了开发人员开发项目的工作量及时间，并且保证了权限系统的一致性，为供电段众多分散的子系统整合提供了整合基础。实现了分布式流程管理器。分布式流程管理器提供独立于应用的流程管理，它以服务的方式提供流程引擎的功能，可分布式部署，应用系统采用服务调用的方式管理流程。我们还开发了轻量级的流程设计器，支持常用浏览器,支持常用的流程控制节点，支持自动调用节点等。市面上多是嵌入式的流程引擎，独立的流程引擎只有大公司才有，它为复杂的企业化业务集成提供了整合支持。实现了服务容器。服务容器提供服务的注册（自动发现）、服务路由、服务的管理、服务运行监控等功能。服务容器思想来源于SOA架构的企业服务总线（即ESB），但比一般的ESB要轻量很多，它可分布式部署，支持负载均衡，为高并发提高了基础。除此之外，服务容器还提高了方便的分布式调用框架，便于和业务系统集成。服务容器是DIP平台的核心之一，它是SOA思想的体现，它将业务功能服务化，提供了业务功能级别的复用，降低业务系统的复杂度，便于系统的扩展与升级。实现了自定义流程中间件。自定义流程中间件提供简单业务流程的审批功能，用户可以根据自己的需要定义审批流程，并可以设置每一步的审批内容，可以提交每一步的审批意见。自定义流程中间件能简化一部分业务功能的开发，提高业务的开发效率。目前，DIP平台已经使用在郑州铁路局的信息安全项目、综合信息管理的设备履历项目，明年将大规模的使用在运维、6C等项目上。展望未来2015年研发部系统组基本开发完成一个基本可用的、能集成企业业务的、基于插件思想和SOA的企业信息化基础化平台。从技术上来看，DIP平台将目前IT业界流行的技术和思想应用在其中，具有一定的先进性和创新性。从功能及业务应用上来看，已实现了作为一个企业信息化平台的核心功能，基本满足一般信息项目的需求。DIP平台还有很多工作也做，它需要更丰富的功能，它需要更高的稳定性、更优的性能表现。在我们的规划中，我们还将提供数据交换中间件，为数据中心建设提供基础；提供API服务网关，为移动应用及第三方应用提供支持；提供完善的平台及应用系统监控功能，为系统的稳定运行提供保障。未来对GIS、报表、内容管理等多个方面提供支持。", "product/昆明供电段应急指挥系统解决方案.md": "参考：电力应急指挥解决方案www.techstar.com.cn/caseinfo.aspx?m=20100723115246312667融智通电网应急指挥解决方案www.rongzhitong.com/jjfa/jjfa51.html中科软应急指挥系统解决方案www.sinosoft.com.cn/khyal/E_ggws_news/ggws_news_0001.html一、概述昆明供电段应急指挥系统解决方案是一个充分利用现代网络技术、计算机技术和多媒体技术，以**基础资源数据库、知识库为基础，以地理信息系统、数据分析系统、信息表示系统**为手段，实现对**应急情况数据的收集、分析、对应急指挥的辅助决策、对应急资源的组织、协调和管理控制**等指挥功能。该系统在面对突发事件时，能够为指挥领导和参与指挥的业务人员和专家，提供各种通讯和信息服务，提供决策依据和分析手段以及指挥命令实施部署和监督方法，能及时、有效地调集各种资源，实施险情控制和抢险工作，用最有效的控制手段和小的资源投入，将损失控制在最小范围内。**方案实现目标**对各种应急预案进行管理，包括预案分类、分级以及预案附件上传，包括应急预案的增加、删除、修改、查询、附件下载和基本信息的导出。在数据采集和信息处理方面，实现应急情况（异常信息）的采集、传输、存储、处理、分析、预案确定及启动全过程的信息化、自动化和网络化。在预警方面，建立处理突发事件信息管理网络，实现对突发事件的评估与预警触发启动；在会商方面，利用视频接收设备、通讯系统、数据库系统、地理信息系统（GIS）等设施，为指挥领导、业务人员和专家提供大屏幕显示和信息服务，随时为领导决策提供各种有效而生动的辅助决策信息；在决策支持方面，形成一套具有实时监测、科学预测、及时有效发布和动态反馈评估等功能的辅助决策系统，实现对突发事件应急处理的决策支持。在资源调度方面，通过接入第三方物资管理系统对应急资源（线路图纸、工具、材料等）的科学调度，充分保证对特定突发事件应急处理所需资源的配置。**方案特色**应急指挥系统的建设是建立在光芒集成开发平台之上的，平台为应急指挥提供服务和数据的支撑，保证基础数据的共享、服务的共用，在基础软硬件上提供了保障。在监测、预警和应急领域提供“监测、预警、应急”一体化的应急决策指挥解决方案，实现系统“平战结合”的建设思想。基于我们在铁路供电行业的业务积累，应急指挥系统将以多样化、可扩展的可靠信息渠道解决应急指挥中必须的信息来源问题；基于数据仓库和数据挖掘技术，提供多类行业的数据分析和预警模型，实现监测与预警联动；光芒集成开发平台提供了门户集成技术和关键指标仪表盘设计技术，结合系统中丰富的系统分析模块，实现各种业务数据的显示界面集成，便于决策者快速、直观地了解信息、把握全局；以业界主流和开放的技术标准和设计模式，提供开放的、平台级的应用编程接口和管理工具，既满足供电段快速拓展和实施系统，又便于保护投资，使系统长期健康发展。二、总体框架应急指挥系统涉及领域广，技术层次深，系统的构架也是比较复杂，总体来讲，其框架图如下：!_v_images/20191120212750.png光芒公司依据铁路供电领域的应急决策指挥的要求，结合以往的应急指挥系统的经验，在光芒集成开发基础平台基础上，进一步细化应用框架到可实施框架，从下向上依次是**基础设施层、数据中心层、资源整合层、应用支撑层、应用层、综合门户**，并有安全保障体系和运行维护与支持体系保障系统的正常运行。如下图所示：!_v_images/20191120212805.png基础设施层：整个系统的底层是信息系统的基础设施，这包括网络及通讯设施、主机服务器及存储系统、视频会议系统、大屏幕数据演示系统，以及操作系统、数据库管理系统及网络通讯基础设施等，这些是系统最基本的运行基础。数据中心：数据是整个系统的基础，基础数据经过采集、处理、标准化、传输、存储，形成系统资源库，为系统提供了高效的业务分析、决策、交换、共享的数据环境。主要包括以下数据库：知识数据库预案数据库应急事件库应急材料库设备资源（图纸、物资等）数据库地理信息空间数据库组织基础数据库人员基础数据库资源整合层：应急指挥需要多部门、多系统联动配合，如果彼此孤立，不能实现信息共享，就会形成的“信息孤岛”。造成缺乏可比数据、缺乏分析、缺乏管理。难以获得全面的业务信息，就会影响业务和决策的效率和准确性。通过提供应用整合服务、业务整合服务、数据整合服务连接相关职能部门的系统、业务、数据，最大程度的解决信息孤岛，最大限度地利用现有的数据资源。应用支撑层：应用支撑层的设计直接影响系统的稳定性、安全性及可靠性等重要因素，光芒公司凭借多年的软件开发经验，采用低耦合，高内聚的设计思想，基于开放的标准在该层部署应用部件，为系统高效、可靠的运行提供保障。包括：GIS服务流程引擎全文检索消息中间件信息推送服务内容管理数据交换权限管理报表服务应用层光芒公司应急决策系统根据突发事件应急的特点，综合各种数据信息及处理软件，缺省提供了辅助会商决策系统、数据收集与管理系统、信息处理与分析系统、资源管理系统、信息发布系统等应用系统，并可根据需要，快速的扩展业务系统。综合门户综合门户系统建立了一个灵活、规范的信息组织管理平台和全网范围的网络协作环境，实现集成的信息采集、内容管理、信息搜索，能够直接组织各类共享信息和内部业务基础信息，面向不同使用对象，通过门户技术实现个性化服务，从而实现初步的信息整合；门户不同的用户提供个性化、服务，实现用户的统一认证、统一管理，提供实时信息访问及多系统协同工作。三、基础设施解决方案应急基础平台是基于先进信息技术、网络技术、GIS技术、通信技术和应急信息资源基础上的，充分利用现有资源，依托供电段信息化建设，建立统一应急指挥网络平台，实现紧急事件报警的统一接入与交换。根据突发公共事件突发性、区域性、持续性等特点，以及应急组织指挥机构及其职责、工作流程、应急响应、处置步骤、处置方案等应急业务的集成，应急指挥系统基础平台建设主要包括以下几个方面。1.音视频系统；2.会议系统；3.通信系统；4.后勤保障系统音视频系统：音视频系统贯穿在整个应急指挥中心的日常工作、应急受理、指挥调度、管理系统等等各种活动中，是应急指挥系统最有效的信息获取、协调指挥的手段之一；是应急指挥系统与指挥人员人机交互的最主要的表现形式。包括但不限于下列子系统：音视频整合系统（将各种不同格式的音像信号整合后接入指挥中心）大屏幕显示系统远程视频监控视频点播系统综合指挥席会议系统：会议系统是应急指挥系统对于突发事件进行协调处理、信息分析、决策以及指令下达的重要工具，实现各级指挥部门直接交流，成为应急指挥系统最有效的信息获取，协调指挥的手段之一。包括但不限于下列子系统：数字会议系统电话会议系统视频会议系统通信系统为应急抢修通过通信保障，应急指挥通信平台整合现有通信资源，如视频会议终端、手机、调度电话、行政电话、集群、卫星通信、PAD等都作为应急指挥中的通信手段，有效的融合，才能保证指令的有效下达，最终才能做到信息对称。应急指挥中心的通信系统即要覆盖多个下级部门，同时又要保障与上级的通信，实现在紧急状况下调度指挥和协调管理。包括但不限于下列子系统：有线通信系统无线通信系统后勤保障系统后勤保障系统的作用是确保应急指挥平台各种设备的可靠运行，确保各种应急数据的传输、存储及灾备，并为指挥中心内部人员提供安全和舒适的工作环境。包括但不限于下列子系统：机房建设（包括机房装修、配电、空调等）综合布线系统计算机网络系统数据存储系统异地灾备系统音、视频存储系统中央控制系统安防系统（含监控和门禁系统）不间断电源系统四、软件解决方案!_v_images/20191120212828.png应急指挥系统主要功能1、异常信息监测功能完成各自对异常信息（应急情况）的监控监测，而应急指挥系统从这些系统获取异常信息，并管理好这些异常信息。对发生的应急情况进行分析，确定应急事件的类型、等级，否是构成启动对应的应急预案。突发事件的发生具有分散性、隐蔽性、积聚性和突发性的特点，因此根据这些特点建立了异常信息监测的机制，能从接触网、电力、变电等系统通过数据的抽取发现突发事件隐患的功能，并利用各种数据挖掘工具，进行突发事件信息的挖掘分析，做到突发事件及早发现、消灭，提前预防、及时处理。2、异常信息分析与预警根据坚持预防为主的原则，突发事件应急系统需要根据不同专业特点建立各种突发事件预测预警模型，日常管理系统不断为模型输入参数，一旦模型计算结果出现异常情况时，系统必须能够通过预先设定的途径进行报警，并自动通过电话、传真、Email、短信等方式提醒突发事件相关人员。3、会商决策抢修中，领导在应急指挥中心，可以随时享受现场传回的照片，视频录像，文字，语音汇报，有利于分析决策，可以与现场人员任意组织会议对工作加以指导和了解。即使有些领导因为出差，无法及时赶赴现场，现场实施人员可通过系统上报现场的照片，或者语音，或者视频、录像让不在现场的领导也可以清楚的了解到现场的进展情况，并加入与现场的互动，快速作出指示。4、应急资源管理与调度应急指挥中心根据应急事件等级和预案对所涉应急资源集中管理和统一调度。由于各个专业应急指挥中心涉及的不同专业的应急资源具有不同的调度权限，应急资源的调度指令的下达根据调度权限逐级下达。应急资源的现场调度情况，通过系统直接反馈到应急指挥部，指挥中心根据现场情况及时进行预案的调整。并且系统具备应急资源分配功能，能够设置本专业应急资源的空间分布、资源属性以及分配和调度方式。5、应急事件录入功能除了通过应急事件数据采集模块及数据整合模块获得基础数据外，通过该功能能够对应急事件进行补充（包括文字信息、数据信息、图片信息、录象信息、空间位置信息等），便于系统进行应急事件分析，建立抢修方案。在抢修完成后，可以将处理结果录入到系统，完成对应急事件的管理。6、应急知识库管理通过收集国内外铁路供电行业的应急事件所需各种知识，汇总编排后录入系统，提供综合查询、对外使用接口等功能，快速简易的查询知识库内容。7、教育培训功能系统能够通过统一的综合门户系统，建立各个专业应急教育培训栏目，为应急指挥工作人员加强专业技能培训，广大铁路职工提供应对突发事件的基础知识。通过培训教育，提高工作人员指挥分析能力，提供广大铁路职工应对突发事件的应对能力。7、地理信息系统（GIS）支持GIS电子地图作为业务信息的载体，可提供对业务信息在地图上的直观定位、可视化展示、查询和专题分析。利用地理信息特有的空间关联关系，可以建立多种业务信息之间的空间关联关系，寻找业务信息之间的分布规律和空间关系，为指挥决策、情报分析等提供依据。利用地理信息可以实现对控制力量、命令执行情况的动态管理与监督，对应急态势的实时掌控，实现对应急力量的科学化管理、合理的调度。GIS系统是应急指挥中心系统的重要辅助系统，它利用SOA模型设计出包含了多层次的多种应用和技术组件，为用户提供基于网络的桌面、移动服务以及应用程序的Web服务。包括但不限于下列功能：空间数据维护以地理信息空间数据库和数据仓库的方式方便地统一管理地理空间数据和相应的属性数据，并能够对空间数据进行数据转载、转换、存储、更新等操作。GIS制图与输出基于地理信息系统平台，以多种比例的电子地图为基础，各种比例尺空间数据库能够无缝嵌套使用。GIS空间分析解决所涉及到地理空间的实际问题，提取和传输地理空间信息，特别是隐含信息，以辅助决策空间专题分析空间专题分析的目的是解决某类与地理空间有关的问题，涉及多种空间分析操作的组合。空间查询管理检索某类与地理空间有关的数据。", "product/水力发电生产管理信息系统.md": "项目内容新华水力发电集团生产管理信息系统（以下简称“PMIS”）是以新华发电公司发展规划确定的管理为基础，配合集团体制、机制、管理和技术的持续创新，充分利用现代信息技术，建立和形成满足集团公司及其分子公司的协同运转、高效管理和科学决策需要的新华发电公司综合信息系统。系统建设内容主要体现在以下三个方面：1、建立电厂运行实时数据采集平台。分析研究集团所属各类发电厂对电厂运行实时信息的需求情况和利用方法，建立一套集团统一的电厂运行指标体系标准，并依据该标准设计出数据库的主要数据结构，同时保留可扩充性。针对集团总部、区域分公司和各发电厂对实时数据需求的不同，按照统一的接口标准分别提取各自所需的关键指标数据，并进行长期存储和加工处理。2、建立各级电厂运行实时监测系统。在集团公司本部，以抽取上来的各发电厂实时数据为基础，建设集团电厂运行实时监测系统，成为集团公司未来的生产监测指挥中心。在各区域分公司，以抽取上来的各发电厂实时数据为基础，建设区域分公司运行实时监测系统，成为区域分公司未来的运行监测指挥中心。在各发电厂，以建立的实时数据库为基础，建设运行实时监测系统。3、为集团化生产调度提供所需信息。实现对各下属发电厂生产运营状况的在线监视，跟踪机组运行状态，反映其生产运营中发生的生产事故和有较大影响的紧急事件,并能通过系统实时向总公司报告；满足生产运营信息的收集、整理、汇总、分析及向集团公司上报的要求；分析所辖电厂机组运行的经济性，指导协调管辖电厂的生产运营和电力市场有关工作。系统架构PMIS全面基于面向服务的体系架构（SOA）和N层B/S体系模式，自底向上分为基础设施层、数据层、基础应用层、业务应用层和表示层。采用分层的技术架构具有很强的扩展性、可维护性和安全性。系统功能架构如下图所示：!_v_images/20191120205015.png", "product/水电厂运行管理系统.md": "项目内容水电厂运行管理系统（以下简称“HOMS”）是在先进的设计理念和管理思想的基础上，充分结合水电企业的运行管理特点和电厂生产管理的业务需求，专门为水电企业管理者量身定做的产品，因此该系统符合湖南白竹洲水电站信息化建设要求。HOMS以发电生产、设备为核心，以工单为主线，全面覆盖水电企业生产、资产、经营、预算、决策支持等管理领域，并可将生产实时数据与管理信息有机集成，帮助水电企业及下属电厂快速有效地构建管控一体、分层管理的信息化集成平台。项目建设内容主要包括运行值班、运行台账管理、定期工作管理、工作票管理、操作票管理、设备管理、缺陷管理、实时系统、物资管理、相关方管理、检修管理、安全管理、标准资料管理、系统管理等应用功能。系统架构HOMS全面基于面向服务的体系架构（SOA）和N层B/S体系模式，自底向上分为基础设施层、数据层、基础应用层、业务应用层和表示层。采用分层的技术架构具有很强的扩展性、可维护性和安全性。HOMS提供对移动设备（安卓操作系统）的产品支持，即水电厂运行管理安卓客户端系统（HOMSforAndroid），该系统基于Android（安卓）平台设备，与HOMS系统同步的数据库，协助企业便捷高效地进行水电企业信息化管理。系统功能架构如下图所示：!_v_images/20191120205041.png", "product/水电站生产运行管理系统.md": "水电站生产运行管理系统1、设备管理系统采用树状与列表型双结构管理电站内设备，通过树状结构可以方便的查找到目的设备以及父子关系的设备，从而完成对现场设备的监控和跟踪，并进行维护和更新设备和运行位置的基本信息。另外设备可以与我公司KKS水电编码系统联合使用完成对设备编码和定位的目的。2、物资管理物资管理指对物品或工具的接收、保管、保养、发放、回收等环节的过程控制，本模块主要包括库存管理、物资入库、物质出库、领料与退料、库存盘点、物资采购等。3、工具管理工器具的管理包括日常借用、归还和日常维护，此外还有专用工具的年检和安全试验、工器具的报修、报废和添置等。4、运行管理运行部是电厂的核心部门，担负着上级部门下发到全厂发电任务的重任，因此发电运行的管理功能也是本系统的重点。运行管理模块基本囊括了运行过程中日常的各种记录与操作过程，同时提供方便灵活的两票流程处理功能，为电站和员工提供了安全工作的保障。主要内容有各种运行记录、ON_CALL记录、实时参数记录、规程管理、两票管理和相应报表输出等。5、安全监督管理完善的安全监督工作可以达到减少事故、促进工作的目的，本系统安全监督功能包含了水电站常见的各项工作，如：安全性评价、人员安全管理、设施安全管理、异常故障管理、安措管理、事故管理、安全检查管理、上级指令管理、安全文明生产管理、两票考核管理、安全奖惩管理等。6、预防性维护管理通过合理的预防性维修可以达到防止意外事故、预防计划外停机的目的。通过本功能可以建立预防性维修计划来定义在设备或位置上周期性执行的预防性维修工作。系统支持按照时间、里程表、日历、季节和时间触发的预防性维修。此外，还可以产生需要对多个位置和设备同时进行的检查性预防性维修，也可以通过建立预防性维修计划来定义电厂的大小修项目。7、故障代码管理管理设备或工具的故障信息代码，对每个设备或者工具建立树状管理结构，故障代码信息包含故障代码编号、故障问题及现象、故障原因分析、故障处理措施等信息。通过对设备故障代码的出现趋势分析可以指导维护人员及时采取合适的预防性维护措施。同时历史代码也为今后故障诊断与处理提供有价值的参考作用。8、计划管理计划管理按照目前常用的一套现行计划管理体系编制，实现计划以及合同的电子化管理，该体系包括计划的申报、汇总、审核、批准、执行、完成情况评价等。9、员工管理实现对员工简历、培训、特殊工种及员工考核的管理。10、标准工作包在维修的过程中，可以把一些实际的经验和习惯的做法归纳总结起来，作成在执行某些特定工作任务的标准工作包供日后参考。11、查询统计统一管理系统中各种综合信息的统计查询与报表生成，通过管理员设置可以生成各种专业型查询统计报表，对系统状态一目了然。12、系统管理系统管理模块实现对水电站生产运行管理系统的设计、配置等功能。通过系统配置，我们能为水电站生产运行管理系统设计业务流程、规划系统授权、对现有的应用程序客户化修改以达到适应各项目的不同需求、对系统内的标准参数和运行参数进行配置、对系统辅助应用程序进行设置等。!_v_images/20191120205150.png", "product/铁路6C业务结构.md": "!_v_images/20191120204812.png", "product/需求调研及分析方法.md": "信息化的四个阶段**第一阶段**：现实世界对象的电子化存储和统计分析**第二阶段**：对象之间数据、动作的流程化&自动化伴随着数据大集中、管理分布式、数据深挖掘的大趋势**第三阶段**：负责管理这些对象的人的工作的监控&KPI考核一边考核这些人的工作绩效,一边监控这些人的工作漏洞**第四阶段**：信息化系统的移动化、分享化、社会化需求调研的关键对象实体对象（物）：系统管理的实体对象，ER图的对象及关系即体现这些。组织机构及业务角色（人）：1、记录每一个Role关注的功能。业务流程（事件）：1、按业务领域划分来分析。2、按Role来分析。业务用例（细节）：具体的功能点细节分析报表（考核）：任务完全情况监控和KPI考核移动化：尽量的将业务移动化需求分析步骤与方法1、从客户/集成商那得到仅有的一点可怜的需求信息如果对需求不太了解,一般来说不要直接询问客户细节2、了解客户行业背景，可在百度文库上看一下这个行业相关的信息化解决方案3、向客户确认清楚项目的管理对象，最好是能够了解一下客户的信息化、业务流程、和分布式/集中式管理等现状4、按照上面的【信息化的四个阶段】+【需求调研的关键对象】来解构用户的信息化需求，拟定我们的解决方案和功能清单5、制作UI原型，并与客户确认，完善对象关键字段，确定业务用例的细节。系统创新和亮点流程创新管理创新体验创新技术创新"}