<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/15/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-architecture/敏捷项目管理-在互联网公司中的应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.855Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>《管理3.0 : 培养和提升敏捷领导力》<br>《Scrum敏捷软件开发》</p>
<h2 id="我们需要什么样的管理和流程？"><a href="#我们需要什么样的管理和流程？" class="headerlink" title="我们需要什么样的管理和流程？"></a>我们需要什么样的管理和流程？</h2><ul>
<li>无流程 – 反复无常<br>无管理成本，所有工作都是为了软件产出<br>人数多了后，开发过程混乱，质量降低<br>管理者随时提出需求，产品经理考虑不周全<br>无组织无纪律<br>写单元测试？没时间。系统太复杂。太简单没必要</li>
</ul>
<ul>
<li>强流程 – 例行公事<br>繁琐的文档， 大量的规范、标准和管理活动，每一个环节可控<br>过度的设计<br>会议多， 成本高，效率低，最要命的是降低团队的主动性、创新性<br>遵循规范，但是不知道规范背后的道理<br>写单元测试，但是自己都不知道有没有效果，集中在一起写<br>为什么写单元测试？更快的反馈<br>产品质量完全由测试人员保障</li>
</ul>
<ul>
<li>现状：复杂系统理论</li>
</ul>
<p><strong>当过程运行根本机制相当简单的情况下，典型的做法使用预定义建模方式（在做之前把所有东西想清楚），但是过程复杂程度超过预定义的能力范围，我们会选择经验性方式。</strong></p>
<p><img src="_v_images/2019-11-29-17-48-48.png"></p>
<ul>
<li>自适应 – 驾驭自如<ul>
<li>主管是考理解去做事情。为什么要这样做</li>
<li>丰富的经验和技巧，拥有敏锐的“嗅觉”</li>
<li>团队拥有自己的流程，规则都是根据团队需要去制定，不多不少</li>
<li>自觉遵守团队的流程和纪律</li>
<li>产品的计划、质量和问题都是开发和可视化的</li>
<li>主动发现和暴露问题，从根源上解决问题</li>
<li>有节奏的进行开发</li>
</ul>
</li>
</ul>
<p><strong>经验型过程的3大支柱：可见性、检查及适应</strong></p>
<p>敏捷缺陷或盲点</p>
<ul>
<li>假设每一个人的能力都很强</li>
<li>假设每一个都很守纪律</li>
</ul>
<h2 id="一、造物先造人"><a href="#一、造物先造人" class="headerlink" title="一、造物先造人"></a>一、造物先造人</h2><ul>
<li>找一个牛人<ul>
<li>管理者(二流的管理者只会招三流的下属)</li>
<li>产品经理（掌舵者）</li>
<li>开发（齿轮）</li>
</ul>
</li>
<li>培养团队<ul>
<li> 文化/价值观/原则（开放、工作激情）</li>
<li> 有组织有预谋的学习(团队分享、读书会)</li>
<li> 教练式的管理者（指导人们正确的做事）</li>
<li> 授权 &amp;&amp; 目标指导</li>
<li> 经验只能从犯错中学习</li>
<li> 表扬式的管理，鲸鱼哲学</li>
</ul>
</li>
</ul>
<p><strong>培养团队例子：</strong><br>    - 有组织有计划的培养，读书计划，检查，所有的例子用TDD方式写一遍</p>
<pre><code>- 学习性团队：每天早上浙江站会

- 一起Code Review

- 训练营：做题讨论
</code></pre>
<h2 id="二、清晰的管理模型"><a href="#二、清晰的管理模型" class="headerlink" title="二、清晰的管理模型"></a>二、清晰的管理模型</h2><h3 id="1、项目规划"><a href="#1、项目规划" class="headerlink" title="1、项目规划"></a>1、项目规划</h3><ul>
<li>项目视图/立项制度<ul>
<li><strong>项目规划</strong>：各个部门或中心的项目规划——心中有树/术 (半年/季度)</li>
<li><strong>项目要求</strong>：明确的目标、里程碑、规模、各个角色的负责人，开始和结束时间</li>
<li><strong>各个层次的目标</strong>：产品目标、项目目标、发布目标、迭代目标</li>
<li>特性团队</li>
<li>符合SMART原则</li>
</ul>
</li>
</ul>
<p>搭班子、定战略、带队伍</p>
<h3 id="2、项目启动（Quick-start）"><a href="#2、项目启动（Quick-start）" class="headerlink" title="2、项目启动（Quick start）"></a>2、项目启动（Quick start）</h3><ul>
<li><p>立项书</p>
<ul>
<li><p> 项目背景、目标/愿景</p>
</li>
<li><p>里程碑</p>
</li>
<li><p> User personal</p>
</li>
<li><p>用户界面原型</p>
</li>
<li><p> 业务流程图/技术架构图</p>
</li>
<li><p> 粗粒度的功能列表</p>
</li>
<li><p>沟通计划 ：每天/每迭代/每发布</p>
</li>
<li><p>告诉团队项目的管理流程</p>
</li>
</ul>
</li>
<li><p>原则：</p>
<ul>
<li><p> 详略得当，不要面面俱到</p>
</li>
<li><p> WBS工作任务分解</p>
</li>
<li><p>  文档不是目的，思考过程，清楚和透彻</p>
</li>
</ul>
</li>
</ul>
<h3 id="3、自适应的软件开发方法–敏捷（-流程可视化-）"><a href="#3、自适应的软件开发方法–敏捷（-流程可视化-）" class="headerlink" title="3、自适应的软件开发方法–敏捷（ 流程可视化 ）"></a>3、自适应的软件开发方法–敏捷（ 流程可视化 ）</h3><p>XP、Scrum</p>
<p>变态编程：既然这个东西很好，那么我们就要把它做到极致。</p>
<p>结对编程&lt;–CodeReview，时时刻刻做code review</p>
<p>敏捷Value观</p>
<ul>
<li>Communication（沟通）</li>
<li>Simplicity（简单）</li>
<li>Feedback（反馈）</li>
<li>Courage（勇气）</li>
<li>Respect（尊重）</li>
</ul>
<h3 id="4、可视化管理"><a href="#4、可视化管理" class="headerlink" title="4、可视化管理"></a>4、可视化管理</h3><ul>
<li>kanban</li>
<li> 燃尽图。做出燃尽图，表明可控。 燃尽图工期是骗人的，一定要有工作量</li>
<li>质量可视化（ 只有两个指标）<ul>
<li>千行代码的测试密度</li>
<li>人均单元测试代码行</li>
</ul>
</li>
</ul>
<h3 id="5、纪律可视化"><a href="#5、纪律可视化" class="headerlink" title="5、纪律可视化"></a>5、纪律可视化</h3><p>纪律 x 技能 = 能力</p>
<p><img src="_v_images/2019-11-29-17-49-04.png"></p>
<p>团队规则</p>
<ul>
<li>需求评审咋做？</li>
<li>如何测试？</li>
<li>需求变更规则？</li>
</ul>
<h2 id="三、持续的反馈"><a href="#三、持续的反馈" class="headerlink" title="三、持续的反馈"></a>三、持续的反馈</h2><p>敏捷整个过程都强调反馈</p>
<p>PDCA：Plan(计划)、Do(执行)、Check(检查)和Action(行动)</p>
<p><img src="_v_images/2019-11-29-17-49-19.png"></p>
<p>敏捷PDCA精髓：</p>
<p><img src="_v_images/2019-11-29-17-49-28.png"></p>
<ul>
<li>各个层面的反馈<ul>
<li>需求评审/设计评审 需求/设计层面的反馈</li>
<li>单元测试 方法/类层面的反馈</li>
<li>交叉编程(设计讨论&amp;Code Review) 详细设计和代码质量层面的反馈</li>
<li>自测/功能验收/测试 功能层面的反馈</li>
<li>Show case/灰度上线</li>
<li>站立会议/User Story Wall/燃尽图/回顾会议</li>
</ul>
</li>
</ul>
<ul>
<li>反馈的有效性<ul>
<li>更快和频繁的反馈，降低反馈的周期</li>
<li>自动化</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>文化：工作热情＋开放</li>
<li>传统敏捷的错误假设<ul>
<li>卓越</li>
<li>自律</li>
</ul>
</li>
<li>我的敏捷＝能力＋反馈</li>
<li>纪律 × 技能 ＝ 能力</li>
<li>每一个团队都不一样</li>
<li>忘记所学，团队自适应</li>
<li>全盘思考，增量工作</li>
<li>问题驱动，解决实际问题</li>
<li>天时、地利、人和</li>
<li>用心</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E5%9C%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" data-id="ckqg285uc0037rcfphj9y29fu" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/插件容器文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E6%8F%92%E4%BB%B6%E5%AE%B9%E5%99%A8%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.854Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-插件容器原理"><a href="#1-插件容器原理" class="headerlink" title="1. 插件容器原理"></a>1. 插件容器原理</h2><h3 id="1-1-插件容器提供的功能"><a href="#1-1-插件容器提供的功能" class="headerlink" title="1.1  插件容器提供的功能"></a>1.1  插件容器提供的功能</h3><p>容器主要提供统一的权限管理（认证、授权、鉴权）和插件管理功能。权限管理采用Shiro、redis在应用层来实现，抛弃了tomcat等web服务器提供的session管理功能。结构如下图：</p>
<p><img src="_v_images/2019-11-29-17-02-04.png"></p>
<h4 id="统一认证"><a href="#统一认证" class="headerlink" title="统一认证"></a>统一认证</h4><p>认证功能是由容器提供，插件不提供认证功能。用户在容器中认证后，容器将已认证的jSessionId传送给插件，插件通过jSessionId从redis中获取用户的认证信息，即完成统一的认证过程。用户可以通过Shiro的提供的API来获取用户的认证信息，可以参考  SecurityUtils.getSubject() 的用法。</p>
<h4 id="统一授权"><a href="#统一授权" class="headerlink" title="统一授权"></a>统一授权</h4><p>统一授权是指统一管理插件的资源，统一授予给用户。 插件注册时，将自身的资源注册到容器中，容器统一管理所有插件的资源；管理员可以通过容器提供的权限管理功能，将这些资源分配给用户。</p>
<h4 id="统一鉴权"><a href="#统一鉴权" class="headerlink" title="统一鉴权"></a>统一鉴权</h4><p>判断用户是否具有资源的访问权限，即鉴权。统一鉴权是指在容器和插件中，采用统一的权限校验方式来判断用户是否可以访问某资源，插件无需为鉴权开发任何功能。用户通过认证后，将获取所拥有的插件资源访问权限，并将此权限信息缓存入redis数据库，而插件通过jSessionId从redis中获取用户的权限信息，完成权限校验。</p>
<p>页面的鉴权是通过tag完成的，目前提供freemaker和jsp两套标签。鉴权标签是通过资源url来判断的，所以 插件必须保证自身提供的资源url在所有插件资源中是唯一的 。</p>
<h4 id="插件管理与监控"><a href="#插件管理与监控" class="headerlink" title="插件管理与监控"></a>插件管理与监控</h4><p>插件管理提供插件注册、启用/停用、修改、删除等功能，而插件监控主要是监控插件的运行状况，当插件异常停止时，发出告警信息。</p>
<h3 id="1-2-统一认证和授权的过程"><a href="#1-2-统一认证和授权的过程" class="headerlink" title="1.2  统一认证和授权的过程"></a>1.2  统一认证和授权的过程</h3><p>用户访问业务系统的认证及鉴权过程如下：</p>
<p><img src="_v_images/2019-11-29-17-02-38.png"></p>
<p>插件获取认证授权信息过程如下：</p>
<p><img src="_v_images/2019-11-29-17-02-46.png"></p>
<h2 id="2-插件开发文档"><a href="#2-插件开发文档" class="headerlink" title="2.  插件开发文档"></a>2.  插件开发文档</h2><h3 id="2-1-插件注册"><a href="#2-1-插件注册" class="headerlink" title="2.1 插件注册"></a>2.1 插件注册</h3><p>插件注册到应用插件容器有两种方式：</p>
<ul>
<li><p>插件启动时注册容器<br> 容器提供的 插件 注册接口：<br>  url ： <a href="http://xxx.xxx.xxx.xxx:port/{contextPath}/uaa/re">http://xxx.xxx.xxx.xxx:port/{contextPath}/uaa/re</a> g,<br>  参数： 插件自解释JSON，参见下面的 插件自解释接口</p>
<p>  返回值：{status: , message: }， status为0表示调用成功， 1表示失败； message为返回信息</p>
</li>
</ul>
<ul>
<li>插件启动后，在容器段手动添加<br>  插件提供自解释接口（接口返回内容参见下面插件自解释接口），在插件容器输入该自解释地址，手动添加插件</li>
</ul>
<p><strong>插件自解释接口</strong>标准如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: <span class="string">&quot;pluginId&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;插件Demo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uaaUrl&quot;</span>: <span class="string">&quot;http://192.168.0.209:8080/uaa/ck&quot;</span>,</span><br><span class="line">  <span class="string">&quot;menuJson&quot;</span>: <span class="string">&quot;[</span></span><br><span class="line"><span class="string">&#123;&#x27;id&#x27;:&#x27;pluginId&#x27;, &#x27;name&#x27;:&#x27;插件2&#x27;, &#x27;pid&#x27;:null, &#x27;description&#x27;:null, &#x27;pageurl&#x27;:null, &#x27;type&#x27;:1, &#x27;state&#x27;:&#x27;是&#x27;, &#x27;sort&#x27;:null, &#x27;icon&#x27;:null&#125;,</span></span><br><span class="line"><span class="string">&#123;&#x27;id&#x27;:&#x27;pluginId_list&#x27;, &#x27;name&#x27;:&#x27;列表&#x27;, &#x27;pid&#x27;:&#x27;pluginId&#x27;, &#x27;description&#x27;:null, &#x27;pageurl&#x27;:&#x27;/system/plugin/list&#x27;, &#x27;type&#x27;:1, &#x27;state&#x27;:&#x27;是&#x27;, &#x27;sort&#x27;:null, &#x27;icon&#x27;:null&#125;,</span></span><br><span class="line"><span class="string">&#123;&#x27;id&#x27;:&#x27;pluginId_update&#x27;, &#x27;name&#x27;:&#x27;修改&#x27;, &#x27;pid&#x27;:&#x27;pluginId&#x27;, &#x27;description&#x27;:null, &#x27;pageurl&#x27;:&#x27;/system/plugin/update&#x27;, &#x27;type&#x27;:0, &#x27;state&#x27;:&#x27;是&#x27;, &#x27;sort&#x27;:null, &#x27;icon&#x27;:null&#125;,</span></span><br><span class="line"><span class="string">&#123;&#x27;id&#x27;:&#x27;pluginId_delete&#x27;, &#x27;name&#x27;:&#x27;删除&#x27;, &#x27;pid&#x27;:&#x27;pluginId&#x27;, &#x27;description&#x27;:null, &#x27;pageurl&#x27;:&#x27;/system/plugin/delete&#x27;, &#x27;type&#x27;:0, &#x27;state&#x27;:&#x27;是&#x27;, &#x27;sort&#x27;:null, &#x27;icon&#x27;:null&#125;</span></span><br><span class="line"><span class="string">]&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插件自解释接口中的 menuJson字段的值是一个JSON字符串，用来传递插件资源，是资源的列表。除menuJson之外的信息是插件自身的信息。</p>
<h4 id="2-2-插件接收授权的URL地址"><a href="#2-2-插件接收授权的URL地址" class="headerlink" title="2.2 插件接收授权的URL地址"></a>2.2 插件接收授权的URL地址</h4><p>插件必须实现一个接收 认证授权信息的URL，该URL接收成功认证后的jSessionId。在用户登录时，这个URL链接将被客户端浏览器访问，插件将该jSessionId存入浏览器的Cookie中，这个cookie作为用户通过认证的唯一标识。浏览器拥有这个Cookie后，表明插件的权限管理被容器接管，插件资源已被容器授权控制。</p>
<p>PS: 这个URL需要填入到 插件自解释接口的uaaUrl中。</p>
<p>这个地址实现的功能是将jSessionId写入浏览器Cookie，此jSessionId是采用DES对称加密过的，实现参考：idbp-uaa-shiro工程中UaaConsumer类writeCookie方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StringCrypto des = <span class="keyword">new</span> StringCrypto();</span><br><span class="line">jid = des.decrypt(jid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对IE，必须加P3P到header中，否则无法写入cookie</span></span><br><span class="line">response.addHeader(<span class="string">&quot;P3P&quot;</span>, <span class="string">&quot;CP=\&quot;CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR\&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;SHAREJSESSIONID&quot;</span>, jid);</span><br><span class="line">cookie.setMaxAge(-<span class="number">1</span>);       <span class="comment">// 浏览器关闭此Cookie时效</span></span><br><span class="line">cookie.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">response.addCookie(cookie); <span class="comment">//加入Cookies</span></span><br></pre></td></tr></table></figure>


<h4 id="2-3-Shiro-Redis缓存配置"><a href="#2-3-Shiro-Redis缓存配置" class="headerlink" title="2.3 Shiro-Redis缓存配置"></a>2.3 Shiro-Redis缓存配置</h4><p>Shiro-Redis缓存配置有两种方式：基于Spring配置、基于INI配置。</p>
<p>Spring配置参考：idbp-plugin1的applicationContext-shiro-prod.xml文件<br>INI配置参考： idbp-plugin2-jfinal的shiro.ini文件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E6%8F%92%E4%BB%B6%E5%AE%B9%E5%99%A8%E6%96%87%E6%A1%A3/" data-id="ckqg285ub0036rcfpb8f1ctyh" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/排序算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.853Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="选择排序与冒泡排序"><a href="#选择排序与冒泡排序" class="headerlink" title="选择排序与冒泡排序"></a>选择排序与冒泡排序</h2><p><strong>相同点</strong>：每一轮都把最大或最小的元素筛选出来放在相应的位置上 。<br><strong>不同点</strong>：冒泡排序每次比较和移动相邻的两项，而选择排序每次交换当前项和第n项。即是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡： </span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span> to n-<span class="number">1</span> <span class="function"><span class="keyword">do</span> </span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(a[i]&gt;a[i+<span class="number">1</span>])</span> then <span class="title">swap</span><span class="params">(i,i+<span class="number">1</span>)</span></span>; </span><br><span class="line"><span class="comment">//选择： </span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span> to n-<span class="number">1</span> <span class="function"><span class="keyword">do</span> </span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(a[i]&gt;a[n])</span> then <span class="title">swap</span><span class="params">(i,n)</span></span>; </span><br></pre></td></tr></table></figure>


<p>总的来说，两种排序比较的次数是相同的，但交换的次数，选择排序是更少的。虽然两者的时间复杂度都是 O（n^2) 但选择排序更快一点。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">    max=i; <span class="comment">// 假定第i个元素的关键字最大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) <span class="comment">// 找最大元素的下标</span></span><br><span class="line">      <span class="keyword">if</span>(arr[max]&lt;arr[j]) max=j;</span><br><span class="line">    <span class="keyword">if</span>(max!=i)&#123; <span class="comment">// 第i个元素和最大元素交换</span></span><br><span class="line">      <span class="keyword">int</span> t = arr[i];</span><br><span class="line">      arr[i] = arr[max];</span><br><span class="line">      arr[max] = t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;=i;j--) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>]) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j<span class="number">-1</span>] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的原理： 以第一个记录为“枢轴”，查询记录序列，确定“枢轴“的位置。枢轴将待排序文件分成两部分：枢轴左面的记录的关键字都不大于它的关键字，而枢轴右面的记录的关键字都不小于它的关键字。对枢轴的左右两部分继续实施这一过程，直至全部文件有序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">14</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">17</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">17</span>,<span class="number">1</span>,<span class="number">18</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* swap函数：交换v[k]与v[j]的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> v[], <span class="keyword">int</span> k, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> temp;</span><br><span class="line"> temp = v[k];</span><br><span class="line"> v[k] = v[j];</span><br><span class="line"> v[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span> v[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> j, last;</span><br><span class="line"> <span class="keyword">if</span> (left &gt;= right) <span class="comment">/* 若数组包含的元素个数少于两个 */</span></span><br><span class="line">     <span class="keyword">return</span>; <span class="comment">/* 则不执行任何操作 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> last=left; <span class="comment">/* 用last记录中比关键字小间的最右位置*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (j = left+<span class="number">1</span>; j &lt;= right; j++) &#123;<span class="comment">/* 划分子集 */</span></span><br><span class="line">     <span class="keyword">if</span> (v[j] &lt; v[left])&#123;</span><br><span class="line">         swap(v, ++last, j);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*通过上述过程会形成 关键字（中left所在位置） 小小小...（last所在位置）大大大大（最后）*/</span></span><br><span class="line"> swap(v, left, last); <span class="comment">/* 恢复划分的元素 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*小小。。。。关键字大大大大*/</span></span><br><span class="line"> qsort(v, left, last<span class="number">-1</span>);</span><br><span class="line"> qsort(v, last+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> j;</span><br><span class="line"> qsort(arr, <span class="number">0</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;=<span class="number">19</span>; j++)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[j]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传统的快速排序是递归的，这就会受到递归栈深度的限制。比如在一台普通的PC上，当待排序元素达到10^6以上时，传统的递归快排会导致栈溢出异常，或者一个莫名其妙的错误结果。所以，对于巨大的数据规模，将快速排序消除递归是十分必要的。而消除递归，又将带来巨大的性能提升，把系统级的消耗降到最低。</p>
<p>消除递归的方法，就是模拟栈操作。但是从代码可以看出，这种模拟的消耗几乎可以忽略不计。因此消除递归的快排的效率是有保障的。</p>
<p>（虽然下面的代码没有使用随机化，但经过测试，它是目前所有快排编写方法中，效率最高，速度最快的！）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXARRAY 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(A,B) &#123;sl[sp]=A;sr[sp]=B;sp++;&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP(A,B) &#123;sp--;A=sl[sp];B=sr[sp];&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> sl[MAXARRAY], sr[MAXARRAY], sp;</span><br><span class="line">  <span class="keyword">int</span> i,j,p,t;</span><br><span class="line">  sp=<span class="number">0</span>;</span><br><span class="line">  PUSH(l,r);</span><br><span class="line">  <span class="keyword">while</span>(sp)&#123;</span><br><span class="line">    POP(l,r);</span><br><span class="line">    i=l;</span><br><span class="line">    j=r;</span><br><span class="line">    p=a[(i+j)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">      <span class="keyword">while</span>(a[i]&lt;p)i++;</span><br><span class="line">      <span class="keyword">while</span>(a[j]&gt;p)j--;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;=j)&#123;</span><br><span class="line">        t=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=t;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;j)PUSH(l,j);</span><br><span class="line">    <span class="keyword">if</span>(i&lt;r)PUSH(i,r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>1.基本概念<br>树形选择排序(锦标赛排序)，1964年威洛姆斯(J.Willioms)提出了进一步改正的排序方法，即堆排序(heap sort)。<br>堆是n个元素的有限序列{ K1,K2,…,Kn }，它当且仅当满足如下关系：</p>
<p>这是一个上小、底大的堆。若是一个上大、底小的堆，只需把” &lt;= “改为” &gt;= “即可。堆是一种数据元素之间的逻辑关系，常用向量做存储结构。对于满二叉树，当对它的结点由上而下，自左至右编号之后，编号为 i 的结点是编号为 2i 和 2i+1 结点的双亲。反过来讲，结点 2i 是结点 i 的左孩子，结点 2i+1 是结点 i 的右孩子。图 9.7 表示完全二叉树和它在向量中的存储状态。结点编号对应向量中的下标号。</p>
<p>用堆的概念分析向量中的数据，它显然满足（上小、底大）堆的关系。不难看出满足堆的逻辑关系的一组数据，可画成二叉树的形状，并且它是一棵完全二叉树树形。因此，也可借助完全二叉树来描述堆的概念。若完全二叉树中任一非叶子结点的值小于等于（或大于等于）其左、右孩子结点的值，则从根结点开始按结点编号排列所得的结点序列就是一个堆。在图 9.8 中 (a) 、 (c) 是堆， (b) 、 (d) 不是堆。</p>
<p>2.算法思想<br>    堆排序利用了大根堆(或小根堆)堆顶记录的关键字最大(或最小)这一特征，使得在当前无序区中选取最大(或最小)关键字的记录变得简单。<br>（1）用大根堆排序的基本思想</p>
<ul>
<li>① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区</li>
<li>② 再将关键字最大的记录R<a href="%E5%8D%B3%E5%A0%86%E9%A1%B6">1</a>和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key</li>
<li>③ 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。<br>……<br>直到无序区只有一个元素为止。</li>
</ul>
<p>（2）大根堆排序算法的基本操作：</p>
<ul>
<li>① 初始化操作：将R[1..n]构造为初始堆；</li>
<li>② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆(亦称重建堆)。</li>
</ul>
<p>  注意：</p>
<ul>
<li>①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。</li>
<li>②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻，堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。</li>
</ul>
<p>3.具体算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  (T r[],<span class="keyword">int</span> n) &#123; <span class="comment">//n为文件的实际记录数，r[0]没有使用</span></span><br><span class="line">    <span class="keyword">int</span> i,m;node x;</span><br><span class="line">    <span class="keyword">for</span>(i=/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)heappass(r,i,n);       <span class="comment">//初建堆</span></span><br><span class="line">    <span class="comment">//以下for语句为输出堆顶元素、调整堆操作</span></span><br><span class="line">    <span class="keyword">for</span>(m=n<span class="number">-1</span>;m&gt;=<span class="number">1</span>;m--)&#123;      <span class="comment">//逻辑堆尾下标m不断变小</span></span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;r[<span class="number">1</span>].key&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">          x=r[<span class="number">1</span>];r[<span class="number">1</span>]=r[m+<span class="number">1</span>];r[m+<span class="number">1</span>]=x;    <span class="comment">//堆顶与堆尾元素对换</span></span><br><span class="line">          heappass(r,<span class="number">1</span>,m);<span class="comment">//恢复堆</span></span><br><span class="line">       &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;r[<span class="number">1</span>].key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="comment">//heapsort</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="ckqg285ub0035rcfp6gq4bcv2" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/技术知识体系层次" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%B1%82%E6%AC%A1/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.852Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="技术知识体系层次"><a href="#技术知识体系层次" class="headerlink" title="技术知识体系层次"></a>技术知识体系层次</h1><ul>
<li><p>理论基础。</p>
<ul>
<li><p>非常重要；</p>
</li>
<li><p>应该从书上获取，在笔记中不应收集；</p>
</li>
</ul>
</li>
<li><p>技术入门使用。</p>
<ul>
<li><p>技术入门使用方面知识不应收集到笔记中；</p>
</li>
<li><p>最好以代码形式放入Github中，如learning库；</p>
</li>
</ul>
</li>
<li><p>技术架构解决方案。</p>
<ul>
<li><p>多种技术的组合使用，如：kafka+spark streaming实时数据处理；</p>
</li>
<li><p>行业典型解决方案；</p>
</li>
<li><p>专题总结，总结成熟的技术方案，如：报表；</p>
</li>
<li><p> 技术架构解决方案可以收集到笔记中，能代码实现的方案，一定需要代码实现，放入Github中；</p>
</li>
</ul>
</li>
<li><p>产品。</p>
<ul>
<li>包括中间件、平台、项目等。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>笔记中以收集【 技术架构解决方案】为主，清理其他内容；</li>
<li>【技术入门使用】知放入Github的learning库中</li>
<li>空余学习性编程主要是三个方面：技术入门使用、技术架构解决方案、产品；</li>
<li>日常工作中，应该是工作任务+（理论基础 | 学习性编程）；</li>
</ul>
<h1 id="避免碎片化学习–问题式学习方法"><a href="#避免碎片化学习–问题式学习方法" class="headerlink" title="避免碎片化学习–问题式学习方法"></a>避免碎片化学习–问题式学习方法</h1><ul>
<li><p>原则</p>
<ul>
<li><p><strong>缩小关注圈，扩大影响圈。</strong>自己完全搞不懂的知识不要花时间、收藏，努力加深已知知识深度，扩大自己已知知识的外延（广度）。</p>
</li>
<li><p>知识结构化。用思维导图来组织自己的所有知识。</p>
</li>
<li><p>721原则。70%时间和精力花在练习上，20%花在思考与讨论上，10%花在碎片化信息浏览上。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>互联网时代学习知识方法</li>
</ul>
<p><img src="_v_images/2019-11-29-17-52-16.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%B1%82%E6%AC%A1/" data-id="ckqg285ua0034rcfph1xh69bv" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/快速掌握Python学习手册" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1Python%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.851Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>3引用VS拷贝<br>Python中，在传递大型对象时如果的确需要持贝，那么可以明确要求。<br>1.没有限制条件的分片表达式能够复制序列<br>2.字典copy方法能够复制字典<br>3.有些内置函数（例如1ist）能够生成持贝（list（L））<br>4.copy标准库模块能够生成完整持贝</p>
<hr>
<p>4比较、相等性和真值<br>所有的Python对象也可以支持比较操作一测试相等性、相对大小等。Python的比较总是检查复合对象的部分，直到可以得出结果为止。事，当嵌套对象存在时，Python能够自动遍历数据结构，并从左到右递归地应用比较，要多深就走多深。<br>·“==”：操作符测试值的相等性。（递归地比较所有内嵌对象）<br>·“is”：表达式测试对象的一致性。（试二者是否是同一个对象，检查内存地址）</p>
<p>一般来说，在Python不同的类型的比较方法如下：<br>·数字通过相对大小进行比较。k<br>·字符串是按照字典顺序，一个字符接一个字符地对比进行比较。<br>·列表和元组从左到右对每部分的内容进行比较。·字典通过排序之后的（键、值）列表进行比较。</p>
<hr>
<p><img src="_v_images/2019-11-21-20-56-21.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = l *<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [l]*<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[[<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%BF%AB%E9%80%9F%E6%8E%8C%E6%8F%A1Python%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" data-id="ckqg285ua0033rcfpcg7sgebh" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/工业4.0时代的物联网架构实践之道" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%B7%A5%E4%B8%9A4.0%E6%97%B6%E4%BB%A3%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%81%93/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.849Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="物联网四要素"><a href="#物联网四要素" class="headerlink" title="物联网四要素"></a>物联网四要素</h1><p>物体、数据、连接、分析</p>
<h1 id="智能制造对终端平台的需求"><a href="#智能制造对终端平台的需求" class="headerlink" title="智能制造对终端平台的需求"></a>智能制造对终端平台的需求</h1><ul>
<li>平台扩展性<ul>
<li> 通用开发框架</li>
<li> 硬件外设驱动</li>
<li> 低成本的芯片</li>
<li> 低耗电</li>
</ul>
</li>
</ul>
<ul>
<li><p>传感器链接</p>
<ul>
<li><p> 无线链接 (BLE, Wi-Fi, MBB)</p>
</li>
<li><p> 有线链接(Ethernet, USB)</p>
</li>
<li><p> 集成MCU/功能单元 (GPIO, I2C, SPI)</p>
</li>
<li><p> 工业协议链接(Modbus)</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>安全性<ul>
<li> 数据传输安全</li>
<li> 平台架构安全</li>
</ul>
</li>
</ul>
<ul>
<li>平台升级<ul>
<li> 远程在线平台升级</li>
</ul>
</li>
</ul>
<ul>
<li>应用管理<ul>
<li> 终端应用的远程部署/更新</li>
</ul>
</li>
</ul>
<ul>
<li>云集成<ul>
<li> 云端集成或适配集成( AMQP, MQTT)</li>
</ul>
</li>
</ul>
<h1 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h1><p><img src="_v_images/2019-11-29-17-26-36.png"></p>
<p><img src="_v_images/2019-11-29-17-26-48.png"></p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><p><img src="_v_images/2019-11-29-17-26-56.png"></p>
<p><img src="_v_images/2019-11-29-17-27-06.png"></p>
<h1 id="参考架构"><a href="#参考架构" class="headerlink" title="参考架构"></a>参考架构</h1><p><img src="_v_images/2019-11-29-17-27-17.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%B7%A5%E4%B8%9A4.0%E6%97%B6%E4%BB%A3%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5%E4%B9%8B%E9%81%93/" data-id="ckqg285u90032rcfp8gui1ycr" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/容灾系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%AE%B9%E7%81%BE%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.847Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="_v_images/2019-11-29-17-24-03.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%AE%B9%E7%81%BE%E7%B3%BB%E7%BB%9F/" data-id="ckqg285u90031rcfpdmppdkmm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/实时数据库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.846Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-实时数据库-vs-关系型DB"><a href="#1-实时数据库-vs-关系型DB" class="headerlink" title="1 实时数据库 vs 关系型DB"></a>1 实时数据库 vs 关系型DB</h2><ul>
<li>写入速度：实时数据库要求写入速度快，没有事务处理要求。</li>
<li>读取方式和速度：SQL的读取方式不适应实时数据，RDB读取的速度也难满足要求。</li>
<li>压缩性：由于实时数据具有连续性、重复性、关联性等特征，实时数据常常要求常驻内存，不压缩难以保存大量数据。</li>
<li>数据备份存储：RDB只能整体备份存储，存储部分是无意义的，而实时DB要求可以部分存储和恢复。</li>
</ul>
<h2 id="2-现有的方案"><a href="#2-现有的方案" class="headerlink" title="2 现有的方案"></a>2 现有的方案</h2><ul>
<li><p>美国OSIsoft公司，PI； 在国内应用最多，主要用于大型行业用户，如电力、石油、化工和冶金等。</p>
</li>
<li><p>美国Wonderware公司，IndustrialSQL Server，简称INSQL；</p>
</li>
<li><p> 美国AspenTech公司，InfoPlus；</p>
</li>
<li><p>北京庚顿：<a target="_blank" rel="noopener" href="http://www.golden-data.com.cn/">www.golden-data.com.cn</a></p>
</li>
</ul>
<p><strong>报价</strong>：</p>
<ul>
<li><p>PI—-10万美元，每个接口6000美元，OPC接口收费；</p>
</li>
<li><p>InfoPlus.21—-11万美元，每个接口1万美元，OPC接口不收费；</p>
</li>
<li><p>Industrial SQL Server—-6.5万美元，每个IDAS1200美元，OPC Link免费。</p>
</li>
</ul>
<p>优势：</p>
<ul>
<li>入门快。能借用这些企业快速的进入我们不熟悉的行业。</li>
<li>方案成熟，坑少。</li>
</ul>
<p>劣势：</p>
<ul>
<li>成本高。</li>
<li>技术基础受限制。</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/guohu/p/5165163.html">实时数据库简介和比较</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/liqfyiyi/article/details/6862886">实时数据库简介</a></li>
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-ftegnyni-sc.html">实时数据库</a></li>
</ul>
<h2 id="3-开源或替代方案"><a href="#3-开源或替代方案" class="headerlink" title="3 开源或替代方案"></a>3 开源或替代方案</h2><p><strong>开源方案：</strong></p>
<ul>
<li>BekeleyDb 只支持单机的，不支持网络访问，基本不适用。</li>
</ul>
<p><strong>替代方案：</strong></p>
<ul>
<li>采用Redis替代。读写速度能满足要求，但没有压缩存储能力，备份机制可能支持。</li>
<li>采用HBase替代。参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/rjj510/article/details/7987074">基于分布式存储的开源系统在实时数据库海量历史数据存储项目上的预研</a></li>
</ul>
<p>劣势：</p>
<ul>
<li>Redis、HBase替代方案都只满足部分要求，不满足的部分必然影响功能或性能，可用于小规模应用，如果要支持大规模、稳定性要求高的应用，需要投入开发成本。</li>
</ul>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h2><p>开源方案基本没有；如果是要求高的大型应用，建议选择购买，国外厂商太贵，国内厂商可以咨询一下北京庚顿价格；如果做一个要求不高的应用，从成本考虑，可以选择替代方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="ckqg285u8002zrcfper4u35id" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/实现类似MyBatis的注解Mapper" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCMyBatis%E7%9A%84%E6%B3%A8%E8%A7%A3Mapper/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.846Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文讲解在Spring中实现类似MyBatis的注解Mapper功能。</p>
<p>以查询为例，定义一个接口，并接口上标注@Dao注解；定义一个查询方法，并在其上标注上@Select注解，填充上命名参数的sql；使用@Param注解在方法参数上标明sql命名参数，所有预定义过程完成。使用spring的@Autowired注入即可调用。</p>
<h1 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h1><ul>
<li>利用类 ClassPathScanningCandidateComponentProvider 查找自定义注解的类。</li>
<li>利用Java的动态代理实现接口的代理类。</li>
<li>利用类 BeanFactoryPostProcessor 接口将代理类注入到spring容器中。</li>
</ul>
<h1 id="定义三个注解"><a href="#定义三个注解" class="headerlink" title="定义三个注解"></a>定义三个注解</h1><ul>
<li>@Dao 作用于接口上，表明此接口的代理实现类是可以动态注入到Spring容器中。<pre>
@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Dao {
String value() default "";
}
</pre></li>
</ul>
<ul>
<li>@Select作用于方法上，用来填写方法需要使用的SQL，sql的格式采用JDBC的命名查询格式。<pre>
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Select {
String[] value();
}
</pre></li>
</ul>
<ul>
<li>@Param作用于方法的参数上，用来表明参数的名称。<br>PS:由于Java的接口不是类，方法参数无法存入局部变量表中，因此在运行时是无法获取接口方法准确的参数名称，只能获得arg0,arg1这类的名称，所以需要采用注解来指定。<pre>
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
public @interface Param {
String value();
}
</pre></li>
</ul>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><ul>
<li>定义接口类<pre>
@Dao
public interface UserDao {</li>
</ul>
<p>@Select(“select * from m_user where login_Name=:loginName”)<br>User findUserByAccount(@Param(“loginName”)String loginName);</p>
<p>@Select(“select * from m_user where login_Name=:loginName”)<br>Page<User> paginateUserByAccount(@Param(“pageNo”)Integer pageNo,<br>                        @Param(“pageSize”)Integer pageSize,<br>@Param(“loginName”)String loginName);<br>}<br></pre></p>
<ul>
<li>测试类<pre>
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext.xml")
public class UserDaoTest  {</li>
</ul>
<p>@Autowired<br>UserDao userDao;</p>
<p>@Test<br>public void test_findUserByAccount() {<br>String account = “support1”;</p>
<p>User user = userDao.findUserByAccount(account);<br>Assert.assertNotNull(user.getId());<br>}</p>
<p>@Test<br>public void paginateUserByAccount(){<br>Integer pageNo = 1;<br>Integer pageSize = 10;</p>
<p>String account = “support1”;</p>
<p>Page<User> pageUser = userDao.paginateUserByAccount(pageNo, pageSize, account);<br>Assert.assertNotNull(pageUser);<br>}<br>}<br></pre></p>
<h1 id="扫描标有-Dao注解的类"><a href="#扫描标有-Dao注解的类" class="headerlink" title="扫描标有@Dao注解的类"></a>扫描标有@Dao注解的类</h1><pre>
public class DaoAnnotationComponentProvider extends ClassPathScanningCandidateComponentProvider {
 
    public DaoAnnotationComponentProvider() {
        super(false);
        // 添加scan 的类型：@Dao
        addIncludeFilter(new AnnotationTypeFilter(Dao.class, false));
    }


    @Override
    protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
        // 返回true表示要scan interface
    return beanDefinition.getMetadata().isInterface();
    }
}
</pre>


<h1 id="实现-Dao接口类的代理类"><a href="#实现-Dao接口类的代理类" class="headerlink" title="实现@Dao接口类的代理类"></a>实现@Dao接口类的代理类</h1><p>采用Java的动态代理实现，实现接口InvocationHandler即可。主要的思路是：从@Select接口获取SQL，通过Reflection获取Method的返回类型，从@Param中获取参数名称，此参数名称和SQL中名称参数一一对应。</p>
<pre>
public class DaoInvocationHandlerImpl implements InvocationHandler{
private static Logger logger = LoggerFactory.getLogger(DaoInvocationHandlerImpl.class);
private final static String PAGE_NO = "pageNo";
private final static String PAGE_SIZE = "pageSize";

@SuppressWarnings("unchecked")
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
Select annoSelect = method.getAnnotation(Select.class);
if (annoSelect != null) {
Map<String, Object> params = new HashMap<>();
Parameter[] parameters = method.getParameters();

for (int i=0;i<parameters.length;i++){
Class<?> paramClass = parameters[i].getType();
if (paramClass.isAssignableFrom(Map.class)){
params.putAll((Map<String, Object>)args[i]);
} else {
Param annoParam = parameters[i].getAnnotation(Param.class);
String paramName = annoParam.value();
params.put(paramName, args[i]);
}
}

Object retObj = callJdbc(method, String.join("",annoSelect.value()), params);
return retObj;
} else {
return method.invoke(this, args);
}
}


private Object callJdbc(Method method, String sql, Map<String, Object> params) {
logger.debug(String.format("%s==>SQL: %s , 参数: %s", method.getName(), sql, params.toString()));
Object retObj = null;
Finder finder = Finder.of(sql).bind(params);    

Class<?> retClass = method.getReturnType();

if (retClass.isAssignableFrom(List.class)){
ParameterizedType retType = (ParameterizedType)method.getGenericReturnType();
Class<?> clazz = (Class<?>) retType.getActualTypeArguments()[0];
retObj = finder.list(clazz);
} else if (retClass.isAssignableFrom(Map.class)){
retObj = finder.first(Map.class);
} else if (retClass.isAssignableFrom(Page.class)){
ParameterizedType retType = (ParameterizedType)method.getGenericReturnType();
Class<?> clazz = (Class<?>) retType.getActualTypeArguments()[0];
Object pn = params.get(PAGE_NO);
Object ps = params.get(PAGE_SIZE);
if (ObjectUtils.isEmpty(pn) || ObjectUtils.isEmpty(ps) ){
throw new IllegalArgumentException("缺少 pageNo / pageSize 参数");
}
int pageNo = Integer.valueOf(pn.toString());
int pageSize = Integer.valueOf(ps.toString());
retObj = finder.paginate(clazz, pageNo, pageSize);
} else {
retObj = finder.first(retClass);
}
logger.debug(String.format("<==成功执行查询(%s)",method.getName()));
return retObj;
}


}
</pre>


<h1 id="将Dao的代理类注入到Spring容器中"><a href="#将Dao的代理类注入到Spring容器中" class="headerlink" title="将Dao的代理类注入到Spring容器中"></a>将Dao的代理类注入到Spring容器中</h1><pre>
public class DaoBeanProcessor implements BeanFactoryPostProcessor, ResourceLoaderAware {
private ResourceLoader resourceLoader;
/** @Dao接口类所在的包，可以是逗号分割的多个包名 */
private String packages;


    @Override
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }
    
@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
Set<BeanDefinition> beans = scanCallerInterfaceDef();
DefaultListableBeanFactory bf = (DefaultListableBeanFactory)beanFactory;
registerDaoProxyBean(beans, bf);
}
    
    private Set<BeanDefinition> scanCallerInterfaceDef() {
    ClassPathScanningCandidateComponentProvider componentProvider = new DaoAnnotationComponentProvider();
    componentProvider.setResourceLoader(resourceLoader);
   
    Set<BeanDefinition> beans = new LinkedHashSet<BeanDefinition>();
    String[] pkgArr = packages.split(",");
    for (String pkg : pkgArr){
    beans.addAll(componentProvider.findCandidateComponents(pkg.trim()));
    }
    return beans;
    }
    
    private void registerDaoProxyBean(Set<BeanDefinition> beans, DefaultListableBeanFactory beanFactory){
    for (BeanDefinition bd : beans){
Class<?> clazz = null;
try {
clazz = Class.forName(bd.getBeanClassName());
} catch (ClassNotFoundException e) {
e.printStackTrace();
continue;
}
String name = clazz.getSimpleName();
Object obj = DaoProxyFactory.getDaoBean(clazz);
beanFactory.registerSingleton(name.substring(0,1).toUpperCase() + name.substring(1), obj);
    }
    }


public String getPackages() {
return packages;
}


public void setPackages(String packages) {
this.packages = packages;
}


}
</pre>


<p>不要忘了在spring中配置这类的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.xx.DaoBeanProcessor&quot;&gt;</span><br><span class="line">&lt;property name=&quot;packages&quot; value=&quot;com.xxx&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCMyBatis%E7%9A%84%E6%B3%A8%E8%A7%A3Mapper/" data-id="ckqg285u80030rcfp3zxk8ttw" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/大型网站架构技术一览" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E4%B8%80%E8%A7%88/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.845Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="大型网站架构技术一览"><a href="#大型网站架构技术一览" class="headerlink" title="大型网站架构技术一览"></a>大型网站架构技术一览</h1><p>大型网站的挑战主要来自庞大的用户，高并发的访问和海量数据，任何简单的业务一旦需要处理数以P计的数据和面对数以亿计的用户，问题就会变得棘手。大型网站架构主要就是解决这类问题。更多内容也可以阅读 各大互联网公司架构演进之路汇总 、 大型网站架构演化历程 两篇文章。</p>
<p>本文内容大部分来自 《大型网站技术架构》 ,这本书很值得一看，强烈推荐。</p>
<p>网站系统架构层次如下图所示：</p>
<p><img src="_v_images/2019-11-29-17-57-44.png"></p>
<h2 id="1-前端架构"><a href="#1-前端架构" class="headerlink" title="1.前端架构"></a>1.前端架构</h2><p>前端指用户请求到达网站应用服务器之前经历的环节，通常不包含网站业务逻辑，不处理动态内容。 </p>
<h3 id="浏览器优化技术"><a href="#浏览器优化技术" class="headerlink" title="浏览器优化技术"></a>浏览器优化技术</h3><p>并不是优化浏览器，而是通过优化响应页面，加快浏览器页面的加载和显示，常用的有页面缓存、合并HTTP减少请求次数、使用页面压缩等。</p>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>内容分发网络，部署在网络运营商机房，通过将静态页面内容分发到离用户最近最近的CDN服务器，使用户可以通过最短路径获取内容。 </p>
<h3 id="动静分离，静态资源独立部署"><a href="#动静分离，静态资源独立部署" class="headerlink" title="动静分离，静态资源独立部署"></a>动静分离，静态资源独立部署</h3><p>静态资源，如JS、CSS等文件部署在专门的服务器集群上，和Web应用动态内容服务分离，并使用专门的（二级）域名。 </p>
<h3 id="图片服务"><a href="#图片服务" class="headerlink" title="图片服务"></a>图片服务</h3><p>图片不是指网站Logo、按钮图标等，这些文件属于上面提到的静态资源，应该和JS、CSS部署在一起。这里的图片指用户上传的图片，如产品图片、用户头像等，图片服务同样适用独立部署的图片服务器集群，并使用独立（二级）域名。 </p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>部署在网站机房，在应用服务器、静态资源服务器、图片服务器之前，提供页面缓存服务。 </p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名服务，将域名解析成IP地址，利用DNS可以实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后指向CDN服务器。 </p>
<h2 id="2-应用层架构"><a href="#2-应用层架构" class="headerlink" title="2.应用层架构"></a>2.应用层架构</h2><p>应用层是处理网站主要业务逻辑的地方。 </p>
<h3 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h3><p>网站业务是多变的，网站的大部分软件工程师都是在加班加点开发网站业务，一个好的开发框架至关重要。一个号的开发框架应该能够分离关注面，使美工、开发工程师可以各司其事，易于协作。同时还应该内置一些安全策略，防护Web用攻击。 </p>
<h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>将分别开发维护的动态内容和静态页面模板集成起来，组合成最终显示给用户的完整页面。 </p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>将多台应用服务器组成一个集群，通过负载均衡技术将用户请求分发到不同的服务器上，以应对大量用户同时访问时产生的高并发负载压力。 </p>
<h3 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h3><p>为了实现高可用的应用服务器集群，应用服务器通常设计为无状态，不保存用户请求上下文信息，但是网站业务通常需要保持用户会话信息，需要专门的机制管理Session，使集群内甚至跨集群的应用服务器可以共享Session。 </p>
<h3 id="动态页面静态化"><a href="#动态页面静态化" class="headerlink" title="动态页面静态化"></a>动态页面静态化</h3><p>对于访问量特别大而更新又不很频繁的动态页面，可以将其静态化，即生成一个静态页面，利用静态页面的优化手段加速用户访问，如反向代理、CDN、浏览器缓存等。 </p>
<h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3><p>将复杂而庞大的业务拆分开来，形成多个规模较小的产品，独立开发、部署、维护，除了降低系统耦合度，也便于数据库业务分库。按业务对关系数据库进行拆分，技术难度相对较小，而效果又相对较好。 </p>
<h3 id="虚拟化服务器"><a href="#虚拟化服务器" class="headerlink" title="虚拟化服务器"></a>虚拟化服务器</h3><p>将一台物理服务器虚拟化成多态虚拟服务器，对于并发访问较低的业务，更容易用较少的资源构架高可用的应用服务器集群。 </p>
<h2 id="3-服务层架构"><a href="#3-服务层架构" class="headerlink" title="3.服务层架构"></a>3.服务层架构</h2><p>提供基础服务，供应用层调用，完成网站业务。 </p>
<h3 id="分布式消息"><a href="#分布式消息" class="headerlink" title="分布式消息"></a>分布式消息</h3><p>利用消息队列机制，实现业务和业务、业务和服务之间的异步消息发送及低耦合的业务关系。 </p>
<h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3><p>提供高性能、低耦合、易复用、易管理的分布式服务，在网站实现面向服务架构（SOA）。 </p>
<h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>通过可伸缩的服务器集群提供大规模热点数据的缓存服务，是网站性能优化的重要手段。 </p>
<h3 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h3><p>系统运行需要配置许多参数，如果这些参数需要修改，比如分布式缓存集群加入新的缓存服务器，需要修改应用程序客户端的缓存服务器列表配置，并重启应用程序服务器。分布式配置在系统运行期提供配置动态推送服务，将配置修改实时推送到应用系统，无需重启服务器。 </p>
<h2 id="4-存储层架构"><a href="#4-存储层架构" class="headerlink" title="4.存储层架构"></a>4.存储层架构</h2><p>提供数据、文件的持久化存储访问与管理服务。 </p>
<h3 id="分布式文件"><a href="#分布式文件" class="headerlink" title="分布式文件"></a>分布式文件</h3><p>网站在线业务需要存储的文件大部分都是图片、网页、视频等比较小的文件，但是这些文件的数量非常庞大，而且通常都在持续增加，需要伸缩性设计比较好的分布式文件系统。 </p>
<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><p>大部分万丈的主要业务是基于关系数据库开发的，但是关系数据库对集群伸缩性的支持表较差。通过在应用程序的数据访问层增加数据库访问的路由功能，根据业务配置将数据库访问路由到不同的物理数据库上，可实现关系数据库的分布式访问。 </p>
<h3 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h3><p>目前各种NoSQL数据库层出不穷，在内存管理、数据模型、集群分布式管理等方面各有优势，不过从社区活动性角度看，HBase无疑是目前最好的。 </p>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>在支持全球范围内数据共享的分布式数据库技术成熟之前，拥有多个数据中心的网站必须在多个数据中心之间进行数据同步，以保证每个数据中心都拥有完整的数据。在实践中，为了减轻数据库压力，将数据库的事物日志（或者NoSQL的写操作Log）同步到其他数据中心，根据Log进行数据重演，实现数据同步。 </p>
<h2 id="5-后台架构"><a href="#5-后台架构" class="headerlink" title="5.后台架构"></a>5.后台架构</h2><p>网站应用中，除了要处理用户的实时访问请求外，还有一些后台非实时数据分析要处理。 </p>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><p>即使是网站内部的搜索引擎，也需要进行数据增量更新及全量更新、构建索引等。这些操作通过后台系统定时执行。 </p>
<h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>根据离线数据，提供数据分析与数据挖掘服务。 </p>
<h3 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h3><p>社交网站及购物网站通过挖掘人与人之间的关系，人和商品之间的关系，发展潜在的人际关系和购物兴趣，为用户提供个性化推荐服务。 </p>
<h2 id="6-数据采集与监控"><a href="#6-数据采集与监控" class="headerlink" title="6.数据采集与监控"></a>6.数据采集与监控</h2><p>监控网站访问情况与系统运行情况，为网站运营决策和运维管理提供支持保障。 </p>
<h3 id="浏览器数据采集"><a href="#浏览器数据采集" class="headerlink" title="浏览器数据采集"></a>浏览器数据采集</h3><p>通过在网站页面中嵌入JS脚本采集用户浏览器环境与操作记录，分析用户行为。 </p>
<h3 id="服务器业务数据采集"><a href="#服务器业务数据采集" class="headerlink" title="服务器业务数据采集"></a>服务器业务数据采集</h3><p>服务器业务数据包括两种，一种是采集在服务器端记录的用户请求操作日志；一种是采集应用程序运行期业务数据，比如待处理消息数目等。 </p>
<h3 id="服务器性能数据采集"><a href="#服务器性能数据采集" class="headerlink" title="服务器性能数据采集"></a>服务器性能数据采集</h3><p>采集服务器性能数据，如系统负载、内存使用率、网卡流量等。 </p>
<h3 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h3><p>将前述采集的数据以图表的方式展示，以便运营和运维人员监控网站运行状况，做到这一步仅仅是系统监视。更先进的做法是根据采集的数据进行自动化运维，自动处理系统异常状况，是吸纳自动化控制。 </p>
<h3 id="系统报警"><a href="#系统报警" class="headerlink" title="系统报警"></a>系统报警</h3><p>如果采集来的数据超过预设的正常情况的阀值，比如系统负载过高，就通过邮件、短信、语音电话等方式发出警报信号，等待工程师干预。 </p>
<h2 id="7-安全架构"><a href="#7-安全架构" class="headerlink" title="7.安全架构"></a>7.安全架构</h2><p>保护网站免遭攻击及敏感信息泄露。 </p>
<h3 id="Web攻击"><a href="#Web攻击" class="headerlink" title="Web攻击"></a>Web攻击</h3><p>以HTTP请求的方式发起的攻击，危害最大的就是XSS和SQL注入攻击。但是只要措施得当，这两种攻击都是比较容易防范的。 </p>
<h3 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h3><p>敏感信息加密传输与存储，保护网站和用户资产。 </p>
<h2 id="8-数据中心机房架构"><a href="#8-数据中心机房架构" class="headerlink" title="8.数据中心机房架构"></a>8.数据中心机房架构</h2><p>大型网站需要的服务器规模数以十万计，机房物理架构也需要关注。 </p>
<h3 id="机房架构"><a href="#机房架构" class="headerlink" title="机房架构"></a>机房架构</h3><p>对于一个拥有十万台服务器的大型网站，每台服务器耗电（包括服务器本身耗电及空调耗电）每年大约需要人民币2000元，那么网站每年机房电费就需要两亿人民币。数据中心能耗问题日趋严重，Google、Facebook选择数据中心地理位置的时候趋向选择散热良好，供电充裕的地方。 </p>
<h3 id="机柜架构"><a href="#机柜架构" class="headerlink" title="机柜架构"></a>机柜架构</h3><p>包括机柜大小，网线布局、指示灯规格、不间断电源、电压规格（是48V直流电还是220V民用交流电）等一系列问题。 </p>
<h3 id="服务器架构"><a href="#服务器架构" class="headerlink" title="服务器架构"></a>服务器架构</h3><p>大型网站由于服务器采购规模庞大，大都采用定制服务器的方式代替购买服务器整机。根据网站应用需求，定制硬盘、内存、甚至CPU，同时去除不必要的外设接口（显示器输出接口，鼠标、键盘输入接口），并使空间结构利于散热。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E4%B8%80%E8%A7%88/" data-id="ckqg285u8002yrcfpc7fl2lak" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/16/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%8C%87%E5%BC%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%93%81%E8%B7%AF6C%E4%B8%9A%E5%8A%A1%E7%BB%93%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E7%AB%99%E7%94%9F%E4%BA%A7%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E5%8E%82%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>