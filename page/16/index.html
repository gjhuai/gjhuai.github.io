<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/16/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-architecture/基于数据同步的云服务架构实践" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.843Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/presentations/cloud-services-architecture-practice-bsed-on-data-synchronization">http://www.infoq.com/cn/presentations/cloud-services-architecture-practice-bsed-on-data-synchronization</a></p>
<p>[TOC]</p>
<h1 id="野狗的数据同步理念"><a href="#野狗的数据同步理念" class="headerlink" title="野狗的数据同步理念"></a>野狗的数据同步理念</h1><h2 id="Wilddog是什么？"><a href="#Wilddog是什么？" class="headerlink" title="Wilddog是什么？"></a>Wilddog是什么？</h2><ul>
<li>一个云端树形数据库</li>
<li>一个App的所有的数据存到一个大JSON中</li>
<li>事件驱动客户端</li>
</ul>
<h2 id="Schema-free-数据存储"><a href="#Schema-free-数据存储" class="headerlink" title="Schema-free 数据存储"></a>Schema-free 数据存储</h2><ul>
<li>树形数据库</li>
<li>像一颗Json树</li>
<li>面向聚合</li>
<li>数据之间的关系更直观</li>
<li>完美的与Url结合</li>
<li>每条数据都能通过url来唯一定位</li>
<li>Path为key，key - value</li>
</ul>
<h2 id="基于野狗的应用架构是这样的"><a href="#基于野狗的应用架构是这样的" class="headerlink" title="基于野狗的应用架构是这样的"></a>基于野狗的应用架构是这样的</h2><p><img src="_v_images/2019-11-29-17-37-20.png"></p>
<h2 id="数据副本的同步"><a href="#数据副本的同步" class="headerlink" title="数据副本的同步"></a>数据副本的同步</h2><p><img src="_v_images/2019-11-29-17-37-29.png"></p>
<h2 id="数据同步的基本模型"><a href="#数据同步的基本模型" class="headerlink" title="数据同步的基本模型"></a>数据同步的基本模型</h2><ul>
<li>初始化慢同步<ul>
<li>full sync</li>
<li>condition sync</li>
</ul>
</li>
<li>增量同步<ul>
<li>本地 best-effort</li>
<li>push op log</li>
</ul>
</li>
<li>基于长连接<ul>
<li>保证有序性</li>
<li>重连需要初始化慢同步</li>
</ul>
</li>
</ul>
<p><img src="_v_images/2019-11-29-17-38-11.png"></p>
<h1 id="数据同步的架构演进"><a href="#数据同步的架构演进" class="headerlink" title="数据同步的架构演进"></a>数据同步的架构演进</h1><h2 id="架构特点"><a href="#架构特点" class="headerlink" title="架构特点"></a>架构特点</h2><ul>
<li>写多读少<ul>
<li>写同步越实时越好</li>
<li>读容忍一定延迟</li>
</ul>
</li>
<li>最终一致性</li>
<li>并行写冲突</li>
<li>实时</li>
<li>操作幂等</li>
</ul>
<h2 id="v-0-1-架构框图"><a href="#v-0-1-架构框图" class="headerlink" title="v 0.1 架构框图"></a>v 0.1 架构框图</h2><ul>
<li>面向早期用户</li>
<li>物化路径存储</li>
</ul>
<p><img src="_v_images/2019-11-29-17-38-28.png"></p>
<h2 id="v0-2-架构框图"><a href="#v0-2-架构框图" class="headerlink" title="v0.2 架构框图"></a>v0.2 架构框图</h2><ul>
<li>动态建库，app数据隔离</li>
<li>Mongo 提升读写性能</li>
<li>副本集多活</li>
<li>机枪换导弹（批量Batch数据操作）</li>
</ul>
<p><img src="_v_images/2019-11-29-17-38-39.png"></p>
<h2 id="v0-3-架构框图"><a href="#v0-3-架构框图" class="headerlink" title="v0.3 架构框图"></a>v0.3 架构框图</h2><ul>
<li>appId - topic</li>
<li>大大提升写性能（写缓冲队列kafka）</li>
<li>类似Nagle减低写压力</li>
<li>读性能下降</li>
</ul>
<p><img src="_v_images/2019-11-29-17-38-48.png"></p>
<h2 id="解决读的不一致问题"><a href="#解决读的不一致问题" class="headerlink" title="解决读的不一致问题"></a>解决读的不一致问题</h2><ul>
<li>幂等的覆盖模式操作</li>
</ul>
<p><img src="_v_images/2019-11-29-17-38-58.png"></p>
<h2 id="v-0-3-1-架构框图"><a href="#v-0-3-1-架构框图" class="headerlink" title="v 0.3.1 架构框图"></a>v 0.3.1 架构框图</h2><ul>
<li>keys xxx* 引发的血案</li>
<li>需要Performance Monitoring</li>
</ul>
<p><img src="_v_images/2019-11-29-17-39-07.png"></p>
<h2 id="Performance-Monitoring"><a href="#Performance-Monitoring" class="headerlink" title="Performance Monitoring"></a>Performance Monitoring</h2><ul>
<li>流量统计</li>
<li>调用延迟</li>
<li>异常报警</li>
</ul>
<p><img src="_v_images/2019-11-29-17-39-16.png"></p>
<h1 id="数据同步的细节问题"><a href="#数据同步的细节问题" class="headerlink" title="数据同步的细节问题"></a>数据同步的细节问题</h1><h2 id="问题一-并发写"><a href="#问题一-并发写" class="headerlink" title="问题一 并发写"></a>问题一 并发写</h2><ul>
<li>静态一致性</li>
<li>写隔离</li>
<li>解决方案<ul>
<li>中心化锁机制</li>
<li>进程间协商机制</li>
</ul>
</li>
</ul>
<p><img src="_v_images/2019-11-29-17-39-27.png"></p>
<h2 id="分布式树形锁"><a href="#分布式树形锁" class="headerlink" title="分布式树形锁"></a>分布式树形锁</h2><ul>
<li>注意问题</li>
<li>tryLock/release 需要2次交互</li>
<li>注册Lock的有效期</li>
<li>等待Lock超时</li>
<li>动态hash</li>
<li>连接异常时退化</li>
</ul>
<p><img src="_v_images/2019-11-29-17-39-36.png"></p>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><ul>
<li>吞吐量下降</li>
<li>每个app一个树形锁，单进程，终究有吞吐上限</li>
<li>任何操作，包括没有冲突操作，都需要先获得锁</li>
<li>主要性能的点</li>
<li>单次push sync量大，可以导致阻塞</li>
<li>异步push sync</li>
</ul>
<h2 id="令人恶心的架构诞生了"><a href="#令人恶心的架构诞生了" class="headerlink" title="令人恶心的架构诞生了"></a>令人恶心的架构诞生了</h2><ul>
<li>缩减了write操作的过程</li>
<li>保证云端与客户端一致性</li>
<li>太过复杂，不确定因素累加过多</li>
</ul>
<p><img src="_v_images/2019-11-29-17-40-07.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/" data-id="ckqg285u7002xrcfp0mkt52il" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/图片播放技术总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%9B%BE%E7%89%87%E6%92%AD%E6%94%BE%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.837Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>由于工作的项目上的需求，需要在浏览器上不间断的播放图片，即像播放视频一样播放图片。</p>
<p>后端支持采用Java实现，需要用Java编写一个Http服务器，并提供WebSocket服务。前后端通过Http链接或WebSocket提供图片浏览服务，前端采用JS轮询或WebSocket推送的方式获取图片，浏览器显示图片有两种方式：一种是采用<img>连续切换图片源，实现播放效果；另一种采用将图片画在canvas上面，实现播放。</p>
<p>要完成这个功能涉及到以下技术：</p>
<ul>
<li>Http服务器的实现</li>
<li>高速的读文件</li>
<li>WebSocket原理及实现</li>
<li>基于浏览器pull方式的http资源获取</li>
<li>基于服务器端push方式的http资源获取</li>
<li>JS播放图片帧的性能</li>
</ul>
<h1 id="2-技术分析"><a href="#2-技术分析" class="headerlink" title="2 技术分析"></a>2 技术分析</h1><h2 id="2-1-Http服务器的实现"><a href="#2-1-Http服务器的实现" class="headerlink" title="2.1 Http服务器的实现"></a>2.1 Http服务器的实现</h2><p>实现HTTP服务器比较容易，实现方式也有如下多种：</p>
<ul>
<li>基于jdk中com.sun包下面的HttpServer来实现。（不推荐，com.sun不在java规范内，jdk升级可能会不兼容）</li>
<li>基于jetty或tomcat的嵌入式包来实现。此方式基于Servlet规范来实现的，较简单且易于理解。</li>
<li>基于netty的方式实现。性能好，需要对NIO有了解，编程难度相对大一些。</li>
<li>基于vert.x的实现。这种方式底层还是采用netty实现，较简单，但是也需要熟悉vert.x的编程模型。</li>
</ul>
<p>我们采用jetty的方式实现，基于servlet3.0规范，可以支持异步请求方式。代码如下：</p>
<pre>
public static void main(String[] args){
    Server server = new Server();
    ServerConnector connector = new ServerConnector(server);
    connector.setPort(8080);
    server.addConnector(connector);


    ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);
    context.setContextPath("/");


    context.addServlet(new ServletHolder(new HelloServlet()), "/hello");  
    server.setHandler(context);


    try {
        // Initialize javax.websocket layer
        ServerContainer wscontainer = WebSocketServerContainerInitializer.configureContext(context);
        // Add WebSocket endpoint to javax.websocket layer
        wscontainer.addEndpoint(EventSocket.class);


        server.start();
        server.dump(System.err);
        server.join();
    } catch (Throwable t){
        t.printStackTrace(System.err);
    }
}
</pre>


<h2 id="2-2-高速的读文件"><a href="#2-2-高速的读文件" class="headerlink" title="2.2  高速的读文件"></a>2.2  高速的读文件</h2><p>关于Java高速读取文件可参考这篇文章：<a target="_blank" rel="noopener" href="http://nadeausoftware.com/articles/2008/02/java_tip_how_read_files_quickly">How to read files quickly</a><br>这篇文章得出四个结论：</p>
<ul>
<li>为了减少I/O操作，每次 应该 读一个byte数组，而不是一个byte字节，8K的byte数组就是一个好的选择。</li>
<li>为了减少方法调用的开销，每次应该获取一个byte数组的数据，而不是一个byte字节。</li>
<li>为了减少线程同步锁的开销，要么减少线程同步方法的调用，要么采用非线程安全的类，如：FileChannel 和MappedByteBuffer。</li>
<li>为了减少在JVM/OS、 internal buffers和应用程序数组之间的数据拷贝，要么使用带有内存映射的FileChannel类，要么使用 a direct or wrapped array ByteBuffer.</li>
</ul>
<p>下面提高两种高速读取文件方法：</p>
<pre>
for (String filePath : fileList){
try(FileChannel ch = new RandomAccessFile(filePath, "r").getChannel()){
int size = (int) ch.size();
MappedByteBuffer buf = ch.map(MapMode.READ_ONLY, 0, size);
// 处理buf....
} catch (IOException e) {
e.printStackTrace();
}
}
</pre>


<pre>
for (String filePath : fileList){
try (SeekableByteChannel sbc = Files.newByteChannel(Paths.get(filePath), StandardOpenOption.READ)) {
   ByteBuffer buf = ByteBuffer.allocate(10);


   // Read the bytes with the proper encoding for this platform.  If
   // you skip this step, you might see something that looks like
   // Chinese characters when you expect Latin-style characters.
   //String encoding = System.getProperty("file.encoding");
   while (sbc.read(buf) > 0) {
       buf.rewind();
       // 处理buf...
       //System.out.print(Charset.forName(encoding).decode(buf));
       buf.flip();
   }
} catch (IOException x) {
   System.out.println("caught exception: " + x);
}
}
</pre>



<h2 id="2-3-WebSocket原理及实现"><a href="#2-3-WebSocket原理及实现" class="headerlink" title="2.3  WebSocket原理及实现"></a>2.3  WebSocket原理及实现</h2><p>WebSocket的原理以及与Http区别可以参考：<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_bf397e780102w25k.html">WebSocket与http的区别，以及它的原理</a>，总体来说，原理及区别如下：</p>
<ul>
<li>WebSocket和Http协议没有太大的关系，WS只是借助Http实现了第一次握手，之后从http协议upgrade为ws://协议。</li>
<li>WS是持久性连接（类似socket），而HTTP的短连接、长连接都不是持久的。</li>
<li>WS协议是支持全双工的，可以pull，亦可以push。</li>
</ul>
<p>用Java实现WebSocket服务端：</p>
<pre>
@ClientEndpoint
@ServerEndpoint(value="/events/")
public class EventSocket{
private static int DEFAULT_BUFFER_SIZE = 128 * 1024;// 8192
private byte[] bytes;

    @OnOpen
    public void onWebSocketConnect(Session session, EndpointConfig config)  {
session.setMaxBinaryMessageBufferSize(DEFAULT_BUFFER_SIZE);
    }
    
    @OnMessage
    public void onWebSocketText(Session session, String message) throws Exception{
        System.out.println("Received TEXT message: " + message);
        bytes = ... // 读取图片文件字节
        // 发送图片文件
        session.getAsyncRemote().sendBinary( ByteBuffer.wrap( this.bytes ) );
    }
    
    @OnClose
    public void onWebSocketClose(Session session, CloseReason reason){
        System.out.println("Socket Closed: " + reason);
    }
    
    @OnError
    public void onWebSocketError(Session session, Throwable cause){
        cause.printStackTrace(System.err);
    }
}
</pre>



<h2 id="2-4-浏览器并发请求与长连接"><a href="#2-4-浏览器并发请求与长连接" class="headerlink" title="2.4  浏览器并发请求与长连接"></a>2.4  浏览器并发请求与长连接</h2><p>浏览器请求一般都是拉取服务器的资源，而请求方式分为短连接和长连接两种，这篇文章介绍很清楚：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/cswuyg/p/3653263.html">HTTP的长连接和短连接</a></p>
<p>浏览器对后端资源的请求都是并发的执行的，不同的浏览器并发连接数不同。现在大多数浏览器都支持http1.1协议，默认都会开启keep-alive，支持长连接。在浏览器对后端的资源发出请求，在开启keep-alive情况下，都会复用连接通道。如果是不间断的下载图片，应该使用的是长连接通道复用功能。</p>
<h2 id="2-5-Web服务器Push技术"><a href="#2-5-Web服务器Push技术" class="headerlink" title="2.5 Web服务器Push技术"></a>2.5 Web服务器Push技术</h2><p>实现服务器端Push有以下几种方式：</p>
<ul>
<li>Ajax轮询。采用setInterval方法不停的调用</li>
<li>Ajax长轮询。俗称Comet方式，不需要重复建立连接，没有响应就一直等，等到才关闭连接。</li>
<li> WebSocket</li>
<li>server-sent-events</li>
</ul>
<p>Ajax轮询原理还是pull的方式，不算真正的push，但是对一些老版本的浏览器是适用的。WebSocket优点是支持全双工、可跨域。server-sent-server实现简单，但只支持server到client单向传输，且IE系列都不支持。 详细内容参考： <a target="_blank" rel="noopener" href="https://w3ctech.com/topic/1754">web服务器端推送技术简介</a></p>
<p>除了上面一些方法外，还有一些其他方式，如：Flash  XML Socket， Java Applet等非主流。</p>
<p>而在本案例中，如果采用WebSocket传送图片，可实现真正的服务器端不间断的推送图片数据，但是如果要实现并发传送，必须自己在浏览器端来实现，否则，仅仅单连接的情况下不一定比浏览器的并发连接快。</p>
<h2 id="2-6-JS播放图片帧的性能"><a href="#2-6-JS播放图片帧的性能" class="headerlink" title="2.6  JS播放图片帧的性能"></a>2.6  JS播放图片帧的性能</h2><p>JS播放图片有多种方式，如：</p>
<ul>
<li>采用<img>标签，不停改变img的src属性，实现播放。</li>
<li>采用Html5的Canvas，将Image对象画在Canvas上，实现播放。</li>
<li>将图片设置为Div的背景，不停的更换背景，实现播放。</li>
</ul>
<p>采用<img>标签方式实现如下：</p>
<pre>
(function() {
    var i = 0;
    var pics = [ "andy_white.jpg", "andy_black.jpg" ];
    var el = document.getElementById('img_to_flip');  // el doesn't change
    function toggle() {
        el.src = pics[i];           // set the image
        i = (i + 1) % pics.length;  // update the counter
    }
    setInterval(toggle, 2000);
})();
</pre>



<p>这种方式下浏览器CPU占用率非常高，在IE11和Chrome下，i3的CPU（T440P）占用都在60%左右，内存占用较少，大约在100M左右。CPU的消耗主要在浏览器对图片的渲染上。<br>用Canvas替代<img>标签，CPU占用方面，IE11仍然占用那么高，Chrome能降一半。更换背景的方式没有实验。基于以上，采用Canvas的方式是一种比较好的选择。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%9B%BE%E7%89%87%E6%92%AD%E6%94%BE%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/" data-id="ckqg285u7002wrcfpddbt5ios" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/区块链" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.836Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yinanmo5569/article/details/80313710">区块链（Block Chain）结构解析</a></p>
<h2 id="Python开发区块链"><a href="#Python开发区块链" class="headerlink" title="Python开发区块链"></a>Python开发区块链</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?src=11&timestamp=1570764209&ver=1905&signature=Fo09EY6xZp2oEL6cH7XjnOhKIiPn63xU0ey2*Ws3yCEzOEZ0nfrStidxbVzmWcaAIQeyvzxbCJn5CfgCZZ-7KVM2liEKThiiXCPeYqttVPBFUhj893uKxmmxC9T5ibKr&new=1">Python 实现最简单的区块链</a></li>
<li><a target="_blank" rel="noopener" href="https://learnblockchain.cn/2017/10/27/build_blockchain_by_python/">用 Python 从零开始创建区块链</a></li>
</ul>
<h1 id="1-第1课"><a href="#1-第1课" class="headerlink" title="1 第1课"></a>1 第1课</h1><h2 id="1-1-比特币"><a href="#1-1-比特币" class="headerlink" title="1.1 比特币"></a>1.1 比特币</h2><h3 id="1-1-1-比特币-起源"><a href="#1-1-1-比特币-起源" class="headerlink" title="1.1.1 比特币-起源"></a>1.1.1 比特币-起源</h3><ul>
<li>Bitcoin(BTC): A Peer-to-Peer Electronic Cash  System( 点对点电子现金系统 )</li>
<li>中本聪在 2009 年初挖出第一批比特币</li>
<li>总量不超过 2100 万枚</li>
</ul>
<h3 id="1-1-2-比特币-底层机制"><a href="#1-1-2-比特币-底层机制" class="headerlink" title="1.1.2 比特币-底层机制"></a>1.1.2 比特币-底层机制</h3><ul>
<li>去中心化， P2P 分布式数字货币系统</li>
<li>共识机制 -POW 工作量证明</li>
<li>非对称加密算法 - 数字签名</li>
<li>区块链账本技术</li>
</ul>
<h3 id="1-1-3-比特币-特性"><a href="#1-1-3-比特币-特性" class="headerlink" title="1.1.3 比特币-特性"></a>1.1.3 比特币-特性</h3><ul>
<li>硬通货 - 跨境交易</li>
<li>易携带 - 只需一个私钥</li>
<li>隐秘性 - 只暴露钱包地址</li>
<li>无货币超发</li>
</ul>
<h3 id="1-1-4-比特币-钱包"><a href="#1-1-4-比特币-钱包" class="headerlink" title="1.1.4 比特币-钱包"></a>1.1.4 比特币-钱包</h3><ul>
<li>钱包就是 P2P 里的 P( 节点 ) ，主要用来管理私钥和比特币转账地 址</li>
<li>钱包分类</li>
<li>轻钱包 - 只存储维护跟你自己交易相关的数据</li>
<li>中心化钱包 - 数字货币交易所</li>
<li>钱包下载地址： <a target="_blank" rel="noopener" href="https://bitcoin.org/zh_CN/download">https://bitcoin.org/zh_CN/download</a></li>
</ul>
<h3 id="1-1-5-比特币-产生"><a href="#1-1-5-比特币-产生" class="headerlink" title="1.1.5 比特币-产生"></a>1.1.5 比特币-产生</h3><ul>
<li>比特币由矿工挖矿产生</li>
<li>生成的比特币被记录在矿工的名下</li>
<li>比特币通过矿工的公钥哈希值锁定</li>
<li>比特币通过交易 (UTXO) 在节点之间转移</li>
<li>UTXO- 未花费的交易</li>
</ul>
<h2 id="1-2-区块链"><a href="#1-2-区块链" class="headerlink" title="1.2 区块链"></a>1.2 区块链</h2><h3 id="1-2-1-区块链-分布式账本系统"><a href="#1-2-1-区块链-分布式账本系统" class="headerlink" title="1.2.1 区块链-分布式账本系统"></a>1.2.1 区块链-分布式账本系统</h3><p><img src="_v_images/2019-11-20-20-37-05.png"></p>
<ul>
<li>共识机制 -POW 工作量证明<ul>
<li>通过挖矿证明自己是善意节点，并获得生成区块和在该区块记账的权利</li>
</ul>
</li>
<li>基于 P2P 网络，每个全节点都存储着最全的比特币交易记录</li>
<li>新区块通过包含前一个区块头部的哈希值 ( 区块的唯一标识 ) 建立链接关系</li>
<li>区块里装的就是所有的比特币交易记录 (UTXO)</li>
</ul>
<h3 id="1-2-2-区块链网络"><a href="#1-2-2-区块链网络" class="headerlink" title="1.2.2  区块链网络"></a>1.2.2  区块链网络</h3><ul>
<li>区块链节点<ul>
<li>矿工-运行于强大或专用的硬件（比如 ASIC）之上，主要目的是挖矿</li>
<li>全节点-这些节点验证矿工挖出来的块的有效性，并对交易进行确认。</li>
<li>SPV节点-简单支付验证，如钱包节点</li>
</ul>
</li>
</ul>
<h3 id="1-2-3-区块链-挖矿"><a href="#1-2-3-区块链-挖矿" class="headerlink" title="1.2.3  区块链-挖矿"></a>1.2.3  区块链-挖矿</h3><ul>
<li>在全网中和其他节点竞争计算 ( 解一个难题 ) 的过程<ul>
<li>证明自己是非恶意节点</li>
</ul>
</li>
<li>获得的权利和义务<ul>
<li>记账权 - 把交易写入区块里</li>
<li>广播义务 - 把区块在全网广播</li>
</ul>
</li>
<li>获得的奖励<ul>
<li>挖矿奖励 -12.5BTC</li>
<li>收取交易手续费</li>
</ul>
</li>
</ul>
<h3 id="1-2-4-区块链-共识机制"><a href="#1-2-4-区块链-共识机制" class="headerlink" title="1.2.4  区块链-共识机制"></a>1.2.4  区块链-共识机制</h3><ul>
<li><p>拜占庭将军问题 - 共识机制之一<br><img src="_v_images/2019-11-20-20-37-27.png"></p>
</li>
<li><p>POW(Proof of Work)-工作量证明</p>
<ul>
<li>通过付出大量工作代价证明自己是非恶意节点</li>
<li>计算一个随机数 (nonce) ，算出的正确随机数即 POW</li>
<li>获取记账权利</li>
<li>打包交易并通知其它节点</li>
</ul>
</li>
<li><p>理性人都是逐利的， POW 抑制了节点的恶意动机</p>
</li>
</ul>
<h3 id="1-2-5-区块链-交易确认"><a href="#1-2-5-区块链-交易确认" class="headerlink" title="1.2.5  区块链-交易确认"></a>1.2.5  区块链-交易确认</h3><ul>
<li>当一项交易被链上的区块收录后，就是交易确认</li>
<li>在此区块之后每产生一个区块，此项交易的确认数相应加 1</li>
<li>经过 6 个以上区块确认的交易才是安全确认的，因为篡改成本巨大</li>
<li>比特币钱包可以设置交易确认数</li>
</ul>
<h3 id="1-2-6-区块链-区块生成"><a href="#1-2-6-区块链-区块生成" class="headerlink" title="1.2.6  区块链-区块生成"></a>1.2.6  区块链-区块生成</h3><p><img src="_v_images/2019-11-20-20-37-48.png"></p>
<ul>
<li><p>矿工在挖矿前要组建区块</p>
<ul>
<li>将 coinbase 交易打包进区块</li>
<li>将交易池中高优先级的交易打包进区块</li>
<li>创建区块头部<br><img src="_v_images/2019-11-20-20-38-04.png"></li>
</ul>
</li>
<li><p>挖矿成功后，将计算出来的随机数 nonce(POW) 填入区块头部， 并向临近节点传播</p>
</li>
</ul>
<h3 id="1-2-7-区块链-区块验证"><a href="#1-2-7-区块链-区块验证" class="headerlink" title="1.2.7  区块链-区块验证"></a>1.2.7  区块链-区块验证</h3><ul>
<li>相邻节点收到新区块后，立即做以下验证<ul>
<li>验证 POW 的 nonce 值是否符合难度值</li>
<li>检查时间戳是否小于当前时间两小时</li>
<li>检查 merkle 树根是否正确</li>
<li>检查区块 size 要小于区块 size 的上限</li>
<li>第一笔交易必须是 coinbase 交易</li>
<li>验证每个交易</li>
</ul>
</li>
</ul>
<h3 id="1-2-8-区块链-分类"><a href="#1-2-8-区块链-分类" class="headerlink" title="1.2.8  区块链-分类"></a>1.2.8  区块链-分类</h3><ul>
<li>公有链<ul>
<li>任何人都可以参与使用和维护，信息公开，如比特币，以太坊等</li>
</ul>
</li>
<li>联盟链<ul>
<li>若干组织共同维护，使用有权限限制，信息受保护，如银联组织</li>
</ul>
</li>
<li>私有链<ul>
<li>集中管理者进行限制，内部少数人可以使用，信息不公开</li>
</ul>
</li>
</ul>
<h3 id="1-2-9-区块链-篡改账本"><a href="#1-2-9-区块链-篡改账本" class="headerlink" title="1.2.9  区块链-篡改账本"></a>1.2.9  区块链-篡改账本</h3><ul>
<li>双花问题：同一笔比特币被支付多次</li>
</ul>
<p><img src="_v_images/2019-11-20-20-38-25.png"></p>
<p><img src="_v_images/2019-11-20-20-40-08.png"></p>
<p><img src="_v_images/2019-11-20-20-40-32.png"></p>
<p><img src="_v_images/2019-11-20-20-40-51.png"></p>
<h2 id="1-3-密码学"><a href="#1-3-密码学" class="headerlink" title="1.3 密码学"></a>1.3 密码学</h2><h3 id="1-3-1-密码学-对称加密"><a href="#1-3-1-密码学-对称加密" class="headerlink" title="1.3.1 密码学-对称加密"></a>1.3.1 密码学-对称加密</h3><ul>
<li>对称加密 - 加解密钥相同</li>
<li>缺点：无法确保密钥被安全传递</li>
<li>常用算法： DES 、 3DES （ TripleDES ）、 AES 等</li>
</ul>
<p><img src="_v_images/2019-11-20-20-43-11.png"></p>
<h3 id="1-3-2-密码学-非对称加密"><a href="#1-3-2-密码学-非对称加密" class="headerlink" title="1.3.2  密码学-非对称加密"></a>1.3.2  密码学-非对称加密</h3><ul>
<li>非对称加密 - 公私钥加密对，公钥加密，私钥解密</li>
</ul>
<p><img src="_v_images/2019-11-20-20-43-22.png"></p>
<p><img src="_v_images/2019-11-20-20-43-33.png"></p>
<ul>
<li>公钥由私钥生成，私钥可以推导出公钥</li>
<li>从公钥无法推导出私钥</li>
<li>优点：解决了密钥传输中的安全行问题</li>
<li>常用算法： RSA 、 ECC （椭圆曲线加密算法 )</li>
<li>使用场景： SSH 安全验证等</li>
<li>问题：解决了信息传送的问题，如何验证发送方是正确的了 ?</li>
</ul>
<h3 id="1-3-3-密码学-哈希-Hash"><a href="#1-3-3-密码学-哈希-Hash" class="headerlink" title="1.3.3  密码学-哈希(Hash)"></a>1.3.3  密码学-哈希(Hash)</h3><ul>
<li>哈希 - 将一段数据 ( 任意长度 ) 经过计算转换成一段定长的数据</li>
<li>不可逆性 - 几乎无法通过哈希的结果推导出原文</li>
<li>无碰撞性 - 两个不同原文哈希后的结果一定不同</li>
<li>常用算法： MD5 ， SHA256</li>
<li>使用场景<ul>
<li>数据库中的用户密码存储 (MD5)</li>
<li>挖矿计算 (SHA256)</li>
</ul>
</li>
</ul>
<h3 id="1-3-4-密码学-数字签名"><a href="#1-3-4-密码学-数字签名" class="headerlink" title="1.3.4  密码学-数字签名"></a>1.3.4  密码学-数字签名</h3><ul>
<li>数字签名 - 公私钥加密对，私钥签名，公钥解签名</li>
<li>使用场景 - 比特币交易验证等</li>
</ul>
<p><img src="_v_images/2019-11-20-20-43-46.png"></p>
<h3 id="1-3-5-Java实现区块链与比特币"><a href="#1-3-5-Java实现区块链与比特币" class="headerlink" title="1.3.5  Java实现区块链与比特币"></a>1.3.5  Java实现区块链与比特币</h3><ul>
<li>区块链结构</li>
<li>挖矿生成新区块</li>
<li>共识机制</li>
<li>比特币交易</li>
<li>比特币钱包 </li>
<li>区块链 P2P 网络通讯</li>
</ul>
<p><img src="_v_images/2019-11-20-20-44-02.png"></p>
<p>比特派</p>
<h1 id="第2课"><a href="#第2课" class="headerlink" title="第2课"></a>第2课</h1><ul>
<li><p>区块链整体结构设计与实现</p>
</li>
<li><p>共识机制</p>
<ul>
<li><p>工作量证明原理</p>
</li>
<li><p>挖矿算法</p>
</li>
</ul>
</li>
</ul>
<p><img src="_v_images/2019-11-20-20-44-16.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挖矿算法</span></span><br><span class="line"><span class="comment">//创建一个空的区块链</span></span><br><span class="line">List&lt;Block&gt; blockchain = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//生成创世区块</span></span><br><span class="line">Block block = <span class="keyword">new</span> Block(<span class="number">1</span>, System.currentTimeMillis(), <span class="keyword">new</span> ArrayList&lt;Transaction&gt;(), <span class="number">1</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//加入创世区块到区块链里</span></span><br><span class="line">blockchain.add(block);</span><br><span class="line">System.out.println(JSON.toJSONString(blockchain));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个空的交易结合</span></span><br><span class="line">List&lt;Transaction&gt; txs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Transaction tx1 = <span class="keyword">new</span> Transaction();</span><br><span class="line">Transaction tx2 = <span class="keyword">new</span> Transaction();</span><br><span class="line">Transaction tx3 = <span class="keyword">new</span> Transaction();</span><br><span class="line">txs.add(tx1);</span><br><span class="line">txs.add(tx2);</span><br><span class="line">txs.add(tx3);</span><br><span class="line"><span class="comment">//加入系统奖励的交易</span></span><br><span class="line">Transaction sysTx = <span class="keyword">new</span> Transaction();</span><br><span class="line">txs.add(sysTx);</span><br><span class="line"><span class="comment">//获取当前区块链里的最后一个区块</span></span><br><span class="line">Block latestBlock = blockchain.get(blockchain.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nonce = <span class="number">1</span>;</span><br><span class="line">String hash = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"> hash = CryptoUtil.SHA256(latestBlock.getHash() + JSON.toJSONString(txs) + nonce);</span><br><span class="line"> <span class="keyword">if</span> (hash.startsWith(<span class="string">&quot;0000&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=====计算结果正确，计算次数为：&quot;</span> +nonce+ <span class="string">&quot;,hash:&quot;</span> + hash);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> nonce++;</span><br><span class="line"> System.out.println(<span class="string">&quot;计算错误，hash:&quot;</span> + hash); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Block newBlock = <span class="keyword">new</span> Block(latestBlock.getIndex() + <span class="number">1</span>, System.currentTimeMillis(), txs, nonce, latestBlock.getHash(), hash);</span><br><span class="line">blockchain.add(newBlock);</span><br><span class="line">System.out.println(<span class="string">&quot;挖矿后的区块链：&quot;</span> + JSON.toJSONString(blockchain));</span><br></pre></td></tr></table></figure>


<p><img src="_v_images/2019-11-20-20-44-37.png"></p>
<h3 id="密码学–非对称加密"><a href="#密码学–非对称加密" class="headerlink" title="密码学–非对称加密"></a>密码学–非对称加密</h3><ul>
<li>非对称加密–公私钥加密对，共要加密，私钥解密</li>
<li>公钥由私钥生成，私钥可以推到出公钥</li>
<li>从公钥无法推导出私钥</li>
<li>优点：解决了密钥传输中的安全问题</li>
<li>常用算法：RSA、ECC（椭圆曲线加密算法）</li>
<li>使用场景：SSH安全验证等</li>
<li>问题：解决了信息传送的问题，如何验证发送方是正确的？<br><img src="_v_images/2019-11-20-20-45-16.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncrypt</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> System.err.println(<span class="string">&quot;公钥加密——私钥解密&quot;</span>);</span><br><span class="line"> String inputStr = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"> <span class="keyword">byte</span>[] data = inputStr.getBytes();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span>[] encodedData = RSACoder.encryptByPublicKey(data, publicKey);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">byte</span>[] decodedData = RSACoder.decryptByPrivateKey(encodedData, privateKey);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> String outputStr = <span class="keyword">new</span> String(decodedData);</span><br><span class="line"> System.err.println(<span class="string">&quot;加密前: &quot;</span> + inputStr + <span class="string">&quot;\n\r&quot;</span> + <span class="string">&quot;解密后: &quot;</span> + outputStr);</span><br><span class="line"> assertEquals(inputStr, outputStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="密码学–哈希（Hash）"><a href="#密码学–哈希（Hash）" class="headerlink" title="密码学–哈希（Hash）"></a>密码学–哈希（Hash）</h3><ul>
<li>哈希–讲一段数据（任意长度）经过计算转换成一段定长的数据</li>
<li>不可逆性–几乎无法通过哈希的结果推导出原文</li>
<li>无碰撞行–两个不同原文哈希后的结果一定不同</li>
<li>常用算法：MD5、SHA256</li>
<li>使用场景：<ul>
<li>数据库中的用户密码存储（MD5）</li>
<li>挖矿计算（SHA256）</li>
</ul>
</li>
</ul>
<h3 id="密码学–数字签名"><a href="#密码学–数字签名" class="headerlink" title="密码学–数字签名"></a>密码学–数字签名</h3><p>1、数字签名：公私钥加密对，私钥签名，公钥验证签名。<br>2、使用场景：比特币交易验证等。</p>
<p><img src="_v_images/2019-11-20-20-45-42.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSign</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> System.err.println(<span class="string">&quot;私钥签名——公钥验证签名&quot;</span>);</span><br><span class="line"> String inputStr = <span class="string">&quot;sign&quot;</span>;</span><br><span class="line"> <span class="keyword">byte</span>[] data = inputStr.getBytes();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 产生签名</span></span><br><span class="line"> String sign = RSACoder.sign(data, privateKey);</span><br><span class="line"> System.err.println(<span class="string">&quot;签名:\r&quot;</span> + sign);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 验证签名</span></span><br><span class="line"> <span class="keyword">boolean</span> status = RSACoder.verify(data, publicKey, sign);</span><br><span class="line"> System.err.println(<span class="string">&quot;状态:\r&quot;</span> + status);</span><br><span class="line"> assertTrue(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="生成钱包"><a href="#生成钱包" class="headerlink" title="生成钱包"></a>生成钱包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地生成公私钥对</span></span><br><span class="line">Map&lt;String, Object&gt; initKey = RSACoder.initKey();</span><br><span class="line">String publicKey = RSACoder.getPublicKey(initKey);</span><br><span class="line">String privateKey = RSACoder.getPrivateKey(initKey);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Wallet(publicKey, privateKey);</span><br></pre></td></tr></table></figure>



<h1 id="3-第3课：比特币的设计与实现"><a href="#3-第3课：比特币的设计与实现" class="headerlink" title="3 第3课：比特币的设计与实现"></a>3 第3课：比特币的设计与实现</h1><p>比特币交易UTXO<br>    - 交易输出</p>
<pre><code>- 交易输入
</code></pre>
<p>比特币余额</p>
<h2 id="3-1-比特币–UTXO"><a href="#3-1-比特币–UTXO" class="headerlink" title="3.1 比特币–UTXO"></a>3.1 比特币–UTXO</h2><ul>
<li>UTXO(unspent transaction output) - 未花费交易输出<ul>
<li>比特币拥有者的公钥锁定（加密）的一个数字</li>
<li>UTXO就是比特币，比特币系统中只有UTXO,没有比特币</li>
<li>新的UTXO由挖矿或交易产生</li>
</ul>
</li>
<li>UTXO存在全节点的数据库里</li>
<li>转账交易消耗自己的UTXO,同时生成新的UTXO,并用接受者的公钥锁定</li>
<li>比特币系统中用户的“余额”实际上并不直接存在，而是通过计算得来</li>
</ul>
<h3 id="3-2-比特币–交易模型"><a href="#3-2-比特币–交易模型" class="headerlink" title="3.2 比特币–交易模型"></a>3.2 比特币–交易模型</h3><ul>
<li>交易输出（UTXO）<ul>
<li>锁定的比特币数量</li>
<li>锁定脚本（用接收者的公钥哈希）</li>
</ul>
</li>
<li>交易输入（UTXO+解锁脚本）<ul>
<li>解锁脚本（发送者的签名和公钥）</li>
</ul>
</li>
<li>签名–对发送者和接收者的公钥哈希以及整个交易签名</li>
</ul>
<p><img src="_v_images/2019-11-20-20-46-24.png"><br><img src="_v_images/2019-11-20-20-46-43.png"></p>
<h3 id="3-2-比特币–交易全流程"><a href="#3-2-比特币–交易全流程" class="headerlink" title="3.2 比特币–交易全流程"></a>3.2 比特币–交易全流程</h3><p><img src="_v_images/2019-11-20-20-47-01.png"></p>
<p>coinbase的系统交易，input为空。</p>
<h3 id="3-3-交易代码"><a href="#3-3-交易代码" class="headerlink" title="3.3 交易代码"></a>3.3 交易代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交易发起方</span></span><br><span class="line">Wallet walletSender = Wallet.generateWallet();</span><br><span class="line"><span class="comment">//交易接收方</span></span><br><span class="line">Wallet walletReciptent = Wallet.generateWallet();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TransactionInput txIn = <span class="keyword">new</span> TransactionInput(tx2.getId(), <span class="number">10</span>, <span class="keyword">null</span>, walletSender.getPublicKey());</span><br><span class="line">TransactionOutput txOut = <span class="keyword">new</span> TransactionOutput(<span class="number">10</span>, walletReciptent.getHashPubKey());</span><br><span class="line">Transaction tx3 = <span class="keyword">new</span> Transaction(CryptoUtil.UUID(), txIn , txOut);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//假定tx2之前已经被打包进区块，也就是已经被记录进账本了</span></span><br><span class="line">tx3.sign(walletSender.getPrivateKey(), tx2);</span><br><span class="line">txs.add(tx3);</span><br></pre></td></tr></table></figure>


<h3 id="3-4-签名代码"><a href="#3-4-签名代码" class="headerlink" title="3.4 签名代码"></a>3.4 签名代码</h3><p>对发送者和接收者的公钥哈希以及整个交易签名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用私钥生成交易签名</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prevTx</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sign</span><span class="params">(String privateKey, Transaction prevTx)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (coinbaseTx()) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!prevTx.getId().equals(txIn.getTxId())) &#123;</span><br><span class="line">  System.err.println(<span class="string">&quot;交易签名失败：当前交易输入引用的前一笔交易与传入的前一笔交易不匹配&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Transaction txClone = cloneTx();</span><br><span class="line"> txClone.getTxIn().setPublicKey(prevTx.getTxOut().getPublicKeyHash());</span><br><span class="line"> String sign = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  sign = RSACoder.sign(txClone.hash().getBytes(), privateKey);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> txIn.setSignature(sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成用于交易签名的交易记录副本</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Transaction <span class="title">cloneTx</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> TransactionInput transactionInput = <span class="keyword">new</span> TransactionInput(txIn.getTxId(), txIn.getValue(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"> TransactionOutput transactionOutput = <span class="keyword">new</span> TransactionOutput(txOut.getValue(), txOut.getPublicKeyHash());</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> Transaction(id, transactionInput, transactionOutput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%8C%BA%E5%9D%97%E9%93%BE/" data-id="ckqg285u6002vrcfpgahq1jnf" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/前后端分离开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.835Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1、前后端分离"><a href="#1、前后端分离" class="headerlink" title="1、前后端分离"></a>1、前后端分离</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul>
<li>需求明确，需求领先开发一个周期</li>
<li>有明确的设计，特别是接口设计，接口文档需要管理，可以采用软件，如swagger</li>
</ul>
<h2 id="公共组件"><a href="#公共组件" class="headerlink" title="公共组件"></a>公共组件</h2><ul>
<li>Mock Server支持</li>
<li>持续集成 + 单元测试（方便debug、回归测试）</li>
<li>公共业务接口（如：findById、查询接口可配置），接口遵循REST</li>
<li>接口转换层（easyui格式转换）</li>
</ul>
<h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><ul>
<li>web层权限控制（Freemarker标签？）</li>
<li>接口API权限控制</li>
<li>session管理</li>
<li>webpage框架（SpringMVC vs Ratpack vs NodeJS）</li>
<li>图片上传</li>
<li>前端校验</li>
<li>国际化</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>前后端重构更容易；后端引入单元测试后，质量有提升</li>
<li>前端更多自主权，页面可做更多个性化的设计</li>
</ul>
<h2 id="要注意的"><a href="#要注意的" class="headerlink" title="要注意的"></a>要注意的</h2><ul>
<li>前端人员须到位，后端人员可以减半</li>
<li>后端负责业务逻辑，前端负责View+Controller，校验、上传、权限等</li>
<li>API遵循Restful风格</li>
<li>前后须加强沟通，接口必有文档，可通过Mock Server模拟接口</li>
</ul>
<h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><ul>
<li>设计接口：前端参与UI设计，决定前后端开发协作模式及职责，前后端一起确定业务接口。</li>
<li>开发阶段：前后端并行开发，后端使用JUnit进行单元测试，前端使用Mock Server进行测试；开发过程中双方可以协商变动接口。</li>
<li>部署：前后端集成测试</li>
</ul>
<h2 id="Mock-Server"><a href="#Mock-Server" class="headerlink" title="Mock Server"></a>Mock Server</h2><p>根据接口文档自动生成假数据</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/dreamhead/moco">moco</a></li>
<li><a target="_blank" rel="noopener" href="http://wiremock.org/index.html">wiremock</a></li>
</ul>
<h2 id="接口管理"><a href="#接口管理" class="headerlink" title="接口管理"></a>接口管理</h2><p>加入json-schema规则，实现了对http请求的参数校验。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://rap.taobao.org/org/index.do">RAP</a></li>
<li><a target="_blank" rel="noopener" href="http://swagger.io/"> swagger </a>.</li>
</ul>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>用着一样的模版语言 XTemplate，一样的渲染引擎 JavaScript</p>
<p>在不同的渲染环境（Server-side、PC Browser、Mobile Browser、Web View、etc.）渲染出一样的结果。</p>
<h2 id="参考架构"><a href="#参考架构" class="headerlink" title="参考架构"></a>参考架构</h2><p>该解决方案，session，登录态什么的仍然是后端管理; 前端仍然只管理模板，只不过起了后台来管理模板；对后端来说，除了nginx配置改变几乎没有任何新的东西。</p>
<p><img src="_v_images/2019-11-29-17-53-12.png"></p>
<h2 id="技术储备"><a href="#技术储备" class="headerlink" title="技术储备"></a>技术储备</h2><ul>
<li>BigPipe</li>
</ul>
<h2 id="基于Thrift前后端分离Demo"><a href="#基于Thrift前后端分离Demo" class="headerlink" title="基于Thrift前后端分离Demo"></a>基于Thrift前后端分离Demo</h2><p>一个难点在于web 与 services 的数据交互。好在facebook开源的一个项目 <a target="_blank" rel="noopener" href="http://thrift.apache.org/">Thrift</a> 为我们解决了这个问题。<br>Demo中使用了Nodejs 的Express搭建web服务，使用 Thrift 生成 Node 的client和server的接口文件。</p>
<p><strong>Client</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  client = thrift.createClient(Calculator, connection);</span><br><span class="line"></span><br><span class="line">router.get( <span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    client.add( <span class="number">10</span>, <span class="number">100</span> )</span><br><span class="line">             .then( <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">                   res.render( <span class="string">&#x27;index&#x27;</span>, &#123; <span class="attr">title</span>: <span class="string">&#x27;Express + Thrift&#x27;</span>, <span class="attr">desc</span>: <span class="string">&#x27;：1+1=&#x27;</span>  + response &#125;);</span><br><span class="line">            &#125;);   </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* jade */</span>block content    h1= title    p Welcome to #&#123;title</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Server</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Nodejs server */</span>...var</span><br><span class="line">server = thrift.createServer(Calculator, &#123;</span><br><span class="line"> </span><br><span class="line"><span class="attr">add</span>: <span class="function"><span class="keyword">function</span> (<span class="params">n1, n2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span>  result = n1 + n2;</span><br><span class="line"><span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;localhost:9090&quot;</span> );</span><br><span class="line">server.listen( <span class="number">9090</span>);</span><br></pre></td></tr></table></figure>


<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/weivea/FE-separate">前后端分离想法的一些实践</a></li>
</ul>
<h1 id="2、Node-js-后端REST架构"><a href="#2、Node-js-后端REST架构" class="headerlink" title="2、Node.js+后端REST架构"></a>2、Node.js+后端REST架构</h1><h3 id="node-js不适合做全栈"><a href="#node-js不适合做全栈" class="headerlink" title="node.js不适合做全栈"></a>node.js不适合做全栈</h3><p>其实，没有哪个语言或框架适合做全栈，即使如Spring也不行（web层不轻量）。</p>
<p>node.js有一下缺陷：</p>
<ul>
<li>臭名昭著的异步回调。上8层的异步调用嵌套实在难读和难以维护。</li>
<li>javascript 的不严谨和 灵活性导致了程序在运行过程中很容易出现难以调试的Bug，而Bug的日志会让人摸不着头脑。</li>
<li> 完全异步化带来的另一个问题就是调试困难。</li>
<li> 没法直接发挥多核、多CPU的服务器的优势。</li>
<li>没有像Java一样的工程化体系、中间件、开源库。</li>
<li> 要真正以node来支撑开发一个电商平台对JS工程师的要求非常高，我觉得业内这样的人才依然相当难觅，上手容易不等于高级功能也容易。</li>
</ul>
<p>只作为web层 ：</p>
<ul>
<li> 如果你要做的是小型项目，或者逻辑非常简单的项目，可以选择Node.js，因为开发、调试都很很快。</li>
<li> 如果你要做的是逻辑简单，而并发大的项目，可以选择Node.js，它还是很适合左右游戏的聊天服务器，长连接消息推送服务器之类的项目的。</li>
<li> 在真正的重要的、大型的项目上请不要盲目，追求一些比如“语言层面的前后端统一”这样的议题，这是没有意义的。</li>
<li> paypal只是把web端开发从JSP切换成了node.js，系统平台里的该是什么还是什么。还有类似的例子就是Groupon，他们也用node重构了网页部分内容，沃尔玛亦然。</li>
</ul>
<p>结论：</p>
<ul>
<li>1、 如果能用Java做，就用Java做，参考淘宝网。</li>
<li>2、如果做大了需要升级用户体验，后端服务器接口化，前端服务器用Node.js替换，参考淘宝网前后端分离实践。</li>
<li>3、考虑到电商项目的失败率，项目有很大的可能走不到第二步，请先考虑第一步。</li>
<li>4、不是所有公司都像淘宝一样有大量的技术储备力量，去完成前后端分离，创业公司或不大的公司还是选择一种技术栈比较合适。</li>
</ul>
<p>PS:</p>
<ul>
<li>Web服务器端一直都存在两个阵营，以Java/C#为代表的工业设计语言和以PHP/RoR为代表的快速开发语言。前者一直牢牢地占据着企业应用开发市场，而后者则普遍认为更适合灵活多变的互联网，Node.JS显然是属于后者的。</li>
<li>   用 Java / JSP 来开发网站太过于重量过于繁琐了，不如 RoR / PHP 等动态脚本语言灵活快速。</li>
</ul>
<h2 id="Node-js-Web选型"><a href="#Node-js-Web选型" class="headerlink" title="Node.js Web选型"></a>Node.js Web选型</h2><p><strong>Sinatra-like</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://expressjs.com/">Express</a></li>
<li><a target="_blank" rel="noopener" href="http://koajs.cn/">koa.js</a></li>
<li><a target="_blank" rel="noopener" href="http://hapijs.com/">hapi</a></li>
</ul>
<p>koa.js比Express先进最重要的一点：koa.js在coroute上所做工作，引入yield，不再需要多层的异步调用嵌套。</p>
<p><strong>Rails-like</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://sailsjs.org/">sails</a></li>
</ul>
<p>sails在windows下安装需要python2.7， VC++2010的支持，太麻烦，我没有安装试用。</p>
<p><strong>Node.js渲染模板</strong><br>ICanHaz.js / mustache / hogan.js / Jade / Haml / /Slim / CoffeeKup / Markaby / ejs / eco 等</p>
<h2 id="使用node做web前端的好处"><a href="#使用node做web前端的好处" class="headerlink" title="使用node做web前端的好处"></a>使用node做web前端的好处</h2><ul>
<li>前后端分离是的业务层独立，更容易结合多种前端，如web和app。</li>
<li>如果可以用 JavaScript 来渲染页面，前端工程师就可以有更大的空间。</li>
<li>前端想要对页面进行重构优化的时候也不再需要打扰后端工程师，大家都可以更专注于自己的事情。</li>
</ul>
<h2 id="REST后端接口"><a href="#REST后端接口" class="headerlink" title="REST后端接口"></a>REST后端接口</h2><p>Java做后端优势：</p>
<ul>
<li> 熟悉 Java 的工程师很多，我们很容易找到需要的人。</li>
<li>Java 平台的性能已经的到多年的验证。</li>
<li>Java 平台上众多的第三方产品、类库无所不有。</li>
<li>基于 JVM 的动态/函数式语言也给了 Java 平台良好的扩展性。</li>
</ul>
<h1 id="3、基于dubbo的前后端分离"><a href="#3、基于dubbo的前后端分离" class="headerlink" title="3、基于dubbo的前后端分离"></a>3、基于dubbo的前后端分离</h1><p>基于dubbo的前后端分离分为两大类，一类是dubbo+阻塞前端WebServer，如dubbo+tomcat，dubbo+Apache PHP；另一类是duboo+异步非阻塞WebService，如：dubbo+nodejs， dubbo+ratpack。涉及到的前端WebServer有基于Java和非Java的，列举流行的几种说明：</p>
<h2 id="1-dubbo-nodejs"><a href="#1-dubbo-nodejs" class="headerlink" title="1. dubbo+nodejs"></a>1. dubbo+nodejs</h2><p>nodejs与dubbo服务通信有两种方式：Hessian, jsonrpc。Hessian协议dubbo原本就支持，而jsonrpc协议需要另外实现，不过万幸Github上已经有人做了。</p>
<h3 id="jsonrpc"><a href="#jsonrpc" class="headerlink" title="jsonrpc"></a>jsonrpc</h3><p><a target="_blank" rel="noopener" href="https://github.com/QianmiOpen/dubbo-rpc-jsonrpc"> QianmiOpen/ dubbo-rpc-jsonrpc</a><br><a target="_blank" rel="noopener" href="https://github.com/QianmiOpen/dubbo-node-client">QianmiOpen/dubbo-node-client</a></p>
<p><strong>另一个node-dubbo客户端：</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/hufeng/node-jsonrpc-dubbo">node-jsonrpc-dubbo</a>使用json-rpc协议，使node可以调用dubbo的服务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> client = <span class="built_in">require</span>(<span class="string">&#x27;./dubbo-client&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> provider = <span class="string">&#x27;com.ofpay.demo.api.UserProvider&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//简单的调用一个接口</span></span><br><span class="line">client.getProvider(provider, <span class="function"><span class="keyword">function</span>(<span class="params">err, userProvider</span>) </span>&#123;</span><br><span class="line">  err</span><br><span class="line">    ? <span class="built_in">console</span>.log(err)</span><br><span class="line">    : userProvider.queryAll(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;<span class="built_in">console</span>.log(err, data);&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//group version support</span></span><br><span class="line">client.getProvider(provider, <span class="string">&#x27;test1&#x27;</span>, <span class="string">&#x27;2.1&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, userProvider</span>) </span>&#123;</span><br><span class="line">  err</span><br><span class="line">    ? <span class="built_in">console</span>.log(err)</span><br><span class="line">    : userProvider.queryAll(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;<span class="built_in">console</span>.log(err, data);&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><p><a target="_blank" rel="noopener" href="http://shiyanjun.cn/archives/349.html">基于Dubbo的Hessian协议实现远程调用</a><br>[nodejs zookeper 客户端 通过hessian 与dubbo交互](</p>
<p><a target="_blank" rel="noopener" href="https://github.com/xuyan2680/node-java">https://github.com/xuyan2680/node-java</a>)</p>
<h2 id="2-dubbo-vert-x-web"><a href="#2-dubbo-vert-x-web" class="headerlink" title="2. dubbo+vert.x-web"></a>2. dubbo+vert.x-web</h2><p><a target="_blank" rel="noopener" href="http://vertx.io/docs/vertx-web/java/">Vert.x-Web</a></p>
<h2 id="3-dubbo-servlet"><a href="#3-dubbo-servlet" class="headerlink" title="3. dubbo+servlet"></a>3. dubbo+servlet</h2><h2 id="4-dubbo-ratpack"><a href="#4-dubbo-ratpack" class="headerlink" title="4. dubbo+ratpack"></a>4. dubbo+ratpack</h2><p>Ratpack is a set of Java libraries that facilitate fast, efficient, evolvable and well tested HTTP applications.</p>
<p>It is built on the highly performant and efficient Netty event-driven networking engine.</p>
<p>Ratpack focuses on allowing HTTP applications to be efficient, modular, adaptive to new requirements and technologies, and well-tested over time.</p>
<p>Ratpack可以使用Groovy和Java，运行与JVM上，调用dubbo服务很方便。</p>
<p>Ratpack的问题是服务器集群方案、负载均衡等没有现成案例。</p>
<h2 id="5-dubbo-python-php"><a href="#5-dubbo-python-php" class="headerlink" title="5. dubbo+python/php"></a>5. dubbo+python/php</h2><p>可以通过Hessian协议来调用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%BC%80%E5%8F%91/" data-id="ckqg285u6002urcfpcm3b9t1c" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/分布式服务框架" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.834Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1、服务的远程调用（RPC）产品"><a href="#1、服务的远程调用（RPC）产品" class="headerlink" title="1、服务的远程调用（RPC）产品"></a>1、服务的远程调用（RPC）产品</h3><ul>
<li>Google: gRPC （Protocol Buffers RPC）</li>
<li>Facebook: Thrift</li>
<li>Twitter: Finagle - dubbo</li>
<li>WebS ervices</li>
<li> hprose</li>
<li>commonRPC</li>
<li>spring http Invoker</li>
<li>RMI</li>
<li>EJB</li>
<li>ICE :  <a target="_blank" rel="noopener" href="http://zh.wikipedia.org/zh-cn/ICE_(%E4%B8%AD%E9%97%B4%E4%BB%B6)">ICE介绍</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/serialization-and-deserialization">序列化和反序列化</a> : 介绍了Corba/COM/XML/JSON/Protobuf/Thrift/Avro等方式。<br><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/news/2011/05/sl-data-exchange-protocol">孙立： 软件系统开发中的数据交换协议</a>  :  文中对各种数据交换协议进行了对比.<br><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/lp-java-remoting-1">Java Remoting远程服务（上）</a><br><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/lp-java-remoting-2"> Java Remoting远程服务（下） </a>: 介绍了RMI/EJB/ Web Service/ Hessian/ NIO(Mina/Netty)几个远程调用方式。</p>
<h3 id="2、服务的分布式调用链及服务状态跟踪统计"><a href="#2、服务的分布式调用链及服务状态跟踪统计" class="headerlink" title="2、服务的分布式调用链及服务状态跟踪统计"></a>2、服务的分布式调用链及服务状态跟踪统计</h3><ul>
<li>Google: Dapper</li>
<li>Twitter: zipkin</li>
</ul>
<h3 id="3、服务的配置管理。包括服务发现、负载均衡及服务依赖管理。"><a href="#3、服务的配置管理。包括服务发现、负载均衡及服务依赖管理。" class="headerlink" title="3、服务的配置管理。包括服务发现、负载均衡及服务依赖管理。"></a>3、服务的配置管理。包括服务发现、负载均衡及服务依赖管理。</h3><ul>
<li>ZooKeeper</li>
<li>serfdom</li>
<li>consui。</li>
</ul>
<h3 id="4、服务之间的调度及生命周期管理"><a href="#4、服务之间的调度及生命周期管理" class="headerlink" title="4、服务之间的调度及生命周期管理"></a>4、服务之间的调度及生命周期管理</h3><ul>
<li>Apache: Mesos</li>
<li> Apache:  YARN</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.useopen.net/blog/2015/rpc-performance.html">RPC框架性能基本比较测试</a>：比较了gRPC/Thrift/Wildfly EJB/Dubbo/ Redhat JBoss EAP的性能。<br><a target="_blank" rel="noopener" href="http://timyang.net/distributed/service-architecture/"> 分布式服务框架的4项特性 </a><br><a target="_blank" rel="noopener" href="http://my.oschina.net/u/1166271/blog/316686">RSF 分布式服务框架设计</a> ： 模拟淘宝的HSF设计？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/" data-id="ckqg285u5002srcfphy658ozt" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/初创公司构建数据分析平台" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.834Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>干货推荐：  <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/presentations/start-up-companies-build-data-analysis-platform">http://www.infoq.com/cn/presentations/start-up-companies-build-data-analysis-platform</a></p>
<p>[TOC]</p>
<h1 id="常用-数据分析解决方案（WHY）"><a href="#常用-数据分析解决方案（WHY）" class="headerlink" title="常用 数据分析解决方案（WHY）"></a>常用 数据分析解决方案（WHY）</h1><ol>
<li>第三方统计服务：Google Analytcs、友盟、百度统计<ul>
<li>好处<ul>
<li> 使用简单</li>
<li> 免费</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> -  不足
      - 无法与业务数据交叉分析
      - 分析能力较弱，无法覆盖深度分析
      - 指标无法自定义
      - 数据无法取回
      - 数据安全存在顾虑
</code></pre>
<ol start="2">
<li>业务数据库写SQL<ul>
<li>好处<ul>
<li>可根据需求灵活定制</li>
<li>数据准确、实时</li>
<li>可分析业务数据</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> - 不足
      - 历史状态被覆盖
     -  能力有限，无法水平扩展
      - 开发维护代价大
           - 需额外开发工作
           - 查询逻辑随着业务的演进复杂化，不好维护（SQL、脚本、结果数据）
           -  和业务数据无法解耦
           - 随分析需求增加字段、数据表
</code></pre>
<ol start="3">
<li>基于日志写统计脚本<ul>
<li>好处<ul>
<li> 与业务数据库解耦</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>-  不足
     -  开发效率低（2天/个，重复开发）
     -  准确性无法保证
     -  计算能力有限
     -  有技术门槛
           -  打好日志是一件很难的事情
          -  数据流难以管理
</code></pre>
<h1 id="数据分析平台的推荐方案（HOW）"><a href="#数据分析平台的推荐方案（HOW）" class="headerlink" title="数据分析平台的推荐方案（HOW）"></a>数据分析平台的推荐方案（HOW）</h1><p><img src="_v_images/2019-11-29-17-41-12.png"></p>
<h2 id="1、数据记录（采集）"><a href="#1、数据记录（采集）" class="headerlink" title="1、数据记录（采集）"></a>1、数据记录（采集）</h2><ul>
<li>生成高质量的源数据<ul>
<li> 全</li>
<li> 准</li>
</ul>
</li>
<li>数据类型<ul>
<li> 行为数据</li>
<li> 业务数据：用户、订单、库存</li>
</ul>
</li>
<li>数据规范<ul>
<li> 行为数据：操作系统、应用版本、是否WIFI、 屏幕尺寸、设备型号、商品ID、商品价格等。</li>
<li> 用户属性数据：性别、年龄、婚姻状况、注册 时间、收入级别、是否有小孩等。</li>
</ul>
</li>
</ul>
<p><img src="_v_images/2019-11-29-17-41-25.png"></p>
<ul>
<li>数据格式<ul>
<li> 非格式化文本 Vs. Json、Thrift、Protocol Buffer、Avro</li>
</ul>
</li>
<li>数据采集点<ul>
<li> 尽量在后端打</li>
<li> 前端打（压缩、加密、批量）</li>
</ul>
</li>
<li>数据落地<ul>
<li> 写网络</li>
<li> 写本地文件</li>
</ul>
</li>
</ul>
<h2 id="2、数据传输"><a href="#2、数据传输" class="headerlink" title="2、数据传输"></a>2、数据传输</h2><ul>
<li>需关注的问题<ul>
<li> 时效性（实时？批量？）</li>
<li> 可靠性（丢？重？）</li>
<li> 扩展性</li>
</ul>
</li>
</ul>
<ul>
<li>方案<ul>
<li> FTP</li>
<li> Kafka</li>
<li> Scribe、Flume</li>
</ul>
</li>
</ul>
<h2 id="3、数据建模-存储"><a href="#3、数据建模-存储" class="headerlink" title="3、数据建模/存储"></a>3、数据建模/存储</h2><ul>
<li>数据模型抽象<ul>
<li> Event：  Event Type + Properties + UserID</li>
<li> User Profile： UserID + Properties（年龄、所在地、Tag等）</li>
</ul>
</li>
<li>Event：记录所有的历史状态变更</li>
<li>ETL (Extract, Transform and Load)<ul>
<li> ID-Mapping</li>
<li> Merge</li>
<li> 批量 or 实时</li>
</ul>
</li>
</ul>
<ul>
<li>存储<ul>
<li> 单机文件</li>
<li> 关系型数据库（Mysql、Vertica、 Teradata）</li>
<li> Nosql (HBase、MongoDB)</li>
<li> HDFS</li>
</ul>
</li>
</ul>
<h2 id="4、数据统计-分析-挖掘"><a href="#4、数据统计-分析-挖掘" class="headerlink" title="4、数据统计/分析/挖掘"></a>4、数据统计/分析/挖掘</h2><ul>
<li><p> 批处理</p>
</li>
<li><p>交互式</p>
</li>
<li><p>OLAP (Online Analytical  Processing)</p>
<ul>
<li> 维度</li>
<li> 指标</li>
<li> 数据魔方</li>
</ul>
</li>
</ul>
<p><img src="_v_images/2019-11-29-17-41-40.png"></p>
<ul>
<li><p>分析模型</p>
<ul>
<li><p> 基于事件分析</p>
</li>
<li><p> 漏斗</p>
</li>
<li><p> 留存</p>
</li>
</ul>
</li>
</ul>
<h2 id="5、数据可视化-反馈"><a href="#5、数据可视化-反馈" class="headerlink" title="5、数据可视化/反馈"></a>5、数据可视化/反馈</h2><ul>
<li>展现方式</li>
<li>曲线</li>
<li>柱状图</li>
<li>饼状图</li>
<li>热力图</li>
<li>地域分布</li>
</ul>
<ul>
<li>可视化工具</li>
<li>OpenCharts</li>
<li>HighCharts</li>
<li>ECharts</li>
<li>Tableau Software</li>
<li>Oracle BIEE</li>
</ul>
<ul>
<li>数据分析的结果直接反馈到产品系统中，提升产品体验（BI只是数据分析的很小一部分）</li>
<li>反馈方式</li>
<li>推送</li>
<li>个性化推荐</li>
<li>风控</li>
<li>CRM集成</li>
</ul>
<h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p><img src="_v_images/2019-11-29-17-41-48.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/" data-id="ckqg285u5002trcfp61slenie" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/关于技术选型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.833Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><h4 id="1-选择流行的技术"><a href="#1-选择流行的技术" class="headerlink" title="1. 选择流行的技术"></a>1. 选择流行的技术</h4><p><strong>社区提供 各种扩展和插件 解决方案</strong>。流行的技术社区必大。一种技术用的人多了，就会碰到各种各样的问题，他们会把自己的解决方案提交到社区，这解决了很多人类似需求，不需要从头投入时间去研究。比如：Bootstrap的各种插件组件很丰富，特别是各种独特显示需求，大多数我们能在社区找到解决方案。再比如，绝大多数的Java技术都会支持Spring，为Spring提供各种扩展解决方案；选择Spring就是选择了一系列的解决方案，而不仅仅是Spring本身。</p>
<p><strong>架构考虑全面</strong>。流行的框架需要应对各种需求，必须全面设计好其架构，以保证其扩展性和稳定性等。比如：Spring架构是基于接口实现的，方便扩展定制其功能；而JFinal是基于类设计的，必须改动其源码才能扩展；为了使Freemaker支持多template的basePath（classpath和webappDir），JFinal需要重写FreemakerRender类，而Spring则不用修改其源码。</p>
<p><strong>流行的框架Bug少</strong>。想当年选择JSF、JBoss Seam、jBPM4时，那个Bug可真多，最终只能放弃。</p>
<p><strong>发展延续性</strong>。流行技术的发展和维护延续的时间会更长，不会搞个几年就没人维护了。</p>
<h4 id="2-同时选择两个相似的解决方案，那是浪费时间"><a href="#2-同时选择两个相似的解决方案，那是浪费时间" class="headerlink" title="2. 同时选择两个相似的解决方案，那是浪费时间"></a>2. 同时选择两个相似的解决方案，那是浪费时间</h4><p><strong>节约精力</strong>。选择一种技术或框架，是一种时间和精力的投入。如果对解决相同问题、功能相似的多个技术或框架同时学习，那是两法时间；比如：对于Web开发，可以选择Spring和JFinal，而它们的多数据源问题的处理方式是不一样的，我们需要对这两个框架同时研究，这种没有技术含量的东西，真心没必要同时研究两个。</p>
<p><strong>加强深度</strong>。可以选择一种技术或框架，从各种技术需求和业务需求出发，研究其解决方法。比如数据库访问可以选择基于JDBC方案和基于ORM框架（Hibernate），选择其中的一种，深入的研究其分库分表、缓存、读写分离怎么实现的。</p>
<p>** 积累**。选择一种技术长期投入时间和精力，遇到问题多，积累的知识多；长期使用一种技术，那么对其就更熟练。</p>
<h4 id="3-选择自己要用功能，避免纯净洁癖症"><a href="#3-选择自己要用功能，避免纯净洁癖症" class="headerlink" title="3. 选择自己要用功能，避免纯净洁癖症"></a>3. 选择自己要用功能，避免纯净洁癖症</h4><p>一种技术和框架往往包括内容挺多，而我们需要使用的功能很少。不要看到多余的内容就觉得碍眼，非要去找一个更纯粹纯净的解决方案，使用我们需要的功能即可。JVM对没有使用的类是不会实例化成对象放入内存中的，就是占点磁盘空间，体积大程序未必耗资源，体积小的程序未必不占资源，比如病毒木马等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/" data-id="ckqg285u5002rrcfpb6k814gy" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/优化网站加载速度的14个技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E7%9A%8414%E4%B8%AA%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.832Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>优化了加载速度的网站不仅可以提高其搜索引擎的排名，同时也可以降低网站的跳出率，提高其转换率，还能提供更好的终端用户体验，这是当今基于Web环境取得成功的关键。 </p>
<p>下面我将介绍几个优化网站加载网页速度的简单方法，一起来看一下。</p>
<p>1.服务器响应时间</p>
<p>即使网站已经格外优化，但是除非服务器响应时间非常快，否则就不会有什么大的效果。当涉及到提高网站的速度，服务器响应时间起着重要的作用。下面是一些提高服务器响应时间的小贴士。</p>
<p>有独立的服务器，而不是选择共享/托管服务器。<br>提高Web服务器的质量。<br>移除不必要的插件，只有那些必要的插件，才需要一直保持启用状态。</p>
<p>2.浏览器缓存</p>
<p>浏览器缓存可以减少HTTP请求，从而反过来提高网站的加载速度。下面就是如何利用浏览器缓存的代码示例：</p>
<p>Java代码<br><IfModule mod_expires.c><br>ExpiresActive On<br>ExpiresByType image/jpg  “access 1 year”<br>ExpiresByType image/jpeg  “access 1 year”<br>ExpiresByType image/gif  “access 1 year”<br>ExpiresByType image/png  “access 1 year”<br>ExpiresByType text/css  “access 1 month”<br>ExpiresByType text/html  “access 1 month”<br>ExpiresByType application/pdf  “access 1 month”<br>ExpiresByType text/x-javascript  “access 1 month”<br>ExpiresByType application/x-shockwave-flash  “access 1 month”<br>ExpiresByType image/x-icon  “access 1 year”<br>ExpiresDefault  “access 1 month”<br></IfModule><br><IfModule mod_expires.c><br>ExpiresActive On<br>ExpiresByType image/jpg “access 1 year”<br>ExpiresByType image/jpeg “access 1 year”<br>ExpiresByType image/gif “access 1 year”<br>ExpiresByType image/png “access 1 year”<br>ExpiresByType text/css “access 1 month”<br>ExpiresByType text/html “access 1 month”<br>ExpiresByType application/pdf “access 1 month”<br>ExpiresByType text/x-javascript “access 1 month”<br>ExpiresByType application/x-shockwave-flash “access 1 month”<br>ExpiresByType image/x-icon “access 1 year”<br>ExpiresDefault “access 1 month”<br></IfModule><br>注意：如果过期时间与文件挂钩，而此时文件中的内容需要更改的话，那必须先重命名文件，以便浏览器可以获取新添加的代码。</p>
<p>3.gzip压缩</p>
<p>gzip压缩是一个压缩实用程序，我们可以用它来快速加载网站。它的工作原理是在发送HTML和CSS文件到互联网浏览器之前，先压缩文件大小。允许mod_defalte模块启用Gzip压缩，下面是如何使用它的代码示例：</p>
<p>Java代码<br><IfModule mod_deflate.c>  </p>
<h1 id="Compress-HTML-CSS-JavaScript-Text-XML"><a href="#Compress-HTML-CSS-JavaScript-Text-XML" class="headerlink" title="Compress HTML, CSS, JavaScript, Text, XML"></a>Compress HTML, CSS, JavaScript, Text, XML</h1><p>AddOutputFilterByType DEFLATE application/javascript<br>AddOutputFilterByType DEFLATE application/xhtml+xml<br>AddOutputFilterByType DEFLATE application/xml<br>AddOutputFilterByType DEFLATE text/css<br>AddOutputFilterByType DEFLATE text/html<br>AddOutputFilterByType DEFLATE text/javascript<br>AddOutputFilterByType DEFLATE text/plain<br>AddOutputFilterByType DEFLATE text/xml  </p>
<h1 id="Remove-browser-bugs-only-needed-for-really-old-browsers"><a href="#Remove-browser-bugs-only-needed-for-really-old-browsers" class="headerlink" title="Remove browser bugs (only needed  for  really old browsers)"></a>Remove browser bugs (only needed  for  really old browsers)</h1><p>BrowserMatch ^Mozilla/ 4  gzip-only-text/html<br>BrowserMatch ^Mozilla/ 4 . 0 [ 678 ] no-gzip<br>BrowserMatch \bMSIE !no-gzip !gzip-only-text/html<br>Header append Vary User-Agent<br></IfModule><br><IfModule mod_deflate.c></p>
<h1 id="Compress-HTML-CSS-JavaScript-Text-XML-1"><a href="#Compress-HTML-CSS-JavaScript-Text-XML-1" class="headerlink" title="Compress HTML, CSS, JavaScript, Text, XML"></a>Compress HTML, CSS, JavaScript, Text, XML</h1><p>AddOutputFilterByType DEFLATE application/javascript<br>AddOutputFilterByType DEFLATE application/xhtml+xml<br>AddOutputFilterByType DEFLATE application/xml<br>AddOutputFilterByType DEFLATE text/css<br>AddOutputFilterByType DEFLATE text/html<br>AddOutputFilterByType DEFLATE text/javascript<br>AddOutputFilterByType DEFLATE text/plain<br>AddOutputFilterByType DEFLATE text/xml</p>
<h1 id="Remove-browser-bugs-only-needed-for-really-old-browsers-1"><a href="#Remove-browser-bugs-only-needed-for-really-old-browsers-1" class="headerlink" title="Remove browser bugs (only needed for really old browsers)"></a>Remove browser bugs (only needed for really old browsers)</h1><p>BrowserMatch ^Mozilla/4 gzip-only-text/html<br>BrowserMatch ^Mozilla/4.0[678] no-gzip<br>BrowserMatch \bMSIE !no-gzip !gzip-only-text/html<br>Header append Vary User-Agent<br></IfModule><br>4.异步脚本</p>
<p>还有一个可以提高网站页面速度的超棒选择就是异步加载脚本。如此一来网页负载就并不必依赖于这些异步脚本，网站访问者也不再需要不得不按捺下性子，等待所有的脚本加载完之后才能呈现页面。在异步模式中，脚本是在后台下载的。通常，我们会将第三方脚本作为异步脚本，因为下载这些脚本时常会让网站速度变得非常慢。</p>
<p>Css代码</p>
<script async src= "http://www.yoursite.com/script.js" ></script>  
<script async src="http://www.yoursite.com/script.js"></script>
<p>5.内容分发网络（CDN）</p>
<p>内容分发网络（CDN）是位于不同地理位置的服务器组成的网络。每个服务器都拥有所有网站的文件副本。要是有网站访问者请求文件和网页时，就可以直接从就近的网站服务器发送过来（也可以是从负载最小的服务器）。</p>
<p>6.优化JavaScript、HTML和CSS</p>
<p>优化JavaScript和CSS也可以提高一个网站的网页速度，而且这个方法非常简单。优化JavaScript、HTML和CSS就是删除所有不必要的空格和注释，从而减小文件大小。下面是一些最小化JavaScript和CSS的流行工具，非常有用。</p>
<p>CSS Minifier<br>Avivo<br>HTML Compressor</p>
<p>7.置于顶部的样式表和底部的脚本</p>
<p>将样式表放在顶部有助网站的迅速加载，因为这样可以使得网页渐进式呈现。一般地，所有的互联网浏览器都支持在给定时间内并行下载两个组件（图像、样式和脚本）。但是通常而言，霸道的脚本会在并行下载时会阻止其他的下载，直到脚本下载完毕。<br>8.避免阻塞型的JavaScript和CSS</p>
<p>在浏览器呈现网页之前，它首先需要通过解析HTML标记语言来构建一个DOM树。在此过程中，如果遇到了脚本，此过程就会中止，转而先执行脚本，完了才会继续原先的活动。因此建议避免阻塞型的JavaScript，尤其是外部脚本。</p>
<p>阻塞型JavaScript还会导致网站的延迟。所以不妨推迟加载那些不重要的JavaScript，或者采用异步加载的方式。另一种选择是将这些HTML代码内嵌到网站上，同时需要确保CSS的优化。</p>
<p>9.JavaScript的延迟解析</p>
<p>为了加载网页，浏览器必须解析所有的<script>标记内容，从而增加了网站的加载时间。通过延迟解析脚本，那么就可以减少初始网站的加载时间了。</p>
<p>10.启用Keep Alive</p>
<p>当用户通过浏览器请求网页时，浏览器首先需要访问HTML文件。然后它才能读取这些文件，并请求与其他资料相关联（此处的资料可以是CSS，JavaScript，也可以是任何相关的图像）。</p>
<p>如果“Keep Alive”选项被禁止，那么下载网站的进程通常就会增加，从而拖累了网站速度。启用KeepAlive的另一个好处是，它可以减少CPU的使用。</p>
<p>引用<br>语法: KeepAlive On<br>11.图像和文件格式</p>
<p>图像对于任何网站都非常有价值，因为它能传达一些强有力的信息给网站的访问者。最常见的图像格式是GIF、JPEG、PNG等。每种格式都有其长处和局限。建议使用JPEG格式，而不是GIF和PNG图像，除非图像包含Alpha因子或者是透明的。<br>12.优化代码：不使用内联CSS</p>
<p>内联了样式就不能清清楚楚地将内容从设计中剥离开来。同时可能还会需要大量的维护工作，给网站管理员带来各种不便，还会进一步增加网页的大小。</p>
<p>13.文件分离</p>
<p>网站的文件可以分为CSS、JavaScripts和图像。文件分离虽然并不能直接改善网站的加载时间。但是，这么做可以提高服务器的稳定性，特别是当网站流量突然出现了尖峰的时候。子域也可以用于托管文件，这样可以增加并行下载的数量。</p>
<p>14.尽量减少HTTP请求</p>
<p>还有一种简单的优化网页速度的方法是，减少HTTP请求。当一个网站一下子收到太多的HTTP请求，它的访客就会有响应时间延迟的体验，这不仅增加了CPU使用率也增加了页面的加载时间。那么，又该如何减少HTTP请求？请见以下步骤。</p>
<p>减少网站上的对象数量；<br>最小化网站上的重定向数量；<br>使用CSS Sprites技术（只要你需要的那部分图片内容）；<br>结合JavaScripts和CSS。</p>
<p>上述建议已被证明在优化网站的页面加载速度上非常有效。总之，炫彩夺目的图形，有趣的内容和更好的导航可以帮助你获得更多的网站访问者，但更快的网页加载速度则能帮助你留住他们。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E7%9A%8414%E4%B8%AA%E6%8A%80%E5%B7%A7/" data-id="ckqg285u4002qrcfp8dytcyy9" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/二叉树建立与遍历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.831Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>算法原理 ：</p>
<p>//先定义数据类型<br>typedef struct BiTNode{<br>  char data;   //data你想用什么类型自己变就行了<br> struct BiTNode *lchild,*rchild;<br>} BiTNode,*BiTree;</p>
<p>//建树也用递归<br>void createTree( char data,BiTree &amp;T)//用引用<br>{<br>  char c;<br> c = getchar();</p>
<p>  if (c!=NULL){<br>    T = (BiTree)malloc(sizeof(BiTNode);<br>    T-&gt;data = c;<br>    createTree(data,lchild);<br>  createTree(data,rchild);<br> } else {<br>    T=NULL;<br> }<br>}//这是先序建树，中序和后序只是变变顺序</p>
<p>//遍历，这是后序，也是递归<br>void traverse(BiTree T)<br>{<br>  if (T){<br>    traverse(T-&gt;lchild);<br>    traverse(T-&gt;rchild);<br>    printf(T-&gt;data);<br> }<br>}//还是那样，先序和中序变一变这三句的顺序就行。</p>
<p>下面是c语言的代码：</p>
<p>#include &lt;stddef.h&gt;<br>#include &lt;stdio.h&gt;</p>
<p>typedef struct tree {<br> struct tree *left;<br>  int date;<br> struct tree *right;<br>}<br>treenode,*b_tree;</p>
<p>///////插入节点/////////////////////<br>b_tree insert(b_tree root, int node) {<br> b_tree newnode;<br> b_tree currentnode;<br> b_tree parentnode;</p>
<p> newnode=(b_tree)malloc(sizeof(treenode));<br> newnode-&gt;date=node;<br> newnode-&gt;right=NULL;<br> newnode-&gt;left=NULL;</p>
<p>  if (root==NULL)   return newnode;<br>  else {<br>   currentnode=root;<br>    while (currentnode!=NULL)  {<br>     parentnode=currentnode;<br>      if (currentnode-&gt;date&gt;node)   currentnode=currentnode-&gt;left;<br>      else<br>       currentnode=currentnode-&gt;right;<br>   }</p>
<pre><code>if (parentnode-&gt;date&gt;node)  parentnode-&gt;left=newnode;
else   parentnode-&gt;right=newnode;
</code></pre>
<p> }<br>  return root;<br>}</p>
<p>//////建立树///////////////////<br>b_tree create( int *date, int len) {<br> b_tree root=NULL;<br>  int i;<br>  for (i=0;i&lt;len;i++)   root=insert(root,date[i]);<br>  return root;<br>}</p>
<p>//////中序打印////////////////<br>void print1(b_tree root) {<br>  if (root!=NULL) {<br>   print1(root-&gt;left);<br>   printf(“%d-&gt;”,root-&gt;date);<br>   print1(root-&gt;right);<br> }<br>}</p>
<p>//////后序打印////////////////<br>void print2(b_tree root) {<br>  if (root!=NULL)  {<br>   print2(root-&gt;left);<br>   print2(root-&gt;right);<br>   printf(“%d-&gt;”,root-&gt;date);<br> }<br>}</p>
<p>//////前序打印////////////////<br>void print3(b_tree root) {<br>  if (root!=NULL)  {<br>   printf(“%d-&gt;”,root-&gt;date);<br>   print3(root-&gt;left);<br>   print3(root-&gt;right);<br> }<br>}</p>
<p>//////////在二叉树中查找给定关键字 ////////////<br>b_tree lookfor(b_tree root, int e) {<br> b_tree p1,p2;<br>  if (root!=NULL)  {<br>    if (root-&gt;date==e)   return root;<br>    else<br>     p1=lookfor(root-&gt;left,e);</p>
<p>   p2=lookfor(root-&gt;right,e);</p>
<pre><code>if (p1!=NULL)    return p1;
else   if (p2!=NULL)    return p2;
else   return NULL;
</code></pre>
<p> }<br>  else return NULL;<br>}</p>
<p>main (){<br>  int arr[] = {1,2,3,4,5,6,7,8};<br> b_tree bt = create(arr,sizeof(arr)/sizeof(arr[0]));<br> print1(bt);printf(“\n”);<br> print2(bt);printf(“\n”);<br> print3(bt);printf(“\n”);<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86/" data-id="ckqg285u4002prcfpg11h7g3t" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/《构建高可用Linux服务器（第4版）》" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E3%80%8A%E6%9E%84%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89%E3%80%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.830Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="第1章-Linux服务器的性能调优1"><a href="#第1章-Linux服务器的性能调优1" class="headerlink" title="第1章　Linux服务器的性能调优1"></a>第1章　Linux服务器的性能调优1</h1><h2 id="1-1-网站架构设计相关1"><a href="#1-1-网站架构设计相关1" class="headerlink" title="1.1 网站架构设计相关1"></a>1.1 网站架构设计相关1</h2><h3 id="1-1-1-评估网站性能涉及的专业名词术语1"><a href="#1-1-1-评估网站性能涉及的专业名词术语1" class="headerlink" title="1.1.1 评估网站性能涉及的专业名词术语1"></a>1.1.1 评估网站性能涉及的专业名词术语1</h3><h3 id="1-1-2-CDN业务的选项2"><a href="#1-1-2-CDN业务的选项2" class="headerlink" title="1.1.2 CDN业务的选项2"></a>1.1.2 CDN业务的选项2</h3><h3 id="1-1-3-IDC机房的选择3"><a href="#1-1-3-IDC机房的选择3" class="headerlink" title="1.1.3 IDC机房的选择3"></a>1.1.3 IDC机房的选择3</h3><h2 id="1-2-如何根据服务器应用来选购服务器-4"><a href="#1-2-如何根据服务器应用来选购服务器-4" class="headerlink" title="1.2 如何根据服务器应用来选购服务器 4"></a>1.2 如何根据服务器应用来选购服务器 4</h2><h2 id="1-3-硬件对Linux性能的影响9"><a href="#1-3-硬件对Linux性能的影响9" class="headerlink" title="1.3 硬件对Linux性能的影响9"></a>1.3 硬件对Linux性能的影响9</h2><h2 id="1-4-CentOS-6-8-x86-64最小化安装后的优化11"><a href="#1-4-CentOS-6-8-x86-64最小化安装后的优化11" class="headerlink" title="1.4 CentOS 6.8 x86_64最小化安装后的优化11"></a>1.4 CentOS 6.8 x86_64最小化安装后的优化11</h2><h3 id="1-4-1-系统的基础优化11"><a href="#1-4-1-系统的基础优化11" class="headerlink" title="1.4.1 系统的基础优化11"></a>1.4.1 系统的基础优化11</h3><h3 id="1-4-2-优化Linux下的内核TCP参数以提高系统性能19"><a href="#1-4-2-优化Linux下的内核TCP参数以提高系统性能19" class="headerlink" title="1.4.2 优化Linux下的内核TCP参数以提高系统性能19"></a>1.4.2 优化Linux下的内核TCP参数以提高系统性能19</h3><h3 id="1-4-3-CentOS-6-8-x86-64系统最小化安装优化脚本21"><a href="#1-4-3-CentOS-6-8-x86-64系统最小化安装优化脚本21" class="headerlink" title="1.4.3 CentOS 6.8 x86_64系统最小化安装优化脚本21"></a>1.4.3 CentOS 6.8 x86_64系统最小化安装优化脚本21</h3><h3 id="1-4-4-Linux下CPU使用率与机器负载的关系与区别23"><a href="#1-4-4-Linux下CPU使用率与机器负载的关系与区别23" class="headerlink" title="1.4.4 Linux下CPU使用率与机器负载的关系与区别23"></a>1.4.4 Linux下CPU使用率与机器负载的关系与区别23</h3><h2 id="1-5-服务器调优实际案例25"><a href="#1-5-服务器调优实际案例25" class="headerlink" title="1.5 服务器调优实际案例25"></a>1.5 服务器调优实际案例25</h2><h2 id="1-6-小结28"><a href="#1-6-小结28" class="headerlink" title="1.6 小结28"></a>1.6 小结28</h2><h1 id="第2章-Shell脚本在生产环境下的应用29"><a href="#第2章-Shell脚本在生产环境下的应用29" class="headerlink" title="第2章　Shell脚本在生产环境下的应用29"></a>第2章　Shell脚本在生产环境下的应用29</h1><h2 id="2-1-Shell编程基础29"><a href="#2-1-Shell编程基础29" class="headerlink" title="2.1 Shell编程基础29"></a>2.1 Shell编程基础29</h2><h3 id="2-1-1-Shell脚本基本元素30"><a href="#2-1-1-Shell脚本基本元素30" class="headerlink" title="2.1.1 Shell脚本基本元素30"></a>2.1.1 Shell脚本基本元素30</h3><h3 id="2-1-2-Shell基础正则表达式30"><a href="#2-1-2-Shell基础正则表达式30" class="headerlink" title="2.1.2 Shell基础正则表达式30"></a>2.1.2 Shell基础正则表达式30</h3><h3 id="2-1-3-Shell特殊字符32"><a href="#2-1-3-Shell特殊字符32" class="headerlink" title="2.1.3 Shell特殊字符32"></a>2.1.3 Shell特殊字符32</h3><h3 id="2-1-4-变量和运算符33"><a href="#2-1-4-变量和运算符33" class="headerlink" title="2.1.4 变量和运算符33"></a>2.1.4 变量和运算符33</h3><h2 id="2-2-Shell中控制流结构45"><a href="#2-2-Shell中控制流结构45" class="headerlink" title="2.2 Shell中控制流结构45"></a>2.2 Shell中控制流结构45</h2><h2 id="2-3-Sed的基础用法及实用举例48"><a href="#2-3-Sed的基础用法及实用举例48" class="headerlink" title="2.3 Sed的基础用法及实用举例48"></a>2.3 Sed的基础用法及实用举例48</h2><h3 id="2-3-1-Sed的基础语法格式48"><a href="#2-3-1-Sed的基础语法格式48" class="headerlink" title="2.3.1 Sed的基础语法格式48"></a>2.3.1 Sed的基础语法格式48</h3><h3 id="2-3-2-Sed的用法举例说明53"><a href="#2-3-2-Sed的用法举例说明53" class="headerlink" title="2.3.2 Sed的用法举例说明53"></a>2.3.2 Sed的用法举例说明53</h3><h2 id="2-4-awk的基础用法及实用举例56"><a href="#2-4-awk的基础用法及实用举例56" class="headerlink" title="2.4 awk的基础用法及实用举例56"></a>2.4 awk的基础用法及实用举例56</h2><h2 id="2-5-Shell基础正则表达式举例61"><a href="#2-5-Shell基础正则表达式举例61" class="headerlink" title="2.5 Shell基础正则表达式举例61"></a>2.5 Shell基础正则表达式举例61</h2><h2 id="2-6-Shell开发中应该掌握的系统知识点68"><a href="#2-6-Shell开发中应该掌握的系统知识点68" class="headerlink" title="2.6 Shell开发中应该掌握的系统知识点68"></a>2.6 Shell开发中应该掌握的系统知识点68</h2><h2 id="2-7-生产环境下的Shell脚本74"><a href="#2-7-生产环境下的Shell脚本74" class="headerlink" title="2.7 生产环境下的Shell脚本74"></a>2.7 生产环境下的Shell脚本74</h2><h3 id="2-7-1-Amazon-Linux系统简介74"><a href="#2-7-1-Amazon-Linux系统简介74" class="headerlink" title="2.7.1 Amazon Linux系统简介74"></a>2.7.1 Amazon Linux系统简介74</h3><h3 id="2-7-2-生产环境下的备份类脚本75"><a href="#2-7-2-生产环境下的备份类脚本75" class="headerlink" title="2.7.2 生产环境下的备份类脚本75"></a>2.7.2 生产环境下的备份类脚本75</h3><h3 id="2-7-3-生产环境下的监控类脚本78"><a href="#2-7-3-生产环境下的监控类脚本78" class="headerlink" title="2.7.3 生产环境下的监控类脚本78"></a>2.7.3 生产环境下的监控类脚本78</h3><h3 id="2-7-4-生产环境下的运维开发类脚本84"><a href="#2-7-4-生产环境下的运维开发类脚本84" class="headerlink" title="2.7.4 生产环境下的运维开发类脚本84"></a>2.7.4 生产环境下的运维开发类脚本84</h3><h2 id="2-8-小结88"><a href="#2-8-小结88" class="headerlink" title="2.8 小结88"></a>2.8 小结88</h2><h1 id="第3章-利用Vagrant搭建分布式环境89"><a href="#第3章-利用Vagrant搭建分布式环境89" class="headerlink" title="第3章　利用Vagrant搭建分布式环境89"></a>第3章　利用Vagrant搭建分布式环境89</h1><h2 id="3-1-Vagrant简单介绍89"><a href="#3-1-Vagrant简单介绍89" class="headerlink" title="3.1 Vagrant简单介绍89"></a>3.1 Vagrant简单介绍89</h2><h2 id="3-2-Vagrant安装90"><a href="#3-2-Vagrant安装90" class="headerlink" title="3.2 Vagrant安装90"></a>3.2 Vagrant安装90</h2><h2 id="3-3-使用Vagrant配置本地开发环境91"><a href="#3-3-使用Vagrant配置本地开发环境91" class="headerlink" title="3.3 使用Vagrant配置本地开发环境91"></a>3.3 使用Vagrant配置本地开发环境91</h2><h3 id="3-3-1-Vagrant的具体安装步骤91"><a href="#3-3-1-Vagrant的具体安装步骤91" class="headerlink" title="3.3.1 Vagrant的具体安装步骤91"></a>3.3.1 Vagrant的具体安装步骤91</h3><h3 id="3-3-2-Vagrant配置文件详解93"><a href="#3-3-2-Vagrant配置文件详解93" class="headerlink" title="3.3.2 Vagrant配置文件详解93"></a>3.3.2 Vagrant配置文件详解93</h3><h3 id="3-3-3-Vagrant常用命令详解95"><a href="#3-3-3-Vagrant常用命令详解95" class="headerlink" title="3.3.3 Vagrant常用命令详解95"></a>3.3.3 Vagrant常用命令详解95</h3><h2 id="3-4-使用Vagrant搭建分布式环境96"><a href="#3-4-使用Vagrant搭建分布式环境96" class="headerlink" title="3.4 使用Vagrant搭建分布式环境96"></a>3.4 使用Vagrant搭建分布式环境96</h2><h2 id="3-5-小结99"><a href="#3-5-小结99" class="headerlink" title="3.5 小结99"></a>3.5 小结99</h2><h1 id="第4章-轻量级自动化运维工具介绍100"><a href="#第4章-轻量级自动化运维工具介绍100" class="headerlink" title="第4章　轻量级自动化运维工具介绍100"></a>第4章　轻量级自动化运维工具介绍100</h1><h2 id="4-1-轻量级自动化运维工具pssh介绍101"><a href="#4-1-轻量级自动化运维工具pssh介绍101" class="headerlink" title="4.1 轻量级自动化运维工具pssh介绍101"></a>4.1 轻量级自动化运维工具pssh介绍101</h2><h3 id="4-1-1-pssh的安装103"><a href="#4-1-1-pssh的安装103" class="headerlink" title="4.1.1 pssh的安装103"></a>4.1.1 pssh的安装103</h3><h3 id="4-1-2-pssh的使用103"><a href="#4-1-2-pssh的使用103" class="headerlink" title="4.1.2 pssh的使用103"></a>4.1.2 pssh的使用103</h3><h2 id="4-2-轻量级自动化运维工具Fabric介绍105"><a href="#4-2-轻量级自动化运维工具Fabric介绍105" class="headerlink" title="4.2 轻量级自动化运维工具Fabric介绍105"></a>4.2 轻量级自动化运维工具Fabric介绍105</h2><h3 id="4-2-1-Fabric的安装105"><a href="#4-2-1-Fabric的安装105" class="headerlink" title="4.2.1 Fabric的安装105"></a>4.2.1 Fabric的安装105</h3><h3 id="4-2-2-Fabric的命令行入口fab命令详细介绍107"><a href="#4-2-2-Fabric的命令行入口fab命令详细介绍107" class="headerlink" title="4.2.2 Fabric的命令行入口fab命令详细介绍107"></a>4.2.2 Fabric的命令行入口fab命令详细介绍107</h3><h3 id="4-2-3-Fabric的环境变量设置108"><a href="#4-2-3-Fabric的环境变量设置108" class="headerlink" title="4.2.3 Fabric的环境变量设置108"></a>4.2.3 Fabric的环境变量设置108</h3><h3 id="4-2-4-Fabric的核心API109"><a href="#4-2-4-Fabric的核心API109" class="headerlink" title="4.2.4 Fabric的核心API109"></a>4.2.4 Fabric的核心API109</h3><h3 id="4-2-5-Fabric的执行逻辑112"><a href="#4-2-5-Fabric的执行逻辑112" class="headerlink" title="4.2.5 Fabric的执行逻辑112"></a>4.2.5 Fabric的执行逻辑112</h3><h3 id="4-2-6-如何利用进程池大小来限制Fabric并发进程数114"><a href="#4-2-6-如何利用进程池大小来限制Fabric并发进程数114" class="headerlink" title="4.2.6 如何利用进程池大小来限制Fabric并发进程数114"></a>4.2.6 如何利用进程池大小来限制Fabric并发进程数114</h3><h2 id="4-3-Fabric在工作中应用实例114"><a href="#4-3-Fabric在工作中应用实例114" class="headerlink" title="4.3 Fabric在工作中应用实例114"></a>4.3 Fabric在工作中应用实例114</h2><h3 id="4-3-1-开发环境中Fabric应用实例115"><a href="#4-3-1-开发环境中Fabric应用实例115" class="headerlink" title="4.3.1 开发环境中Fabric应用实例115"></a>4.3.1 开发环境中Fabric应用实例115</h3><h3 id="4-3-2-工作场景中常见的Fabric应用实例116"><a href="#4-3-2-工作场景中常见的Fabric应用实例116" class="headerlink" title="4.3.2 工作场景中常见的Fabric应用实例116"></a>4.3.2 工作场景中常见的Fabric应用实例116</h3><h2 id="4-4-小结120"><a href="#4-4-小结120" class="headerlink" title="4.4 小结120"></a>4.4 小结120</h2><h1 id="第5章-Linux集群及其项目案例分享121"><a href="#第5章-Linux集群及其项目案例分享121" class="headerlink" title="第5章　Linux集群及其项目案例分享121"></a>第5章　Linux集群及其项目案例分享121</h1><h2 id="5-1-负载均衡高可用核心概念及常用软件121"><a href="#5-1-负载均衡高可用核心概念及常用软件121" class="headerlink" title="5.1 负载均衡高可用核心概念及常用软件121"></a>5.1 负载均衡高可用核心概念及常用软件121</h2><h3 id="5-1-1-什么是负载均衡高可用121"><a href="#5-1-1-什么是负载均衡高可用121" class="headerlink" title="5.1.1 什么是负载均衡高可用121"></a>5.1.1 什么是负载均衡高可用121</h3><h3 id="5-1-2-以F5-BIG-IP作为负载均衡器122"><a href="#5-1-2-以F5-BIG-IP作为负载均衡器122" class="headerlink" title="5.1.2 以F5 BIG-IP作为负载均衡器122"></a>5.1.2 以F5 BIG-IP作为负载均衡器122</h3><h3 id="5-1-3-以LVS作为负载均衡器123"><a href="#5-1-3-以LVS作为负载均衡器123" class="headerlink" title="5.1.3 以LVS作为负载均衡器123"></a>5.1.3 以LVS作为负载均衡器123</h3><h3 id="5-1-4-以Nginx作为负载均衡器132"><a href="#5-1-4-以Nginx作为负载均衡器132" class="headerlink" title="5.1.4 以Nginx作为负载均衡器132"></a>5.1.4 以Nginx作为负载均衡器132</h3><h3 id="5-1-5-以HAProxy作为负载均衡器132"><a href="#5-1-5-以HAProxy作为负载均衡器132" class="headerlink" title="5.1.5 以HAProxy作为负载均衡器132"></a>5.1.5 以HAProxy作为负载均衡器132</h3><h3 id="5-1-6-高可用软件Keepalived134"><a href="#5-1-6-高可用软件Keepalived134" class="headerlink" title="5.1.6 高可用软件Keepalived134"></a>5.1.6 高可用软件Keepalived134</h3><h3 id="5-1-7-高可用软件Heartbeat134"><a href="#5-1-7-高可用软件Heartbeat134" class="headerlink" title="5.1.7 高可用软件Heartbeat134"></a>5.1.7 高可用软件Heartbeat134</h3><h3 id="5-1-8-高可用块设备DRBD135"><a href="#5-1-8-高可用块设备DRBD135" class="headerlink" title="5.1.8 高可用块设备DRBD135"></a>5.1.8 高可用块设备DRBD135</h3><h2 id="5-2-负载均衡关键技术136"><a href="#5-2-负载均衡关键技术136" class="headerlink" title="5.2 负载均衡关键技术136"></a>5.2 负载均衡关键技术136</h2><h3 id="5-2-1-什么是Session136"><a href="#5-2-1-什么是Session136" class="headerlink" title="5.2.1 什么是Session136"></a>5.2.1 什么是Session136</h3><h3 id="5-2-2-什么是Session共享136"><a href="#5-2-2-什么是Session共享136" class="headerlink" title="5.2.2 什么是Session共享136"></a>5.2.2 什么是Session共享136</h3><h3 id="5-2-3-什么是会话保持137"><a href="#5-2-3-什么是会话保持137" class="headerlink" title="5.2.3 什么是会话保持137"></a>5.2.3 什么是会话保持137</h3><h2 id="5-3-负载均衡器的会话保持机制138"><a href="#5-3-负载均衡器的会话保持机制138" class="headerlink" title="5.3 负载均衡器的会话保持机制138"></a>5.3 负载均衡器的会话保持机制138</h2><h3 id="5-3-1-LVS的会话保持机制138"><a href="#5-3-1-LVS的会话保持机制138" class="headerlink" title="5.3.1 LVS的会话保持机制138"></a>5.3.1 LVS的会话保持机制138</h3><h3 id="5-3-2-Nginx负载均衡器中的ip-hash算法142"><a href="#5-3-2-Nginx负载均衡器中的ip-hash算法142" class="headerlink" title="5.3.2 Nginx负载均衡器中的ip_hash算法142"></a>5.3.2 Nginx负载均衡器中的ip_hash算法142</h3><h3 id="5-3-3-HAProxy负载均衡器的source算法145"><a href="#5-3-3-HAProxy负载均衡器的source算法145" class="headerlink" title="5.3.3 HAProxy负载均衡器的source算法145"></a>5.3.3 HAProxy负载均衡器的source算法145</h3><h2 id="5-4-服务器健康检测150"><a href="#5-4-服务器健康检测150" class="headerlink" title="5.4 服务器健康检测150"></a>5.4 服务器健康检测150</h2><h2 id="5-5-Linux集群的项目案例分享151"><a href="#5-5-Linux集群的项目案例分享151" class="headerlink" title="5.5 Linux集群的项目案例分享151"></a>5.5 Linux集群的项目案例分享151</h2><h3 id="5-5-1-用LVS-Keepalived建高可用集群151"><a href="#5-5-1-用LVS-Keepalived建高可用集群151" class="headerlink" title="5.5.1 用LVS+Keepalived建高可用集群151"></a>5.5.1 用LVS+Keepalived建高可用集群151</h3><h3 id="5-5-2-用Nginx-Keepalived实现在线票务系统154"><a href="#5-5-2-用Nginx-Keepalived实现在线票务系统154" class="headerlink" title="5.5.2 用Nginx+Keepalived实现在线票务系统154"></a>5.5.2 用Nginx+Keepalived实现在线票务系统154</h3><h3 id="5-5-3-企业级Web负载均衡高可用之Nginx-Keepalived157"><a href="#5-5-3-企业级Web负载均衡高可用之Nginx-Keepalived157" class="headerlink" title="5.5.3 企业级Web负载均衡高可用之Nginx+Keepalived157"></a>5.5.3 企业级Web负载均衡高可用之Nginx+Keepalived157</h3><h3 id="5-5-4-HAProxy双机高可用方案之HAProxy-Keepalived169"><a href="#5-5-4-HAProxy双机高可用方案之HAProxy-Keepalived169" class="headerlink" title="5.5.4 HAProxy双机高可用方案之HAProxy+Keepalived169"></a>5.5.4 HAProxy双机高可用方案之HAProxy+Keepalived169</h3><h3 id="5-5-5-巧用DNS轮询作负载均衡179"><a href="#5-5-5-巧用DNS轮询作负载均衡179" class="headerlink" title="5.5.5 巧用DNS轮询作负载均衡179"></a>5.5.5 巧用DNS轮询作负载均衡179</h3><h3 id="5-5-6-百万级PV高可用网站架构设计184"><a href="#5-5-6-百万级PV高可用网站架构设计184" class="headerlink" title="5.5.6 百万级PV高可用网站架构设计184"></a>5.5.6 百万级PV高可用网站架构设计184</h3><h3 id="5-5-7-千万级PV高性能高并发网站架构设计187"><a href="#5-5-7-千万级PV高性能高并发网站架构设计187" class="headerlink" title="5.5.7 千万级PV高性能高并发网站架构设计187"></a>5.5.7 千万级PV高性能高并发网站架构设计187</h3><h2 id="5-6-软件级负载均衡器的特点介绍与对比193"><a href="#5-6-软件级负载均衡器的特点介绍与对比193" class="headerlink" title="5.6 软件级负载均衡器的特点介绍与对比193"></a>5.6 软件级负载均衡器的特点介绍与对比193</h2><h2 id="5-7-四层负载均衡和七层负载均衡工作流程的对比194"><a href="#5-7-四层负载均衡和七层负载均衡工作流程的对比194" class="headerlink" title="5.7 四层负载均衡和七层负载均衡工作流程的对比194"></a>5.7 四层负载均衡和七层负载均衡工作流程的对比194</h2><h2 id="5-8-Linux集群的总结和思考196"><a href="#5-8-Linux集群的总结和思考196" class="headerlink" title="5.8 Linux集群的总结和思考196"></a>5.8 Linux集群的总结和思考196</h2><h2 id="5-9-小结198"><a href="#5-9-小结198" class="headerlink" title="5.9 小结198"></a>5.9 小结198</h2><h1 id="第6章-MySQL性能调优及高可用案例分享200"><a href="#第6章-MySQL性能调优及高可用案例分享200" class="headerlink" title="第6章　MySQL性能调优及高可用案例分享200"></a>第6章　MySQL性能调优及高可用案例分享200</h1><h2 id="6-1-MySQL数据库的优化200"><a href="#6-1-MySQL数据库的优化200" class="headerlink" title="6.1 MySQL数据库的优化200"></a>6.1 MySQL数据库的优化200</h2><h3 id="6-1-1-服务器物理硬件的优化200"><a href="#6-1-1-服务器物理硬件的优化200" class="headerlink" title="6.1.1 服务器物理硬件的优化200"></a>6.1.1 服务器物理硬件的优化200</h3><h3 id="6-1-2-MySQL配置文件的优化201"><a href="#6-1-2-MySQL配置文件的优化201" class="headerlink" title="6.1.2 MySQL配置文件的优化201"></a>6.1.2 MySQL配置文件的优化201</h3><h3 id="6-1-3-MySQL上线后根据status状态进行适当优化204"><a href="#6-1-3-MySQL上线后根据status状态进行适当优化204" class="headerlink" title="6.1.3 MySQL上线后根据status状态进行适当优化204"></a>6.1.3 MySQL上线后根据status状态进行适当优化204</h3><h3 id="6-1-4-利用tuning-primer脚本进行数据库调优212"><a href="#6-1-4-利用tuning-primer脚本进行数据库调优212" class="headerlink" title="6.1.4 利用tuning-primer脚本进行数据库调优212"></a>6.1.4 利用tuning-primer脚本进行数据库调优212</h3><h3 id="6-1-5-MySQL架构设计调优216"><a href="#6-1-5-MySQL架构设计调优216" class="headerlink" title="6.1.5 MySQL架构设计调优216"></a>6.1.5 MySQL架构设计调优216</h3><h2 id="6-2-MySQL数据库的高可用架构方案216"><a href="#6-2-MySQL数据库的高可用架构方案216" class="headerlink" title="6.2 MySQL数据库的高可用架构方案216"></a>6.2 MySQL数据库的高可用架构方案216</h2><h3 id="6-2-1-生产环境下的DRBD-Heart-beat-MySQL双机高可用217"><a href="#6-2-1-生产环境下的DRBD-Heart-beat-MySQL双机高可用217" class="headerlink" title="6.2.1 生产环境下的DRBD+Heart-beat+MySQL双机高可用217"></a>6.2.1 生产环境下的DRBD+Heart-beat+MySQL双机高可用217</h3><h3 id="6-2-2-生产环境下的MySQL数据库主从Replication同步228"><a href="#6-2-2-生产环境下的MySQL数据库主从Replication同步228" class="headerlink" title="6.2.2 生产环境下的MySQL数据库主从Replication同步228"></a>6.2.2 生产环境下的MySQL数据库主从Replication同步228</h3><h2 id="6-3-小结240"><a href="#6-3-小结240" class="headerlink" title="6.3 小结240"></a>6.3 小结240</h2><h1 id="第7章-Linux防火墙介绍242"><a href="#第7章-Linux防火墙介绍242" class="headerlink" title="第7章　Linux防火墙介绍242"></a>第7章　Linux防火墙介绍242</h1><h2 id="7-1-基础网络知识242"><a href="#7-1-基础网络知识242" class="headerlink" title="7.1 基础网络知识242"></a>7.1 基础网络知识242</h2><h3 id="7-1-1-OSI网络参考模型242"><a href="#7-1-1-OSI网络参考模型242" class="headerlink" title="7.1.1 OSI网络参考模型242"></a>7.1.1 OSI网络参考模型242</h3><h3 id="7-1-2-TCP-IP三次握手的过程详解243"><a href="#7-1-2-TCP-IP三次握手的过程详解243" class="headerlink" title="7.1.2 TCP/IP三次握手的过程详解243"></a>7.1.2 TCP/IP三次握手的过程详解243</h3><h3 id="7-1-3-Socket应用245"><a href="#7-1-3-Socket应用245" class="headerlink" title="7.1.3 Socket应用245"></a>7.1.3 Socket应用245</h3><h3 id="7-1-4-其他基础网络知识247"><a href="#7-1-4-其他基础网络知识247" class="headerlink" title="7.1.4 其他基础网络知识247"></a>7.1.4 其他基础网络知识247</h3><h2 id="7-2-Linux防火墙的状态机制247"><a href="#7-2-Linux防火墙的状态机制247" class="headerlink" title="7.2 Linux防火墙的状态机制247"></a>7.2 Linux防火墙的状态机制247</h2><h2 id="7-3-Linux防火墙在企业中的应用247"><a href="#7-3-Linux防火墙在企业中的应用247" class="headerlink" title="7.3 Linux防火墙在企业中的应用247"></a>7.3 Linux防火墙在企业中的应用247</h2><h2 id="7-4-Linux防火墙的语法248"><a href="#7-4-Linux防火墙的语法248" class="headerlink" title="7.4 Linux防火墙的语法248"></a>7.4 Linux防火墙的语法248</h2><h2 id="7-5-iptables的基础知识252"><a href="#7-5-iptables的基础知识252" class="headerlink" title="7.5 iptables的基础知识252"></a>7.5 iptables的基础知识252</h2><h3 id="7-5-1-iptables的状态state252"><a href="#7-5-1-iptables的状态state252" class="headerlink" title="7.5.1 iptables的状态state252"></a>7.5.1 iptables的状态state252</h3><h3 id="7-5-2-iptables的Conntrack记录254"><a href="#7-5-2-iptables的Conntrack记录254" class="headerlink" title="7.5.2 iptables的Conntrack记录254"></a>7.5.2 iptables的Conntrack记录254</h3><h3 id="7-5-3-关于iptables模块的说明255"><a href="#7-5-3-关于iptables模块的说明255" class="headerlink" title="7.5.3 关于iptables模块的说明255"></a>7.5.3 关于iptables模块的说明255</h3><h3 id="7-5-4-iptables防火墙初始化的注意事项256"><a href="#7-5-4-iptables防火墙初始化的注意事项256" class="headerlink" title="7.5.4 iptables防火墙初始化的注意事项256"></a>7.5.4 iptables防火墙初始化的注意事项256</h3><h3 id="7-5-5-如何保存运行中的iptables规则256"><a href="#7-5-5-如何保存运行中的iptables规则256" class="headerlink" title="7.5.5 如何保存运行中的iptables规则256"></a>7.5.5 如何保存运行中的iptables规则256</h3><h2 id="7-6-如何流程化编写iptables脚本257"><a href="#7-6-如何流程化编写iptables脚本257" class="headerlink" title="7.6 如何流程化编写iptables脚本257"></a>7.6 如何流程化编写iptables脚本257</h2><h2 id="7-7-学习iptables应该掌握的工具260"><a href="#7-7-学习iptables应该掌握的工具260" class="headerlink" title="7.7 学习iptables应该掌握的工具260"></a>7.7 学习iptables应该掌握的工具260</h2><h3 id="7-7-1-命令行的抓包工具TCPDump260"><a href="#7-7-1-命令行的抓包工具TCPDump260" class="headerlink" title="7.7.1 命令行的抓包工具TCPDump260"></a>7.7.1 命令行的抓包工具TCPDump260</h3><h3 id="7-7-2-图形化抓包工具Wireshark261"><a href="#7-7-2-图形化抓包工具Wireshark261" class="headerlink" title="7.7.2 图形化抓包工具Wireshark261"></a>7.7.2 图形化抓包工具Wireshark261</h3><h3 id="7-7-3-强大的命令行扫描工具Nmap264"><a href="#7-7-3-强大的命令行扫描工具Nmap264" class="headerlink" title="7.7.3 强大的命令行扫描工具Nmap264"></a>7.7.3 强大的命令行扫描工具Nmap264</h3><h3 id="7-7-4-使用TCPPing工具检测TCP延迟266"><a href="#7-7-4-使用TCPPing工具检测TCP延迟266" class="headerlink" title="7.7.4 使用TCPPing工具检测TCP延迟266"></a>7.7.4 使用TCPPing工具检测TCP延迟266</h3><h2 id="7-8-iptables的简单脚本学习267"><a href="#7-8-iptables的简单脚本学习267" class="headerlink" title="7.8 iptables的简单脚本学习267"></a>7.8 iptables的简单脚本学习267</h2><h3 id="7-8-1-普通的Web主机防护脚本267"><a href="#7-8-1-普通的Web主机防护脚本267" class="headerlink" title="7.8.1 普通的Web主机防护脚本267"></a>7.8.1 普通的Web主机防护脚本267</h3><h3 id="7-8-2-如何让别人ping不到自己，而自己能ping通别人呢？269"><a href="#7-8-2-如何让别人ping不到自己，而自己能ping通别人呢？269" class="headerlink" title="7.8.2 如何让别人ping不到自己，而自己能ping通别人呢？269"></a>7.8.2 如何让别人ping不到自己，而自己能ping通别人呢？269</h3><h3 id="7-8-3-建立安全的vsftpd服务器271"><a href="#7-8-3-建立安全的vsftpd服务器271" class="headerlink" title="7.8.3 建立安全的vsftpd服务器271"></a>7.8.3 建立安全的vsftpd服务器271</h3><h2 id="7-9-线上生产服务器的iptables脚本275"><a href="#7-9-线上生产服务器的iptables脚本275" class="headerlink" title="7.9 线上生产服务器的iptables脚本275"></a>7.9 线上生产服务器的iptables脚本275</h2><h3 id="7-9-1-安全的主机iptables防火墙脚本275"><a href="#7-9-1-安全的主机iptables防火墙脚本275" class="headerlink" title="7.9.1 安全的主机iptables防火墙脚本275"></a>7.9.1 安全的主机iptables防火墙脚本275</h3><h3 id="7-9-2-自动分析黑名单及白名单的iptables脚本278"><a href="#7-9-2-自动分析黑名单及白名单的iptables脚本278" class="headerlink" title="7.9.2 自动分析黑名单及白名单的iptables脚本278"></a>7.9.2 自动分析黑名单及白名单的iptables脚本278</h3><h3 id="7-9-3-利用recent模块限制同一IP的连接数281"><a href="#7-9-3-利用recent模块限制同一IP的连接数281" class="headerlink" title="7.9.3 利用recent模块限制同一IP的连接数281"></a>7.9.3 利用recent模块限制同一IP的连接数281</h3><h3 id="7-9-4-利用DenyHosts工具和脚本来防止SSH暴力破解285"><a href="#7-9-4-利用DenyHosts工具和脚本来防止SSH暴力破解285" class="headerlink" title="7.9.4 利用DenyHosts工具和脚本来防止SSH暴力破解285"></a>7.9.4 利用DenyHosts工具和脚本来防止SSH暴力破解285</h3><h2 id="7-10-工作中的Linux防火墙总结287"><a href="#7-10-工作中的Linux防火墙总结287" class="headerlink" title="7.10　工作中的Linux防火墙总结287"></a>7.10　工作中的Linux防火墙总结287</h2><h2 id="7-11-小结289"><a href="#7-11-小结289" class="headerlink" title="7.11　小结289"></a>7.11　小结289</h2><h1 id="第8章-Linux系统安全相关篇290"><a href="#第8章-Linux系统安全相关篇290" class="headerlink" title="第8章　Linux系统安全相关篇290"></a>第8章　Linux系统安全相关篇290</h1><h2 id="8-1-TCP-wrappers应用级防火墙的介绍和应用290"><a href="#8-1-TCP-wrappers应用级防火墙的介绍和应用290" class="headerlink" title="8.1 TCP_wrappers应用级防火墙的介绍和应用290"></a>8.1 TCP_wrappers应用级防火墙的介绍和应用290</h2><h2 id="8-2-DDos攻击和运营商劫持292"><a href="#8-2-DDos攻击和运营商劫持292" class="headerlink" title="8.2 DDos攻击和运营商劫持292"></a>8.2 DDos攻击和运营商劫持292</h2><h2 id="8-3-Linux服务器的安全防护294"><a href="#8-3-Linux服务器的安全防护294" class="headerlink" title="8.3 Linux服务器的安全防护294"></a>8.3 Linux服务器的安全防护294</h2><h3 id="8-3-1-Linux服务器基础防护篇294"><a href="#8-3-1-Linux服务器基础防护篇294" class="headerlink" title="8.3.1 Linux服务器基础防护篇294"></a>8.3.1 Linux服务器基础防护篇294</h3><h3 id="8-3-2-Linux服务器高级防护篇295"><a href="#8-3-2-Linux服务器高级防护篇295" class="headerlink" title="8.3.2 Linux服务器高级防护篇295"></a>8.3.2 Linux服务器高级防护篇295</h3><h2 id="8-4-Linux系统如何防止入侵301"><a href="#8-4-Linux系统如何防止入侵301" class="headerlink" title="8.4 Linux系统如何防止入侵301"></a>8.4 Linux系统如何防止入侵301</h2><h2 id="8-5-小结301"><a href="#8-5-小结301" class="headerlink" title="8.5 小结301"></a>8.5 小结301</h2><h1 id="附录A-GibLab在开发工作中的实际应用302"><a href="#附录A-GibLab在开发工作中的实际应用302" class="headerlink" title="附录A　GibLab在开发工作中的实际应用302"></a>附录A　GibLab在开发工作中的实际应用302</h1><h1 id="附录B-Sublime-Text3的快捷键操作308"><a href="#附录B-Sublime-Text3的快捷键操作308" class="headerlink" title="附录B　Sublime Text3的快捷键操作308"></a>附录B　Sublime Text3的快捷键操作308</h1><h1 id="附录C-调试网络接口的利器Postman315"><a href="#附录C-调试网络接口的利器Postman315" class="headerlink" title="附录C　调试网络接口的利器Postman315"></a>附录C　调试网络接口的利器Postman315</h1><h1 id="附录D-RSYNC及INOTIFY在工作中的应用321"><a href="#附录D-RSYNC及INOTIFY在工作中的应用321" class="headerlink" title="附录D　RSYNC及INOTIFY在工作中的应用321"></a>附录D　RSYNC及INOTIFY在工作中的应用321</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E3%80%8A%E6%9E%84%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89%E3%80%8B/" data-id="ckqg285u3002orcfphfg9fkte" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/17/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%8C%87%E5%BC%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%93%81%E8%B7%AF6C%E4%B8%9A%E5%8A%A1%E7%BB%93%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E7%AB%99%E7%94%9F%E4%BA%A7%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E5%8E%82%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>