<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/18/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-architecture/Spring-Cloud" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Spring-Cloud/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.809Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring-Cloud"></a>Spring-Cloud</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Spring-Cloud/" data-id="ckqg285tz002drcfp1xi0c8e9" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/shiro总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/shiro%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.807Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="学习序列"><a href="#学习序列" class="headerlink" title="学习序列"></a>学习序列</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34021712/column/info/26947">Shiro学习 系列</a><br>springboot整合shiro -shiro介绍(一)<br>springboot整合shiro -快速入门(二)<br>springboot整合shiro-Whitelabel Error Page解决(三)<br>springboot整合shiro-配置记住我(四)<br>springboot整合shiro-ehcache缓存(五)<br>springboot整合shiro-session管理(六)<br>springboot整合shiro-在线人数以及并发登录人数控制(七)<br>springboot整合shiro-登录失败次数限制(八)<br>springboot整合shiro-实现验证码认证(九)<br>springboot使用shiro-整合redis作为缓存(十)<br>Shiro使用redis作为缓存(解决shiro频繁访问Redis)(十一)<br>解决Shiro频繁访问Redis读取和更新session(十二)<br>shiro 整合oauth2.0 服务端 和 客户端实现(入门教程)(十三)<br>关于shiro使用密码加密加盐之后序列化失败的问题(十四)<br>springboot整合shiro-对密码进行MD5并加盐处理(十五)<br>springboot整合shiro-实现自己的登出(十六)<br>springboot整合shiro-关于登出时,redis中缓存没有清理干净的问题(十七)<br>springboot整合shiro-SimpleAuthenticationInfo 参数该使用username 还是User实体(十八)</p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/kvJ3EXo9dg/">Apache-Shiro+Zookeeper系统集群安全解决方案之缓存管理</a></p>
<p>（一） shiro入门介绍<br>（二） shiro 的INI配置<br>（三）shiro身份认证（Shiro Authentication）<br>（四）shiro授权（Authentication）–访问控制<br>（五）分布式集群系统下的高可用session解决方案<br>（六）分布式集群系统下的高可用session解决方案—Session共享<br>（七）分布式集群系统下—cache共享<br>（八） web集群时session同步的3种方法</p>
<h2 id="SessionDAO-vs-CacheManager"><a href="#SessionDAO-vs-CacheManager" class="headerlink" title="SessionDAO vs CacheManager"></a>SessionDAO vs CacheManager</h2><ul>
<li>SessionDAO、CacheManager 两者的职责不一样。 SessionDAO可以实现有缓存的，也可以实现没有的； 而CacheManager不仅仅用于CachingSessionDAO，还有CachingRealm</li>
<li> CacheManager 实例会自动地直接传送到SessionDAO（通过EnterpriseCacheSessionDAO 实现CacheManagerAware 接口的性质）。 然后，当SessionManager 要求EnterpriseCacheSessionDAO 去持久化一个Session 时，它使用一个CacheManager去存储Session 数据。</li>
<li>如果想Session存于Redis中，有两种方式：1、实现Redis的SessionDAO就行；2、实现Redis的CacheManager，而SessionDao使用 EnterpriseCacheSessionDAO，并设置cacheManager。</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p><a target="_blank" rel="noopener" href="https://stormpath.com/blog/hazelcast-support-apache-shiro">Hazelcast Support in Apache Shiro</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/kvJ3EXo9dg/">Apache-Shiro+Zookeeper系统集群安全解决方案之缓存管理</a><br>如今的系统多不是孤军奋战,在多结点会话共享管理方面有着各自的解决办法,比如Session粘连,基于Web容器的各种处理等或者类似本文说的完全接管Web容器的Session管理,只是做法不尽相同. 而本 …</p>
<p><a target="_blank" rel="noopener" href="https://www.bbsmax.com/A/GBJrlweEd0/">Apache shiro集群实现系列</a>  备用： <a target="_blank" rel="noopener" href="https://blog.csdn.net/lishehe/article/details/45218251">https://blog.csdn.net/lishehe/article/details/45218251</a></p>
<h2 id="Token、JWT登录"><a href="#Token、JWT登录" class="headerlink" title="Token、JWT登录"></a>Token、JWT登录</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011687186/article/details/80702912">Shrio框架Token认证思路</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40194399/article/details/85539158">shiro实现免密登录，解决三方登录问题</a><br><a target="_blank" rel="noopener" href="https://github.com/HowieYuan/Shiro-SpringBoot">shiro 框架的构建以及与 JWT 的整合</a><br><a target="_blank" rel="noopener" href="https://github.com/Smith-Cruise/Spring-Boot-Shiro">Shiro基于SpringBoot +JWT搭建简单的restful服务</a></p>
<h2 id="Session问题"><a href="#Session问题" class="headerlink" title="Session问题"></a>Session问题</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/suruiliang/article/details/78824448">shiro的session和servlet的session的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013628152/article/details/84031784">shiro将ServletHttpSession包装成了ShiroHttpSession</a></p>
<h2 id="OAuth2集成"><a href="#OAuth2集成" class="headerlink" title="OAuth2集成"></a>OAuth2集成</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34021712/article/details/80510774">shiro 整合oauth2.0 服务端 和 客户端实现(入门教程)(十三)</a><br><a target="_blank" rel="noopener" href="https://github.com/zhangtr/teedao">teedao例子代码    </a></p>
<h2 id="CAS集成"><a href="#CAS集成" class="headerlink" title="CAS集成"></a>CAS集成</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/suiyueqiannian/p/9359597.html">spring boot 2.0 集成 shiro 和 pac4j cas单点登录</a></p>
<h2 id="20181101"><a href="#20181101" class="headerlink" title="20181101"></a>20181101</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vinozly/p/5080692.html">spring mvc下shiro的session,request等问题</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shenjixiaodao/p/7426594.html">Session(数据)共享的前后端分离Shiro实战</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/eab0b28f6fea">https://www.jianshu.com/p/eab0b28f6fea</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/achenyuan/article/details/78541529">https://blog.csdn.net/achenyuan/article/details/78541529</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/vinozly/p/5080692.html">https://www.cnblogs.com/vinozly/p/5080692.html</a><br><a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/blog/2025656">http://jinnianshilongnian.iteye.com/blog/2025656</a></p>
<h2 id="Old"><a href="#Old" class="headerlink" title="Old"></a>Old</h2><p><a target="_blank" rel="noopener" href="http://www.9iu.org/2013/12/20/springrain5-shiro-httpsession.html">springrain技术详解(5)-shiro的httpSession</a></p>
<p><a target="_blank" rel="noopener" href="http://bbs.landingbj.com/showtopic.jsp?rootid=174571&CPages=1">jsessionid传递方式对session实现机制</a></p>
<p><a target="_blank" rel="noopener" href="http://618119.com/archives/2007/12/19/48.html">解决iframe中jsessionid无法传递导致session丢失的问题</a></p>
<p><a target="_blank" rel="noopener" href="http://www.verydemo.com/demo_c432_i2937.html">实现跨域cookie共享</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/michaelliuyang/article/details/8819852">apache shiro集群实现（一） session共享</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/michaelliuyang/article/details/8820390">apache shiro集群实现（二）— cache共享</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/alexxiyang/shiro-redis">alexxiyang/shiro-redis</a></p>
<p><a target="_blank" rel="noopener" href="http://jetgeng.github.io/blog/html/2014/09/07/redis_shiro.html">使用Redis让Shiro实现集群</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/shiro%E6%80%BB%E7%BB%93/" data-id="ckqg285u2002lrcfp4e1jcein" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/Sharding-JDBC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Sharding-JDBC/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.806Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="一、什么是Sharding-JDBC"><a href="#一、什么是Sharding-JDBC" class="headerlink" title="一、什么是Sharding-JDBC"></a>一、什么是Sharding-JDBC</h1><p>Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p>
<h1 id="二、Sharding-JDBC能做什么"><a href="#二、Sharding-JDBC能做什么" class="headerlink" title="二、Sharding-JDBC能做什么"></a>二、Sharding-JDBC能做什么</h1><ul>
<li>分库 &amp; 分表</li>
<li>读写分离</li>
<li>分布式主键</li>
<li>分布式事务</li>
</ul>
<h1 id="三、适用项目框架"><a href="#三、适用项目框架" class="headerlink" title="三、适用项目框架"></a>三、适用项目框架</h1><p>Sharding-JDBC适用于：</p>
<pre><code>- 任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。
- 基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。
- 支持任意实现JDBC规范的数据库，目前支持MySQL，Oracle，SQLServer和PostgreSQL。
</code></pre>
<h1 id="四、Maven依赖"><a href="#四、Maven依赖" class="headerlink" title="四、Maven依赖"></a>四、Maven依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sharding jdbc 开始--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-namespace<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果不配置分布式事务的话配置上边两个就够了 --&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 分布式事务引用依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-transaction-2pc-xa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-transaction-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;sharding.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- sharding jdbc 结束--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--AspectJ AOP支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;aspectjweaver.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="五、读写分离"><a href="#五、读写分离" class="headerlink" title="五、读写分离"></a>五、读写分离</h1><h2 id="5-1-数据源配置"><a href="#5-1-数据源配置" class="headerlink" title="5.1 数据源配置"></a>5.1 数据源配置</h2><p>先配置数据源</p>
<p>也可以配置读写分离</p>
<p>以下配置是ds0和ds1两个数据库的主和从一共四个数据源。</p>
<p>parentDs 是数据源公共的配置，抽出去以免写重复代码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ds0的主--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ds0_master&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parentDs&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ds0的从--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ds0_slave&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parentDs&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;sharding.connection.url.0&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ds1的主--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ds1_master&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parentDs&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;sharding.connection.url.1&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ds1的从--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ds1_slave&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;parentDs&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;sharding.connection.url.1&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-2-读写分离配置"><a href="#5-2-读写分离配置" class="headerlink" title="5.2 读写分离配置"></a>5.2 读写分离配置</h2><p>只配置主从不配置分库分表的情况如下，如果要配置分库分表则不需要下面这个配置。</p>
<p>master-data-source-name 是主数据源ID</p>
<p>slave-data-source-names 是从数据源ID</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">master-slave:data-source</span> <span class="attr">id</span>=<span class="string">&quot;masterSlaveDataSource&quot;</span> <span class="attr">master-data-source-name</span>=<span class="string">&quot;ds0_master, ds1_master&quot;</span> <span class="attr">slave-data-source-names</span>=<span class="string">&quot;ds0_slave, ds1_slave &quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">master-slave:props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sql.show&quot;</span>&gt;</span>$&#123;sql_show&#125;<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;executor.size&quot;</span>&gt;</span>10<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">master-slave:props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">master-slave:data-source</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-读写分离和分库分表一起配置"><a href="#5-3-读写分离和分库分表一起配置" class="headerlink" title="5.3 读写分离和分库分表一起配置"></a>5.3 读写分离和分库分表一起配置</h2><p>如果读写分离和分库分表一起使用的话把主从路由配置到 shardingdata-source下就可以了。</p>
<p>sharding:master-slave-rule 的 id 就是配置出来的逻辑的数据源的名称，如果多个从的话还可以通过配置strategy-ref来配置负载均衡。</p>
<p>master-data-source 配置的是主库数据源ID 。</p>
<p>slave-data-source 配置的是从库数据源ID，多个以逗号分开。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sharding数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:data-source</span> <span class="attr">id</span>=<span class="string">&quot;shardingDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 读写分离的话要把所有的主从数据源都写在这里--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sharding:sharding-rule</span></span></span><br><span class="line"><span class="tag">            <span class="attr">data-source-names</span>=<span class="string">&quot;ds0_master,ds0_slave,ds1_master,ds1_slave &quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 读写分离的路由 一主一从配置 strategy-ref  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sharding:master-slave-rules</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">sharding:master-slave-rule</span> <span class="attr">id</span>=<span class="string">&quot;ds0&quot;</span> <span class="attr">master-data-source-name</span>=<span class="string">&quot;ds0_master&quot;</span> <span class="attr">slave-data-source-names</span>=<span class="string">&quot;ds0_slave&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">sharding:master-slave-rule</span> <span class="attr">id</span>=<span class="string">&quot;ds1&quot;</span> <span class="attr">master-data-source-name</span>=<span class="string">&quot;ds1_master&quot;</span> <span class="attr">slave-data-source-names</span>=<span class="string">&quot;ds1_slave&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sharding:master-slave-rules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 读写分离配置 结束--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">sharding:table-rules</span>&gt;</span></span><br><span class="line">    &lt;!— 这里是分库分表路由的配置 --&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">sharding:table-rules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sharding:binding-table-rules</span>&gt;</span></span><br><span class="line">    &lt;!—- 绑定表的配置 --&gt; </span><br><span class="line">        <span class="tag">&lt;/<span class="name">sharding:binding-table-rules</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">sharding:sharding-rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:props</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 显示SQL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;sql.show&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sharding:props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sharding:data-source</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="六、数据分片"><a href="#六、数据分片" class="headerlink" title="六、数据分片"></a>六、数据分片</h1><h2 id="6-1-分片支持"><a href="#6-1-分片支持" class="headerlink" title="6.1 分片支持"></a>6.1 分片支持</h2><p>Sharding-JDBC提供了5种分片策略。由于分片算法和业务实现紧密相关，因此Sharding-JDBC并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。</p>
<ul>
<li><strong>StandardShardingStrategy</strong></li>
</ul>
<p>标准分片策略。提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片；RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。</p>
<ul>
<li><strong>ComplexShardingStrategy</strong></li>
</ul>
<p>复合分片策略。提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此Sharding-JDBC并未做过多的封装，而是直接将分片键值组合以及分片操作符交于算法接口，完全由应用开发者实现，提供最大的灵活度。</p>
<ul>
<li><strong>InlineShardingStrategy</strong></li>
</ul>
<p>Inline表达式分片策略。使用Groovy的Inline表达式，提供对SQL语句中的=和IN的分片操作支持。InlineShardingStrategy只支持单分片键，对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: tuser${user_id % 8} 表示t_user表按照user_id按8取模分成8个表，表名称为t_user_0到t_user_7。</p>
<ul>
<li><strong>HintShardingStrategy</strong></li>
</ul>
<p>通过Hint而非SQL解析的方式分片的策略。</p>
<ul>
<li><strong>NoneShardingStrategy</strong></li>
</ul>
<p>不分片的策略。</p>
<h2 id="6-2-分片配置"><a href="#6-2-分片配置" class="headerlink" title="6.2 分片配置"></a>6.2 分片配置</h2><p>标准分片配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 标准分片策略。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoUserStandardStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;shard.strategy.DemoUserStandardStrategy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:standard-strategy</span> <span class="attr">id</span>=<span class="string">&quot;shardingDemoUserStandardStrategy&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">precise-algorithm-ref</span>=<span class="string">&quot;demoUserStandardStrategy&quot;</span> <span class="attr">sharding-column</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">range-algorithm-ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>DemoUserStandardStrategy标准分片要实现 PreciseShardingAlgorithm 接口，doSharding的两个参数一个是所有数据源的cllection.另一个参数是执行SQL时传过来的分片的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据ID取</span></span><br><span class="line"><span class="comment"> * 标准分片策略</span></span><br><span class="line"><span class="comment"> * 用于处理=和IN的分片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yulonggao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/31 14:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoUserStandardStrategy</span> <span class="keyword">implements</span> <span class="title">PreciseShardingAlgorithm</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; collection, PreciseShardingValue&lt;Long&gt; preciseShardingValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个里边有异常会被处理掉，然后导致拿不到分片。但出异常一般是业务代码写错了。</span></span><br><span class="line">        <span class="comment">//每条指定分片的操作都会调用此方法，如果是in 条件查询的话每个值会调用一次此方法，如果是批量插入也是每一条都要调用一次进行分片</span></span><br><span class="line">        log.info(<span class="string">&quot;DemoUserStandardStrategy_preciseShardingValue=&#123;&#125;&quot;</span>, preciseShardingValue);</span><br><span class="line">        Long suffix = preciseShardingValue.getValue() % <span class="number">4</span>;</span><br><span class="line">        log.info(<span class="string">&quot;suffix=&#123;&#125;&quot;</span>, suffix);</span><br><span class="line">        <span class="keyword">final</span> String targetDb = String.valueOf(Math.abs(suffix.intValue()));</span><br><span class="line">        String shardingValue = collection.stream().filter(p -&gt; p.endsWith(targetDb)).findFirst().get();</span><br><span class="line">        log.info(<span class="string">&quot;preciseShardingValue=&#123;&#125;,shardingValue=&#123;&#125;&quot;</span>, preciseShardingValue, shardingValue);</span><br><span class="line">        <span class="keyword">return</span> shardingValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>强制分片</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 强制路由分片策略--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoUserHintStrategy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;shard.strategy.DemoUserHintStrategy&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 强制路由例子使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sharding:hint-strategy</span> <span class="attr">id</span>=<span class="string">&quot;shardingDemoUserHintStrategy&quot;</span> <span class="attr">algorithm-ref</span>=<span class="string">&quot;demoUserHintStrategy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>DemoUserHintStrategy 的Java 如下，强制分片要实现HintShardingAlgorithm接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DemoUserHint强制路由分片策略,其实可以共用，只是例子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yulonggao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/31 14:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoUserHintStrategy</span> <span class="keyword">implements</span> <span class="title">HintShardingAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ShardingValue shardingValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//availableTargetNames 这个参数是所有的dataSource的集合，shardingValue是HintManager传过来的分片信息</span></span><br><span class="line">        log.info(<span class="string">&quot;DemoUserHintStrategy_availableTargetNames=&#123;&#125;&quot;</span>, availableTargetNames);</span><br><span class="line">        log.info(<span class="string">&quot;DemoUserHintStrategy_shardingValue=&#123;&#125;&quot;</span>, shardingValue);</span><br><span class="line">        ListShardingValue listShardingValue = (ListShardingValue) shardingValue;</span><br><span class="line">        Collection shardingValueList = listShardingValue.getValues();</span><br><span class="line">        <span class="comment">//因为调用的时候分片是直接传的 DataSource的名称，所以直接返回就可以了，如果传其它值则要加业务逻辑进行分片筛选</span></span><br><span class="line">        <span class="comment">//返回结果只能是availableTargetNames 里边所包含的</span></span><br><span class="line">        <span class="keyword">return</span> shardingValueList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成分部式ID的配置，生成主键的类要实现KeyGenerator接口。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!—主键生成 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;keyId&quot;</span> <span class="attr">class</span>=<span class="string">&quot;shard.key.DefaultKeyGenerator&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="_v_images/20200604065002540_18818.png" alt="Sharding-JDBC配置"></p>
<h1 id="七、分布式事务"><a href="#七、分布式事务" class="headerlink" title="七、分布式事务"></a>七、分布式事务</h1><p>把下面这行代码配置在spring里，shardingTransaction.xml 是jar包里边带的。</p>
<p>文件的源码只有两行配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;shardingDataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 事务支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:META-INF/shardingTransaction.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用注解配置事务要同时使用ShardingTransactionType和Transactional两个注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：<span class="doctag">@ShardingTransactionType</span>需要同Spring的<span class="doctag">@Transactional</span>配套使用，事务才会生效。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ShardingTransactionType(TransactionType.XA)</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addParam</span><span class="params">(DemoParam param)</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;addParam-param=&#123;&#125;&quot;</span>, param);</span><br><span class="line"><span class="keyword">return</span> demoParamDao.addParam(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-1-支持程度"><a href="#7-1-支持程度" class="headerlink" title="7.1 支持程度"></a>7.1 支持程度</h2><p>完全支持非跨库事务，例如：仅分表或分库但是路由的结果在单库中。</p>
<p>完全支持因逻辑异常导致的跨库事务。例如：同一事务中跨两个库更新，更新完毕后，抛出空指针，则两个库的内容都能回滚。</p>
<p>支持数据库字段约束造成的回滚。</p>
<h1 id="八、其他问题"><a href="#八、其他问题" class="headerlink" title="八、其他问题"></a>八、其他问题</h1><p>关于order by 排序，如果排序的字段不在查询结果中，生成的SQL也会被带上，但结果不返回给你。<br>不支持因网络、硬件异常导致的跨库事务。例如：同一事务中跨两个库更新，更新完毕后、未提交之前，第一个库死机，则只有第二个库数据提交。</p>
<p><img src="_v_images/20200604065318535_1841.png"></p>
<p>九、参考文档</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://shardingsphere.apache.org/document/current/cn/manual/sharding-jdbc/usage/sharding/">https://shardingsphere.apache.org/document/current/cn/manual/sharding-jdbc/usage/sharding/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yixinjishu/p/10876071.html">https://www.cnblogs.com/yixinjishu/p/10876071.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Sharding-JDBC/" data-id="ckqg285tz002crcfpazq8ax79" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/Redis知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Redis%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.804Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Redis作为缓存"><a href="#Redis作为缓存" class="headerlink" title="Redis作为缓存"></a>Redis作为缓存</h2><p>当用jdk默认的序列化方案时，对类的版本要求严格一直，否则抛出ClassNotFoundException。比如：</p>
<ul>
<li>几个共用redis缓存的应用，它们共用的jar包版本有差异（serialNo），就会导致整个系统失败。 <a target="_blank" rel="noopener" href="https://github.com/alexxiyang/shiro-redis/issues/78">https://github.com/alexxiyang/shiro-redis/issues/78</a></li>
<li>class一旦上线，就不能改变包名或位置，否则无法序列号。 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/technologykai/p/10097167.html">https://www.cnblogs.com/technologykai/p/10097167.html</a></li>
</ul>
<h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><p>Redis比较适合的一些应用场景：</p>
<h4 id="1-取最新N个数据的操作"><a href="#1-取最新N个数据的操作" class="headerlink" title="1.取最新N个数据的操作"></a>1.取最新N个数据的操作</h4><p>比如典型的取你网站的最新文章，通过下面方式，我们可以将最新的5000条评论的ID放在Redis的List集合中，并将超出集合部分从数据库获取</p>
<ul>
<li> 使用LPUSH latest.comments<ID>命令，向 list 集合中插入数据</li>
<li> 插入完成后再用LTRIM latest.comments 0 5000命令使其永远只保存最近5000个ID</li>
<li>然后我们在客户端获取某一页评论时可以用下面的逻辑（伪代码）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION get_latest_comments(start,num_items):   </span><br><span class="line">     id_list = redis.lrange(<span class="string">&quot;latest.comments&quot;</span>,start,start+num_items-<span class="number">1</span>)    </span><br><span class="line">     IF id_list.length &lt; num_items        </span><br><span class="line">          id_list = SQL_DB(<span class="string">&quot;SELECT ... ORDER BY time LIMIT ...&quot;</span>)    </span><br><span class="line">     END    </span><br><span class="line">     RETURN id_list</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>如果你还有不同的筛选维度，比如某个分类的最新N条，那么你可以再建一个按此分类的List，只存ID的话，Redis是非常高效的。</p>
<h4 id="2-排行榜应用，取TOP-N操作"><a href="#2-排行榜应用，取TOP-N操作" class="headerlink" title="2.排行榜应用，取TOP N操作"></a>2.排行榜应用，取TOP N操作</h4><p>这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sortedset的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。</p>
<h4 id="3-需要精准设定过期时间的应用"><a href="#3-需要精准设定过期时间的应用" class="headerlink" title="3.需要精准设定过期时间的应用"></a>3.需要精准设定过期时间的应用</h4><p>比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把 Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。</p>
<h4 id="4-计数器应用"><a href="#4-计数器应用" class="headerlink" title="4.计数器应用"></a>4.计数器应用</h4><p>Redis的命令都是原子性的，你可以轻松地利用INCR，DECR命令来构建计数器系统。</p>
<h4 id="5-Uniq操作，获取某段时间所有数据排重值"><a href="#5-Uniq操作，获取某段时间所有数据排重值" class="headerlink" title="5.Uniq操作，获取某段时间所有数据排重值"></a>5.Uniq操作，获取某段时间所有数据排重值</h4><p>这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。</p>
<h4 id="6-实时系统，反垃圾系统"><a href="#6-实时系统，反垃圾系统" class="headerlink" title="6.实时系统，反垃圾系统"></a>6.实时系统，反垃圾系统</h4><p>通过上面说到的set功能，你可以知道一个终端用户是否进行了某个操作，可以找到其操作的集合并进行分析统计对比等。没有做不到，只有想不到。</p>
<h4 id="7-Pub-Sub构建实时消息系统"><a href="#7-Pub-Sub构建实时消息系统" class="headerlink" title="7.Pub/Sub构建实时消息系统"></a>7.Pub/Sub构建实时消息系统</h4><p>Redis的Pub/Sub系统可以构建实时的消息系统，比如很多用Pub/Sub构建的实时聊天系统的例子。</p>
<h4 id="8-构建队列系统"><a href="#8-构建队列系统" class="headerlink" title="8.构建队列系统"></a>8.构建队列系统</h4><p>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。</p>
<h4 id="9-缓存"><a href="#9-缓存" class="headerlink" title="9.缓存"></a>9.缓存</h4><p>这个不必说了，性能优于Memcached，数据结构更多样化。</p>
<p>转自: <a target="_blank" rel="noopener" href="http://blog.nosqlfan.com/html/2235.html?ref=rediszt">http://blog.nosqlfan.com/html/2235.html?ref=rediszt</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Redis%E7%9F%A5%E8%AF%86/" data-id="ckqg285ty002arcfpepqx52ex" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/Python爬虫框架scrapy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Python%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6scrapy/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.803Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>pip install scrapy<br>编译Twised时需要Visual C++ Build Tools，可以在这来下载安装：<a target="_blank" rel="noopener" href="http://www.xdowns.com/soft/38/138/2017/soft_226169.html#download_box">Microsoft Visual C++ Build Tools</a></p>
<h2 id="Scrapy框架"><a href="#Scrapy框架" class="headerlink" title="Scrapy框架"></a>Scrapy框架</h2><p><img src="_v_images/2019-11-29-17-57-09.png"></p>
<p>scrapy爬虫项目开发分成四步：新建项目、明确目标、制作爬虫、存储内容</p>
<h2 id="新建scrapy项目"><a href="#新建scrapy项目" class="headerlink" title="新建scrapy项目"></a>新建scrapy项目</h2><ul>
<li>新建项目<br><code>scrapy startproject douban</code></li>
<li>douban\spiders<br>进入douban\spiders目录，执行：<code>scrapy genspider douban_spider movie.douban.com</code></li>
</ul>
<h2 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h2><p>分析<code>https://movie.douban.com/top250</code>，需要抓取序号、电影名、导演、演员、星级、评价数、描述等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序号</span></span><br><span class="line">serial_number = scrapy.Field()</span><br><span class="line"><span class="comment"># 电影的名称</span></span><br><span class="line">movie_name = scrapy.Field()</span><br><span class="line"><span class="comment"># 电影的介绍</span></span><br><span class="line">introduce = scrapy.Field()</span><br><span class="line"><span class="comment"># 星级</span></span><br><span class="line">star = scrapy.Field()</span><br><span class="line"><span class="comment"># 电影的评论数</span></span><br><span class="line">evaluate = scrapy.Field()</span><br><span class="line"><span class="comment"># 电影的描述</span></span><br><span class="line">describe = scrapy.Field()</span><br></pre></td></tr></table></figure>


<h2 id="爬虫文件编写（制作爬虫）"><a href="#爬虫文件编写（制作爬虫）" class="headerlink" title="爬虫文件编写（制作爬虫）"></a>爬虫文件编写（制作爬虫）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubanSpiderSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    <span class="comment"># 爬虫名称</span></span><br><span class="line">    name = <span class="string">&#x27;douban_spider&#x27;</span></span><br><span class="line">    <span class="comment"># 允许的域名</span></span><br><span class="line">    allowed_domains = [<span class="string">&#x27;movie.douban.com&#x27;</span>]</span><br><span class="line">    <span class="comment"># 入口url，扔到调度器里面去</span></span><br><span class="line">    start_urls = [<span class="string">&#x27;https://movie.douban.com/top250&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>
<p>进入douban\spiders目录，执行：<code>scrapy crawl douban_spider</code><br>windows下运行会出现错误：</p>
<blockquote>
<p>Could not find a version that satisfies the requirement win32api (from versions: )  No matching distribution found for win32api<br>解决办法：<code>pip install pypiwin32</code></p>
</blockquote>
<p>远程运行，新建main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> cmdline</span><br><span class="line">cmdline.execute(<span class="string">&#x27;scrapy crawl douban_spider&#x27;</span>.split())</span><br></pre></td></tr></table></figure>


<h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><h2 id="常见问题处理"><a href="#常见问题处理" class="headerlink" title="常见问题处理"></a>常见问题处理</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/830ca5623211">scrapy模拟登录代码演示及cookie原理说明</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Python%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6scrapy/" data-id="ckqg285tx0029rcfp72fghamn" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/Python文件操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.802Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="文件打开方式"><a href="#文件打开方式" class="headerlink" title="文件打开方式"></a>文件打开方式</h2><p>文件打开方法：open（name, [mode[buf]]）<br>    - name：文件路径<br>    - mode：打开方式<br>        - r 只读方式打开，文件必须存在<br>        - w 只写方式打开，文件不存在创建文件，文件存在则清空文件内容<br>        - a 追加方式打开，文件不存在创建文件<br>        - r+/w+ 读写方式打开，r+ 文件必须存在，w+ 文件不存在创建文件，文件存在则清空文件内容<br>        - a+ 追加和读写方式打开，文件不存在创建文件<br>        - rb，wb，ab，rb+，wb+，ab+：二进制方式打开<br>    - buf：缓冲buffering大小</p>
<h2 id="文件读取方式"><a href="#文件读取方式" class="headerlink" title="文件读取方式"></a>文件读取方式</h2><p>文件读取方式：<br>read（[size]）：读取文件（读取size个字节，默认读取全部）<br>readline（[size]）：读取一行（读取字节数为：[size, len(line)]）<br>readlines（[size]）：读取完文件，返回每一行所组成的列表（返回字节数为：io.DEFAULT_BUFFER_SIZE=8192 左右个，是左是右要看第8192个字节在行的什么位置，反正要读到完整的行）<br>iter ：使用迭代器读取文件，适合读取大文件</p>
<h2 id="文件写入方式"><a href="#文件写入方式" class="headerlink" title="文件写入方式"></a>文件写入方式</h2><p>文件写入方式：<br>write（str）：将字符串写入文件<br>writelines（sequence_of_strings）：写多行到文件</p>
<p>write只是将内容写入OS内核的缓冲区，并没有立刻写入磁盘，可以使用flush()和close()强制写入磁盘；写入数据量大于或者等于写缓存，写缓存同步到磁盘；</p>
<h2 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h2><p>Python 文件为什么要关闭<br>1、将写缓存同步到磁盘；<br>2、linux系统中每个进程打开文件的个数是有限的；<br>    在文件 /proc/pid/limits 中，Max open files : soft limit(1024), Hard limit(4096) ， 操作系统可打开的文件描述符个数为1024<br>3、如果打开文件数到了系统限制，在打开文件就会失败；</p>
<h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p>文件写入和读取问题：<br>1、写入文件后，必须打开才能读取写入内容<br>2、读取文件后，无法重新再次读取读过的内容</p>
<p>文件读取写入文件指针移动过程：</p>
<p><img src="_v_images/2019-11-21-20-55-07.png"></p>
<p>seek（offset[，whence]）：移动文件指针；</p>
<ul>
<li>offset：偏移量，可以为负数；</li>
<li>whence：偏移相对位置；</li>
<li>os.SEEK SET：相对文件起始位置；</li>
<li>os.SEEK CUR：相对文件当前位置；</li>
<li>os.SEEK END：相对文件结尾位置；</li>
</ul>
<h2 id="文件属性及编码"><a href="#文件属性及编码" class="headerlink" title="文件属性及编码"></a>文件属性及编码</h2><ul>
<li>文件属性</li>
<li>file.fileno0：文件描述符；</li>
<li>file.mode：文件打开权限；</li>
<li>file.encoding：文件编码格式；</li>
<li>file.closed：文件是否关闭；</li>
</ul>
<ul>
<li>标准文件<br>文件标准输入：sys.stdin； input(“”)在终端录入，由此实现<br>文件标准输出：sys.stdout； print(“”)由sys.stdout.write(“”)实现<br>文件标准错误：sys.stderr；</li>
</ul>
<ul>
<li>文件命令行参数<br>sys模块提供sys.argv属性，通过该属性可以得到命令行参数；sys.argv是字符串组成的列表；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main++&#x27;</span>:</span><br><span class="line"> <span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv:</span><br><span class="line">  <span class="built_in">print</span> arg</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>文件编码<br>怎样将u’编程’的unicode写入到acsii编码的文件中？<br>unicode转码为utf-8然后可以写入<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># f.write(u&#x27;编程’)  直接写入unicode出错</span></span><br><span class="line">a=unicode.encode（<span class="string">u&#x27;编程’，‘utf-8&#x27;</span>）</span><br><span class="line">f.write(a)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>我们如何创建一个utf-8或者其他编码格式的文件？<br><code>f=codecs.open(&#39;test.txt&#39;,&#39;w&#39;,&#39;utf-8&#39;)</code></p>
<h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><p><strong>Linux文件系统一切皆文件，文件包括：磁盘（ext2，ext4）文件，NFS文件系统，各种外设（sd卡，USB设备）等；</strong><br>Linux文件系统简单示意图</p>
<p><img src="_v_images/2019-11-21-20-55-34.png"></p>
<p>Python操作文件流程</p>
<h2 id="OS模块对文件和目录操作"><a href="#OS模块对文件和目录操作" class="headerlink" title="OS模块对文件和目录操作"></a>OS模块对文件和目录操作</h2><ul>
<li>使用os模块打开文件<br>os.open（filename，flag L，mode]）：打开文件；flag：打开文件方式</li>
<li>os.OCREAT：创建文件.</li>
<li>os.O_RDONLY：只读方式打开</li>
<li>os.O_WRONLY：只写方式打开</li>
<li>os.O_RDWR：读写方式打开</li>
</ul>
<p><strong>os方法</strong></p>
<ul>
<li>os.read（fd，buffersize）：读取文件</li>
<li>os.write（fd，string）：写入文件</li>
<li>os.lseek（fd，pos，how）：文件指针操作</li>
<li>os.close（fd）：/关闭文件</li>
<li>access(path, mode) 判断该文件权限：F_OK存在，权限：R_OK，W_OK.X_OK</li>
<li>listdir(path) 返回当前目录下所有文件组成的列表</li>
<li>remove(path) 删除文件</li>
<li>rename(old，new) 修改文件或者目录名</li>
<li>mkdir(path[，mode]) 创建目录</li>
<li>makedirs(path[，mode]) 创建多级目录</li>
<li>removedirs(path) 删除多级目录</li>
<li>rmdir(path) 删除目录（目录必须空目录）</li>
</ul>
<p><strong>os.path方法</strong></p>
<ul>
<li>exists(path) 当前路径是否存在</li>
<li>isdir(s) 是否是一个目录</li>
<li>isfile(path) 是否是一个文件</li>
<li>getsize(filename) 返回文件大小</li>
<li>dirname(p) 返回路径的目录</li>
<li>basename(p) 返回路径的文件名</li>
</ul>
<h2 id="常用文件目录操作"><a href="#常用文件目录操作" class="headerlink" title="常用文件目录操作"></a>常用文件目录操作</h2><h3 id="遍历文件"><a href="#遍历文件" class="headerlink" title="遍历文件"></a>遍历文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">walkdir</span>(<span class="params">rootdir</span>):</span></span><br><span class="line">    <span class="comment">#三个参数：分别返回1.父目录 2.所有文件夹名字（不含路径） 3.所有文件名字</span></span><br><span class="line">    <span class="keyword">for</span> parent,dirnames,filenames <span class="keyword">in</span> os.walk(rootdir):</span><br><span class="line">        <span class="keyword">for</span> dirname <span class="keyword">in</span>  dirnames:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;dir path: &quot;</span> + os.path.join(parent, dirname))</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;file path:&quot;</span> + os.path.join(parent,filename))</span><br></pre></td></tr></table></figure>


<h3 id="glob文件查找"><a href="#glob文件查找" class="headerlink" title="glob文件查找"></a>glob文件查找</h3><p><strong>glob</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">&#x27;d:\a\*\*.txt&#x27;</span>)</span><br><span class="line">glob.glob(<span class="string">&#x27;./glob_?.png&#x27;</span>)</span><br><span class="line">glob.glob(<span class="string">&#x27;../glob_[0-9].png&#x27;</span>)</span><br><span class="line">glob.glob(<span class="string">&#x27;glob_[0-9].*&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>iglob</strong><br>获取一个迭代器(iterator)对象，使用它可以逐个获取匹配的文件路径名。与glob.glob()的区别是：glob.glob()同时获取所有的匹配路径，而glob.iglob()一次只获取一个匹配路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">files = glob.iglob(<span class="string">&#x27;*.png&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> png <span class="keyword">in</span> files:</span><br><span class="line">    <span class="built_in">print</span>(png)</span><br></pre></td></tr></table></figure>


<p><strong>多模式匹配来搜索文件</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it, glob, os</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiple_file_types</span>(<span class="params">*patterns</span>):</span></span><br><span class="line">    <span class="keyword">return</span> it.chain.from_iterable(glob.glob(pattern) <span class="keyword">for</span> pattern <span class="keyword">in</span> patterns)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> multiple_file_types(<span class="string">&quot;*.txt&quot;</span>, <span class="string">&quot;*.py&quot;</span>): <span class="comment"># add as many filetype arguements</span></span><br><span class="line">    realpath = os.path.realpath(filename)</span><br><span class="line">    <span class="built_in">print</span> realpath</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" data-id="ckqg285tx0028rcfphxfm39yo" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/Python+urllib2+BeautifulSoup开发简单爬虫" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Python+urllib2+BeautifulSoup%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.801Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol>
<li>爬虫简介</li>
<li>简单爬虫架构</li>
<li>URL管理器 ：管理待抓取URL集合和已抓取URL集合<br> 防止重复抓取、防止循环抓取</li>
<li>网页下载器(urllib2)</li>
<li>网页解析器(BeautifulSoup)</li>
<li>完整实例<br> 爬取百度百科Python词条相关的1000个页面数据</li>
</ol>
<h2 id="网页下载器-urllib2"><a href="#网页下载器-urllib2" class="headerlink" title="网页下载器-urllib2"></a>网页下载器-urllib2</h2><h3 id="方法1：最简洁方法"><a href="#方法1：最简洁方法" class="headerlink" title="方法1：最简洁方法"></a>方法1：最简洁方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ur1lib2</span><br><span class="line"><span class="comment">#直接请求</span></span><br><span class="line">response=urllib2.urlopen(http://www.baidu.com<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">#获取状态码，如果是2ee表示获取成功</span></span><br><span class="line"><span class="string">print response.getcode()</span></span><br><span class="line"><span class="string">#读取内容</span></span><br><span class="line"><span class="string">cont=response.read()</span></span><br></pre></td></tr></table></figure>


<h3 id="方法2：添加data、http-header-import-urllib2"><a href="#方法2：添加data、http-header-import-urllib2" class="headerlink" title="方法2：添加data、http header import urllib2"></a>方法2：添加data、http header import urllib2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建Request对象</span></span><br><span class="line">request=ur11ib2.Request(ur1)</span><br><span class="line"><span class="comment">#添加数据</span></span><br><span class="line">request.add_data(a<span class="string">&#x27;，‘12)</span></span><br><span class="line"><span class="string">#添加http的header request.add_header(‘User-Agent&#x27;</span>，‘Mozilla/<span class="number">5.</span>e<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">#发送请求获取结果</span></span><br><span class="line"><span class="string">response=ur1lib2.urlopen(request)</span></span><br></pre></td></tr></table></figure>


<h3 id="方法3：添加特殊情景的处理器：HTTPCookieProcessor-ProxyHandler-HTTPSHandler-HTTPRedirectHandler"><a href="#方法3：添加特殊情景的处理器：HTTPCookieProcessor-ProxyHandler-HTTPSHandler-HTTPRedirectHandler" class="headerlink" title="方法3：添加特殊情景的处理器：HTTPCookieProcessor, ProxyHandler, HTTPSHandler, HTTPRedirectHandler"></a>方法3：添加特殊情景的处理器：HTTPCookieProcessor, ProxyHandler, HTTPSHandler, HTTPRedirectHandler</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ur1lib2，cookielib</span><br><span class="line"><span class="comment">#创建cookie容器</span></span><br><span class="line">cj=cookielib.CookieJar()</span><br><span class="line"><span class="comment">#创建1个opener opener=ur11ib2.build_opener(ur1lib2.HTTPCookieProcessor(cj)</span></span><br><span class="line"><span class="comment">#给ur11ib2安装opener ur1lib2.install_opener(opener)</span></span><br><span class="line"><span class="comment">#使用带有cookie的ur11ib2访问网页</span></span><br><span class="line">response=url1ib2.urlopen(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>三种方法的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line">ur1=<span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span><span class="string">&#x27;第一种方法’</span></span><br><span class="line"><span class="string">response1=ur11ib2.urlopen(ur1)</span></span><br><span class="line"><span class="string">print responsel.getcode()</span></span><br><span class="line"><span class="string">print len(response1.read())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print“第二种方法”</span></span><br><span class="line"><span class="string">request=ur1lib2.Request(url)</span></span><br><span class="line"><span class="string">request.add_header(&quot;user-agent&quot;，&quot;Mozilla/5.e&quot;)</span></span><br><span class="line"><span class="string">response2=ur11ib2.urlopen(request)</span></span><br><span class="line"><span class="string">print response2.getcode()</span></span><br><span class="line"><span class="string">print len(response2.read())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">print‘第三种方法’</span></span><br><span class="line"><span class="string">cj=cookielib.CookieJar()</span></span><br><span class="line"><span class="string">opener=ur11ib2.build_opener(ur11ib2.HTTPCookieProcessor(cj))</span></span><br><span class="line"><span class="string">ur11ib2.install_opener(opener)</span></span><br><span class="line"><span class="string">response3=ur11ib2.urlopen(ur1)</span></span><br><span class="line"><span class="string">print response3.getcode()</span></span><br><span class="line"><span class="string">print cj</span></span><br><span class="line"><span class="string">print response3.read()</span></span><br></pre></td></tr></table></figure>


<h2 id="网页解析器"><a href="#网页解析器" class="headerlink" title="网页解析器"></a>网页解析器</h2><h3 id="Python有哪几种网页解析器？"><a href="#Python有哪几种网页解析器？" class="headerlink" title="Python有哪几种网页解析器？"></a>Python有哪几种网页解析器？</h3><ul>
<li>正则表达式： 模糊匹配</li>
<li>html.parser： 结构化解析</li>
<li>Beautiful Soup： 结构化解析</li>
<li>lxml ： 结构化解析</li>
</ul>
<h2 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h2><p>-安装：pip install beautifulsoup4<br>-测试：import bs4</p>
<h3 id="解析步骤"><a href="#解析步骤" class="headerlink" title="解析步骤"></a>解析步骤</h3><ul>
<li>创建 BeautifulSoup对象</li>
<li>搜索节点 find all、find<ul>
<li> 按节点名称</li>
<li> 按节点属性值</li>
<li> 按节点文字</li>
</ul>
</li>
<li>访问节点： 名称、属性、文字</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment">#根据HTML网页字符串创建Beautifulsoup对象</span></span><br><span class="line">soup=BeautifulSoup(</span><br><span class="line">    html_doc，<span class="comment">#HTML文档字符串</span></span><br><span class="line">    <span class="string">&#x27;html.parse&#x27;</span>,  <span class="comment">#HTML解析器</span></span><br><span class="line">    from_encoding=‘utf8<span class="string">&#x27; #HTML文档的编码</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#方法：find_all(name，attrs，string)</span></span><br><span class="line"><span class="string">#查找所有标签为a的节点</span></span><br><span class="line"><span class="string">soup.find_all(&#x27;</span>a<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">#查找所有标签为a，链接符合/view/123.htm形式的节点soup.find_all(a&#x27;</span>，href=/view/<span class="number">123.</span>htm<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">soup.find_all(&#x27;</span>a<span class="string">&#x27;，href=re.compile(r&quot;/view/\d+\.html&quot;))</span></span><br><span class="line"><span class="string">#查找所有标签为div，class为abc，文字为Python的节点</span></span><br><span class="line"><span class="string">soup.find_all(div&#x27;</span>，class_=‘abc<span class="string">&#x27;，string=‘Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#得到节点：&lt;a href=‘1.htm12&gt;Python&lt;/a&gt;</span></span><br><span class="line"><span class="comment">#获取查找到的节点的标签名称</span></span><br><span class="line">node.name</span><br><span class="line"><span class="comment">#获取查找到的a节点的href属性</span></span><br><span class="line">node[‘href2]</span><br><span class="line"><span class="comment">#获取查找到的a节点的链接文字</span></span><br><span class="line">node.get_text()</span><br></pre></td></tr></table></figure>


<h2 id="Beautiful-Soup实例"><a href="#Beautiful-Soup实例" class="headerlink" title="Beautiful Soup实例"></a>Beautiful Soup实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">soup=BeautifulSoup ( html_doc，‘html.parse<span class="string">r&#x27;，from_encoding=&#x27;</span>utf-<span class="number">8</span><span class="string">&#x27; )</span></span><br><span class="line"><span class="string">print‘获取所有的链接”</span></span><br><span class="line"><span class="string">1inks=soup.find_all ( &#x27;</span>a<span class="string">&#x27; )</span></span><br><span class="line"><span class="string">for link in links：print link.name，link[&#x27;</span>hre<span class="string">f&#x27;]，link.get_text ( )</span></span><br><span class="line"><span class="string">print‘获取Lacie的链接’</span></span><br><span class="line"><span class="string">link node =soup.find ( &#x27;</span>a<span class="string">&#x27;，href=&#x27;</span>http://example.com/Lacie<span class="string">&#x27; )</span></span><br><span class="line"><span class="string">print link_node.name，link_node[&#x27;</span>hre<span class="string">f&#x27;]，link_node.get_text ( )</span></span><br><span class="line"><span class="string">print &#x27;</span>正则匹配<span class="string">&#x27;</span></span><br><span class="line"><span class="string">link_node=soup.find(&#x27;</span>a<span class="string">&#x27;,href=re.compile(r&quot;ill&quot;))</span></span><br><span class="line"><span class="string">print‘获P段落文字</span></span><br><span class="line"><span class="string">pnode=soup.find ( &#x27;</span>p<span class="string">&#x27;，class_=&quot;title&quot; )</span></span><br><span class="line"><span class="string">print p_node.name，p_nodel.get_text ( )</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Python+urllib2+BeautifulSoup%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/" data-id="ckqg285tw0027rcfp557g158d" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/Oracle札记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Oracle%E6%9C%AD%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.798Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="instantclient-连接PL-SQL-Develop"><a href="#instantclient-连接PL-SQL-Develop" class="headerlink" title="instantclient 连接PL/SQL Develop"></a>instantclient 连接PL/SQL Develop</h2><ul>
<li>win8<br>可以使用 instantclient_10_2，  instantclient_11_2没有试过。</li>
</ul>
<ul>
<li>win10<br>只能使用 instantclient_11_2，且需要安装 <a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/download/details.aspx?id=18471">Microsoft Visual Studio 2005 Redistributable</a></li>
</ul>
<p>-步骤<br>    - TNS_ADMIN=D:\dev\instantclient_11_2</p>
<pre><code>- 加  D:\dev\instantclient_11_2 到  Path中

- 配置 NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK

- 编写tnsnames.ora
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ORCL =</span><br><span class="line"></span><br><span class="line">  (DESCRIPTION =</span><br><span class="line"></span><br><span class="line">    (ADDRESS_LIST =</span><br><span class="line"></span><br><span class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.106)(PORT = 1521))</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line"></span><br><span class="line">      (SERVICE_NAME = orcl)</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>- 在PLSQL Developer中设置Oracle_Home和OCI Library：
</code></pre>
<p>Tools -&gt; Preferences -&gt; Oracle -&gt; Connection：</p>
<p>Oracle_Home： D:\dev\instantclient_11_2</p>
<p>OCI Library： D:\dev\instantclient_11_2\oci.dll</p>
<h2 id="创建表空间和用户"><a href="#创建表空间和用户" class="headerlink" title="创建表空间和用户"></a>创建表空间和用户</h2><p>create temporary tablespace ts_snhb_tmp<br>tempfile ‘/opt/oracle/oradata/oracle10g/snhb_tmp.dbf’<br>size 50m<br>autoextend on<br>next 50m maxsize 20480m<br>extent management local;</p>
<p>create tablespace ts_snhb<br>logging<br>datafile ‘/opt/oracle/oradata/oracle10g/snhb.dbf’<br>size 50m<br>autoextend on<br>next 50m maxsize 20480m<br>extent management local;</p>
<p>create user snhb identified by snhb<br>default tablespace ts_snhb<br>temporary tablespace ts_snhb_tmp;</p>
<p>grant connect,resource,dba to snhb;<br>grant all privileges to snhb;</p>
<p>– resource is a role in oracle, which gives you the right to create objects (tables, procedures, some more but no views!). ALL PRIVILEGES grants a lot more of system privileges.</p>
<h2 id="查看oracle数据库-database-的版本命令"><a href="#查看oracle数据库-database-的版本命令" class="headerlink" title="查看oracle数据库(database)的版本命令"></a>查看oracle数据库(database)的版本命令</h2><p>在sqlplus下输入以下任意一个语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v$version;</span><br><span class="line"></span><br><span class="line">SQL&gt; select version from v$instance;</span><br><span class="line"></span><br><span class="line">SQL&gt; Select version FROM Product_component_version   Where SUBSTR(PRODUCT,1,6)=&#x27;Oracle&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Oracle锁表"><a href="#Oracle锁表" class="headerlink" title="Oracle锁表"></a>Oracle锁表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.SID,</span><br><span class="line">       s.serial#,</span><br><span class="line">       s.USERNAME,</span><br><span class="line">       s.machine,</span><br><span class="line">       s.OSUSER,</span><br><span class="line">       s.PROGRAM,</span><br><span class="line">       l.locked_mode,</span><br><span class="line">       o.OBJECT_NAME,</span><br><span class="line">       a.sql_text</span><br><span class="line"><span class="keyword">from</span> v$session s, v$locked_object l, v$sqlarea a, dba_objects o</span><br><span class="line"><span class="keyword">where</span> l.session_id <span class="operator">=</span> s.sid</span><br><span class="line">   <span class="keyword">and</span> s.prev_sql_addr <span class="operator">=</span> a.address</span><br><span class="line">   <span class="keyword">and</span> o.object_id <span class="operator">=</span> l.object_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> sid, s.serial#;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shenckicc/p/5458574.html">https://www.cnblogs.com/shenckicc/p/5458574.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dgq-blog/p/9243196.html">https://www.cnblogs.com/dgq-blog/p/9243196.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/su1643/p/6598571.html">https://www.cnblogs.com/su1643/p/6598571.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Oracle%E6%9C%AD%E8%AE%B0/" data-id="ckqg285tw0026rcfp1r68453a" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/OAuth2认证" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/OAuth2%E8%AE%A4%E8%AF%81/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.797Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>参考：<br><a target="_blank" rel="noopener" href="http://blog.csdn.net/seccloud/article/details/8192707">帮你深入理解OAuth2.0协议</a><br><a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/blog/2038646">OAuth2集成——《跟我学Shiro》</a></p>
<h1 id="一、OAuth基础"><a href="#一、OAuth基础" class="headerlink" title="一、OAuth基础"></a>一、OAuth基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>目前实现开放授权的方法分为两种：一种是使用OAuth协议[1]；另一种是使用IAM服务[2]。OAuth协议主要适用于针对个人用户对资源的开放授权，比如Google的用户Alice。OAuth的特点是“现场授权”或“在线授权”：客户端主要通过浏览器去访问资源，授权时需要认证Alice的资源所有者身份，并且需要Alice现场审批。OAuth一般在SNS服务中广泛使用，如微博。IAM服务则不同，它的特点是“预先授权”或“离线授权”：客户端主要通过REST API方式去访问资源，资源所有者可以预先知道第三方应用所需要的资源请求，一次授权之后，很少会变更。IAM服务一般在云计算服务中使用，如AWS服务、阿里云计算服务。</p>
<h2 id="OAuth角色"><a href="#OAuth角色" class="headerlink" title="OAuth角色"></a>OAuth角色</h2><ul>
<li><strong>资源拥有者（resource owner）</strong>：能授权访问受保护资源的一个实体，可以是一个人，那我们称之为最终用户；如新浪微博用户zhangsan；</li>
<li><strong>资源服务器（resource server）</strong>：存储受保护资源，客户端通过access token请求资源，资源服务器响应受保护资源给客户端；存储着用户zhangsan的微博等信息。</li>
<li><strong>授权服务器（authorization server）</strong>：成功验证资源拥有者并获取授权之后，授权服务器颁发授权令牌（Access Token）给客户端。</li>
<li><strong>客户端（client）</strong>：如新浪微博客户端weico、微格等第三方应用，也可以是它自己的官方应用；其本身不存储资源，而是资源拥有者授权通过后，使用它的授权（授权令牌）访问受保护资源，然后客户端把相应的数据展示出来/提交到服务器。“客户端”术语不代表任何特定实现（如应用运行在一台服务器、桌面、手机或其他设备）。</li>
</ul>
<h3 id="OAuth协议流程"><a href="#OAuth协议流程" class="headerlink" title="OAuth协议流程"></a>OAuth协议流程</h3><p><img src="_v_images/2019-11-29-17-53-50.png"></p>
<ol>
<li>客户端从资源拥有者那请求授权。授权请求可以直接发给资源拥有者，或间接的通过授权服务器这种中介，后者更可取。</li>
<li>客户端收到一个授权许可，代表资源服务器提供的授权。</li>
<li>客户端使用它自己的私有证书及授权许可到授权服务器验证。</li>
<li>如果验证成功，则下发一个访问令牌。</li>
<li>客户端使用访问令牌向资源服务器请求受保护资源。</li>
<li>资源服务器会验证访问令牌的有效性，如果成功则下发受保护资源。</li>
</ol>
<h2 id="授权类型"><a href="#授权类型" class="headerlink" title="授权类型"></a>授权类型</h2><ul>
<li>授权码 (Authorization Code Grant)、 – 最核心、最难理解、也是最广泛使用的一种授权类型</li>
<li>隐式授权 (Implicit Grant)、</li>
<li>RO凭证授权 (Resource Owner Password Credentials Grant)、</li>
<li>Client凭证授权 (Client Credentials Grant)。</li>
</ul>
<h1 id="二、Session-Authentication-vs-Token-Authentication"><a href="#二、Session-Authentication-vs-Token-Authentication" class="headerlink" title="二、Session Authentication vs Token Authentication"></a>二、Session Authentication vs Token Authentication</h1><p>参考： <a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/81756/session-authentication-vs-token-authentication">Session Authentication vs Token Authentication</a><br><a target="_blank" rel="noopener" href="http://www.baeldung.com/spring-security-session">Control the Session with Spring Security</a></p>
<ol>
<li>In <strong>Session-based Authentication</strong> the Server does all the heavy lifting server-side. Broadly speaking a client authenticates with its credentials and receives a session_id (which can be stored in a cookie) and attaches this to every subsequent outgoing request. So this could be considered a “token” as it is the equivalent of a set of credentials. There is however nothing fancy about this session_id-String. It is just an identifier and the server does everything else. It is stateful. It associates the identifier with a user account (e.g. in memory or in a database). It can restrict or limit this session to certain operations or a certain time period and can invalidate it if there are security concern and more importantly it can do and change all of this on the fly. Furthermore it can log the users every move on the website(s). Possible disadvantages are bad scale-ability (especially over more than one server farm) and extensive memory usage.</li>
<li>In <strong>Token-based Authentication</strong> no session is persisted server-side (stateless). The initial steps are the same. Credentials are exchanged against a token which is then attached to every subsequent request (It can also be stored in a cookie). However for the purpose of decreasing memory usage, easy scale-ability and total flexibility (tokens can be exchanged with another client) a string with all the necessary information is issued (the token) which is checked after each request made by the client to the server. There are a number of ways to use/ create tokens:</li>
</ol>
<ul>
<li>a) using a hash mechanism e.g. HMAC-SHA1<blockquote>
<p>token = user_id|expiry_date|HMAC(user_id|expiry_date, k)</p>
</blockquote>
</li>
<li>-id and expiry_id are sent in plaintext with the resulting hash attached (k is only know to the server)</li>
</ul>
<ul>
<li>b) encrypting the token symmetrically e.g. with AES<blockquote>
<p>token = AES(user_id|expiry_date, x)</p>
</blockquote>
</li>
<li>-x represents the en-/decryption key</li>
</ul>
<ul>
<li>c) encrypting it asymmetrically e.g. with RSA<blockquote>
<p>token = RSA(user_id|expiry_date, private key)</p>
</blockquote>
</li>
</ul>
<p><strong>Productive systems</strong> are usually more complex than those two archetypes. Amazon for example uses both mechanisms on its website. Also hybrids can be used to issue tokens as described in 2 and also associate a user session with it for user tracking or possible revocation and still retain the client flexibility of classic tokens. Also OAuth 2.0 uses short-lived and specific bearer-tokens and longer-lived refresh tokens e.g. to get bearer-tokens.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/OAuth2%E8%AE%A4%E8%AF%81/" data-id="ckqg285tv0025rcfpgvf45ff3" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/Nginx反向代理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.796Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Location指令URI匹配规则"><a href="#Location指令URI匹配规则" class="headerlink" title="Location指令URI匹配规则"></a>Location指令URI匹配规则</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tzy233/article/details/79780444">Nginx的location规则：优先级和路径替换</a></p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>proxy_pass的目标地址，默认不带/，表示只代理域名，url和querystring部分不会变（把请求的path拼接到proxy_pass目标域名之后作为代理的URL）</p>
<p>如果在目标地址后增加/，则表示把path中location匹配成功的部分剪切掉之后再拼接到proxy_pass目标地址</p>
<p>比如请求 /a/b.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /a &#123;</span><br><span class="line">    proxy_pass http://server;</span><br><span class="line">&#125;</span><br><span class="line">location /a &#123;</span><br><span class="line">    proxy_pass http://server/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上两个匹配成功后，实际代理的目标url分别是<br><a target="_blank" rel="noopener" href="http://server/a/b.html">http://server/a/b.html</a> (把/a/b.html拼接到<a target="_blank" rel="noopener" href="http://server之后/">http://server之后</a>)<br><a target="_blank" rel="noopener" href="http://server/b.html">http://server/b.html</a> (把/a/b.html的/a去掉之后，拼接到<a target="_blank" rel="noopener" href="http://server/%E4%B9%8B%E5%90%8E">http://server/之后</a>)</p>
<h2 id="反向代理VS正向代理"><a href="#反向代理VS正向代理" class="headerlink" title="反向代理VS正向代理"></a>反向代理VS正向代理</h2><p><img src="_v_images/2019-11-29-17-56-20.png"></p>
<p><img src="_v_images/2019-11-29-17-56-28.png"></p>
<p>正向代理中，proxy和client同属一个LAN；它是代理客户端，为客户端收发请求，使真实客户端对服务器不可见。其是<strong>从内到外</strong>。<br>反向代理中，proxy和server同属一个LAN；它是代理(v)服务器，为服务器收发请求，使真实服务器对客户端不可见。”反向”这个词在这儿的意思其实是指方向相反，即代理把来自外网client的请求forward到内网server，<strong>从外到内</strong>。<br>因为服务对象和自身角色不同，所以刚好是相反的。</p>
<h2 id="反向代理两种用途"><a href="#反向代理两种用途" class="headerlink" title="反向代理两种用途"></a>反向代理两种用途</h2><h3 id="1、作内容服务器的替身"><a href="#1、作内容服务器的替身" class="headerlink" title="1、作内容服务器的替身"></a>1、作内容服务器的替身</h3><p><img src="_v_images/2019-11-29-17-56-36.png"></p>
<h3 id="2、作为内容服务器的负载均衡器"><a href="#2、作为内容服务器的负载均衡器" class="headerlink" title="2、作为内容服务器的负载均衡器"></a>2、作为内容服务器的负载均衡器</h3><p>可以在一个组织内使用多个代理服务器来平衡各 Web 服务器间的网络负载。在此模型中，可以利用代理服务器的高速缓存特性，创建一个用于负载平衡的服务器池。此时，代理服务器可以位于防火墙的任意一侧。如果 Web 服务器每天都会接收大量的请求，则可以使用代理服务器分担 Web 服务器的负载并提高网络访问效率。</p>
<p>对于客户机发往真正服务器的请求，代理服务器起着中间调停者的作用。代理服务器会将所请求的文档存入高速缓存。如果有不止一个代理服务器，DNS 可以采用“循环复用法”选择其 IP 地址，随机地为请求选择路由。客户机每次都使用同一个 URL，但请求所采取的路由每次都可能经过不同的代理服务器。</p>
<p><img src="_v_images/2019-11-29-17-56-45.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" data-id="ckqg285tv0024rcfp8on6g0pw" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/19/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%8C%87%E5%BC%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%93%81%E8%B7%AF6C%E4%B8%9A%E5%8A%A1%E7%BB%93%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E7%AB%99%E7%94%9F%E4%BA%A7%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E5%8E%82%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>