<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/12/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-backend/Linux/CentOS7下安装jdk和groovy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/backend/Linux/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85jdk%E5%92%8Cgroovy/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:11.074Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="删除原有的OpenJDK的JRE"><a href="#删除原有的OpenJDK的JRE" class="headerlink" title="删除原有的OpenJDK的JRE"></a>删除原有的OpenJDK的JRE</h1><p>centos7自带只有OpenJDK的JRE，没有JDK。JRE和JDK默认被安装在 <code>/usr/lib/jvm</code> 目录下</p>
<ol>
<li><p>查看系统是否安装过java<br><code>[root@localhost home]# yum list installed | grep java</code></p>
</li>
<li><p>如果有旧版本的java，可以用如下方法卸载java<br><code>[root@localhost home]# yum -y remove java-1.8.0-openjdk*</code></p>
</li>
<li><p>查看java软件包列表<br><code>[root@localhost home]# yum -y list java*</code></p>
</li>
</ol>
<h2 id="安装OpenJDK"><a href="#安装OpenJDK" class="headerlink" title="安装OpenJDK"></a>安装OpenJDK</h2><p>这部分可选。（由于Oracle的OpenJDK在6个月后，会被强制要求升级到JDK11，所以不推荐安装）</p>
<ol start="4">
<li>下载安装java1.8的所有软件包，中途需要输入y来确认下载。<br><code>[root@localhost home]# yum installjava-1.8.0-openjdk*</code></li>
</ol>
<p>5.安装成功，输入如下命令检查是否安装成功，如果返回正确的版本号则表示安装成功。<br><code>[root@localhost home]#  java -version</code></p>
<h1 id="安装-Amazon-Corretto-JDK-8"><a href="#安装-Amazon-Corretto-JDK-8" class="headerlink" title="安装 Amazon Corretto JDK 8"></a>安装 Amazon Corretto JDK 8</h1><p><a target="_blank" rel="noopener" href="https://docs.aws.amazon.com/zh_cn/corretto/latest/corretto-8-ug/generic-linux-install.html">Corretto JDK官方安装说明</a></p>
<p>Corretto JDK 是 OpenJDK的分支，更新比较及时，推荐使用。</p>
<p>要将 Corretto RPM 存储库与 yum 软件包管理器（例如 Amazon Linux AMI）一起使用，请导入 Corretto 公有密钥，然后将存储库添加到系统列表中。对于大多数系统，您必须运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://yum.corretto.aws/corretto.key </span><br><span class="line">sudo curl -L -o /etc/yum.repos.d/corretto.repo https://yum.corretto.aws/corretto.repo</span><br></pre></td></tr></table></figure>

<p>添加存储库后，您可以运行以下命令来安装 Corretto 8：</p>
<p><code>sudo yum install -y java-1.8.0-amazon-corretto-devel</code></p>
<p>验证安装<br><code>java -version</code></p>
<h1 id="安装Groovy"><a href="#安装Groovy" class="headerlink" title="安装Groovy"></a>安装Groovy</h1><p>Simply open a new terminal and enter:<br><code>curl -s get.sdkman.io | bash</code></p>
<p>Open a new terminal or type the command:<br><code>source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;</code></p>
<p>Then install the latest stable Groovy:<br><code>sdk install groovy</code></p>
<p>After installation is complete and you’ve made it your default version, test it with:</p>
<p>$ groovy -v</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/backend/Linux/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85jdk%E5%92%8Cgroovy/" data-id="ckqg285v2004orcfpglsfh5ja" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-backend/Linux/CentOS7下安装docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/backend/Linux/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85docker/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:11.073Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yufeng218/p/8370670.html">Centos7上安装docker</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/centos/#install-docker-ce">Install Docker CE for GentOS</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/we_shell/article/details/38368137">Docker学习笔记(2)–Docker常用命令</a></p>
<p>1、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span></span><br></pre></td></tr></table></figure>
<p>2、设置yum源</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>
<p>3、可以查看所有仓库中所有docker版本，并选择特定版本安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum list docker-ce --showduplicates | sort -r</span></span><br></pre></td></tr></table></figure>
<p>4、安装docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install docker-ce <span class="comment">#由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install &lt;FQPN&gt; <span class="comment"># 例如：sudo yum install docker-ce-17.12.0.ce</span></span></span><br></pre></td></tr></table></figure>
<p>5、启动并加入开机启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl start docker</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl <span class="built_in">enable</span> docker</span></span><br></pre></td></tr></table></figure>
<p>6、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker version</span></span><br></pre></td></tr></table></figure>

<h2 id="docker容器网络无法访问"><a href="#docker容器网络无法访问" class="headerlink" title="docker容器网络无法访问"></a>docker容器网络无法访问</h2><p>docker网络原理：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37423198/article/details/78682404">Docker学习笔记(4)——Docker网络配置</a></p>
<p>采用默认的网桥模式网络。需要修改宿主机配置：<br>在/etc/sysctl.conf文件中加入以下两行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.all.disable_ipv6=1    # 停止ipv6</span><br><span class="line">net.ipv4.ip_forward=1    # docker网络转发</span><br></pre></td></tr></table></figure>
<p>重启网络： service network restart</p>
<h2 id="改变docker的image存放目录"><a href="#改变docker的image存放目录" class="headerlink" title="改变docker的image存放目录"></a>改变docker的image存放目录</h2><p>steps:</p>
<ol>
<li>mkdir /data/docker（你想要docker存放image的目录）</li>
<li>systemctl stop docker</li>
<li>vi /usr/lib/systemd/system/docker.service</li>
<li>添加 -g /data/docker<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">...</span><br><span class="line">ExecStart=/usr/bin/docker daemon -g /data/docker</span><br><span class="line">...</span><br><span class="line">[Install]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>cp -R /var/lib/docker/* /data/docker/</li>
<li>systemctl daemon-reload</li>
<li>systemctl start docker</li>
</ol>
<h2 id="安装oracle-xe镜像"><a href="#安装oracle-xe镜像" class="headerlink" title="安装oracle-xe镜像"></a>安装oracle-xe镜像</h2><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xp541130126/article/details/70138904">mac os下使用 Docker安装oracle-xe-11g数据库</a><br>可以在 <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a> 搜索自己需要的image。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索包括oracle的image， 选择镜像：alexeiled/docker-oracle-xe-11g</span></span><br><span class="line">docker search oracle</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像</span></span><br><span class="line">docker pull alexeiled/docker-oracle-xe-11g</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动镜像为一个容器，并命名为oracle</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker run -h <span class="string">&quot;oracle&quot;</span> --name <span class="string">&quot;oracle&quot;</span> -d -p 49160:22 -p 49161:1521 -p 49162:8080 alexeiled/docker-oracle-xe-11g</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 映射端口时，指定了ip，那么宿主机采用ipv4，否则采用ipv6，为了减少麻烦，最好指定ip，ip不要设成127.0.0.1，否则外网无法访问</span></span><br><span class="line">docker run -h &quot;oracle_xe_1&quot; --name &quot;oracle_xe_1&quot; -d -p 192.168.31.200:49150:22 -p 192.168.31.200:49151:1521 -p 192.168.31.200:49152:8080 alexeiled/docker-oracle-xe-11g</span><br></pre></td></tr></table></figure>
<p>oracle express版本是免费的开发版，它的主要限制是数据库的大小最大1G，和一些性能的限制。</p>
<ul>
<li><p>此镜像的oracle数据库连接信息</p>
<ul>
<li>hostname:  宿主机IP</li>
<li>port: 49161</li>
<li>sid: xe</li>
<li>username: system / oracle</li>
<li>username: sys / oracle</li>
</ul>
</li>
<li><p>ubuntu的帐户： root / admin</p>
</li>
<li><p>进入docker容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> -it &lt;CONTAINER&gt; &lt;COMMAND&gt;</span></span><br><span class="line">docker exec -it 0deb75d61474 /bin/bash</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xhyan/p/6593075.html">Docker容器进入的4种方式</a></p>
</li>
</ul>
<h2 id="安装oracle企业版镜像"><a href="#安装oracle企业版镜像" class="headerlink" title="安装oracle企业版镜像"></a>安装oracle企业版镜像</h2><ul>
<li>wget 下载oracle安装文件<br>登录oracle官网，得到下载链接，类似：<a target="_blank" rel="noopener" href="http://download.oracle.com/otn/linux/oracle11g/R2/linux.x64_11gR2_database_1of2.zip?AuthParam=1528547837_6e9ab74583f4c5b6b8bc7256af0436be">http://download.oracle.com/otn/linux/oracle11g/R2/linux.x64_11gR2_database_1of2.zip?AuthParam=1528547837_6e9ab74583f4c5b6b8bc7256af0436be</a><br>用下面命令下载即可<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --limit-rate=2M &quot;http://download.oracle.com/otn/linux/oracle11g/R2/linux.x64_11gR2_database_1of2.zip?AuthParam=1528547837_6e9ab74583f4c5b6b8bc7256af0436be&quot;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/backend/Linux/CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85docker/" data-id="ckqg285v2004nrcfp7uk78wqk" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-backend/Linux/03-Linux学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/backend/Linux/03-Linux%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:11.072Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Linux-统计文件夹下文件个数及目录个数"><a href="#Linux-统计文件夹下文件个数及目录个数" class="headerlink" title="Linux 统计文件夹下文件个数及目录个数"></a>Linux 统计文件夹下文件个数及目录个数</h3><ol>
<li><p>统计文件夹下文件的个数<br><code>ls -l | grep &quot;^-&quot; | wc -l</code></p>
</li>
<li><p>统计文件夹下目录的个数<br><code>ls -l | grep &quot;^d&quot; | wc -l</code></p>
</li>
<li><p>统计文件夹下文件个数，包括子文件<br><code>ls -lR | grep &quot;^-&quot; | wc -l</code></p>
</li>
<li><p>统计文件夹下目录个数，包括子目录<br><code>ls -lR | grep &quot;^d&quot; | wc -l</code></p>
</li>
</ol>
<p>wc命令： (Word Count)功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。</p>
<p>wc [-lcw]</p>
<p>-c 统计字节数<br>-l 统计行数<br>-m 统计字符数，此标志不能与-c标志一起使用<br>-w 统计字数。一个字定义为由空白、跳格或换行字符分隔的字符串</p>
<h3 id="使用ps-awk杀死进程"><a href="#使用ps-awk杀死进程" class="headerlink" title="使用ps/awk杀死进程"></a>使用ps/awk杀死进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Grabs and <span class="built_in">kill</span> a process from the pidlist that has the word myapp</span></span><br><span class="line">​</span><br><span class="line">pid=`ps aux | grep myapp | awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">kill -9 $pid</span><br></pre></td></tr></table></figure>

<h3 id="查看程序端口占用情况"><a href="#查看程序端口占用情况" class="headerlink" title="查看程序端口占用情况"></a>查看程序端口占用情况</h3><p>netstat   -anp   |   grep  portno<br>即：netstat –apn | grep 8080</p>
<p>其中最后一栏是 * PID/Program name *</p>
<h3 id="查看linux磁盘空间容量"><a href="#查看linux磁盘空间容量" class="headerlink" title="查看linux磁盘空间容量"></a>查看linux磁盘空间容量</h3><p>查看磁盘使用情况<br>df -lh</p>
<p>查看目录的磁盘占用情况<br>du -sh * | sort -h</p>
<p>crontab</p>
<p>Ubuntu查看crontab运行日志</p>
<p>修改rsyslog文件，将/etc/rsyslog.d/50-default.conf 文件中的#cron.*前的#删掉；<br>重启rsyslog服务service rsyslog restart；<br>重启cron服务service cron restart</p>
<h3 id="linux下ssh客户端以及sftp文件传送的一般用法"><a href="#linux下ssh客户端以及sftp文件传送的一般用法" class="headerlink" title="linux下ssh客户端以及sftp文件传送的一般用法"></a>linux下ssh客户端以及sftp文件传送的一般用法</h3><p>linux下ssh客户端以及sftp文件传送的一般用法</p>
<p>   以前在windows上，我要用ssh连接服务器，我一般都用putty。<br>    这段时间一直在linux上工作，由于linux上一般都自带ssh客户端，也就是ssh命令了，此外还有一个命令sftp，用来安全的传送文件，今天为了管理linux服务器，用到了linux下的这两个命令行工具，现就其最常用的用法描述如下：<br>    假定服务器ip为61.145.34.33，ssh服务的端口号为9186，服务器上有个用户为sshuser；<br>    用ssh登录服务器的命令为：<br>    &gt;ssh -l sshuser 61.145.34.33 -p 9186<br>    回车后，如果是第一次登录，会提示你一条认证信息，你键入yes即可，接着输入服务器sshuser的密码登录即可；</p>
<pre><code>用sftp登录服务器的命令为：
&gt;sftp -oPort=9186 sshuser@61.145.34.33
回车后，输入服务器sshuser的密码登录，然后会显示一个sftp&gt;的环境，这个时候，键入help你会看到所有命令的帮助，跟ftp命令行工具非常类似，比如get,put等等。

至于这两个命令行的其他用法，可参看其联机手册... 
</code></pre>
<h3 id="修改home下的中文目录为英文目录"><a href="#修改home下的中文目录为英文目录" class="headerlink" title="修改home下的中文目录为英文目录"></a>修改home下的中文目录为英文目录</h3><p>在终端下输入命令：<br>     export LANG=en_US<br>     xdg-user-dirs-gtk-update<br>这个时候会弹出一个配置界面，提示是否将中文目录切换为英文目录。选中不再提示，确定。系统会删除没有内容的中文目录，而有内容的目录会保持。并创建8个相应的英文目录如下：“Desktop”、“Download”、“Templates”、“Public”、“Documents”、“Music”、“Pictures”、“Videos”。此时，您在“位置”里看到的常用中文目录已经变成英文目录。只需要将原中文目录的内容拷贝到相应英文目录，并删除中文目录即可。<br>接下来再执行<br>     export LANG=zh_CN.UTF-8<br>以显示中文。</p>
<p>OK，行了，三个命令就行。可就为一次改变要记三个命令，也麻烦。能不能不记啦。当然可以，那您注销，然后在登录界面选择语言种类为“English(united states)”，进入系统后你就发现整个系统都变成English了，同时还会弹出一个对话框提示是否切换用户目录，选择“Update names”，确认并再注销，在登录界面选择“汉语”，进入系统后事个系统又变成了Chinese了，同样会弹出同一个对话框，选择”Keep old names”。OK，大功告成，一个命令都不需要记，就可完成您想要的结果。</p>
<h3 id="分区方案"><a href="#分区方案" class="headerlink" title="分区方案"></a>分区方案</h3><p>/boot    200M    Linux的内核及引导系统程序所需要的文件，比如 vmlinuz initrd.img文件都位于这个目录中。在一般情况下，GRUB或LILO系统引导管理器也位于这个目录；启动撞在文件存放位置，如kernels，initrd，grub。</p>
<p>/              100G    用于存储系统文件<br>/home    200G    用户工作目录；个人配置文件，如个人环境变量等；所有账号分配一个工作目录。<br>swap是内存的两倍</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find . -name .gradle -exec rm -rf &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">find . -type f -exec ls -l &#123;&#125; \;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="linux解压缩命令"><a href="#linux解压缩命令" class="headerlink" title="linux解压缩命令"></a>linux解压缩命令</h3><p>tar</p>
<p>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件</p>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p>
<p>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出</p>
<p>下面的参数-f是必须的</p>
<p>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p>
<p>压缩</p>
<p>tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg</p>
<p>tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</p>
<p>tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</p>
<p>tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</p>
<p>rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux</p>
<p>zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux</p>
<p>解压</p>
<p>1、*.tar 用 tar –xvf 解压<br>2、*.gz 用 gzip -d或者gunzip 解压<br>3、*.tar.gz和*.tgz 用 tar –xzf 解压<br>4、*.bz2 用 bzip2 -d或者用bunzip2 解压<br>5、*.tar.bz2用tar –xjf 解压<br>6、*.Z 用 uncompress 解压<br>7、*.tar.Z 用tar –xZf 解压<br>8、*.rar 用 unrar e解压<br>9、*.zip 用 unzip 解压</p>
<h3 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a>nohup命令</h3><p>  该命令的一般形式为：<code>nohup command &amp;</code></p>
<p>  如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为 nohup.out的文件中，除非另外指定了输出文件：<br>  <code>nohup command &gt; myout.file 2&gt;&amp;1 &amp;</code><br>  在上面的例子中，输出被重定向到myout.file文件中。<br>  使用 jobs 查看任务。<br>  使用 fg %n 关闭。</p>
<h3 id="添加sudoer"><a href="#添加sudoer" class="headerlink" title="添加sudoer"></a>添加sudoer</h3><p>1）进入超级用户模式。也就是输入”su -“,系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root用）<br>2）添加文件的写权限。也就是输入命令”chmod u+w /etc/sudoers”。<br>3）编辑/etc/sudoers文件。也就是输入命令”vim /etc/sudoers”,输入”i”进入编辑模式，找到这一 行：”root ALL=(ALL) ALL”在起下面添加”xxx ALL=(ALL) ALL”(这里的xxx是你的用户名)，然后保存（就是先按一 下Esc键，然后输入”:wq”）退出。<br>4）撤销文件的写权限。也就是输入命令”chmod u-w /etc/sudoers”。 </p>
<h2 id="Linux的文件权限与目录配置"><a href="#Linux的文件权限与目录配置" class="headerlink" title="Linux的文件权限与目录配置"></a>Linux的文件权限与目录配置</h2><ul>
<li><strong>使用者与群组</strong></li>
</ul>
<p><img src="_v_images/2019-11-18-21-04-32.png"></p>
<p>帐号 –&gt; /etc/passwd<br>密码 –&gt; /etc/shadow<br>group –&gt; /etc/group</p>
<ul>
<li><strong>文件属性</strong></li>
</ul>
<p><img src="_v_images/2019-11-18-21-04-54.png"></p>
<p>系统默认语系 –&gt; /etc/sysconfig/i18n</p>
<p><code>改变文件属怅不权限</code></p>
<ul>
<li>chgrp ：改变所属群组   –&gt; chgrp  groupname filename</li>
<li>chown ：改变拥有者     –&gt; chown [-R] 账号名称 filename/dir;   chown [-R] 账号名称:组名 filename/dir </li>
<li>chmod ：改变权限, SUID, SGID, SBIT 等</li>
</ul>
<p>r:4<br>w:2<br>x:1 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 .bashrc</span><br><span class="line">chmod  u/g/o/a  +/-/=  rwx   filename/dir</span><br><span class="line">chmod  u=rwx,go=rx  .bashrc</span><br></pre></td></tr></table></figure>

<p>将权限去掉而保留已存在的权限？如：要拿掉全部人的可执行权限<br><code>chmod  a-x  .bashrc</code></p>
<p><img src="_v_images/2019-11-18-21-06-39.png"></p>
<ul>
<li><strong>Linux更改文件拥有者|chown命令用法</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.isstudy.com/linux/4123.html">http://www.isstudy.com/linux/4123.html</a></p>
<p>chown [-R] 账户名称：用户组名称、文件或目录</p>
<p>参数：<br>-R ：进行递归的持续更改，即将同子目录下的所有文件、目录都更新问这个用户组。通常用在更改某一目录的情况。<br>范例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> [root@linux ~]#chown bin install.log</span><br><span class="line">[root@linux ~]#ls –l</span><br><span class="line">-rw-r--r--  1  bin  users  24343 Jun 23 08:33  install.log</span><br><span class="line">[root@linux ~]#chown  root:root  install.log</span><br><span class="line">[root@linux ~]#ls  -l</span><br><span class="line"></span><br><span class="line">-rw-r--r--  1  root  root  24343 Jun 23 08:33  install.log</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/backend/Linux/03-Linux%E5%AD%A6%E4%B9%A0/" data-id="ckqg285v2004mrcfpb4x9h1p8" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-backend/Docker使用指南" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/backend/Docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:11.069Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xhyan/p/6593075.html">Docker容器进入的4种方式</a></p>
<h3 id="1-查看docker信息（version、info）"><a href="#1-查看docker信息（version、info）" class="headerlink" title="1. 查看docker信息（version、info）"></a>1. 查看docker信息（version、info）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看docker版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker version</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示docker系统的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker info</span></span><br></pre></td></tr></table></figure>


<h3 id="2-对image的操作（search、pull、images、rmi、history）"><a href="#2-对image的操作（search、pull、images、rmi、history）" class="headerlink" title="2. 对image的操作（search、pull、images、rmi、history）"></a>2. 对image的操作（search、pull、images、rmi、history）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检索image</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker search image_name</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载image</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker pull image_name</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出镜像列表; -a, --all=<span class="literal">false</span> Show all images; --no-trunc=<span class="literal">false</span> Don<span class="string">&#x27;t truncate output; -q, --quiet=false Only show numeric IDs</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string">docker images</span></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="string">docker rmi image_name</span></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 显示一个镜像的历史; --no-trunc=false Don&#x27;</span>t truncate output; -q, --quiet=<span class="literal">false</span> Only show numeric IDs</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker <span class="built_in">history</span> image_name</span></span><br></pre></td></tr></table></figure>


<h3 id="3-启动容器（run）"><a href="#3-启动容器（run）" class="headerlink" title="3. 启动容器（run）"></a>3. 启动容器（run）</h3><p>docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器中运行<span class="string">&quot;echo&quot;</span>命令，输出<span class="string">&quot;hello word&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker run image_name <span class="built_in">echo</span> <span class="string">&quot;hello word&quot;</span></span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 交互式进入容器中</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker run -i -t -v /root/software/:/mnt/software/  image_name /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i：表示以“交互模式”运行容器；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t：表示容器启动后会进入其命令行；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;；</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器中安装新的程序</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker run image_name apt-get install -y app_name</span></span><br><span class="line">Note：  在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker run -d -p 22 -p 58080:8080 learn/tutorial /usr/sbin/sshd -D</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d：表示以“守护模式”执行命令或脚本，此时 Tomcat 控制台不会出现在输出终端上。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p：表示宿主机与容器的端口映射，此时将容器内部的 8080 端口映射为宿主机的 58080 端口。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name：表示容器名称，用一个有意义的名称命名即可。</span></span><br></pre></td></tr></table></figure>
<h3 id="4-查看容器（ps）"><a href="#4-查看容器（ps）" class="headerlink" title="4. 查看容器（ps）"></a>4. 查看容器（ps）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出当前所有正在运行的container</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker ps</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有的container</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker ps -a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出最近一次启动的container</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker ps -l</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在docker容器内查看ip</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip addr show eth0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ip route</span></span><br></pre></td></tr></table></figure>


<h3 id="5-保存对容器的修改（commit）"><a href="#5-保存对容器的修改（commit）" class="headerlink" title="5. 保存对容器的修改（commit）"></a>5. 保存对容器的修改（commit）</h3><p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存对容器的修改; -a, --author=<span class="string">&quot;&quot;</span> Author; -m, --message=<span class="string">&quot;&quot;</span> Commit message</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker commit ID new_image_name</span></span><br><span class="line">Note：  image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。</span><br></pre></td></tr></table></figure>
<h3 id="6-对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）"><a href="#6-对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）" class="headerlink" title="6. 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）"></a>6. 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker rm `docker ps -a -q`</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除单个容器; -f, --force=<span class="literal">false</span>; -l, --link=<span class="literal">false</span> Remove the specified link and not the underlying container; -v, --volumes=<span class="literal">false</span> Remove the volumes associated to the container</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker rm Name/ID</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止、启动、杀死一个容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker stop Name/ID</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker start Name/ID</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker <span class="built_in">kill</span> Name/ID</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从一个容器中取日志; -f, --follow=<span class="literal">false</span> Follow <span class="built_in">log</span> output; -t, --timestamps=<span class="literal">false</span> Show timestamps</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker logs Name/ID</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker diff Name/ID</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示一个运行的容器里面的进程信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker top Name/ID</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从容器里面拷贝文件/目录到本地一个路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker cp Name:/container_path to_path</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker cp ID:/container_path to_path</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop <span class="keyword">for</span> before killing the container, Default=10</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker restart Name/ID</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入一个已经在运行的容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it 775c7c9ee1e1 /bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [attach] Attach <span class="built_in">local</span> standard input, output, and error streams to a running container.</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是一个过时的命令，不建议使用</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker attach ID</span></span><br></pre></td></tr></table></figure>


<h3 id="7-保存和加载镜像（save、load）"><a href="#7-保存和加载镜像（save、load）" class="headerlink" title="7. 保存和加载镜像（save、load）"></a>7. 保存和加载镜像（save、load）</h3><p>当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存镜像到一个tar包; -o, --output=<span class="string">&quot;&quot;</span> Write to an file</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker save image_name -o file_path</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载一个tar包格式的镜像; -i, --input=<span class="string">&quot;&quot;</span> Read from a tar archive file</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker load -i file_path</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 机器a</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker save image_name &gt; /home/save.tar</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用scp将save.tar拷到机器b上，然后：</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker load &lt; /home/save.tar</span></span><br></pre></td></tr></table></figure>


<h3 id="8、-登录registry-server（login）"><a href="#8、-登录registry-server（login）" class="headerlink" title="8、 登录registry server（login）"></a>8、 登录registry server（login）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登陆registry server; -e, --email=<span class="string">&quot;&quot;</span> Email; -p, --password=<span class="string">&quot;&quot;</span> Password; -u, --username=<span class="string">&quot;&quot;</span> Username</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker login</span></span><br></pre></td></tr></table></figure>


<h3 id="9-发布image（push）"><a href="#9-发布image（push）" class="headerlink" title="9. 发布image（push）"></a>9. 发布image（push）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布docker镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash">docker push new_image_name</span></span><br></pre></td></tr></table></figure>


<h3 id="10-根据Dockerfile-构建出一个容器"><a href="#10-根据Dockerfile-构建出一个容器" class="headerlink" title="10.  根据Dockerfile 构建出一个容器"></a>10.  根据Dockerfile 构建出一个容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">build</span></span><br><span class="line">      --no-cache=false Do not use cache when building the image</span><br><span class="line">      -q, --quiet=false Suppress the verbose output generated by the containers</span><br><span class="line">      --rm=true Remove intermediate containers after a successful build</span><br><span class="line">      -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success</span><br><span class="line"><span class="meta">$</span><span class="bash">docker build -t image_name Dockerfile_path</span></span><br></pre></td></tr></table></figure>

<h3 id="使容器自启动"><a href="#使容器自启动" class="headerlink" title="使容器自启动"></a>使容器自启动</h3><p><code>docker update --restart=always 81bcb97c4f5e</code></p>
<h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><h4 id="docker命令参数详解"><a href="#docker命令参数详解" class="headerlink" title="docker命令参数详解"></a>docker命令参数详解</h4><p>docker<br>useage of docker<br>-D 默认false 允许调试模式(debugmode)<br>-H 默认是unix:///var/run/docker.sock tcp://[host[:port]]来绑定 或者unix://[/path/to/socket]来使用(二进制文件的时候)，当主机ip host=[0.0.0.0],(端口)port=[4243] 或者 path=[/var/run/docker.sock]是缺省值，做为默认值来使用<br>-api-enable-cors 默认flase 允许CORS header远程api<br>-b 默认是空，附加在已存在的网桥上，如果是用’none’参数，就禁用了容器的网络<br>-bip 默认是空，使用提供的CIDR（ClasslessInter-Domain Routing-无类型域间选路）标记地址动态创建网桥(dcoker0),和-b参数冲突<br>-d 默认false 允许进程模式(daemonmode)<br>-dns 默认是空，使docker使用指定的DNS服务器<br>-g 默认是”/var/lib/docker”:作为docker使用的根路径<br>-icc 默认true，允许inter-container来通信<br>-ip 默认”0.0.0.0”：绑定容器端口的默认Ip地址<br>-iptables 默认true 禁用docker添加iptables规则<br>-mtu 默认1500 : 设置容器网络传输的最大单元(mtu)<br>-p 默认是/var/run/docker.pid进程pid使用的文件路径<br>-r 默认是true 重启之前运行的容器<br>-s 默认是空 ，这个是docker运行是使用一个指定的存储驱动器<br>-v 默认false 打印版本信息和退出</p>
<h4 id="docker-run命令详解"><a href="#docker-run命令详解" class="headerlink" title="docker run命令详解"></a>docker run命令详解</h4><p>Usage: docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG…]<br>Run a command in a new container<br>-a=map[]: 附加标准输入、输出或者错误输出<br>-c=0: 共享CPU格式（相对重要）<br>-cidfile=””: 将容器的ID标识写入文件<br>-d=false: 分离模式，在后台运行容器，并且打印出容器ID<br>-e=[]:设置环境变量<br>-h=””: 容器的主机名称<br>-i=false: 保持输入流开放即使没有附加输入流<br>-privileged=false: 给容器扩展的权限<br>-m=””: 内存限制 (格式:<number><optional unit>, unit单位 = b, k, m or g)<br>-n=true: 允许镜像使用网络<br>-p=[]: 匹配镜像内的网络端口号<br>-rm=false:当容器退出时自动删除容器 (不能跟 -d一起使用)<br>-t=false: 分配一个伪造的终端输入<br>-u=””: 用户名或者ID<br>-dns=[]: 自定义容器的DNS服务器<br>-v=[]: 创建一个挂载绑定：[host-dir]:[container-dir]:[rw|ro].如果容器目录丢失，docker会创建一个新的卷<br>-volumes-from=””: 挂载容器所有的卷<br>-entrypoint=””: 覆盖镜像设置默认的入口点<br>-w=””: 工作目录内的容器<br>-lxc-conf=[]: 添加自定义-lxc-conf=”lxc.cgroup.cpuset.cpus = 0,1”<br>-sig-proxy=true: 代理接收所有进程信号(even in non-tty mode)<br>-expose=[]: 让你主机没有开放的端口<br>-link=””: 连接到另一个容器(name:alias)<br>-name=””: 分配容器的名称，如果没有指定就会随机生成一个<br>-P=false: Publish all exposed ports to thehost interfaces 公布所有显示的端口主机接口  </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.linuxeye.com/Linux/2019.html">docker详细的基础用法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/backend/Docker%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" data-id="ckqg285sz000hrcfpe7nvgly7" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/诸葛-SpringCloudAlibaba-Nacos入门/SpringCloudAlibaba-Nacos入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E8%AF%B8%E8%91%9B-SpringCloudAlibaba-Nacos%E5%85%A5%E9%97%A8/SpringCloudAlibaba-Nacos%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:11.058Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a></p>
<p>![亿级流量电商网络微服务架构](_v_images/20200917161031675_7588.png =1024x)</p>
<h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><p><img src="_v_images/20200917161526033_6220.png" alt="基于Nginx的负载均衡"></p>
<p>增加减少机器需要频繁修改配置</p>
<p><img src="_v_images/20200917162815662_2365.png" alt="Nacos服务注册中心"></p>
<p>基于Ribbon算法的负载均衡</p>
<p>![完整的微服务架构](_v_images/20200917164823949_25307.png =1200x)</p>
<p>Feign：通过动态代理，实现对远程服务的调用。</p>
<h1 id="P6-Sentinel-限流熔断降级"><a href="#P6-Sentinel-限流熔断降级" class="headerlink" title="P6 Sentinel 限流熔断降级"></a>P6 Sentinel 限流熔断降级</h1><p>Sentinel 切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<h2 id="Sentinel教程"><a href="#Sentinel教程" class="headerlink" title="Sentinel教程"></a>Sentinel教程</h2><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">Sentinel介绍 Quick Start</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/noaman_wgs/article/details/103328793%0Ahttps://blog.csdn.net/noaman_wgs/article/details/103328793">【Sentinel（一）】Sentinel介绍与使用</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c47dfd25eeee%0Ahttps://www.jianshu.com/p/c47dfd25eeee">Sentinel 实战-控制台篇</a><br><a target="_blank" rel="noopener" href="https://gitee.com/all_4_you/sentinel-tutorial%0Ahttps://gitee.com/all_4_you/sentinel-tutorial">Sentinel教程</a><br><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/tree/master/sentinel-demo">https://github.com/alibaba/Sentinel/tree/master/sentinel-demo</a></p>
<p>![Sentinel主要特性](<a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20191130203727708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=,size_16,color_FFFFFF,t_70">https://img-blog.csdnimg.cn/20191130203727708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYW1hbl93Z3M=,size_16,color_FFFFFF,t_70</a> =800x)</p>
<h2 id="Sentinel与Hystrix的区别"><a href="#Sentinel与Hystrix的区别" class="headerlink" title="Sentinel与Hystrix的区别"></a>Sentinel与Hystrix的区别</h2><p>关于Sentinel与Hystrix的区别见：<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/633786/">技术选型：Sentinel vs Hystrix</a></p>
<p>总体来说：</p>
<p>Hystrix常用的线程池隔离会造成线程上下切换的overhead比较大；Hystrix使用的信号量隔离对某个资源调用的并发数进行控制，效果不错，但是无法对慢调用进行自动降级；Sentinel通过并发线程数的流量控制提供信号量隔离的功能；</p>
<p>此外，Sentinel支持的熔断降级维度更多，可对多种指标进行流控、熔断，且提供了实时监控和控制面板，功能更为强大。</p>
<h2 id="Spring-Cloud-Alibaba：Sentinel实现熔断与限流"><a href="#Spring-Cloud-Alibaba：Sentinel实现熔断与限流" class="headerlink" title="Spring Cloud Alibaba：Sentinel实现熔断与限流"></a>Spring Cloud Alibaba：Sentinel实现熔断与限流</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903999876022279%0Ahttps://juejin.im/post/6844903999876022279">Spring Cloud Alibaba：Sentinel实现熔断与限流</a></p>
<h3 id="与Feign结合使用"><a href="#与Feign结合使用" class="headerlink" title="与Feign结合使用"></a>与Feign结合使用</h3><ul>
<li><p>引入依赖 <code>spring-cloud-starter-alibaba-sentinel</code></p>
</li>
<li><p>在application.yml中打开Sentinel对Feign的支持： <code>feign.sentinel.enabled: true</code></p>
</li>
<li><p>在应用启动类上添加@EnableFeignClients启动Feign的功能；</p>
</li>
<li><p>定义对nacos-user-service服务的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-user-service&quot;,fallback = UserFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/create&quot;)</span></span><br><span class="line">    <span class="function">CommonResult <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建UserFallbackService类实现UserService接口，用于处理服务降级逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFallbackService</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        User defaultUser = <span class="keyword">new</span> User(-<span class="number">1L</span>, <span class="string">&quot;defaultUser&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CommonResult&lt;&gt;(defaultUser,<span class="string">&quot;服务降级返回&quot;</span>,<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过Feign调用nacos-user-service服务中的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFeignController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.create(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用如下接口会发生服务降级，返回服务降级处理信息：<a target="_blank" rel="noopener" href="http://localhost:8401/user/4">http://localhost:8401/user/4</a></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;id&quot;</span>: <span class="number">-1</span>,</span><br><span class="line">		<span class="attr">&quot;username&quot;</span>: <span class="string">&quot;defaultUser&quot;</span>,</span><br><span class="line">		<span class="attr">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">&quot;message&quot;</span>: <span class="string">&quot;服务降级返回&quot;</span>,</span><br><span class="line">	<span class="attr">&quot;code&quot;</span>: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(Long productId，Long userId，Integer stockCount，Integer creditCount)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;创建订单成功&quot;</span>); <span class="comment">//T0D0</span></span><br><span class="line">    stockService.deductStock(productId，stockCount);</span><br><span class="line">    creditService.addCredit(userId，creditCount); <span class="comment">// DE<span class="doctag">BUG:</span> 停掉积分系统，不能报错</span></span><br><span class="line">    wmsService.delivery(userId，productId);</span><br><span class="line">    <span class="keyword">return</span><span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Seata-分布式事务"><a href="#Seata-分布式事务" class="headerlink" title="Seata 分布式事务"></a>Seata 分布式事务</h1><p>seata.io/zh-cn/</p>
<p>@GlobalTransactional</p>
<h2 id="Seata-AT-模式"><a href="#Seata-AT-模式" class="headerlink" title="Seata AT 模式"></a>Seata AT 模式</h2><p>整体机制：两阶段提交协议的演变：</p>
<ul>
<li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li>
<li>二阶段：<ul>
<li>提交异步化，非常快速地完成。</li>
<li>回滚通过一阶段的回滚日志进行反向补偿。</li>
</ul>
</li>
</ul>
<p>对数据一致性的及时性要求不高的业务场景，尽量不适用分布式事务，因为Seata底层是加锁，降低了系统性能。</p>
<h1 id="电商业务中台整体微服务架构"><a href="#电商业务中台整体微服务架构" class="headerlink" title="电商业务中台整体微服务架构"></a>电商业务中台整体微服务架构</h1><p><a target="_blank" rel="noopener" href="https://www.processon.com/view/link/5e69e768e4b07fc7a6841488">https://www.processon.com/view/link/5e69e768e4b07fc7a6841488</a></p>
<p>![电商业务中台整体微服务架构](_v_images/20200917182324982_14617.png =1200x)</p>
<h2 id="Gateway的作用"><a href="#Gateway的作用" class="headerlink" title="Gateway的作用"></a>Gateway的作用</h2><p>SpringCloud Gateway ：</p>
<ul>
<li>路由（服务转发）</li>
<li>限流</li>
<li>安全认证（对请求统一校验权限）</li>
</ul>
<p><img src="_v_images/20200917174512999_3323.png" alt="Gateway配置"></p>
<h1 id="分布式调用链路追踪Pinpoint"><a href="#分布式调用链路追踪Pinpoint" class="headerlink" title="分布式调用链路追踪Pinpoint"></a>分布式调用链路追踪Pinpoint</h1><h1 id="微服务自动化监控-Prometheus-amp-Grafana"><a href="#微服务自动化监控-Prometheus-amp-Grafana" class="headerlink" title="微服务自动化监控 Prometheus &amp; Grafana"></a>微服务自动化监控 Prometheus &amp; Grafana</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E8%AF%B8%E8%91%9B-SpringCloudAlibaba-Nacos%E5%85%A5%E9%97%A8/SpringCloudAlibaba-Nacos%E5%85%A5%E9%97%A8/" data-id="ckqg285v8004zrcfpccez7xli" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/架构师大型项目实战/第七套/001-集群基础概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E5%A5%97/001-%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:11.043Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h1 id="001-集群基础概念"><a href="#001-集群基础概念" class="headerlink" title="001-集群基础概念"></a>001-集群基础概念</h1><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p><img src="_v_images/20200604160036617_29204.png"></p>
<p>问题：</p>
<ul>
<li><p>什么是Prefork请求？<br><a target="_blank" rel="noopener" href="https://blog.mimvp.com/article/27778.html">Apache 工作的三种模式：Prefork、Worker、Event</a></p>
</li>
<li><p>网络请求，内核进程空间，用户进程空间，网卡，磁盘IO？<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/8410350.html">Linux 内核空间与用户空间</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunsky303/p/8962628.html">Linux-网络IO和磁盘IO详解</a></p>
</li>
</ul>
<h2 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h2><p><img src="_v_images/20200604155954082_1565.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a9b2d5b32a3a">linux运维学习笔记：集群系列之01：linux集群基础概念</a></p>
<ul>
<li>如何分配调度多台主机?<blockquote>
<p>DNS负载均衡技术的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时，DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>大多数域名注册商都支持对统一主机添加多条A记录，这就是DNS轮询，DNS服务器将解析请求按照A记录的顺序，随机分配到不同的IP上，这样就完成了简单的负载均衡。</p>
</blockquote>
<ul>
<li><p>什么是域名的A记录？<br><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/671df0c55fbfc77da269b1f0.html">域名的A记录、mx记录、ns记录怎么查看</a></p>
</li>
<li><p>DNS负载均衡有什么缺点？</p>
<ol>
<li>每台主机都必须有独立外网IP</li>
<li>由于使用了DNS缓存，新的DNS记录生效需要几个小时。一旦发生宕机，不能及时生效。</li>
<li>本地DNS服务器会缓存已解析的域名到IP地址的映射，这会导致使用该DNS服务器的用户在一段时间内访问的是同一台Web服务器，导致Web服务器间的负载不均匀。<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/data2value/p/6107380.html">负载均衡手段之DNS轮询</a></li>
</ol>
</li>
<li><p>如何解决DNS负载均衡的缺点（服务器性能差异，负载不均匀，DNS缓存）？</p>
<blockquote>
<p>Round Robin: 轮调：同一个客户端请求，并发的资源可能来自多台服务器。<br>WRR:weight Round Robin 加权轮调：解决服务器的硬件、性能有所差异。考虑公平以及效率，权重weight。能者多劳。</p>
</blockquote>
</li>
</ul>
<h2 id="LB集群"><a href="#LB集群" class="headerlink" title="LB集群"></a>LB集群</h2><p><img src="_v_images/20200604161328677_28397.png"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chen_fly2011/article/details/54912326">Linux负载均衡LVS原理技术详细讲解</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40470303/article/details/80541639">LVS负载均衡（LVS简介、三种工作模式、十种调度算法）</a></p>
<ul>
<li><p>MySQL数据过载怎么办？</p>
</li>
<li><p>附件：从多台主机上传附件，怎么存储？ NFS<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Lu_tixia/article/details/99571376">nfs文件共享服务器应用实战（一）</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Lu_tixia/article/details/99628052">nfs文件共享服务器应用实战（二）-自动挂载技术</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Lu_tixia/article/details/99675199">nfs文件共享服务器企业实战（三）-nfs高可用</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gongjingyun123--/p/11323968.html">NFS 共享存储实战</a></p>
</li>
<li><p>静态文件如何同步更新？ rsync+inotify<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1008061">inotify+rsync实现实时同步</a></p>
</li>
<li><p>ftp的被动与主动模式是什么？<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jingzi123456789/article/details/83409572">FTP的主动模式和被动模式工作原理及抓包分析</a></p>
</li>
<li><p>调度器过载怎么办？功能切分，比如：新浪子域名</p>
</li>
<li><p>调度器宕机怎么办？Master, Slave。备用调度器如何知道主调度器宕机？心跳</p>
<blockquote>
<p>standy:具备和primary配置一样，IP地址进行切换，自己服务启动。<br>primary 和 standby时刻通信，发送heartbeat（心跳数）,一旦宕机，立即启动，进行切换。   </p>
</blockquote>
</li>
<li><p>调度器如何知道主机是否宕机？健康检查</p>
<blockquote>
<p>负载均衡可以定期向后端服务器发送 Ping、尝试连接或发送请求来探测后端服务器运行的状况，这些探测称为健康检查。负载均衡通过健康检查来判断后端服务的可用性，避免后端服务异常影响前端业务，从而提高业务整体可用性。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yiyuwu7069/article/details/78217985">负载均衡原理与实践详解 第六篇 健康检查机制详解（上）</a></p>
</blockquote>
</li>
</ul>
<h2 id="LB-vs-HA-：-处理能力-vs-可用性"><a href="#LB-vs-HA-：-处理能力-vs-可用性" class="headerlink" title="LB vs HA ： 处理能力 vs 可用性"></a>LB vs HA ： 处理能力 vs 可用性</h2><p><img src="_v_images/20200604165107019_13072.png"></p>
<ul>
<li>LB集群 与 HA集群的区别？<blockquote>
<p>负载均衡集群着重在于提供服务并发处理能力的集群，高可用集群以提升服务在线的能力的集群。高性能集群着重用于处理一个海量任务。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>LB集群具有高可用的能力，但不是高可用集群。HA集群的主机之间要进行通信，发送heartbeat，以及宕机后，快速切换服务。而LB集群的高可用能力是通过上面的调度服务器调度来实现。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shuaishenkkk/article/details/22744979">LB(Load Balancing)集群、HA(High Availability)集群、HP(High Performance)集群</a></p>
<ul>
<li>HA 99% 是 99.9% 的几倍？10倍<blockquote>
<p>可用性= 正常在线时间/正常在线时间+故障处理时间</p>
</blockquote>
</li>
</ul>
<h2 id="HA集群"><a href="#HA集群" class="headerlink" title="HA集群"></a>HA集群</h2><p><img src="_v_images/20200604164420210_17720.png"></p>
<ul>
<li><p>在HA集群中要考虑哪些资源？</p>
<blockquote>
<p>web服务器：primary：IP，web app, 页面—– standby：IP,web app,页面</p>
</blockquote>
</li>
<li><p>在高可用集群中，如何充分利用standby主机资源？</p>
<blockquote>
<p>web主机与mail主机互为standby。某一时刻某个资源只能被某个节点所占用。</p>
</blockquote>
</li>
<li><p>主机宕机，采用哪个standby？</p>
<blockquote>
<p>定义优先级，由协调员DC来决定选择谁。</p>
</blockquote>
</li>
<li><p>主机如何通知standby自己还活着？</p>
<blockquote>
<p>及时发送heartbeat，多播/组播，不能采用广播。</p>
</blockquote>
</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><img src="_v_images/20200604165927268_23242.png"></p>
<ul>
<li><p>NFS 与 硬盘读写文件的区别？</p>
<blockquote>
<p>硬盘是块级别读取，NFS是文件级别读写。</p>
</blockquote>
</li>
<li><p>对于NFS与硬盘，两个程序同时写一个文件区别？</p>
<blockquote>
<p>硬盘：无锁，错乱。NFS：有锁</p>
</blockquote>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/insane-Mr-Li/p/10841166.html">linux高可用集群(HA)原理详解</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/category/899066.html">LB/HA高可用 系列文章</a></p>
<h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p><img src="_v_images/20200604171648321_1417.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevingrace/p/7205846.html">HA高可用集群中”脑裂”问题解决</a></p>
<ul>
<li><p>DAS  (SCSI、RAID)</p>
<ul>
<li>UltraSCSI (320Mbps)</li>
<li>SAS (6Gbps)</li>
</ul>
</li>
<li><p>DAS  vs 1000mbps/8 –&gt; NAS的传输远比不上DAS</p>
</li>
<li><p>RAID与NFS</p>
<blockquote>
<p>NFS对前端服务器而言，就是文件共享服务器。数据请求是在文件级别上完成的。<br>RAID,是磁盘阵列，是通过主板上的总线连接到RAID上，相当于本地存储设备，数据是在块级别上交换的。</p>
</blockquote>
</li>
<li><p>当standby发现主机宕机，如何无错抢占DAS设备？DAS如何解决split-brain(脑裂)问题？</p>
</li>
</ul>
<blockquote>
<p>由于没有及时传递heartbear信息，切换到备用的调度服务器，而主调度服务器还在写数据到DAS中，而standby也同时写同一个文件。左右就不协调了，称为split-brain:脑裂。</p>
</blockquote>
<blockquote>
<p>解决办法：<br>   （1）电源交换机（切断主机的电源），爆头STONITH(Shoot The Other Node In The Head)<br>   （2）fencing（隔离）：拒绝某一节点访问某一资源的机制，使服务器和存储设备断开。<br>    隔离级别： 1.节点级别：STONTIN。  2.资源级别。</p>
</blockquote>
<ul>
<li>当standby误以为主机宕机，抢占DAS，主机如何再抢回来？</li>
</ul>
<p><img src="_v_images/20200604172019789_32378.png"></p>
<blockquote>
<p>注意：为了防止脑裂,集群分裂，高可用集群至少有3个节点，奇数个节点，仲裁机制，少数服从多数。</p>
</blockquote>
<blockquote>
<p>补充：<br>脑裂：本来一个大脑的两半球互相配合，变成了分裂成两个独立的大脑，都认为对方已死。在集群环境中，有这么几种可能造成”Split-Brain”现象：<br>        1、在集群环境中的节点间的心跳线同时断掉后，集群系统所处于的一种特殊状态。例如节点1和2组成一个集群，突然1和2间的心跳同时都断了，如果此前节点1正在运行应用，心跳都断掉后2开始去接管应用，强行加载数据，此时就是split-brain。<br>       2、集群中节点因为处理器忙或者其他原因暂时停止响应时，其他节点可能误认为该节点“已死”。<br>后果：节点间争夺共享磁盘（即资源）的访问权，都对共享文件系统产生读写操作，从而导致共享磁盘文件系统损坏。<br>解决办法：使用硬盘心跳，scsi reservation，以及最极端的power fence。</p>
</blockquote>
<h2 id="HP-高性能集群（HBC）"><a href="#HP-高性能集群（HBC）" class="headerlink" title="HP:高性能集群（HBC）"></a>HP:高性能集群（HBC）</h2><p><img src="_v_images/20200604173501479_19275.png"></p>
<ul>
<li><p>并行计算集群两个基础是什么？</p>
<ul>
<li>分布式文件系统</li>
<li>将大大任务切割为是小任务，分别进行处理的机制。</li>
</ul>
</li>
<li><p>并行计算集群原理？</p>
<blockquote>
<p>化整为零—&gt;合并整合。 Map-Reduce<br>每台计算机只处理所有数据的一部分，且每台计算机上只存储一部分数据。每个节点既是计算节点，也是存储节点。</p>
</blockquote>
</li>
</ul>
<p><img src="_v_images/20200604173728015_5214.png"></p>
<ul>
<li>并行计算集群的主机兼具存储和计算，调度计算。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E7%AC%AC%E4%B8%83%E5%A5%97/001-%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" data-id="ckqg285v90050rcfphx786exg" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/架构师大型项目实战/目录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E7%9B%AE%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:11.039Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="架构师大型项目实战"><a href="#架构师大型项目实战" class="headerlink" title="架构师大型项目实战"></a>架构师大型项目实战</h1><h2 id="第七套：Mysql主从复制-高可用集群-Linux-Nginx-Java-Memcached-Lvs-Redis-实战PB级大型分布式大数据高并发架构实战案例网站性能调优"><a href="#第七套：Mysql主从复制-高可用集群-Linux-Nginx-Java-Memcached-Lvs-Redis-实战PB级大型分布式大数据高并发架构实战案例网站性能调优" class="headerlink" title="第七套：Mysql主从复制+高可用集群+Linux+Nginx+Java+Memcached+Lvs+Redis 实战PB级大型分布式大数据高并发架构实战案例网站性能调优"></a>第七套：Mysql主从复制+高可用集群+Linux+Nginx+Java+Memcached+Lvs+Redis 实战PB级大型分布式大数据高并发架构实战案例网站性能调优</h2><p><a href="%E7%AC%AC%E4%B8%83%E5%A5%97/001-%E9%9B%86%E7%BE%A4%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.md">001-集群基础概念.md</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/%E7%9B%AE%E5%BD%95/" data-id="ckqg285v8004yrcfp42hg51ku" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/FEBS/搭建教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/FEBS/%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.887Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-第一章-基础框架搭建"><a href="#1-第一章-基础框架搭建" class="headerlink" title="1. 第一章 基础框架搭建"></a>1. 第一章 基础框架搭建</h1><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263687">https://www.kancloud.cn/mrbird/spring-cloud/1263687</a></p>
<p>JDK 1.8<br>Spring Boot 2.1.6.RELEASE<br>Spring Cloud Greenwich.SR1<br>Spring Cloud OAuth2<br>Spring Cloud Security</p>
<h2 id="1-1-架构预览"><a href="#1-1-架构预览" class="headerlink" title="1.1. 架构预览"></a>1.1. 架构预览</h2><p>![系统架构图](<a target="_blank" rel="noopener" href="https://s2.ax1x.com/2019/08/31/mxMgW8.png">https://s2.ax1x.com/2019/08/31/mxMgW8.png</a> =1024x)</p>
<p>FEBS-Register：微服务注册中心，用于统一控制各个微服务实例的注册与发现；<br>FEBS-Gateway：微服务网关，统一处理外部请求，是客户端和众多微服务连接的桥梁；<br>FEBS-Auth：微服务认证服务器，用于令牌（Token）生成和令牌校验，是整个权限系统的核心所在；<br>FEBS-Server-System：微服务提供者（资源服务器）A，对外提供系统模块的CRUD服务；<br>FEBS-Server-Test：微服务提供者（资源服务器）B。</p>
<h2 id="1-2-搭建微服务注册中心"><a href="#1-2-搭建微服务注册中心" class="headerlink" title="1.2. 搭建微服务注册中心"></a>1.2. 搭建微服务注册中心</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263688">https://www.kancloud.cn/mrbird/spring-cloud/1263688</a></p>
<p>在这一节中，我们先使用Eureka构建微服务注册中心（Eureka服务端），因为Eureka较为简单，无须启动第三方服务，只需要引入相关依赖即可。</p>
<h2 id="1-3-搭建认证服务器"><a href="#1-3-搭建认证服务器" class="headerlink" title="1.3. 搭建认证服务器"></a>1.3. 搭建认证服务器</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263689">https://www.kancloud.cn/mrbird/spring-cloud/1263689</a></p>
<p>借助Spring Cloud OAuth和Spring Cloud Security搭建一个统一给微服务发放访问令牌的认证服务器febs-auth。</p>
<h2 id="1-4-搭建微服务网关"><a href="#1-4-搭建微服务网关" class="headerlink" title="1.4. 搭建微服务网关"></a>1.4. 搭建微服务网关</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263690">https://www.kancloud.cn/mrbird/spring-cloud/1263690</a></p>
<p>在微服务的架构中，服务网关就是一个介于客户端与服务端之间的中间层。在这种情况下，客户端只需要跟服务网关交互，无需调用具体的微服务接口。这样的好处在于，客户端可以降低复杂性，无需关注具体是哪个微服务在提供服务。这一节我们将使用Spring Cloud Zuul搭建微服务网关febs-gateway。</p>
<h2 id="1-5-搭建资源服务器"><a href="#1-5-搭建资源服务器" class="headerlink" title="1.5. 搭建资源服务器"></a>1.5. 搭建资源服务器</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1420720">https://www.kancloud.cn/mrbird/spring-cloud/1420720</a></p>
<h1 id="2-架构完善"><a href="#2-架构完善" class="headerlink" title="2. 架构完善"></a>2. 架构完善</h1><p>这一章主要对上一节搭建的基础框架进行完善，解决微服务权限系统常见的问题。</p>
<h2 id="2-1-参数配置化"><a href="#2-1-参数配置化" class="headerlink" title="2.1. 参数配置化"></a>2.1. 参数配置化</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263694">https://www.kancloud.cn/mrbird/spring-cloud/1263694</a></p>
<p><code>spring-boot-configuration-processor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:febs-auth.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;febs.auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FebsAuthProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FebsClientsProperties[] clients = &#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accessTokenValiditySeconds = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refreshTokenValiditySeconds = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">febs.auth.accessTokenValiditySeconds</span>=<span class="number">86400</span></span><br><span class="line"><span class="attr">febs.auth.refreshTokenValiditySeconds</span>=<span class="number">604800</span></span><br><span class="line"></span><br><span class="line">febs.auth.clients<span class="section">[0]</span>.<span class="attr">client</span>=febs</span><br><span class="line">febs.auth.clients<span class="section">[0]</span>.<span class="attr">secret</span>=<span class="number">123456</span></span><br><span class="line">febs.auth.clients<span class="section">[0]</span>.<span class="attr">grantType</span>=password,authorization_code,refresh_token</span><br><span class="line">febs.auth.clients<span class="section">[0]</span>.<span class="attr">scope</span>=all</span><br></pre></td></tr></table></figure>

<h2 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2. 异常处理"></a>2.2. 异常处理</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263695">https://www.kancloud.cn/mrbird/spring-cloud/1263695</a></p>
<h2 id="2-3-Feign的使用"><a href="#2-3-Feign的使用" class="headerlink" title="2.3. Feign的使用"></a>2.3. Feign的使用</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263696">https://www.kancloud.cn/mrbird/spring-cloud/1263696</a></p>
<p>微服务之间服务的调用可以借助Spring Cloud Feign来完成，Spring Cloud Feign内部整合了Spring Cloud Ribbon和Spring Cloud Hystrix，所以它具有客户端负载均衡和服务容错的功能。</p>
<p><code>spring-cloud-starter-openfeign</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FebsServerTestApplication</span> </span>&#123;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;FEBS-Server-System&quot;, contextId = &quot;helloServiceClient&quot;, fallbackFactory = HelloServiceFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;hello&quot;)</span></span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-微服务防护"><a href="#2-4-微服务防护" class="headerlink" title="2.4. 微服务防护"></a>2.4. 微服务防护</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263697">https://www.kancloud.cn/mrbird/spring-cloud/1263697</a></p>
<ul>
<li>自定义Zuul过滤器<br>解决这个问题的大致思路是：在网关转发请求前，请求头部加入网关信息，然后在处理请求的微服务模块里定义全局拦截器，校验请求头部的网关信息，这样就能避免客户端直接访问微服务了。<br>在自定义Zuul过滤器前，我们先来简单了解下Zuul的核心过滤器。Zuul中默认定义了4种不同生命周期的过滤器类型。<ul>
<li>PRE：PRE过滤器用于将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址，并做一些前置加工，比如请求的校验等；</li>
<li>ROUTING：ROUTING过滤器用于将外部请求转发到具体服务实例上去；</li>
<li>POST：POST过滤器用于将微服务的响应信息返回到客户端，这个过程种可以对返回数据进行加工处理；</li>
<li>ERROR：上述的过程发生异常后将调用ERROR过滤器。ERROR过滤器捕获到异常后需要将异常信息返回给客户端，所以最终还是会调用POST过滤器。</li>
</ul>
</li>
</ul>
<h2 id="2-5-跨域处理"><a href="#2-5-跨域处理" class="headerlink" title="2.5. 跨域处理"></a>2.5. 跨域处理</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263698">https://www.kancloud.cn/mrbird/spring-cloud/1263698</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FebsGateWayCorsConfigure</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        <span class="keyword">final</span> CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">// 允许cookie跨域</span></span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 请求头部允许携带任何内容</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">// 允许任何来源</span></span><br><span class="line">        corsConfiguration.addAllowedOrigin(CorsConfiguration.ALL);</span><br><span class="line">        <span class="comment">// 允许任何HTTP方法</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(CorsConfiguration.ALL);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-完善登录流程"><a href="#3-完善登录流程" class="headerlink" title="3. 完善登录流程"></a>3. 完善登录流程</h1><h2 id="3-1-表结构设计"><a href="#3-1-表结构设计" class="headerlink" title="3.1. 表结构设计"></a>3.1. 表结构设计</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263701">https://www.kancloud.cn/mrbird/spring-cloud/1263701</a></p>
<p><img src="https://s2.ax1x.com/2019/08/13/mpOPpR.png" alt="用户-角色-权限"></p>
<h2 id="3-2-完善登录"><a href="#3-2-完善登录" class="headerlink" title="3.2. 完善登录"></a>3.2. 完善登录</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263702">https://www.kancloud.cn/mrbird/spring-cloud/1263702</a></p>
<p><code>mybatis-plus-boot-starter</code><br><code>dynamic-datasource-spring-boot-starter</code> MyBatis Plus多数据源依赖<br><code>mysql-connector-java</code></p>
<h2 id="3-3-整合图形验证码"><a href="#3-3-整合图形验证码" class="headerlink" title="3.3. 整合图形验证码"></a>3.3. 整合图形验证码</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263703">https://www.kancloud.cn/mrbird/spring-cloud/1263703</a></p>
<p>Spring Security本质是一长串的过滤器链，处理用户名密码登录的过滤器为<code>UsernamePasswordAuthenticationFilter</code>，要集成图形验证码校验很简单，只需要在<code>UsernamePasswordAuthenticationFilter</code>过滤器前添加图形验证码校验过滤器即可。</p>
<p>我们通常会把验证码存储在Redis中，并设置失效时间。<br>Spring Boot 2.0后推荐使用Lettuce来代替Jedis，Lettuce基于Netty异步，拥有更好的性能。</p>
<p>生成图形验证码可以借助GitHub的一个开源项目<code>https://github.com/whvcse/EasyCaptcha</code>，其提供了较为丰富的验证码配置可供选择。<br>在febs-auth的pom里引入该依赖：<br><dependency><br>    <groupId>com.github.whvcse</groupId><br>    <artifactId>easy-captcha</artifactId><br>    <version>1.6.2</version><br></dependency></p>
<p>在前后端不分离的架构下，我们通过浏览器传输的jsessionid来和验证码图片一一对应，但前后的分离的模式下，客户端发送的请求并没有携带jsessionid（因为不再基于Session），所以我们需要客户端在发送获取验证码请求的时候，携带一个key（比如按一定算法生成的随机字符串，模拟jsessionid）来和验证码一一对应。于是我们在create里一开始就从请求中获取key值，然后根据验证码配置文件生成验证码，并将验证码字符保存到了Redis中（Redis Key为febs.captcha. + 客户端上送的key值，有效时间为配置文件定义的120秒），并将验证码图片以流的形式返回给客户端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateCodeFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ValidateCodeService validateCodeService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验验证码</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-Sentinel验证码限流"><a href="#3-4-Sentinel验证码限流" class="headerlink" title="3.4. Sentinel验证码限流"></a>3.4. Sentinel验证码限流</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263704">https://www.kancloud.cn/mrbird/spring-cloud/1263704</a></p>
<p>因为我们的验证码服务是免认证的，所以只要知道了地址就可以频繁的去获取验证码，这无形之中给服务器增加了很大的压力，甚至可能导致服务器宕机。<br>为了解决这个问题，我们可以在网关处整合阿里巴巴开源的Sentinel流量哨兵来限制验证码的获取频率。</p>
<p><code>com.alibaba.csp:sentinel-zuul-adapter:1.6.3</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FebsGatewaySentinelFilter</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initGatewayRules();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义验证码请求限流，限流规则：</span></span><br><span class="line"><span class="comment">     *  60秒内同一个IP，同一个 key最多访问 10次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initGatewayRules</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;ApiDefinition&gt; definitions = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;ApiPredicateItem&gt; predicateItems = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        predicateItems.add(<span class="keyword">new</span> ApiPathPredicateItem().setPattern(<span class="string">&quot;/auth/captcha&quot;</span>));</span><br><span class="line">        ApiDefinition definition = <span class="keyword">new</span> ApiDefinition(<span class="string">&quot;captcha&quot;</span>)</span><br><span class="line">                .setPredicateItems(predicateItems);</span><br><span class="line">        definitions.add(definition);</span><br><span class="line">        GatewayApiDefinitionManager.loadApiDefinitions(definitions);</span><br><span class="line"></span><br><span class="line">        Set&lt;GatewayFlowRule&gt; rules = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        rules.add(<span class="keyword">new</span> GatewayFlowRule(<span class="string">&quot;captcha&quot;</span>)</span><br><span class="line">                .setResourceMode(SentinelGatewayConstants.RESOURCE_MODE_CUSTOM_API_NAME)</span><br><span class="line">                .setParamItem(</span><br><span class="line">                        <span class="keyword">new</span> GatewayParamFlowItem()</span><br><span class="line">                                .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_URL_PARAM)</span><br><span class="line">                                .setFieldName(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">                                .setMatchStrategy(SentinelGatewayConstants.PARAM_MATCH_STRATEGY_EXACT)</span><br><span class="line">                                .setParseStrategy(SentinelGatewayConstants.PARAM_PARSE_STRATEGY_CLIENT_IP)</span><br><span class="line">                )</span><br><span class="line">                .setCount(<span class="number">10</span>)</span><br><span class="line">                .setIntervalSec(<span class="number">60</span>)</span><br><span class="line">        );</span><br><span class="line">        GatewayRuleManager.loadRules(rules);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-整合Swagger"><a href="#4-整合Swagger" class="headerlink" title="4. 整合Swagger"></a>4. 整合Swagger</h1><h2 id="4-1-完善febs-server-system"><a href="#4-1-完善febs-server-system" class="headerlink" title="4.1. 完善febs-server-system"></a>4.1. 完善febs-server-system</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263707">https://www.kancloud.cn/mrbird/spring-cloud/1263707</a></p>
<p>因为febs-server-system模块负责用户管理、角色管理、菜单管理、部门管理等模块的增删改查，所以这章将演示如何在febs-server-system模块里集成swagger，其他微服务系统要集成swagger照猫画虎就行了。</p>
<ul>
<li>集成MyBatis Plus</li>
<li>配置p6spy<br>p6spy用于在控制台中打印MyBatis执行的SQL。</li>
<li>用户管理模块增删改查</li>
<li>暴露服务</li>
<li>数据校验</li>
<li>PostMan测试</li>
</ul>
<h2 id="4-2-接入Swagger"><a href="#4-2-接入Swagger" class="headerlink" title="4.2. 接入Swagger"></a>4.2. 接入Swagger</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263708">https://www.kancloud.cn/mrbird/spring-cloud/1263708</a></p>
<p><code>io.springfox:springfox-swagger2:2.9.2</code><br><code>io.springfox:springfox-swagger-ui:2.9.2</code></p>
<h2 id="4-3-Swagger-OAuth2认证"><a href="#4-3-Swagger-OAuth2认证" class="headerlink" title="4.3. Swagger OAuth2认证"></a>4.3. Swagger OAuth2认证</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263709">https://www.kancloud.cn/mrbird/spring-cloud/1263709</a></p>
<p>我们在febs-auth模块里配置一个新的Client，专门用于Swagger令牌发放。在febs-auth模块的febs-auth.properties配置文件里添加如下配置:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">febs.auth.clients<span class="section">[1]</span>.<span class="attr">client</span>=swagger</span><br><span class="line">febs.auth.clients<span class="section">[1]</span>.<span class="attr">secret</span>=<span class="number">123456</span></span><br><span class="line">febs.auth.clients<span class="section">[1]</span>.<span class="attr">grantType</span>=password</span><br><span class="line">febs.auth.clients<span class="section">[1]</span>.<span class="attr">scope</span>=test</span><br></pre></td></tr></table></figure>

<h1 id="5-整合第三方服务"><a href="#5-整合第三方服务" class="headerlink" title="5. 整合第三方服务"></a>5. 整合第三方服务</h1><h2 id="5-1-整合Spring-Boot-Admin"><a href="#5-1-整合Spring-Boot-Admin" class="headerlink" title="5.1. 整合Spring Boot Admin"></a>5.1. 整合Spring Boot Admin</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263712">https://www.kancloud.cn/mrbird/spring-cloud/1263712</a></p>
<p>Spring Boot Admin通过<code>spring-boot-starter-actuator</code>提供的REST接口实现了图形化的监控界面，包括应用的配置信息、Beans信息、环境属性、线程信息、JVM状况等。<br>Spring Boot Admin分为服务端和客户端。客户端通过HTTP向服务端提供自身信息，服务端收集这些信息并以图形化界面的方式呈现。下面，Spring Boot Admin客户端简称为SBA客户端，Spring Boot Admin服务端简称为SBA服务端。<br>整合Spring Boot Admin后，我们的系统架构如下所示:</p>
<p>![系统架构图](<a target="_blank" rel="noopener" href="https://s2.ax1x.com/2019/08/31/mxQHHA.png">https://s2.ax1x.com/2019/08/31/mxQHHA.png</a> =1024x)</p>
<p><code>de.codecentric:spring-boot-admin-server:2.1.6</code><br><code>de.codecentric:spring-boot-admin-server-ui:2.1.6</code></p>
<h2 id="5-2-Sleuth-Zipkin链路追踪"><a href="#5-2-Sleuth-Zipkin链路追踪" class="headerlink" title="5.2. Sleuth Zipkin链路追踪"></a>5.2. Sleuth Zipkin链路追踪</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263713">https://www.kancloud.cn/mrbird/spring-cloud/1263713</a></p>
<p>一个复杂的业务流程通常会被拆分多个微服务系统来完成，微服务间通过Feign来通信。当业务流程足够复杂时，一个完整的HTTP请求调用链一般会经过多个微服务系统，要通过日志来跟踪一整个调用链变得不再那么简单。我们可以通过Spring Cloud Sleuth来解决这个问题。</p>
<ul>
<li>整合Spring Cloud Sleuth<br><code>org.springframework.cloud:spring-cloud-starter-sleuth</code></li>
</ul>
<p>从日志里捞取traceId并追踪请求链路。借助zipkin实现使用图形化界面的方式追踪请求链路。</p>
<ul>
<li>整合Zipkin<br>在整合Zipkin之前，我们需要先搭建RabbitMQ。RabbitMQ用于收集Sleuth提供的追踪信息，然后Zipkin Server从RabbitMQ里获取，这样可以提升性能。</li>
</ul>
<h2 id="5-3-logback日志打印"><a href="#5-3-logback日志打印" class="headerlink" title="5.3. logback日志打印"></a>5.3. logback日志打印</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263714">https://www.kancloud.cn/mrbird/spring-cloud/1263714</a></p>
<h2 id="5-4-ELK日志收集"><a href="#5-4-ELK日志收集" class="headerlink" title="5.4. ELK日志收集"></a>5.4. ELK日志收集</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263715">https://www.kancloud.cn/mrbird/spring-cloud/1263715</a></p>
<ul>
<li>搭建ELK环境</li>
<li>修改微服务日志配置<br>我们分别在febs-auth、febs-gateway和febs-server模块的pom里引入<code>Logstash</code>依赖 <code>net.logstash.logback:logstash-logback-encoder:6.1</code>， 并增加logback-spring.xml 配置：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--输出到 logstash的 appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;logstash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">destination</span>&gt;</span>192.168.33.10:4560<span class="tag">&lt;/<span class="name">destination</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> <span class="attr">class</span>=<span class="string">&quot;net.logstash.logback.encoder.LogstashEncoder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;logstash&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-前端系统介绍"><a href="#6-前端系统介绍" class="headerlink" title="6. 前端系统介绍"></a>6. 前端系统介绍</h1><p>FEBS Cloud的前端FEBS Cloud Web采用 vue-element-admin，它是一款基于 vue 和 element-ui实现的后台管理系统模板。</p>
<h2 id="6-1-封装Axios"><a href="#6-1-封装Axios" class="headerlink" title="6.1. 封装Axios"></a>6.1. 封装Axios</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263718">https://www.kancloud.cn/mrbird/spring-cloud/1263718</a></p>
<h2 id="6-2-Vue导航守卫"><a href="#6-2-Vue导航守卫" class="headerlink" title="6.2. Vue导航守卫"></a>6.2. Vue导航守卫</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263719">https://www.kancloud.cn/mrbird/spring-cloud/1263719</a></p>
<h2 id="6-3-动态路由构建"><a href="#6-3-动态路由构建" class="headerlink" title="6.3. 动态路由构建"></a>6.3. 动态路由构建</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263720">https://www.kancloud.cn/mrbird/spring-cloud/1263720</a></p>
<h2 id="6-4-处理用户登录"><a href="#6-4-处理用户登录" class="headerlink" title="6.4. 处理用户登录"></a>6.4. 处理用户登录</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263721">https://www.kancloud.cn/mrbird/spring-cloud/1263721</a></p>
<p><img src="https://s2.ax1x.com/2019/08/28/mHF6WF.png" alt="登录流程"></p>
<h2 id="6-5-处理令牌刷新"><a href="#6-5-处理令牌刷新" class="headerlink" title="6.5. 处理令牌刷新"></a>6.5. 处理令牌刷新</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263722">https://www.kancloud.cn/mrbird/spring-cloud/1263722</a></p>
<p>我们在febs-auth定义的令牌有效时间为86400秒（即24小时），过了24小时候令牌就失效了。假如令牌即将要失效时，用户还在使用系统，那么用户的某个操作可能进行了一半时，系统突然弹出登录过期提示，非常影响用户体验。<br>要解决上面的问题，我们可以在令牌将要失效时，判断用户是否还在使用系统，如果是的话，我们可以偷偷地通过刷新令牌来获取一个新的访问令牌，存储到浏览器内存中。这样就可以在用户无感知的情况下，“延长”访问令牌的有效时间。<br>因为我们系统的请求都是通过6.1节封装的Axios对象来完成的，并且我们在request.js里配置了请求拦截，所以我们刷新令牌的动作也可以在请求拦截器里完成，大致步骤如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/08/28/mH8sDP.png" alt="处理令牌刷新"></p>
<h2 id="6-6-自定义Vue权限指令"><a href="#6-6-自定义Vue权限指令" class="headerlink" title="6.6. 自定义Vue权限指令"></a>6.6. 自定义Vue权限指令</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263723">https://www.kancloud.cn/mrbird/spring-cloud/1263723</a></p>
<p><code>&lt;button v-has-permission=&quot;[&#39;user:add&#39;]&quot;&gt;新增用户&lt;/button&gt;</code></p>
<h1 id="7-微服务部署"><a href="#7-微服务部署" class="headerlink" title="7. 微服务部署"></a>7. 微服务部署</h1><h2 id="7-1-微服务Docker化"><a href="#7-1-微服务Docker化" class="headerlink" title="7.1. 微服务Docker化"></a>7.1. 微服务Docker化</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263726">https://www.kancloud.cn/mrbird/spring-cloud/1263726</a></p>
<h2 id="7-2-使用Docker-Compose部署"><a href="#7-2-使用Docker-Compose部署" class="headerlink" title="7.2. 使用Docker Compose部署"></a>7.2. 使用Docker Compose部署</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263727">https://www.kancloud.cn/mrbird/spring-cloud/1263727</a></p>
<h1 id="8-微服务进阶"><a href="#8-微服务进阶" class="headerlink" title="8. 微服务进阶"></a>8. 微服务进阶</h1><h2 id="8-1-令牌存储策略"><a href="#8-1-令牌存储策略" class="headerlink" title="8.1. 令牌存储策略"></a>8.1. 令牌存储策略</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1277531">https://www.kancloud.cn/mrbird/spring-cloud/1277531</a></p>
<ul>
<li><p>RedisTokenStore<br>在第一章搭建认证服务器的时候，我们使用的是RedisTokenStore令牌存储策略。使用这种策略时，用户的access_token将存储到Redis中，退出登录后，Redis中存储的令牌也会被清除。<br>除了这种令牌存储策略外，Spring还提供了InMemoryTokenStore、JdbcTokenStore和JwtTokenStore三种存储策略：</p>
</li>
<li><p>InMemoryTokenStore<br>该策略将令牌存储到内存中，优点就是无需依赖第三方存储，对于开发小型服务是不错的选择；缺点是认证服务器故障重启后，之前存储的令牌就丢失。</p>
</li>
<li><p>JdbcTokenStore<br>顾名思义，该策略使用数据库来存储令牌。在使用这种策略之前，我们需要先准备好库表。Spring Security OAuth仓库可以找到相应的脚本，只需要使用到oauth_access_token和oauth_refresh_token数据表。</p>
</li>
<li><p>JwtTokenStore<br>前面三种存储策略生成的令牌都是使用UUID生成的无意义字符串，我们也可以使用JwtTokenStore生成JWT格式令牌。<br>在febs-auth模块下认证服务器配置类FebsAuthorizationServerConfigure中配置JwtTokenStore。</p>
</li>
</ul>
<h2 id="8-2-使用Cloud-Gateway搭建网关"><a href="#8-2-使用Cloud-Gateway搭建网关" class="headerlink" title="8.2. 使用Cloud Gateway搭建网关"></a>8.2. 使用Cloud Gateway搭建网关</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1263731">https://www.kancloud.cn/mrbird/spring-cloud/1263731</a></p>
<p>这一节，我们将使用Spring Cloud Gateway构建一个全新的微服务网关，代替之前通过Spring Cloud Zuul构建的微服务网关。和Zuul相比，Spring Cloud Gateway具有如下优势：<br>基于Reactor模型的WebFlux构建，运行在Netty上，具有更好的性能；<br>可拓展性高，内置了非常丰富的转发规则，除此之外，我们也可以定义自己的转发规则。<br>对于WebFlux不熟悉的同学可以在学完本节后阅读我的博文：<a target="_blank" rel="noopener" href="https://mrbird.cc/tags/WebFlux/%E3%80%82">https://mrbird.cc/tags/WebFlux/。</a></p>
<p><code>org.springframework.cloud:spring-cloud-starter-gateway</code></p>
<ul>
<li>转发规则<br>Spring Cloud Gateway两大核心概念为：谓词工厂和过滤器工厂，谓词工厂用于定义转发规则，过滤器工厂用于修改请求和响应。Spring Cloud Gateway内置的谓词工厂和过滤器工厂可以参考：<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-request-predicates-factories%E5%92%8Chttps://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories%E3%80%82">https://cloud.spring.io/spring-cloud-gateway/reference/html/#gateway-request-predicates-factories和https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories。</a></li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">FEBS-Auth</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://FEBS-Auth</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/auth/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">FEBS-Server-System</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://FEBS-Server-System</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/system/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">FEBS-Server-test</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://FEBS-Server-Test</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/test/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义全局过滤器</li>
</ul>
<h2 id="8-3-使用Alibaba-Nacos注册中心"><a href="#8-3-使用Alibaba-Nacos注册中心" class="headerlink" title="8.3. 使用Alibaba Nacos注册中心"></a>8.3. 使用Alibaba Nacos注册中心</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1271133">https://www.kancloud.cn/mrbird/spring-cloud/1271133</a></p>
<h2 id="8-4-使用Alibaba-Nacos存储配置"><a href="#8-4-使用Alibaba-Nacos存储配置" class="headerlink" title="8.4. 使用Alibaba Nacos存储配置"></a>8.4. 使用Alibaba Nacos存储配置</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1289434">https://www.kancloud.cn/mrbird/spring-cloud/1289434</a></p>
<p>Spring Cloud Alibaba Nacos不但可以用于搭建微服务注册中心，还可以统一管理微服务配置，类似于Spring Cloud Config。</p>
<ul>
<li>Nacos数据持久化<br>Nacos支持使用MySQL进行数据持久化。</li>
<li>使用Nacos管理配置<br>增加依赖<code>org.springframework.cloud:spring-cloud-starter-alibaba-nacos-config</code><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">FEBS-Auth</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;nacos.url&#125;:8001</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">$&#123;nacos.url&#125;:8001</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">febs-auth</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-5-接入Prometheus-Grafana"><a href="#8-5-接入Prometheus-Grafana" class="headerlink" title="8.5. 接入Prometheus + Grafana"></a>8.5. 接入Prometheus + Grafana</h2><p>这节的目的是搭建一个多维度监控微服务的可视化平台，包括Docker容器监控、MySQL监控、Redis监控和微服务JVM监控等，并且在必要的情况下可以发送预警邮件。<br>这节主要用到的组件有Prometheus、Grafana、alertmanager、node_exporter、mysql_exporter、redis_exporter、cadvisor。各自作用如下所示：</p>
<ol>
<li>Prometheus：获取、存储监控数据，供第三方查询；</li>
<li>Grafana：提供Web页面，从Prometheus获取监控数据可视化展示；</li>
<li>alertmanager：定义预警规则，发送预警信息；</li>
<li>node_exporter：收集微服务端点监控数据；</li>
<li>mysql_exporter：收集MySQL数据库监控数据；</li>
<li>redis_exporter：收集Redis监控数据；</li>
<li>cadvisor：收集Docker容器监控数据。</li>
</ol>
<h2 id="8-6-整合skywalking分布式追踪"><a href="#8-6-整合skywalking分布式追踪" class="headerlink" title="8.6. 整合skywalking分布式追踪"></a>8.6. 整合skywalking分布式追踪</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1337996">https://www.kancloud.cn/mrbird/spring-cloud/1337996</a></p>
<p>Skywalking是由国人吴晟开发的一款分布式追踪软件，后面成功孵化为Apache的顶级项目。Skywalking主要包括了分布式追踪、性能指标分析、应用和服务依赖分析等功能，使用体验后个人感觉比zipkin更为直观，是替代zipkin的一个不错的选择。<br>Skywalking的主要结构图如下所示:<br>![](<a target="_blank" rel="noopener" href="https://s2.ax1x.com/2019/10/20/Kutat0.png">https://s2.ax1x.com/2019/10/20/Kutat0.png</a> =1024x)</p>
<p>从上图可以看出Skywalking主要分为四个模块：agent、collector、webapp-ui和storage。我们可以使用Skywalking agent探针无侵入地接入Spring Cloud应用，然后通过HTTP或者GRPC将应用数据采集到collector收集器。collector中的数据存储与storage，支持MySQL、H2、Elasticsearch等存储，最终这些数据集中在webapp-ui以图形化的方式呈现。</p>
<h2 id="8-7-升级到Hoxton-RELEASE"><a href="#8-7-升级到Hoxton-RELEASE" class="headerlink" title="8.7. 升级到Hoxton.RELEASE"></a>8.7. 升级到Hoxton.RELEASE</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1411735">https://www.kancloud.cn/mrbird/spring-cloud/1411735</a></p>
<h1 id="9-K8S集群部署"><a href="#9-K8S集群部署" class="headerlink" title="9. K8S集群部署"></a>9. K8S集群部署</h1><h2 id="9-1-集群环境准备"><a href="#9-1-集群环境准备" class="headerlink" title="9.1. 集群环境准备"></a>9.1. 集群环境准备</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426915">https://www.kancloud.cn/mrbird/spring-cloud/1426915</a></p>
<p>这一章节，我们的目标是通过Kubernetes（下面简称k8s，因为k和s之间有8个字符，所以俗称k8s）部署一个高可用的FEBS Cloud微服务权限系统，所以在此之前你需要掌握Kubernetes的基本知识。如果您还未曾接触过Kubernetes，可以通过我的博客<a target="_blank" rel="noopener" href="https://mrbird.cc/tags/Kubernetes/%E6%88%96%E8%80%85%E8%B4%AD%E4%B9%B0%E3%80%8AKubernetes%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC4%E7%89%88)%E3%80%8B%E4%B9%A6%E7%B1%8D%E5%AD%A6%E4%B9%A0%E3%80%82">https://mrbird.cc/tags/Kubernetes/或者购买《Kubernetes权威指南(第4版)》书籍学习。</a></p>
<h2 id="9-2-安装第三方服务"><a href="#9-2-安装第三方服务" class="headerlink" title="9.2. 安装第三方服务"></a>9.2. 安装第三方服务</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426916">https://www.kancloud.cn/mrbird/spring-cloud/1426916</a></p>
<p>这一节我们需要安装的内容较多，包括Docker、Docker Compose、MySQL、Redis、ELK等软件。</p>
<h2 id="9-3-Kubeadm搭建K8S-1-16-2集群"><a href="#9-3-Kubeadm搭建K8S-1-16-2集群" class="headerlink" title="9.3. Kubeadm搭建K8S 1.16.2集群"></a>9.3. Kubeadm搭建K8S 1.16.2集群</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426917">https://www.kancloud.cn/mrbird/spring-cloud/1426917</a></p>
<p>Kubernetes从1.4版本开始后就引入了kubeadm用于简化集群搭建的过程，在Kubernetes 1.13版本中，kubeadm工具进入GA阶段，可用于生产环境Kubernetes集群搭建。本节将使用Kubeadm搭建Kubernetes1.16.2集群，宿主机使用9.1里搭建的master、node1、node2、node3四台虚拟机，即一主三从的K8S集群结构。</p>
<h2 id="9-4-NFS服务器搭建"><a href="#9-4-NFS服务器搭建" class="headerlink" title="9.4. NFS服务器搭建"></a>9.4. NFS服务器搭建</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426918">https://www.kancloud.cn/mrbird/spring-cloud/1426918</a></p>
<p>在K8S中，我们虽然可以使用volume将容器内目录挂载到宿主机目录上，但由于Pod调度的不确定性，这种数据存储方式是不牢靠的。对于有状态的应用，我们希望无论Pod被调度到哪个节点上，它们的数据总能够完整地恢复，这时候我们就不能用volume挂载了，而应该使用“网络共享存储”。</p>
<h2 id="9-5-搭建Docker镜像仓库Harbor"><a href="#9-5-搭建Docker镜像仓库Harbor" class="headerlink" title="9.5. 搭建Docker镜像仓库Harbor"></a>9.5. 搭建Docker镜像仓库Harbor</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426919">https://www.kancloud.cn/mrbird/spring-cloud/1426919</a></p>
<p>在本地环境下（或者公司局域网），将Docker镜像推送到Docker Hub速度比较慢，推荐的做法是安装一个第三方的Docker镜像仓库，这里推荐使用Harbor。Harbor是一款开源的Docker镜像存储仓库，其扩展了Docker Distribution，在此基础上添加了我们常用的功能，比如安全认证，RBAC用户权限管理，可视化页面操作等功能。</p>
<h2 id="9-6-K8S构建高可用Nacos"><a href="#9-6-K8S构建高可用Nacos" class="headerlink" title="9.6. K8S构建高可用Nacos"></a>9.6. K8S构建高可用Nacos</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426920">https://www.kancloud.cn/mrbird/spring-cloud/1426920</a></p>
<h2 id="9-7-K8S构建FEBS-Cloud服务集群"><a href="#9-7-K8S构建FEBS-Cloud服务集群" class="headerlink" title="9.7. K8S构建FEBS Cloud服务集群"></a>9.7. K8S构建FEBS Cloud服务集群</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426921">https://www.kancloud.cn/mrbird/spring-cloud/1426921</a></p>
<h2 id="9-8-部署前端测试"><a href="#9-8-部署前端测试" class="headerlink" title="9.8. 部署前端测试"></a>9.8. 部署前端测试</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1426922">https://www.kancloud.cn/mrbird/spring-cloud/1426922</a></p>
<h1 id="10-分布式事务研究"><a href="#10-分布式事务研究" class="headerlink" title="10. 分布式事务研究"></a>10. 分布式事务研究</h1><h2 id="10-1-分布式架构事务挑战"><a href="#10-1-分布式架构事务挑战" class="headerlink" title="10.1. 分布式架构事务挑战"></a>10.1. 分布式架构事务挑战</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1456143">https://www.kancloud.cn/mrbird/spring-cloud/1456143</a></p>
<h2 id="10-2-分布式事务解决方案"><a href="#10-2-分布式事务解决方案" class="headerlink" title="10.2. 分布式事务解决方案"></a>10.2. 分布式事务解决方案</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1456144">https://www.kancloud.cn/mrbird/spring-cloud/1456144</a></p>
<h2 id="10-3-基于消息中间件RocketMQ方案（一）"><a href="#10-3-基于消息中间件RocketMQ方案（一）" class="headerlink" title="10.3. 基于消息中间件RocketMQ方案（一）"></a>10.3. 基于消息中间件RocketMQ方案（一）</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1456145">https://www.kancloud.cn/mrbird/spring-cloud/1456145</a></p>
<h2 id="10-4-基于消息中间件RocketMQ方案（二）"><a href="#10-4-基于消息中间件RocketMQ方案（二）" class="headerlink" title="10.4. 基于消息中间件RocketMQ方案（二）"></a>10.4. 基于消息中间件RocketMQ方案（二）</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1456146">https://www.kancloud.cn/mrbird/spring-cloud/1456146</a></p>
<h2 id="10-5-基于TX-LCN方案"><a href="#10-5-基于TX-LCN方案" class="headerlink" title="10.5. 基于TX-LCN方案"></a>10.5. 基于TX-LCN方案</h2><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1456147">https://www.kancloud.cn/mrbird/spring-cloud/1456147</a></p>
<h2 id="10-6-基于阿里Seata方案"><a href="#10-6-基于阿里Seata方案" class="headerlink" title="10.6. 基于阿里Seata方案"></a>10.6. 基于阿里Seata方案</h2><p>10.6. <a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1456148">https://www.kancloud.cn/mrbird/spring-cloud/1456148</a></p>
<ul>
<li>搭建Seata Server<br>Seata是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA（适合业务流程长、业务流程多的情况，所以本节不演示） 和 XA（截至2020年1月1日，该功能Seata还在开发中，所以也不演示） 事务模式，为用户打造一站式的分布式解决方案。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/FEBS/%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" data-id="ckqg285w5005nrcfpbbgb2j1c" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/FEBS/开发教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/FEBS/%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.886Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h1><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1265031">https://www.kancloud.cn/mrbird/spring-cloud/1265031</a><br>后端项目结构如下所示：</p>
<p>├─febs-apm                        —— 微服务APM模块<br>│  ├─febs-admin                   —— 微服务监控中心<br>│  ├─prometheus-grafana           —— prometheus grafana apm相关配置，docker文件<br>│  └─skywalking-elk               —— skywalking elk相关配置，docker文件<br>├─febs-auth                       —— 微服务认证服务器<br>├─febs-cloud                      —— 整个项目的父模块<br>│  ├─sql                          —— SQL脚本<br>│  ├─postman                      —— postman脚本<br>│  └─docker compose               —— 项目相关docker compose文件<br>├─febs-common                     —— 通用模块<br>│  ├─febs-common-core                   —— 系统核心依赖包<br>│  ├─febs-common-datasource-starter     —— 系统数据库自动装配starter<br>│  ├─febs-common-doc                    —— 文档模块的核心依赖包<br>│  ├─febs-common-doc-gateway-starter    —— 网关聚合微服务子系统api文档自动装配starter<br>│  ├─febs-common-doc-starter            —— 微服务子系统api文档自动装配starter<br>│  ├─febs-common-redis-starter          —— 系统Redis自动装配starter<br>│  └─febs-common-security-starter       —— 微服务子系统安全配置自动装配starter<br>├─febs-gateway                    —— 微服务网关<br>├─febs-server                     —— 微服务子系统<br>│  ├─ebs-server-system            —— 微服务子系统系统核心模块<br>│  ├─febs-server-test             —— 微服务子系统demo模块<br>│  ├─febs-server-generator        —— 微服务子系统代码生成模块<br>│  └─febs-server-job              —— 微服务子系统任务调度模块<br>└─febs-tx-manager                 —— 微服务分布式事务控制器</p>
<h1 id="如何添加自己的子系统"><a href="#如何添加自己的子系统" class="headerlink" title="如何添加自己的子系统"></a>如何添加自己的子系统</h1><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1647291">https://www.kancloud.cn/mrbird/spring-cloud/1647291</a><br>为了规范，建议将微服务子系统添加到febs-server层级下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>febs-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.mrbird<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>febs-common-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;febs-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">febs:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">security:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">      <span class="attr">user-info-uri:</span> <span class="string">http://$&#123;febs-gateway&#125;:8301/auth/user</span></span><br></pre></td></tr></table></figure>

<h1 id="如何控制权限"><a href="#如何控制权限" class="headerlink" title="如何控制权限"></a>如何控制权限</h1><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1265033">https://www.kancloud.cn/mrbird/spring-cloud/1265033</a></p>
<ul>
<li><p>后端控制<br>后端资源权限控制使用Spring Cloud Security权限注解控制，比如下面这个资源只有拥有”user:add”权限的用户可以访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;user:add&#x27;)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> FebsException </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.userService.createUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>前端控制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-has-permission</span>=<span class="string">&quot;[&#x27;user:add&#x27;]&quot;</span>&gt;</span>新增用户<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h1><p><a target="_blank" rel="noopener" href="https://www.kancloud.cn/mrbird/spring-cloud/1268277">https://www.kancloud.cn/mrbird/spring-cloud/1268277</a></p>
<p>mvn clean 和 mvn package</p>
<h1 id="PostMan测试"><a href="#PostMan测试" class="headerlink" title="PostMan测试"></a>PostMan测试</h1><h1 id="第三方登录使用指南"><a href="#第三方登录使用指南" class="headerlink" title="第三方登录使用指南"></a>第三方登录使用指南</h1><p>以GitHub登录为例</p>
<h1 id="数据权限"><a href="#数据权限" class="headerlink" title="数据权限"></a>数据权限</h1><p>数据权限通常是通过部门或者组织架构来绑定的，目前系统没有组织架构，只有部门数据，所以在FEBS Cloud中，数据权限通过部门ID绑定。</p>
<p><code>@DataPermission(methods = &#123;&quot;selectPage&quot;&#125;)</code> 注解用于控制数据权限，含义是：DataPermissionTestMapper的selectPage方法开启数据权限。<br>开启后，数据查询前系统会在原始查询SQL中拼接xx.dept_id in (xxx)语句：</p>
<h1 id="Feign的使用"><a href="#Feign的使用" class="headerlink" title="Feign的使用"></a>Feign的使用</h1><p>Feign用于一个微服务子系统调用另一个微服务子系统的接口，本质就是http请求。但是我们的微服务都是受保护的，没有合法的令牌是无法获取到数据的，并且Fein默认并不会帮我们传递令牌。</p>
<h1 id="获取当前用户信息"><a href="#获取当前用户信息" class="headerlink" title="获取当前用户信息"></a>获取当前用户信息</h1><p>febs-common-core包下的FebsUtil工具类中。<code>getCurrentUser</code>、 <code>getCurrentUsername</code>、<code>getCurrentUserAuthority</code>、<code>getCurrentTokenValue</code></p>
<h1 id="全局异常控制"><a href="#全局异常控制" class="headerlink" title="全局异常控制"></a>全局异常控制</h1><p>所谓的全局异常捕获指的是系统的最外层Controller层的异常捕获。febs-common-core包中的BaseExceptionHandler类中定义了系统中几种常见的异常处理</p>
<h1 id="开启系统API文档"><a href="#开启系统API文档" class="headerlink" title="开启系统API文档"></a>开启系统API文档</h1><p>目前较为流行的自动api生成框架为swagger，不过UI界面并不怎么适合国人的使用习惯，FEBS Cloud集成的是Knife4J，下面演示下如何开启微服务API文档生成。</p>
<h1 id="starter使用介绍"><a href="#starter使用介绍" class="headerlink" title="starter使用介绍"></a>starter使用介绍</h1><p><code>febs-common-security-starter</code><br><code>febs-common-doc-starter</code><br><code>febs-common-redis-starter</code><br><code>febs-common-datasource-starter</code></p>
<h1 id="分布式事务演示"><a href="#分布式事务演示" class="headerlink" title="分布式事务演示"></a>分布式事务演示</h1><p>演示前，请确保已经启动了febs-tx-manager、febs-auth、febs-gateway、febs-server-system和febs-server-test。</p>
<h1 id="演示5种获取令牌方式"><a href="#演示5种获取令牌方式" class="headerlink" title="演示5种获取令牌方式"></a>演示5种获取令牌方式</h1><p>OAuth2协议规范了4种获取令牌的方式：授权码模式、密码模式、客户端模式和简化模式，具体可以参考<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6749#section-4.1%E3%80%82Spring">https://tools.ietf.org/html/rfc6749#section-4.1。Spring</a> Cloud OAuth2在此基础上添加了刷新令牌方式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/FEBS/%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/" data-id="ckqg285v7004vrcfp18oj297v" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-architecture/面向对象编程一些方法和原则" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%88%99/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.882Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>开发eata-mail有感</p>
<h3 id="建立模型-："><a href="#建立模型-：" class="headerlink" title="建立模型 ："></a>建立模型 ：</h3><pre><code>数据对象有： SMTP服务器， 邮件



方法和原则：E-R分析方法
</code></pre>
<h3 id="分块与类的设计-："><a href="#分块与类的设计-：" class="headerlink" title="分块与类的设计 ："></a>分块与类的设计 ：</h3><ul>
<li><p>读取邮件的XML配置文件</p>
</li>
<li><p>读取邮件模板并实例化</p>
</li>
<li><p>发送邮件</p>
</li>
</ul>
<pre><code>方法和原则：分块组合和职责单一
</code></pre>
<h3 id="找出每一个块提供的对外方法-："><a href="#找出每一个块提供的对外方法-：" class="headerlink" title="找出每一个块提供的对外方法 ："></a>找出每一个块提供的对外方法 ：</h3><pre><code>- 读取邮件的XML配置文件
    - 读取XML

    - 解析XML文件，转换为Java对象

- 读取邮件模板并实例化
    - 读取模板

    - 实例化模板并输出文本内容

- 发送邮件
    - 初始化邮件配置

    - 发送邮件



方法和原则：面向接口编程
</code></pre>
<h3 id="设计方法的实现细节"><a href="#设计方法的实现细节" class="headerlink" title="设计方法的实现细节"></a>设计方法的实现细节</h3><pre><code>采用流程图、时序图、方法注释来理清流程



方法和原则： 思考重于实现
</code></pre>
<h3 id="为每个方法建立测试用例，并逐一测试"><a href="#为每个方法建立测试用例，并逐一测试" class="headerlink" title="为每个方法建立测试用例，并逐一测试"></a>为每个方法建立测试用例，并逐一测试</h3><pre><code>方法和原则： 测试驱动开发
</code></pre>
<h3 id="以结果为导向编码"><a href="#以结果为导向编码" class="headerlink" title="以结果为导向编码"></a>以结果为导向编码</h3><pre><code>方法和原则： 由果及因，小步快跑 VS 由因及果，一步到位
</code></pre>
<h3 id="完善文档"><a href="#完善文档" class="headerlink" title="完善文档"></a>完善文档</h3><pre><code>编写使用手册、README

整理设计文档



方法和原则： 后期文档重于前期文档
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%88%99/" data-id="ckqg285uo003rrcfp92kx04tx" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/13/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%8C%87%E5%BC%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%93%81%E8%B7%AF6C%E4%B8%9A%E5%8A%A1%E7%BB%93%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E7%AB%99%E7%94%9F%E4%BA%A7%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E5%8E%82%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>