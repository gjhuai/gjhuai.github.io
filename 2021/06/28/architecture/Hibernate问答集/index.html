<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Key Generator  Assigned主键由外部程序负责生成，无需 Hibernate 参与。 hilo通过 hi&#x2F;lo 算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态。 seqhilo与 hilo 类似，通过 hi&#x2F;lo 算法实现的主键生成机制，只是主键历史状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。 increment主键按数值顺">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/06/28/architecture/Hibernate%E9%97%AE%E7%AD%94%E9%9B%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Key Generator  Assigned主键由外部程序负责生成，无需 Hibernate 参与。 hilo通过 hi&#x2F;lo 算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态。 seqhilo与 hilo 类似，通过 hi&#x2F;lo 算法实现的主键生成机制，只是主键历史状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。 increment主键按数值顺">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-28T03:26:10.783Z">
<meta property="article:modified_time" content="2020-05-19T11:28:44.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-architecture/Hibernate问答集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Hibernate%E9%97%AE%E7%AD%94%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.783Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Key-Generator"><a href="#Key-Generator" class="headerlink" title=" Key Generator "></a><font color=red> Key Generator </font></h3><ol>
<li>Assigned<br>主键由外部程序负责生成，无需 Hibernate 参与。</li>
<li>hilo<br>通过 hi/lo 算法实现的主键生成机制，需要额外的数据库表保存主<br>键生成历史状态。</li>
<li>seqhilo<br>与 hilo 类似，通过 hi/lo 算法实现的主键生成机制，只是主键历史<br>状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。</li>
<li>increment<br>主键按数值顺序递增。此方式的实现机制为在当前应用实例中维持<br>一个变量，以保存着当前的最大值，之后每次需要生成主键的时候<br>将此值加 1 作为主键。<br>这种方式可能产生的问题是：如果当前有多个实例访问同一个数据<br>库，那么由于各个实例各自维护主键状态，不同实例可能生成同样<br>的主键，从而造成主键重复异常。因此，如果同一数据库有多个实<br>例访问，此方式必须避免使用。</li>
<li>identity<br>采用数据库提供的主键生成机制。如 DB2、SQL Server、MySQL<br>中的主键生成机制。</li>
<li>sequence<br>采用数据库提供的 sequence 机制生成主键。如 Oralce 中的<br>Sequence。</li>
<li>native<br>由 Hibernate 根据底层数据库自行判断采用 identity、hilo、sequence<br>其中一种作为主键生成方式。</li>
<li>uuid.hex<br>由 Hibernate 基于 128 位唯一值产生算法生成 16 进制数值（编码后<br>以长度 32 的字符串表示）作为主键。</li>
<li>uuid.string<br>与 uuid.hex 类似，只是生成的主键未进行编码（长度 16）。在某些<br>数据库中可能出现问题（如 PostgreSQL）。</li>
<li>foreign<br>使用外部表的字段作为主键。<br>一般而言，利用 uuid.hex 方式生成主键将提供最好的性能和数据库平台适<br>应性。</li>
</ol>
<ul>
<li>另外由于常用的数据库，如 Oracle、DB2、SQLServer、MySql 等，都提 供了易用的主键生成机制（Auto-Increase 字段或者 Sequence）。我们可以在数 据库提供的主键生成机制上，采用 generator-class=native 的主键生成方式。</li>
</ul>
<ul>
<li>对于并发 Insert 要求较高的系统，推荐采用 uuid.hex 作为主键生成 机制。</li>
</ul>
<ul>
<li>如果需要采用定制的主键产生算法，则在此处配置主键生成器，主键生成器必 须实现net.sf.hibernate.id.IdentifierGenerator 接口。</li>
</ul>
<h3 id="Inverse-和-和-Cascade"><a href="#Inverse-和-和-Cascade" class="headerlink" title=" Inverse 和 和 Cascade "></a><font color=red> Inverse 和 和 Cascade </font></h3><p><u>Inverse 指的是关联关系的控制方向，而 cascade 指的是层级之间的连锁操作。</u></p>
<p>Inverse，直译为“反转”。 关联关系中，inverse=”false”的为主动方，由主动方负责维护关联关系。具体可 参见一对多关系中的描述。</p>
<p>而 Cascade，译为“级联”，表明对象的级联关系，如 TUser 的 Cascade 设为 all， 就表明如果发生对 user 对象的操作，需要对 user 所关联的对象也进行同样的操作。如对 user 对象执行 save 操作，则必须对 user 对象相关联的 address 也执行 save 操作。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title=" 锁机制"></a><font color=red> 锁机制</font></h3><p>Hibernate 支持两种锁机制：即通常所说的“悲观锁（Pessimistic Locking）” 和“乐观锁（Optimistic Locking）”。</p>
<p><strong>悲观锁（Pessimistic Locking）</strong></p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自 外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定 状态。<u>悲观锁的实现，往往依靠数据库提供的锁机制</u>（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。</p>
<p>一个典型的倚赖数据库的悲观锁调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String hqlStr =  <span class="string">&quot;from TUser as user where user.name=&#x27;Erica&#x27;&quot;</span>;</span><br><span class="line">Query query = session.createQuery(hqlStr);</span><br><span class="line">query.setLockMode(<span class="string">&quot;user&quot;</span>,LockMode.UPGRADE); <span class="comment">//加锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// select * from t_user where name=&#x27;Erica&#x27; for update</span></span><br><span class="line">List userList = query.list();<span class="comment">//执行查询，获取数据</span></span><br></pre></td></tr></table></figure>


<p>这里 Hibernate 通过使用数据库的 for update 子句实现了悲观锁机制。<br>这条 sql 语句锁定了  t_user   表中所有符合检索条件（name=’Erica’）的记录。 本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。</p>
<p>Hibernate 的加锁模式有：</p>
<ul>
<li>LockMode.NONE ： 无锁机制。</li>
<li>LockMode.WRITE ：Hibernate 在 Insert 和 Update 记录的时候会自动 获取。</li>
<li>LockMode.READ ： Hibernate 在读取记录的时候会自动获取。</li>
</ul>
<p>以上这三种锁机制一般由Hibernate内部使用，如Hibernate为了保证Update 过程中对象不会被外界修改，会在 save 方法实现中自动为目标对象加上 WRITE 锁。</p>
<ul>
<li>LockMode.UPGRADE ：利用数据库的 for update 子句加锁。</li>
<li>LockMode. UPGRADE_NOWAIT ：Oracle 的特定实现，利用 Oracle 的 for  update nowait 子句实现加锁。</li>
</ul>
<p>上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现： Criteria.setLockMode、  Query.setLockMode、  Session.lock</p>
<p>** 乐观锁（Optimistic Locking ）**</p>
<p>乐观锁，大多是基于数据版本 （Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于 数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来 实现。</p>
<p>读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p>乐观锁机制避免了长事务中的数据库加锁开销 ，大大提升了大并发量下的系 统整体性能表现。<br>需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。</p>
<h3 id="Cache-管理"><a href="#Cache-管理" class="headerlink" title=" Cache 管理 "></a><font color=red> Cache 管理 </font></h3><p>在我们的系统与第三方系统共享数据库的情况 下，Hibernate 的 Cache 机制可能失效。</p>
<p>如果在同一套系统中，基于 Hibernate 和基于 JDBC 的两种数据访问方式并存，那么 通过 JDBC 更新数据库的时候，Hibernate 同样无法获知数据更新的情况，从而导致脏数 据的出现。</p>
<p>Hibernate 中的 Cache 大致分为两层，第一层 Cache 在 Session 实现，属于事务 级数据缓冲，一旦事务结束，这个 Cache 也就失效。此层 Cache 为内置实现，无需我们 进行干涉。 第二层 Cache，是 Hibernate 中对其实例范围内的数据进行缓存的管理容器。也是 这里我们讨论的。 Hibernate提供了面向第三方 Cache 实现的接口,  第二级 Cache 实现有： EHCache、OSCache等。</p>
<p>cache usage 可选值有以下几种：</p>
<ol>
<li>read-only<br>只读。</li>
<li>read-write<br>可读可写。</li>
<li>nonstrict-read-write<br>如果程序对并发数据修改要求不是非常严格，只是偶尔需要更新数据，可以采用 本选项，以减少无谓的检查，获得较好的性能。</li>
<li>transactional<br>事务性 cache。在事务性 Cache 中，Cache 的相关操作也被添加到事务之中， 如果由于某种原因导致事务失败，我们可以连同缓冲池中的数据一同回滚到事务 开始之前的状态。目前 Hibernate 内置的 Cache 中，只有 JBossCache 支持事务性的 Cache 实现。</li>
</ol>
<h3 id="Hibernate查询的N-1问题及解决方案"><a href="#Hibernate查询的N-1问题及解决方案" class="headerlink" title=" Hibernate查询的N+1问题及解决方案"></a><font color=red> Hibernate查询的N+1问题及解决方案</font></h3><p>Hibernate 数据库查询， 用的最多的是两个方法：</p>
<ul>
<li>Query.list();</li>
<li>Query.iterate();</li>
</ul>
<p>对于 list 方法而言，实际上 Hibernate 是通过一条 Select SQL 获取所有的记录。 并将其读出，填入到 POJO 中返回。</p>
<p>而 iterate 方法，则是首先通过一条 Select SQL 获取所有符合查询条件的记录的 id，再对这个 id 集合进行循环操作，通过单独的 Select SQL 取出每个 id 所对应的记 录，之后填入 POJO 中返回。</p>
<p>也就是说，对于 list 操作，需要一条 SQL 完成。而对于 iterate 操作，需要 n+1  条 SQL。</p>
<p>看上去 iterate 方法似乎有些多余，但在不同的情况下确依然有其独特的功效，如对 海量数据的查询，如果用 list 方法将结果集一次取出，内存的开销可能无法承受。</p>
<p>另一方面，对于我们现在的 Cache 机制而言，list 方法将不会从 Cache 中读取数据， 它总是一次性从数据库中直接读出所有符合条件的记录。而 iterate 方法因为每次根据 id 获取数据，这样的实现机制也就为从 Cache 读取数据提供了可能，hibernate 首先会 根据这个 id 在本地 Cache 内寻找对应的数据，如果没找到，再去数据库中检索。如果系 统设计中对 Cache 比较倚重，则请注意编码中这两种不同方法的应用组合，有针对性的改 善代码，最大程度提升系统的整体性能表现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 会出现N+1问题，所谓的N+1指的是发出了N+1条sql语句</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 1:发出一条查询id列表的语句</span></span><br><span class="line"><span class="comment">* Hibernate: select student0_.id as col_0_0_ from t_student student0_</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* N:根据id发出N条sql语句，加载相关的对象</span></span><br><span class="line"><span class="comment">* Hibernate: select student0_.id as id0_0_, student0_.name as name0_0_,</span></span><br><span class="line"><span class="comment">* student0_.createTime as createTime0_0_, student0_.classesid as classesid0_0_</span></span><br><span class="line"><span class="comment">* from t_student student0_ where student0_.id=?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Iterator iter = session.createQuery(<span class="string">&quot;from Student&quot;</span>).iterate();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Student student = (Student)iter.next();</span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iterate() 是使用缓存的（session里面缓存，也即是一级缓存）</p>
<p>list() 和 iterate()配合使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 在默认情况下，每次执行list查询实体对象都会发出查询语句，除非配置了查询缓存</span></span><br><span class="line"><span class="comment">* 虽然一级缓存中存在Student数据，但list不用，所以仍然发出查询语句，</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 其实list就是只向缓存中放入数据，而不利用缓存中的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List students = session.createQuery(<span class="string">&quot;from Student&quot;</span>).list();</span><br><span class="line"><span class="keyword">for</span> (Iterator iter=students.iterator(); iter.hasNext();) &#123;</span><br><span class="line">    Student student = (Student)iter.next();</span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 避免了N+1问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 因为执行list操作后会将数据放到session的缓存中（一级缓存），所以采用iterate的时候</span></span><br><span class="line"><span class="comment">* 首先会发出一条查询id列表的语句，再根据id到缓存中加载相应的数据，如果缓存中存在与之匹配的数据</span></span><br><span class="line"><span class="comment">* 则不再发出根据id查询的sql语句，直接使用缓存中的数据</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Iterate方法如果缓存中存在数据，它可以提高性能，否则出现N+1问题</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Iterator iter = session.createQuery(<span class="string">&quot;from Student&quot;</span>).iterate();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Student student = (Student)iter.next();</span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="比较Hibernate的三种检索策略优缺点"><a href="#比较Hibernate的三种检索策略优缺点" class="headerlink" title=" 比较Hibernate的三种检索策略优缺点 "></a><font color=red> 比较Hibernate的三种检索策略优缺点 </font></h3><ol>
<li>立即检索；<br>优点：对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；<br>缺点：1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；</li>
<li>延迟检索：<br>优点：由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；<br>缺点：应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；</li>
<li>迫切左外连接检索<br>优点：1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少；<br>缺点：1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能；</li>
</ol>
<h3 id="Hibernate的实体Bean三种状态？这三种状态的转换过程？"><a href="#Hibernate的实体Bean三种状态？这三种状态的转换过程？" class="headerlink" title=" Hibernate的实体Bean三种状态？这三种状态的转换过程？ "></a><font color=red> Hibernate的实体Bean三种状态？这三种状态的转换过程？ </font></h3><h3 id="在数据库中条件查询速度很慢的时候-如何优化"><a href="#在数据库中条件查询速度很慢的时候-如何优化" class="headerlink" title=" 在数据库中条件查询速度很慢的时候,如何优化? "></a><font color=red> 在数据库中条件查询速度很慢的时候,如何优化? </font></h3><ol>
<li>建索引</li>
<li>减少表之间的关联</li>
<li>优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面</li>
<li>简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</li>
</ol>
<h3 id="session-load-和session-get-的区别"><a href="#session-load-和session-get-的区别" class="headerlink" title=" session.load()和session.get()的区别 "></a><font color=red> session.load()和session.get()的区别 </font></h3><p>Session.load/get方法均可以根据指定的实体类和id从数据库读取记录，并返回与之对应的实体对象。其区别在于：</p>
<p>如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObjectNotFoundException。</p>
<p>Load方法可返回实体的代理类实例，而get方法永远直接返回实体类。</p>
<p>load方法可以充分利用内部缓存和二级缓存中的现有数据，而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，直接调用SQL完成数据读取。</p>
<p>Session在加载实体对象时，将经过的过程：</p>
<p>首先，Hibernate中维持了两级缓存。第一级缓存由Session实例维护，其中保持了Session当前所有关联实体的数据，也称为内部缓存。而第二级缓存则存在于SessionFactory层次，由当前所有由本SessionFactory构造的Session实例共享。出于性能考虑，避免无谓的数据库访问，Session在调用数据库查询功能之前，会先在缓存中进行查询。首先在第一级缓存中，通过实体类型和id进行查找，如果第一级缓存查找命中，且数据状态合法，则直接返回。</p>
<p>之后，Session会在当前“NonExists”记录中进行查找，如果“NonExists”记录中存在同样的查询条件，则返回null。“NonExists”记录了当前Session实例在之前所有查询操作中，未能查询到有效数据的查询条件（相当于一个查询黑名单列表）。如此一来，如果Session中一个无效的查询条件重复出现，即可迅速作出判断，从而获得最佳的性能表现。</p>
<p>对于load方法而言，如果内部缓存中未发现有效数据，则查询第二级缓存，如果第二级缓存命中，则返回。</p>
<p>如在缓存中未发现有效数据，则发起数据库查询操作（Select SQL），如经过查询未发现对应记录，则将此次查询的信息在“NonExists”中加以记录，并返回null。</p>
<p>根据映射配置和Select SQL得到的ResultSet，创建对应的数据对象。</p>
<p>将其数据对象纳入当前Session实体管理容器（一级缓存）。</p>
<p>执行Interceptor.onLoad方法（如果有对应的Interceptor）。</p>
<p>将数据对象纳入二级缓存。</p>
<p>如果数据对象实现了LifeCycle接口，则调用数据对象的onLoad方法。</p>
<p>返回数据对象。</p>
<h3 id="Session-管理"><a href="#Session-管理" class="headerlink" title=" Session 管理 "></a><font color=red> Session 管理 </font></h3><p>大多数情况下，Session 管理的目标聚焦于通过合理的设计，避免 Session 的频繁创建 和销毁，从而避免大量的内存开销和频繁的 JVM 垃圾回收，保证系统高效平滑运行。</p>
<p>在各种 Session 管理方案中， ThreadLocal 模式得到了大量使用。ThreadLocal 是 Java 中一种较为特殊的线程绑定机制。通过 ThreadLocal 存取的数据，总是与当前线程相关， 也就是说，JVM 为每个运行的线程，绑定了私有的本地实例存取空间，从而为多线程环境常出 现的并发访问问题提供了一种隔离机制。</p>
<p>首先，我们需要知道，SessionFactory 负责创建 Session，SessionFactory 是线程 安全的，多个并发线程可以同时访问一个 SessionFactory 并从中获取 Session 实例。而 Session 并非线程安全，也就是说，如果多个线程同时使用一个 Session 实例进行数据存取， 则将会导致 Session 数据存取逻辑混乱。 下面是一个典型的 Servlet，我们试图通过一个类 变量 session 实现 Session 的重用，以避免每次操作都要重新创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Session session;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">( HttpServletRequest request,  HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">          session = getSession();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          doSomething();</span><br><span class="line">          session.flush();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">          ......<span class="comment">//基于session的存取操作</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码看上去正确无误，甚至在我们单机测试的时候可能也不会发生什么问题，但这样的代 码一旦编译部署到实际运行环境中，接踵而来的莫名其妙的错误很可能会使得我们摸不找头脑。 问题出在哪里？</p>
<p>首先，Servlet 运行是多线程的，而应用服务器并不会为每个线程都创建一个 Servlet 实例，也就是说，TestServlet 在应用服务器中只有一个实例（在 Tomcat 中是这样，其他的 应用服务器可能有不同的实现），而这个实例会被许多个线程并发调用，doGet 方法也将被不 同的线程反复调用，可想而知，每次调用 doGet 方法，这个唯一的 TestServlet 实例的 session 变量都会被重置，线程 A 的运行过程中，其他的线程如果也被执行，那么 session 的引用将发生改变，之后线程 A 再调用 session，可能此时的 session 与其之前所用的 session 就不再一致，显然，错误也就不期而至。</p>
<p>ThreadLocal 的出现，使得这个问题迎刃而解。 我们对上面的例子进行一些小小的修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> ThreadLocal localSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">( HttpServletRequest request,  HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">          localSession.set(getSession());</span><br><span class="line">     doSomething();</span><br><span class="line">     session.flush();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">          Session session = (Session)localSession.get();</span><br><span class="line">     ......<span class="comment">//基于session的存取操作</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到，localSession 是一个 ThreadLocal 类型的对象，在 doGet 方法中，我们 通过其 set 方法将获取的 session 实例保存，而在 doSomething 方法中，通过 get 方法取 出 session 实例。</p>
<p>这也就是 ThreadLocal 的独特之处，它会为每个线程维护一个私有的变量空间。实际上， 其实现原理是在 JVM 中维护一个 Map，这个 Map 的 key 就是当前的线程对象，而 value 则是 线程通过 ThreadLocal.set 方法保存的对象实例。当线程调用 ThreadLocal.get 方法时， ThreadLocal 会根据当前线程对象的引用，取出 Map 中对应的对象返回。</p>
<p>这样，ThreadLocal 通过以各个线程对象的引用作为区分，从而将不同线程的变量隔离开 来。</p>
<p>回到上面的例子，通过应用 ThreadLocal 机制，线程 A 的 session 实例只能为线程 A  所用，同样，其他线程的 session 实例也各自从属于自己的线程。这样，我们就实现了线程安全的 Session 共享机制。</p>
<p><strong>spring对hibernate是如何避免session的线程不安全的呢？</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Hibernate%E9%97%AE%E7%AD%94%E9%9B%86/" data-id="ckqg285w3005ircfp0nr8e74t" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/28/architecture/Jackson%20json%E5%BA%8F%E5%88%97%E5%8C%96/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/06/28/architecture/Hadoop%E5%AD%A6%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%8C%87%E5%BC%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%93%81%E8%B7%AF6C%E4%B8%9A%E5%8A%A1%E7%BB%93%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E7%AB%99%E7%94%9F%E4%BA%A7%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E5%8E%82%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>