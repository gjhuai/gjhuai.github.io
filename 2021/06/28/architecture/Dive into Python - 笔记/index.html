<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="★ 字典keys, values 和 items 函数    params &#x3D; {“server”:”mpilgrim”, “database”:”master”, “uid”:”sa”, “pwd”:”secret”}       params. keys ()    [‘server’, ‘uid’, ‘database’, ‘pwd’]    params. values ()    [‘m">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/06/28/architecture/Dive%20into%20Python%20-%20%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="★ 字典keys, values 和 items 函数    params &#x3D; {“server”:”mpilgrim”, “database”:”master”, “uid”:”sa”, “pwd”:”secret”}       params. keys ()    [‘server’, ‘uid’, ‘database’, ‘pwd’]    params. values ()    [‘m">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-06-28T03:26:10.779Z">
<meta property="article:modified_time" content="2020-05-19T11:28:44.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-architecture/Dive into Python - 笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/28/architecture/Dive%20into%20Python%20-%20%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-06-28T03:26:10.779Z" itemprop="datePublished">2021-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>★ 字典keys, values 和 items 函数</p>
<blockquote>
<blockquote>
<blockquote>
<p>params = {“server”:”mpilgrim”, “database”:”master”, “uid”:”sa”, “pwd”:”secret”}</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>params. keys ()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[‘server’, ‘uid’, ‘database’, ‘pwd’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>params. values ()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[‘mpilgrim’, ‘sa’, ‘master’, ‘secret’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>params. items ()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[(‘server’, ‘mpilgrim’), (‘uid’, ‘sa’), (‘database’, ‘master’), (‘pwd’, ‘secret’)]</p>
<p>★ join 方法和type 方法</p>
<blockquote>
<blockquote>
<blockquote>
<p>“;”. join ([“%s=%s” % (k, v) for k, v in params.items()])  # join连接一个列表</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘server=mpilgrim;uid=sa;database=master;pwd=secret’</p>
<blockquote>
<blockquote>
<blockquote>
<p>type (odbchelper) == types .ModuleType         # 可以使用 types 模块中的常量来进行对象类型的比较</p>
</blockquote>
</blockquote>
</blockquote>
<p>True</p>
<p>★ str方法</p>
<blockquote>
<blockquote>
<blockquote>
<p>horsemen = [‘war’, ‘pestilence’, ‘famine’]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>horsemen. append (‘Powerbuilder’)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>str (horsemen)</p>
</blockquote>
</blockquote>
</blockquote>
<p>“[‘war’, ‘pestilence’, ‘famine’, ‘Powerbuilder’]”</p>
<blockquote>
<blockquote>
<blockquote>
<p>str (odbchelper)</p>
</blockquote>
</blockquote>
</blockquote>
<p>“&lt;module ‘odbchelper’ from ‘c:\docbook\dip\py\odbchelper.py’&gt;”</p>
<blockquote>
<blockquote>
<blockquote>
<p>str (None)</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘None’</p>
<p>★ callable 函数</p>
<p>callable 函数接收任何对象作为参数， 如果参数对象是可调用的，返回 True；否则返回 False。 可调用对象包括函数、类方法，甚至类自身。</p>
<blockquote>
<blockquote>
<blockquote>
<p>import string</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>string. punctuation</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘!”#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~’</p>
<blockquote>
<blockquote>
<blockquote>
<p>string.join</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;function join at 00C55A7C&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>callable (string.punctuation)</p>
</blockquote>
</blockquote>
</blockquote>
<p>False</p>
<blockquote>
<blockquote>
<blockquote>
<p>callable (string.join)       </p>
</blockquote>
</blockquote>
</blockquote>
<p>True</p>
<blockquote>
<blockquote>
<blockquote>
<p>print string.join.<strong>doc</strong>      # 任何对象都有 doc string</p>
</blockquote>
</blockquote>
</blockquote>
<p>join(list [,sep]) -&gt; string</p>
<pre><code>Return a string composed of the words in list, with

intervening occurrences of sep.  The default separator is a

single space.

(joinfields and join are synonymous)
</code></pre>
<p>★ getattr 函数介绍</p>
<p>使用 函数，可以返回任何对象的任何属性，并且这个属性的名称可以是直到运行时才知道（即可以是字符串）。</p>
<blockquote>
<blockquote>
<blockquote>
<p>li = [“Larry”, “Curly”]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>li.pop                       # 获取列表的 pop 方法的引用。是引用(方法对象本身)，而不是调用( li.pop() ) 。</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;built-in method pop of list object at 010DF884&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>getattr(li, “pop”)            #   返回 pop 方法的引用，但是此时，方法名称是作为一个字符串参数传递给 函数的。</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;built-in method pop of list object at 010DF884&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>getattr (li, “append”)(“Moe”)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>li</p>
</blockquote>
</blockquote>
</blockquote>
<p>[“Larry”, “Curly”, “Moe”]</p>
<p>例 4.12. 使用 创建分发者</p>
<p>statsout 模块定义了三个函数：output_html、output_xml 和 output_text。然后主程序定义了唯一的输出函数，如下：</p>
<p>import statsout</p>
<p>def output(data, format=”text”):                             </p>
<pre><code>output_function = getattr (statsout, &quot;output_%s&quot; % format)

return output_function(data)                             
</code></pre>
<p>缺省值</p>
<p>import statsout</p>
<p>def output(data, format=”text”):</p>
<pre><code># 下面的 第三个参数是一个缺省返回值，如果第二个参数指定的属性或者方法没能找到，则将返回这个缺省返回值 。  

output_function = (statsout, &quot;output_%s&quot; % format, statsout.output_text )

return output_function(data)  
</code></pre>
<p>★ 列表方法 count 的使用</p>
<blockquote>
<blockquote>
<blockquote>
<p>li = [“a”, “mpilgrim”, “foo”, “b”, “c”, “b”, “d”, “d”]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>[elem for elem in li if li. count (elem) == 1]          # count 返回某个值在列表中出现的次数 ，可以用来剔除列表中出现两次以上的值 (本例中的 b 和 d)。</p>
</blockquote>
</blockquote>
</blockquote>
<p>[‘a’, ‘mpilgrim’, ‘foo’, ‘c’]</p>
<p>★ filter方法的使用</p>
<blockquote>
<blockquote>
<blockquote>
<p>def f(x): return x % 2 != 0 and x % 3 != 0</p>
</blockquote>
</blockquote>
</blockquote>
<p>…</p>
<blockquote>
<blockquote>
<blockquote>
<p>filter (f, range(2, 25))         # 对2-24之间的整数运用函数 f(x)， 如果 f(x) 的运行结果是真 ，那么 x 就加入返回列表</p>
</blockquote>
</blockquote>
</blockquote>
<p> [5, 7, 11, 13, 17, 19, 23]</p>
<p> ★ map方法的使用</p>
<blockquote>
<blockquote>
<blockquote>
<p>def cube(x): return x<em>x</em>x</p>
</blockquote>
</blockquote>
</blockquote>
<p>…</p>
<blockquote>
<blockquote>
<blockquote>
<p>map (cube, range(1, 11))        # 对应1-10之间的整数运用函数 cube(x)，并把 cube(x) 的运行结果加入返回列表</p>
</blockquote>
</blockquote>
</blockquote>
<p>[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]</p>
<blockquote>
<blockquote>
<blockquote>
<p>seq = range(8)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>def add(x, y): return x+y</p>
</blockquote>
</blockquote>
</blockquote>
<p>…</p>
<blockquote>
<blockquote>
<blockquote>
<p>map (add, seq, seq)</p>
</blockquote>
</blockquote>
</blockquote>
<p>[0, 2, 4, 6, 8, 10, 12, 14]</p>
<p>★ reduce方法的使用  </p>
<blockquote>
<blockquote>
<blockquote>
<p>def add(x,y): return x+y</p>
</blockquote>
</blockquote>
</blockquote>
<p>…</p>
<blockquote>
<blockquote>
<blockquote>
<p>reduce (add, range(1, 11))         # 计算1-10的累加和</p>
</blockquote>
</blockquote>
</blockquote>
<p>55</p>
<blockquote>
<blockquote>
<blockquote>
<p>def sum(seq):</p>
</blockquote>
</blockquote>
</blockquote>
<p>…     def add(x,y): return x+y</p>
<p>…     return reduce (add, seq, 0 )          # 第三个参数 0 ，是表示列表seq的开始值</p>
<p>…</p>
<blockquote>
<blockquote>
<blockquote>
<p>sum(range(1, 11))</p>
</blockquote>
</blockquote>
</blockquote>
<p>55</p>
<blockquote>
<blockquote>
<blockquote>
<p>sum([])</p>
</blockquote>
</blockquote>
</blockquote>
<p>0</p>
<p>★ and 和 or 布尔逻辑演算符</p>
<p>and 和 or  它们并不返回布尔值，而是返回它们实际进行比较的值之一 。 在布尔环境中从左到右演算表达式的值。0、’’、[]、()、{}、None 在布尔环境中为假；其它任何东西都为真 。</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘’ and ‘b’          # 如果布尔环境中的某个值为假，则 and 返回第一个假值</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘’</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘a’ and ‘b’ and ‘c’          # 所有值都为真，所以 and 返回最后一个真值，’c’</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘c’</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘a’ or ‘b’          # 如果有一个值为真，or 立刻返回该值</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘a’</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘’ or [] or {}      # 如果所有的值都为假，or 返回最后一个假值</p>
</blockquote>
</blockquote>
</blockquote>
<p>{}</p>
<blockquote>
<blockquote>
<blockquote>
<p>def sidefx():</p>
</blockquote>
</blockquote>
</blockquote>
<p>…     print “in sidefx()”</p>
<p>…     return 1</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘a’ or sidefx()             # 进行 or 运算时，会一直进行表达式演算直到找到第一个真值，然后就会忽略剩余的比较值。</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘a’</p>
<p>★ 使用 and-or 技巧</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = “first”</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b = “second”</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1 and a or b         # 1 and ‘first’ 演算值为 ‘first’，然后 ‘first’ or ‘second’ 的演算值为 ‘first’。</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘first’</p>
<blockquote>
<blockquote>
<blockquote>
<p>0 and a or b         # 0 and ‘first’ 演算值为 False，然后 0 or ‘second’ 演算值为 ‘second’。</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘second’</p>
<p>如果 a 为假，and-or 技巧和 C 语言中的 bool ? a : b 语法非常重要的不同。</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = “”</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b = “second”</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1 and a or b        </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘second’</p>
<p>★ 安全使用 and-or 技巧</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = “”</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>b = “second”</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>(1 and [a] or [b])[0]          # 由于 [a] 是一个非空列表，所以它决不会为假。即使 a 是 0 或者 ‘’ 或者其它假值，列表 [a] 也为真，因为它有一个元素。</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘’ </p>
<p>★ lambda方法</p>
<blockquote>
<blockquote>
<blockquote>
<p>g = lambda x: x*2          # 定义单行的最小函数</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>g(3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>6</p>
<blockquote>
<blockquote>
<blockquote>
<p>( lambda x: x*2)(3)</p>
</blockquote>
</blockquote>
</blockquote>
<p>6</p>
<p>processFunc = collapse and (lambda s: “ “.join(s.split())) or (lambda s: s)        # 这里使用了 and-or 技巧的简单形式</p>
<p>processFunc 是一个函数的引用，但是它到底是哪一个函数还要取决于 collapse 变量。如果 collapse 为真，processFunc(string) 将压缩空白；否则 processFunc(string) 将返回未改变的参数。</p>
<p>★ 为什么对一个 doc string 使用 str ？</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>def foo(): print 2</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>foo()</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>2</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>foo.<strong>doc</strong>    </p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>foo.<strong>doc</strong> == None</p>
</blockquote>
</blockquote>
</blockquote>
<p>True</p>
<blockquote>
<blockquote>
<blockquote>
<p>str (foo.<strong>doc</strong>)   </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘None’</p>
<p>★ ljust 方法介绍</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = ‘buildConnectionString’</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>s. ljust (30)                 # ljust 用空格填充字符串以符合指定的长度</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘buildConnectionString         ‘</p>
<blockquote>
<blockquote>
<blockquote>
<p>s. ljust (20)                 # 如果指定的长度小于字符串的长度，ljust 将简单地返回未变化的字符串，而不会截断字符串 。 </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘buildConnectionString’  </p>
<p>class FileInfo(UserDict):</p>
<pre><code>&quot;store file metadata&quot;

def __init__(self, filename=None):

    UserDict.__init__(self)       

    self[&quot;name&quot;] = filename
</code></pre>
<p>在类的实例创建后被立即调用。它不是构造函数</p>
<p>是因为对象在调用 <strong>init</strong> 时已经被构造出来了，你已经有了一个对类的新实例的有效引用。</p>
<p>必须显示地调用在父类中的合适方法。</p>
<p><strong>init</strong> 方法从不返回一个值。</p>
<p><strong>init</strong> 方法是可选的</p>
<blockquote>
<blockquote>
<blockquote>
<p>import fileinfo</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>f = fileinfo.FileInfo(“/music/_singles/kairo.mp3”)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>f.<strong>class</strong>                                       </p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;class fileinfo.FileInfo at 010EC204&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>f.<strong>doc</strong>                                         </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘store file metadata’</p>
<blockquote>
<blockquote>
<blockquote>
<p>f                                                 </p>
</blockquote>
</blockquote>
</blockquote>
<p>{‘name’: ‘/music/_singles/kairo.mp3’}</p>
<p>每一个类的实例有一个内置属性，__class__，它是对象的类。(</p>
<p>这类元数据可以直接通过对象本身的属性，像 <strong>class__、__name</strong> 和 <strong>bases</strong> 来得到。</p>
<p>你可以像对函数或模块一样来访问实例的 doc string。</p>
<p>class UserDict:                               </p>
<pre><code>def __init__(self, dict=None):            

    self.data = &#123;&#125;                        

    if dict is not None: self.update(dict) 
</code></pre>
<p>update 方法是一个字典复制器：它把一个字典中的键和值全部拷贝到另一个字典。这个操作并不 事先清空目标字典，如果一些键在目标字典中已经存在，则它们将被覆盖，那些键名在目标字典中不存在的则不改变。应该把 update 看作是合并函数，而不是复制函数。</p>
<p>例 5.11. 直接继承自内建数据类型 dict</p>
<p>class FileInfo(dict):                 </p>
<pre><code>&quot;store file metadata&quot;

def __init__(self, filename=None):

    self[&quot;name&quot;] = filename
</code></pre>
<p>  第一个区别是你不需要导入 UserDict 模块，因为 dict 是已经可以使用的内建数据类型。第二个区别是你不是继承自 UserDict.UserDict ，而是直接继承自 dict。 </p>
<p>  第三个区别有些晦涩，但却很重要。UserDict 内部的工作方式要求你手工地调用它的 <strong>init</strong> 方法去正确初始化它的内部数据结构。dict 并不这样工作，它不是一个封装所以不需要明确的初始化。 </p>
<p>专用类方法</p>
<p><strong>getitem</strong> 专用方法</p>
<pre><code>def __getitem__(self, key): return self.data[key]&gt;&gt;&gt; f = fileinfo.FileInfo(&quot;/music/_singles/kairo.mp3&quot;)
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>f</p>
</blockquote>
</blockquote>
</blockquote>
<p>{‘name’:’/music/_singles/kairo.mp3’}</p>
<blockquote>
<blockquote>
<blockquote>
<p>f.<strong>getitem</strong>(“name”)</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘/music/_singles/kairo.mp3’</p>
<blockquote>
<blockquote>
<blockquote>
<p>f[“name”]            </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘/music/_singles/kairo.mp3’</p>
<p>暗地里，Python 已经将这个语法转化为 f.<strong>getitem</strong>(“name”) 的方法调用。</p>
<p><strong>setitem</strong> 专用方法</p>
<blockquote>
<blockquote>
<blockquote>
<p>f[“genre”] = 32           </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>f</p>
</blockquote>
</blockquote>
</blockquote>
<p>暗地里调用了 f.<strong>setitem</strong>(“genre”, 32)。</p>
<p><strong>repr</strong></p>
<p>在当调用 repr(instance) 时被调用。</p>
<p>repr 函数是一个内置函数，它返回一个对象的字符串表示。</p>
<p>它可以用在任何对象上，不仅仅是类的实例。</p>
<p>相当于java的toString()方法</p>
<p><strong>cmp</strong> 在比较类实例时被调用。通常，你可以通过使用 == 比较任意两个 Python 对象，不只是类实例。</p>
<p>对于类实例，你可以定义 <strong>cmp</strong> 方法，自已编写比较逻辑，然后你可以使用 == 来比较你的类，Python 将会替你调用你的 <strong>cmp</strong> 专用方法。</p>
<p>相当于java的equals()，需要重载来实现自己的逻辑</p>
<p><strong>len</strong> 在调用 len(instance) 时被调用。</p>
<p>对于类实例，定义 <strong>len</strong> 方法，接着自已编写长度的计算，然后调用 len(instance)，Python 将替你调用你的 <strong>len</strong> 专用方法。</p>
<p><strong>delitem</strong> 在调用 del instance[key] 时调用</p>
<p>当你在类实例中使用 del 时，Python 替你调用 <strong>delitem</strong> 专用方法。</p>
<p>class MP3FileInfo(FileInfo):</p>
<pre><code>&quot;store ID3v1.0 MP3 tags&quot;

tagDataMap = &#123;&quot;title&quot;   : (  3,  33, stripnulls),

              &quot;artist&quot;  : ( 33,  63, stripnulls),

              &quot;album&quot;   : ( 63,  93, stripnulls),

              &quot;year&quot;    : ( 93,  97, stripnulls),

              &quot;comment&quot; : ( 97, 126, stripnulls),

              &quot;genre&quot;   : (127, 128, ord)&#125;&gt;&gt;&gt; import fileinfo
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<p>fileinfo.MP3FileInfo           </p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;class fileinfo.MP3FileInfo at 01257FDC&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>fileinfo.MP3FileInfo.tagDataMap</p>
</blockquote>
</blockquote>
</blockquote>
<p>{‘title’: (3, 33, &lt;function stripnulls at 0260C8D4&gt;),</p>
<p>‘genre’: (127, 128, <built-in function ord>),</p>
<p>‘artist’: (33, 63, &lt;function stripnulls at 0260C8D4&gt;),</p>
<p>‘year’: (93, 97, &lt;function stripnulls at 0260C8D4&gt;),</p>
<p>‘comment’: (97, 126, &lt;function stripnulls at 0260C8D4&gt;),</p>
<p>‘album’: (63, 93, &lt;function stripnulls at 0260C8D4&gt;)}</p>
<blockquote>
<blockquote>
<blockquote>
<p>m = fileinfo.MP3FileInfo()     </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>m.tagDataMap</p>
</blockquote>
</blockquote>
</blockquote>
<p>tagDataMap 是一个类属性：字面的意思，一个类的属性。它在创建任何类实例之前就有效了。 </p>
<p>  类属性既可以通过直接对类的引用，也可以通过对类的任意实例的引用来使用。</p>
<blockquote>
<blockquote>
<blockquote>
<p>f.seek(-128, 2)      </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>f.tell()             </p>
</blockquote>
</blockquote>
</blockquote>
<p>7542909</p>
<blockquote>
<blockquote>
<blockquote>
<p>tagData = f.read(128)</p>
</blockquote>
</blockquote>
</blockquote>
<p>文件对象的 seek 方法在被打开文件中移动到另一个位置。第二个参数指出第一个参数是什么意思：0 表示移动到一个绝对位置 (从文件起始处算起)，1 表示移到一个相对位置 (从当前位置算起)，还有 2 表示相对于文件尾的位置。</p>
<p>tell 方法确认了当前位置已经移动了。</p>
<p>可选参数指定了读取的最大字节数。如果没有指定参数，read 将读到文件末尾。</p>
<blockquote>
<blockquote>
<blockquote>
<p>f.closed      </p>
</blockquote>
</blockquote>
</blockquote>
<p>False</p>
<p>例 6.14. <strong>module</strong> 类属性</p>
<blockquote>
<blockquote>
<blockquote>
<p>from fileinfo import MP3FileInfo</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>MP3FileInfo.<strong>module</strong>             </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘fileinfo’</p>
<blockquote>
<blockquote>
<blockquote>
<p>sys.modules[MP3FileInfo.<strong>module</strong>]</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;module ‘fileinfo’ from ‘fileinfo.pyc’&gt;  每个 Python 类都拥有一个内置的类属性 __module__，它定义了这个类的模块的名字。 </p>
<p>  将它与 sys.modules 字典复合使用，你可以得到定义了某个类的模块的引用。</p>
<p>hasattr 是一个补充性的函数，用来检查一个对象是否具有一个特定的属性；</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.join(“c:\music\ap\“, “mahadeva.mp3”) </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘c:\music\ap\mahadeva.mp3’</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.join(“c:\music\ap”, “mahadeva.mp3”)  </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘c:\music\ap\mahadeva.mp3’</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.expanduser(“~”)                        </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘c:\Documents and Settings\mpilgrim\My Documents’</p>
<p>os.path 的 join 函数把一个或多个部分路径名连接成一个路径名。</p>
<p>expanduser 将对使用 ~ 来表示当前用户根目录的路径名进行扩展。</p>
<p>例 6.17. 分割路径名</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.split(“c:\music\ap\mahadeva.mp3”)                       </p>
</blockquote>
</blockquote>
</blockquote>
<p>(‘c:\music\ap’, ‘mahadeva.mp3’)</p>
<blockquote>
<blockquote>
<blockquote>
<p>(filepath, filename) = os.path.split(“c:\music\ap\mahadeva.mp3”)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>filepath                                                           </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘c:\music\ap’</p>
<blockquote>
<blockquote>
<blockquote>
<p>filename                                                           </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘mahadeva.mp3’</p>
<blockquote>
<blockquote>
<blockquote>
<p>(shortname, extension) = os.path.splitext(filename)                </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>shortname</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘mahadeva’</p>
<blockquote>
<blockquote>
<blockquote>
<p>extension</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘.mp3’</p>
<p>split 函数对一个全路径名进行分割，返回一个包含路径和文件名的 tuple。</p>
<p>os.path 也包含了一个 splitext 函数，可以用来对文件名进行分割，并且返回一个包含了文件名和文件扩展名的 tuple。</p>
<p>例 6.18. 列出目录</p>
<blockquote>
<blockquote>
<blockquote>
<p>[f for f in os.listdir(dirname)</p>
</blockquote>
</blockquote>
</blockquote>
<p>…     if os.path.isfile(os.path.join(dirname, f))]</p>
<p>[‘AUTOEXEC.BAT’, ‘boot.ini’, ‘CONFIG.SYS’, ‘IO.SYS’, ‘MSDOS.SYS’,</p>
<p>‘NTDETECT.COM’, ‘ntldr’, ‘pagefile.sys’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>[f for f in os.listdir(dirname)</p>
</blockquote>
</blockquote>
</blockquote>
<p>…     if os.path.isdir(os.path.join(dirname, f))] </p>
<p>[‘cygwin’, ‘docbook’, ‘Documents and Settings’, ‘Incoming’,</p>
<p>‘Inetpub’, ‘Music’, ‘Program Files’, ‘Python20’, ‘RECYCLER’,</p>
<p>‘System Volume Information’, ‘TEMP’, ‘WINNT’]</p>
<p>listdir 同时返回文件和文件夹，并不指出哪个是文件，哪个是文件夹。</p>
<p>我们使用 os.path.join 来确保得到一个全路径名，但 isfile 对部分路径 (相对于当前目录) 也是有效的。你可以使用 os.getcwd() 来得到当前目录。</p>
<p>fileList = [os.path.normcase(f)</p>
<pre><code>            for f in os.listdir(directory)]           
</code></pre>
<p>os.path.normcase(f) 根据操作系统的缺省值对大小写进行标准化处理。</p>
<p>在 Windows 和 Mac OS 下，normcase 将把整个文件名转换为小写字母；而在 UNIX 兼容的系统下，它将返回未作修改的文件名。</p>
<blockquote>
<blockquote>
<blockquote>
<p>import glob</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>glob.glob(‘c:\music\_singles\*.mp3’)          </p>
</blockquote>
</blockquote>
</blockquote>
<p>[‘c:\music\_singles\a_time_long_forgotten_con.mp3’,</p>
<p>‘c:\music\_singles\hellraiser.mp3’,</p>
<p>‘c:\music\_singles\kairo.mp3’,</p>
<p>‘c:\music\_singles\long_way_home1.mp3’,</p>
<p>‘c:\music\_singles\sidewinder.mp3’,</p>
<p>‘c:\music\_singles\spinning.mp3’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>glob.glob(‘c:\music\_singles\s*.mp3’)         </p>
</blockquote>
</blockquote>
</blockquote>
<p>[‘c:\music\_singles\sidewinder.mp3’,</p>
<p>‘c:\music\_singles\spinning.mp3’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>glob.glob(‘c:\music\*\*.mp3’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>glob 模块，另一方面，接受一个通配符并且返回文件的或目录的完整路径与之匹配。</p>
<p>例 8.10. locals 介绍</p>
<blockquote>
<blockquote>
<blockquote>
<p>def foo(arg):</p>
</blockquote>
</blockquote>
</blockquote>
<p>…     x = 1</p>
<p>…     print locals()</p>
<pre><code>    locals()[&quot;x&quot;] = 2 

    print &quot;x=&quot;,x  #这样会打印出 x= 1，而不是 x= 2。
</code></pre>
<p>…    </p>
<blockquote>
<blockquote>
<blockquote>
<p>foo(7)       </p>
</blockquote>
</blockquote>
</blockquote>
<p>{‘arg’: 7, ‘x’: 1}</p>
<p>函数 foo 在它的局部名字空间中有两个变量：arg (它的值是被传入函数的) 和 x (它是在函数里定义的)。</p>
<p>locals 实际上没有返回局部名字空间，它返回的是一个拷贝。所以对它进行改变对局部名字空间中的变量值并无影响。</p>
<p>例 8.11. globals 介绍</p>
<p>看看下面列出的在文件 BaseHTMLProcessor.py 尾部的代码块：</p>
<p>if <strong>name</strong> == “<strong>main</strong>“:</p>
<pre><code>for k, v in globals().items():            

    print k, &quot;=&quot;, v
</code></pre>
<p>globals 函数返回一个 dictionary，</p>
<p>globals 返回实际的全局名字空间，而不是一个拷贝：与 locals 的行为完全相反。所以对 globals 所返回的 dictionary 的任何的改动都会直接影响到全局变量。</p>
<p>例 8.12. locals 是只读的，globals 不是</p>
<p>def foo(arg):</p>
<pre><code>x = 1

print locals()   

locals()[&quot;x&quot;] = 2

print &quot;x=&quot;,x     
</code></pre>
<p>z = 7</p>
<p>print “z=”,z</p>
<p>foo(3)</p>
<p>globals()[“z”] = 8   </p>
<p>print “z=”,z         </p>
<p>例 8.13. 基于 dictionary 的字符串格式化介绍</p>
<blockquote>
<blockquote>
<blockquote>
<p>params = {“server”:”mpilgrim”, “database”:”master”, “uid”:”sa”, “pwd”:”secret”}</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>“%(pwd)s” % params                                   </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘secret’</p>
<blockquote>
<blockquote>
<blockquote>
<p>“%(pwd)s is not a good password for %(uid)s” % params</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘secret is not a good password for sa’</p>
<p>XML 解析</p>
<blockquote>
<blockquote>
<blockquote>
<p>from xml.dom import minidom                                         </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>xmldoc = minidom.parse(‘~/diveintopython/common/py/kgp/binary.xml’) </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>xmldoc                                                              </p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;xml.dom.minidom.Document instance at 010BE87C&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>print xmldoc.toxml()                                                </p>
</blockquote>
</blockquote>
</blockquote>
<?xml version="1.0" ?>

<grammar>

<ref id="bit">

  <p>0</p>

  <p>1</p>

</ref>

<ref id="byte">

  <p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/>\

<p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/></p></p>
</ref>

</grammar>


<p>minidom.parse 接收一个参数</p>
<p>本地磁盘上一个 XML 文档的文件名。(你需要将路径改为指向下载的例子所在的目录。) 但是你也可以传入一个文件对象，或甚至是一个类文件对象。</p>
<p>从 minidom.parse 返回的对象是一个 Document 对象，它是 Node 类的一个子对象。</p>
<p>toxml 是 Node 类的一个方法</p>
<p>toxml 打印出了 Node 表示的 XML。对于 Document 节点，这样就会打印出整个 XML 文档。</p>
<blockquote>
<blockquote>
<blockquote>
<p>xmldoc.childNodes   </p>
</blockquote>
</blockquote>
</blockquote>
<p>[&lt;DOM Element: grammar at 17538908&gt;]</p>
<blockquote>
<blockquote>
<blockquote>
<p>xmldoc.childNodes[0]  #得到第一个 (在本例中，只有一个) 子节点</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;DOM Element: grammar at 17538908&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>xmldoc.firstChild   </p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;DOM Element: grammar at 17538908&gt;</p>
<p>每个 Node 都有一个 childNodes 属性，它是一个 Node 对象的列表。一个 Document 只有一个子节点，即 XML 文档的根元素</p>
<p>Node 类有一个 firstChild 属性，它和childNodes[0]具有相同的语义。(还有一个 lastChild 属性，它和childNodes[-1]具有相同的语义。)</p>
<p>例 9.10. toxml 用于任何节点</p>
<blockquote>
<blockquote>
<blockquote>
<p>grammarNode = xmldoc.firstChild</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print grammarNode.toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<grammar>

<ref id="bit">

  <p>0</p>

  <p>1</p>

</ref>

<ref id="byte">

  <p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/>\

<p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/></p></p>
</ref>

</grammar>

<p>每一个 Node 类都有toxml()方法</p>
<p>例 9.11. 子节点可以是文本</p>
<blockquote>
<blockquote>
<blockquote>
<p>grammarNode.childNodes                 </p>
</blockquote>
</blockquote>
</blockquote>
<p>[&lt;DOM Text node “\n”&gt;, &lt;DOM Element: ref at 17533332&gt;, \</p>
<p>&lt;DOM Text node “\n”&gt;, &lt;DOM Element: ref at 17549660&gt;, &lt;DOM Text node “\n”&gt;]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print grammarNode.firstChild.toxml()   </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print grammarNode.childNodes[1].toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<ref id="bit">

  <p>0</p>

  <p>1</p>

</ref>

<blockquote>
<blockquote>
<blockquote>
<p>print grammarNode.childNodes[3].toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<ref id="byte">

  <p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/>\

<p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/></p></p>
</ref>

<blockquote>
<blockquote>
<blockquote>
<p>print grammarNode.lastChild.toxml()    </p>
</blockquote>
</blockquote>
</blockquote>
<p>  查看 binary.xml 中的 XML ，你可能会认为 grammar 只有两个子节点，即两个 ref 元素。但是你忘记了一些东西：硬回车！在’<grammar>‘之后，第一个’<ref>‘之前是一个硬回车，并且这个文本算作 grammar 元素的一个子节点。类似地，在每个’</ref>‘之后都有一个硬回车；它们都被当作子节点。所以grammar.childNodes实际上是一个有5个对象的列表：3个 Text 对象和两个 Element 对象。 </p>
<p>  第一个子节点是一个 Text 对象，它表示在’<grammar>‘标记之后、第一个’<ref>‘标记之后的硬回车。 </p>
<p>  第二个子节点是一个 Element 对象，表示了第一个 ref 元素。 </p>
<p>  第四个子节点是一个 Element 对象，表示了第二个 ref 元素。 </p>
<p>  最后一个子节点是一个 Text 对象，表示了在’</ref>‘结束标记之后、’</grammar>‘ 结束标记之前的硬回车。 </p>
<blockquote>
<blockquote>
<blockquote>
<p>reflist = xmldoc.getElementsByTagName(‘ref’)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>reflist</p>
</blockquote>
</blockquote>
</blockquote>
<p>[&lt;DOM Element: ref at 136138108&gt;, &lt;DOM Element: ref at 136144292&gt;]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print reflist[0].toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<ref id="bit">

  <p>0</p>

  <p>1</p>

</ref>

<blockquote>
<blockquote>
<blockquote>
<p>print reflist[1].toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<ref id="byte">

  <p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/>\

<p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/></p></p>
</ref>


<p>例 9.22. 每个元素都是可搜索的</p>
<blockquote>
<blockquote>
<blockquote>
<p>firstref = reflist[0]                     </p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print firstref.toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<ref id="bit">

  <p>0</p>

  <p>1</p>

</ref>

<blockquote>
<blockquote>
<blockquote>
<p>plist = firstref.getElementsByTagName(“p”)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>plist</p>
</blockquote>
</blockquote>
</blockquote>
<p>[&lt;DOM Element: p at 136140116&gt;, &lt;DOM Element: p at 136142172&gt;]</p>
<blockquote>
<blockquote>
<blockquote>
<p>print plist[0].toxml()                    </p>
</blockquote>
</blockquote>
</blockquote>
<p>0</p>

<blockquote>
<blockquote>
<blockquote>
<p>print plist[1].toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<p>1</p>

<p>例 9.23. 搜索实际上是递归的</p>
<blockquote>
<blockquote>
<blockquote>
<p>plist = xmldoc.getElementsByTagName(“p”)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>plist</p>
</blockquote>
</blockquote>
</blockquote>
<p>[&lt;DOM Element: p at 136140116&gt;, &lt;DOM Element: p at 136142172&gt;, &lt;DOM Element: p at 136146124&gt;]</p>
<blockquote>
<blockquote>
<blockquote>
<p>plist[0].toxml()                        </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘<p>0</p>‘</p>
<blockquote>
<blockquote>
<blockquote>
<p>plist[1].toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<p>‘<p>1</p>‘</p>
<blockquote>
<blockquote>
<blockquote>
<p>plist[2].toxml()                        </p>
</blockquote>
</blockquote>
</blockquote>
<p>‘<p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/>\</p>
<p><xref id="bit"/><xref id="bit"/><xref id="bit"/><xref id="bit"/></p>‘</p>
<p>例 9.24. 访问元素属性</p>
<blockquote>
<blockquote>
<blockquote>
<p>xmldoc = minidom.parse(‘binary.xml’)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>reflist = xmldoc.getElementsByTagName(‘ref’)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>bitref = reflist[0]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print bitref.toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<ref id="bit">

  <p>0</p>

  <p>1</p>

</ref>

<blockquote>
<blockquote>
<blockquote>
<p>bitref.attributes         </p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;xml.dom.minidom.NamedNodeMap instance at 0x81e0c9c&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>bitref.attributes.keys()   </p>
</blockquote>
</blockquote>
</blockquote>
<p>[u’id’]</p>
<blockquote>
<blockquote>
<blockquote>
<p>bitref.attributes.values()</p>
</blockquote>
</blockquote>
</blockquote>
<p>[&lt;xml.dom.minidom.Attr instance at 0x81d5044&gt;]</p>
<blockquote>
<blockquote>
<blockquote>
<p>bitref.attributes[“id”]   </p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;xml.dom.minidom.Attr instance at 0x81d5044&gt;</p>
<p>每个 Element 对象都有一个 attributes 属性，它是一个 NamedNodeMap 对象。</p>
<p>NamedNodeMap 是一个行为像字典的对象</p>
<p>再次将 NamedNodeMap 视为一个字典，你可以通过 attributes.values() 获取属性值的一个列表。这些值本身是 Attr 类型的对象。</p>
<blockquote>
<blockquote>
<blockquote>
<p>a = bitref.attributes[“id”]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>a</p>
</blockquote>
</blockquote>
</blockquote>
<p>&lt;xml.dom.minidom.Attr instance at 0x81d5044&gt;</p>
<blockquote>
<blockquote>
<blockquote>
<p>a.name </p>
</blockquote>
</blockquote>
</blockquote>
<p>u’id’</p>
<blockquote>
<blockquote>
<blockquote>
<p>a.value</p>
</blockquote>
</blockquote>
</blockquote>
<p>u’bit’</p>
<p>Attr 对象完整代表了单个 XML 元素的单个 XML 属性。</p>
<p>StringIO可以把字符串转换成类文件对象，那么你只要这个对象传递给 minidom.parse 就可以了。</p>
<p>例 10.5. 解析字符串 XML (类文件对象方式)</p>
<blockquote>
<blockquote>
<blockquote>
<p>contents = “<grammar><ref id='bit'><p>0</p><p>1</p></ref></grammar>“</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>ssock = StringIO.StringIO(contents)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>xmldoc = minidom.parse(ssock)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>ssock.close()</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print xmldoc.toxml()</p>
</blockquote>
</blockquote>
</blockquote>
<?xml version="1.0" ?>

<p><grammar><ref id="bit"><p>0</p><p>1</p></ref></grammar></p>
<p>#stdout.py</p>
<p>import sys</p>
<p>print ‘Dive in’                                         </p>
<p>saveout = sys.stdout                                    </p>
<p>fsock = open(‘out.log’, ‘w’)                            </p>
<p>sys.stdout = fsock                                      </p>
<p>print ‘This message will be logged instead of displayed’</p>
<p>sys.stdout = saveout                                    </p>
<p>fsock.close()                                           </p>
<p>始终在重定向前保存 stdout，这样的话之后你还可以将其设回正常。</p>
<p>所有后续的输出都会被重定向到刚才打开的新文件上。</p>
<p>它设回原来的方式。</p>
<p>#stderr.py</p>
<p>import sys</p>
<p>fsock = open(‘error.log’, ‘w’)              </p>
<p>sys.stderr = fsock                          </p>
<p>raise Exception, ‘this error will be logged’ </p>
<p>引发一个异常。从屏幕输出上可以注意到这个行为没有 在屏幕上打印出任何东西。所有正常的跟踪信息已经写进 error.log。</p>
<p>还要注意你既没有显式关闭日志文件，也没有将 stderr 设回最初的值。这样挺好，因为一旦程序崩溃 (由于引发的异常)，Python 将替我们清理并关闭文件，因此永远不恢复 stderr 不会造成什么影响。然而对于 stdout，恢复初始值相对更为重要――你可能会在后面再次操作标准输出。</p>
<blockquote>
<blockquote>
<blockquote>
<p>import sys</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>print &gt;&gt; sys.stderr, ‘entering function’</p>
</blockquote>
</blockquote>
</blockquote>
<p>entering function</p>
<p>print 语句的快捷语法可以用于写入任何打开的文件 (或者是类文件对象)。在这里，你可以将单个 print 语句重定向到 stderr 而且不用影响后面的 print 语句。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/28/architecture/Dive%20into%20Python%20-%20%E7%AC%94%E8%AE%B0/" data-id="ckqg285w3005hrcfp5oyo36t1" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/28/architecture/FreeMarker%E7%B2%BE%E8%A6%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/06/28/architecture/Consul%E5%AD%A6%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%8C%87%E5%BC%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%93%81%E8%B7%AF6C%E4%B8%9A%E5%8A%A1%E7%BB%93%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E9%9C%80%E6%B1%82%E8%B0%83%E7%A0%94%E5%8F%8A%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E7%AB%99%E7%94%9F%E4%BA%A7%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/28/product/%E6%B0%B4%E7%94%B5%E5%8E%82%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>