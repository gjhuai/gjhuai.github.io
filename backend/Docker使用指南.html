<p><a href="https://www.cnblogs.com/xhyan/p/6593075.html">Docker容器进入的4种方式</a></p>
<h3>1. 查看docker信息（version、info）</h3>
<pre><code class="language-shell"># 查看docker版本
$docker version

# 显示docker系统的信息
$docker info
</code></pre>
<h3>2. 对image的操作（search、pull、images、rmi、history）</h3>
<pre><code class="language-shell">
# 检索image
$docker search image_name

# 下载image
$docker pull image_name

# 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs
$docker images

# 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents
$docker rmi image_name

# 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs
$docker history image_name
</code></pre>
<h3>3. 启动容器（run）</h3>
<p>docker容器可以理解为在沙盒中运行的进程。这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。但这个沙盒默认是不会运行任何程序的。你需要在沙盒中运行一个进程来启动某一个容器。这个进程是该容器的唯一进程，所以当该进程结束的时候，容器也会完全的停止。</p>
<pre><code class="language-shell">
# 在容器中运行&quot;echo&quot;命令，输出&quot;hello word&quot;
$docker run image_name echo &quot;hello word&quot;

# 交互式进入容器中
$docker run -i -t -v /root/software/:/mnt/software/  image_name /bin/bash
# -i：表示以“交互模式”运行容器；
# -t：表示容器启动后会进入其命令行；
# -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;；

# 在容器中安装新的程序
$docker run image_name apt-get install -y app_name
Note：  在执行apt-get 命令的时候，要带上-y参数。如果不指定-y参数的话，apt-get命令会进入交互模式，需要用户输入命令来进行确认，但在docker环境中是无法响应这种交互的。apt-get 命令执行完毕之后，容器就会停止，但对容器的改动不会丢失。


$docker run -d -p 22 -p 58080:8080 learn/tutorial /usr/sbin/sshd -D

# -d：表示以“守护模式”执行命令或脚本，此时 Tomcat 控制台不会出现在输出终端上。
# -p：表示宿主机与容器的端口映射，此时将容器内部的 8080 端口映射为宿主机的 58080 端口。
# --name：表示容器名称，用一个有意义的名称命名即可。
</code></pre>
<h3>4. 查看容器（ps）</h3>
<pre><code class="language-shell">
# 列出当前所有正在运行的container
$docker ps
# 列出所有的container
$docker ps -a
# 列出最近一次启动的container
$docker ps -l


# 在docker容器内查看ip
$ ip addr show eth0
$ ip route
</code></pre>
<h3>5. 保存对容器的修改（commit）</h3>
<p>当你对某一个容器做了修改之后（通过在容器中运行某一个命令），可以把对容器的修改保存下来，这样下次可以从保存后的最新状态运行该容器。</p>
<pre><code class="language-shell">
# 保存对容器的修改; -a, --author=&quot;&quot; Author; -m, --message=&quot;&quot; Commit message
$docker commit ID new_image_name
Note：  image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image。
</code></pre>
<h3>6. 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）</h3>
<pre><code class="language-shell">
# 删除所有容器
$docker rm `docker ps -a -q`

# 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container
$docker rm Name/ID

# 停止、启动、杀死一个容器
$docker stop Name/ID
$docker start Name/ID
$docker kill Name/ID

# 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps
$docker logs Name/ID

# 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的
$docker diff Name/ID

# 显示一个运行的容器里面的进程信息
$docker top Name/ID

# 从容器里面拷贝文件/目录到本地一个路径
$docker cp Name:/container_path to_path
$docker cp ID:/container_path to_path

# 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10
$docker restart Name/ID

# 进入一个已经在运行的容器
$ docker exec -it 775c7c9ee1e1 /bin/bash

# [attach] Attach local standard input, output, and error streams to a running container. 
# 这是一个过时的命令，不建议使用
$docker attach ID
 ```


###   7. 保存和加载镜像（save、load）

当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。


  ```shell
# 保存镜像到一个tar包; -o, --output=&quot;&quot; Write to an file
$docker save image_name -o file_path
# 加载一个tar包格式的镜像; -i, --input=&quot;&quot; Read from a tar archive file
$docker load -i file_path

# 机器a
$docker save image_name &gt; /home/save.tar
# 使用scp将save.tar拷到机器b上，然后：
$docker load &lt; /home/save.tar
</code></pre>
<h3>8、 登录registry server（login）</h3>
<pre><code class="language-shell">
# 登陆registry server; -e, --email=&quot;&quot; Email; -p, --password=&quot;&quot; Password; -u, --username=&quot;&quot; Username
$docker login
</code></pre>
<h3>9. 发布image（push）</h3>
<pre><code class="language-shell">
# 发布docker镜像
$docker push new_image_name
</code></pre>
<h3>10.  根据Dockerfile 构建出一个容器</h3>
<pre><code class="language-shell">
#build
      --no-cache=false Do not use cache when building the image
      -q, --quiet=false Suppress the verbose output generated by the containers
      --rm=true Remove intermediate containers after a successful build
      -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success
$docker build -t image_name Dockerfile_path
</code></pre>
<h3>使容器自启动</h3>
<p><code>docker update --restart=always 81bcb97c4f5e</code></p>
<h3>参数详解</h3>
<h4>docker命令参数详解</h4>
<p>docker 
useage of docker 
-D 默认false 允许调试模式(debugmode) 
-H 默认是unix:///var/run/docker.sock tcp://[host[:port]]来绑定 或者unix://[/path/to/socket]来使用(二进制文件的时候)，当主机ip host=[0.0.0.0],(端口)port=[4243] 或者 path=[/var/run/docker.sock]是缺省值，做为默认值来使用 
-api-enable-cors 默认flase 允许CORS header远程api 
-b 默认是空，附加在已存在的网桥上，如果是用'none'参数，就禁用了容器的网络 
-bip 默认是空，使用提供的CIDR（ClasslessInter-Domain Routing-无类型域间选路）标记地址动态创建网桥(dcoker0),和-b参数冲突 
-d 默认false 允许进程模式(daemonmode) 
-dns 默认是空，使docker使用指定的DNS服务器 
-g 默认是"/var/lib/docker":作为docker使用的根路径 
-icc 默认true，允许inter-container来通信 
-ip 默认"0.0.0.0"：绑定容器端口的默认Ip地址 
-iptables 默认true 禁用docker添加iptables规则 
-mtu 默认1500 : 设置容器网络传输的最大单元(mtu) 
-p 默认是/var/run/docker.pid进程pid使用的文件路径 
-r 默认是true 重启之前运行的容器 
-s 默认是空 ，这个是docker运行是使用一个指定的存储驱动器 
-v 默认false 打印版本信息和退出</p>
<h4>docker run命令详解</h4>
<p>Usage: docker run [OPTIONS] IMAGE[:TAG] [COMMAND] [ARG...] 
Run a command in a new container 
-a=map[]: 附加标准输入、输出或者错误输出 
-c=0: 共享CPU格式（相对重要） 
-cidfile="": 将容器的ID标识写入文件 
-d=false: 分离模式，在后台运行容器，并且打印出容器ID 
-e=[]:设置环境变量 
-h="": 容器的主机名称 
-i=false: 保持输入流开放即使没有附加输入流 
-privileged=false: 给容器扩展的权限 
-m="": 内存限制 (格式:<number><optional unit>, unit单位 = b, k, m or g) 
-n=true: 允许镜像使用网络 
-p=[]: 匹配镜像内的网络端口号 
-rm=false:当容器退出时自动删除容器 (不能跟 -d一起使用) 
-t=false: 分配一个伪造的终端输入 
-u="": 用户名或者ID 
-dns=[]: 自定义容器的DNS服务器 
-v=[]: 创建一个挂载绑定：[host-dir]:[container-dir]:[rw|ro].如果容器目录丢失，docker会创建一个新的卷 
-volumes-from="": 挂载容器所有的卷 
-entrypoint="": 覆盖镜像设置默认的入口点 
-w="": 工作目录内的容器 
-lxc-conf=[]: 添加自定义-lxc-conf="lxc.cgroup.cpuset.cpus = 0,1"
-sig-proxy=true: 代理接收所有进程信号(even in non-tty mode) 
-expose=[]: 让你主机没有开放的端口 
-link="": 连接到另一个容器(name:alias) 
-name="": 分配容器的名称，如果没有指定就会随机生成一个 
-P=false: Publish all exposed ports to thehost interfaces 公布所有显示的端口主机接口  </p>
<h3>参考</h3>
<p><a href="http://www.linuxeye.com/Linux/2019.html">docker详细的基础用法</a></p>