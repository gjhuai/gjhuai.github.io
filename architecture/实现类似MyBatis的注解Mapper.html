<p>本文讲解在Spring中实现类似MyBatis的注解Mapper功能。</p>
<p>以查询为例，定义一个接口，并接口上标注@Dao注解；定义一个查询方法，并在其上标注上@Select注解，填充上命名参数的sql；使用@Param注解在方法参数上标明sql命名参数，所有预定义过程完成。使用spring的@Autowired注入即可调用。</p>
<h1>主要知识点</h1>
<ul>
<li>利用类 ClassPathScanningCandidateComponentProvider 查找自定义注解的类。</li>
<li>利用Java的动态代理实现接口的代理类。</li>
<li>利用类 BeanFactoryPostProcessor 接口将代理类注入到spring容器中。</li>
</ul>
<h1>定义三个注解</h1>
<ul>
<li>@Dao 作用于接口上，表明此接口的代理实现类是可以动态注入到Spring容器中。</li>
</ul>
<pre>
@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Dao {
  String value() default "";
}
</pre>

<ul>
<li>@Select作用于方法上，用来填写方法需要使用的SQL，sql的格式采用JDBC的命名查询格式。</li>
</ul>
<pre>
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Select {
  String[] value();
}
</pre>

<ul>
<li>@Param作用于方法的参数上，用来表明参数的名称。
PS:由于Java的接口不是类，方法参数无法存入局部变量表中，因此在运行时是无法获取接口方法准确的参数名称，只能获得arg0,arg1这类的名称，所以需要采用注解来指定。</li>
</ul>
<pre>
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.PARAMETER)
public @interface Param {
  String value();
}
</pre>

<h1>使用示例</h1>
<ul>
<li>定义接口类</li>
</ul>
<pre>
@Dao
public interface UserDao {

@Select("select * from m_user where login_Name=:loginName")
User findUserByAccount(@Param("loginName")String loginName);

@Select("select * from m_user where login_Name=:loginName")
Page<User> paginateUserByAccount(@Param("pageNo")Integer pageNo, 
                        @Param("pageSize")Integer pageSize, 
@Param("loginName")String loginName);
}
</pre>

<ul>
<li>测试类</li>
</ul>
<pre>
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = "classpath:applicationContext.xml")
public class UserDaoTest  {

@Autowired
UserDao userDao;

@Test
public void test_findUserByAccount() {
String account = "support1";

User user = userDao.findUserByAccount(account);
Assert.assertNotNull(user.getId());
}

@Test
public void paginateUserByAccount(){
Integer pageNo = 1;
Integer pageSize = 10;

String account = "support1";

Page<User> pageUser = userDao.paginateUserByAccount(pageNo, pageSize, account);
Assert.assertNotNull(pageUser);
}
}
</pre>

<h1>扫描标有@Dao注解的类</h1>
<pre>
public class DaoAnnotationComponentProvider extends ClassPathScanningCandidateComponentProvider {

    public DaoAnnotationComponentProvider() {
        super(false);
        // 添加scan 的类型：@Dao
        addIncludeFilter(new AnnotationTypeFilter(Dao.class, false));
    }


    @Override
    protected boolean isCandidateComponent(AnnotatedBeanDefinition beanDefinition) {
        // 返回true表示要scan interface
    return beanDefinition.getMetadata().isInterface();
    }
}
</pre>

<h1>实现@Dao接口类的代理类</h1>
<p>采用Java的动态代理实现，实现接口InvocationHandler即可。主要的思路是：从@Select接口获取SQL，通过Reflection获取Method的返回类型，从@Param中获取参数名称，此参数名称和SQL中名称参数一一对应。</p>
<pre>
public class DaoInvocationHandlerImpl implements InvocationHandler{
private static Logger logger = LoggerFactory.getLogger(DaoInvocationHandlerImpl.class);
private final static String PAGE_NO = "pageNo";
private final static String PAGE_SIZE = "pageSize";

@SuppressWarnings("unchecked")
@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
Select annoSelect = method.getAnnotation(Select.class);
if (annoSelect != null) {
Map<String, Object> params = new HashMap<>();
Parameter[] parameters = method.getParameters();

for (int i=0;i<parameters.length;i++){
Class<?> paramClass = parameters[i].getType();
if (paramClass.isAssignableFrom(Map.class)){
params.putAll((Map<String, Object>)args[i]);
} else {
Param annoParam = parameters[i].getAnnotation(Param.class);
String paramName = annoParam.value();
params.put(paramName, args[i]);
}
}

Object retObj = callJdbc(method, String.join("",annoSelect.value()), params);
return retObj;
} else {
return method.invoke(this, args);
}
}


private Object callJdbc(Method method, String sql, Map<String, Object> params) {
logger.debug(String.format("%s==>SQL: %s , 参数: %s", method.getName(), sql, params.toString()));
Object retObj = null;
Finder finder = Finder.of(sql).bind(params);    

Class<?> retClass = method.getReturnType();

if (retClass.isAssignableFrom(List.class)){
ParameterizedType retType = (ParameterizedType)method.getGenericReturnType();
Class<?> clazz = (Class<?>) retType.getActualTypeArguments()[0];
retObj = finder.list(clazz);
} else if (retClass.isAssignableFrom(Map.class)){
retObj = finder.first(Map.class);
} else if (retClass.isAssignableFrom(Page.class)){
ParameterizedType retType = (ParameterizedType)method.getGenericReturnType();
Class<?> clazz = (Class<?>) retType.getActualTypeArguments()[0];
Object pn = params.get(PAGE_NO);
Object ps = params.get(PAGE_SIZE);
if (ObjectUtils.isEmpty(pn) || ObjectUtils.isEmpty(ps) ){
throw new IllegalArgumentException("缺少 pageNo / pageSize 参数");
}
int pageNo = Integer.valueOf(pn.toString());
int pageSize = Integer.valueOf(ps.toString());
retObj = finder.paginate(clazz, pageNo, pageSize);
} else {
retObj = finder.first(retClass);
}
logger.debug(String.format("<==成功执行查询(%s)",method.getName()));
return retObj;
}


}
</pre>

<h1>将Dao的代理类注入到Spring容器中</h1>
<pre>
public class DaoBeanProcessor implements BeanFactoryPostProcessor, ResourceLoaderAware {
private ResourceLoader resourceLoader;
/** @Dao接口类所在的包，可以是逗号分割的多个包名 */
private String packages;


    @Override
    public void setResourceLoader(ResourceLoader resourceLoader) {
        this.resourceLoader = resourceLoader;
    }

@Override
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
Set<BeanDefinition> beans = scanCallerInterfaceDef();
DefaultListableBeanFactory bf = (DefaultListableBeanFactory)beanFactory;
registerDaoProxyBean(beans, bf);
}

    private Set<BeanDefinition> scanCallerInterfaceDef() {
    ClassPathScanningCandidateComponentProvider componentProvider = new DaoAnnotationComponentProvider();
    componentProvider.setResourceLoader(resourceLoader);

    Set<BeanDefinition> beans = new LinkedHashSet<BeanDefinition>();
    String[] pkgArr = packages.split(",");
    for (String pkg : pkgArr){
    beans.addAll(componentProvider.findCandidateComponents(pkg.trim()));
    }
    return beans;
    }

    private void registerDaoProxyBean(Set<BeanDefinition> beans, DefaultListableBeanFactory beanFactory){
    for (BeanDefinition bd : beans){
Class<?> clazz = null;
try {
clazz = Class.forName(bd.getBeanClassName());
} catch (ClassNotFoundException e) {
e.printStackTrace();
continue;
}
String name = clazz.getSimpleName();
Object obj = DaoProxyFactory.getDaoBean(clazz);
beanFactory.registerSingleton(name.substring(0,1).toUpperCase() + name.substring(1), obj);
    }
    }


public String getPackages() {
return packages;
}


public void setPackages(String packages) {
this.packages = packages;
}


}
</pre>

<p>不要忘了在spring中配置这类的实例：</p>
<pre><code>&lt;bean class=&quot;com.xx.DaoBeanProcessor&quot;&gt;
&lt;property name=&quot;packages&quot; value=&quot;com.xxx&quot;/&gt;
&lt;/bean&gt;
</code></pre>