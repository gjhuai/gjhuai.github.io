<p>[TOC]</p>
<h2>Python+Selenium安装及环境配置</h2>
<hr />
<p>python使用3.7.2，  selenium版本为3.141.0， Firefox版本为52， Geckdriver版本：v0.15.0， chrome版本为 73.0.3683.68，   IE11， IEDriverServer_x64_3.8.0 。
IE11测试时，输入字符和动作太慢，跑一个用例需要很长时间，不建议使用。</p>
<hr />
<h3>Selenium安装</h3>
<p>selenium版本为3.141.0</p>
<pre><code class="language-shell">pip install selenium

#  查看是否安装成功
pip show selenium

</code></pre>
<hr />
<h3>浏览器及驱动安装</h3>
<p>Firefox和chrome要选择合适的版本， 版本低了高了都不行。
驱动文件需要放在环境变量中，例如可以放在： %PYTHON_HOME%\Scripts 目录下。
参考：<a href="https://www.cnblogs.com/qiezizi/p/8632058.html">selenium对应三大浏览器（谷歌、火狐、IE）驱动安装</a></p>
<ul>
<li>
<p>Firefox
使用52版没有出错
Firefox需安装驱动：geckdriver ，版本 v0.15.0 可用，版本v0.24.0不可用。下载地址：
https://github.com/mozilla/geckodriver/releases?after=v0.17.0</p>
</li>
<li>
<p>IE
IE版本为11，项目需要这个版本，其它版本没有试过。
IE11的驱动为：IEDriverServer_x64_3.8.0  。 版本3.9不可用，无法启动IE11。下载地址：
http://selenium-release.storage.googleapis.com/index.html</p>
</li>
</ul>
<p>常出现的错误：</p>
<blockquote>
<p>Unexpected error launching Internet Explorer. Browser zoom level was set to 109%. It should be set to 100%
将浏览器的缩放调为100%，在状态栏可调
Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones.
将所有区域的保护模式勾选去掉即可，如下</p>
</blockquote>
<p><img alt="" src="_v_images/2019-11-21-20-49-59.png" /></p>
<ul>
<li>chrome
chrome版本为 73.0.3683.68，对应驱动版本相同，下载地址： http://npm.taobao.org/mirrors/chromedriver/</li>
</ul>
<h3>例子程序</h3>
<pre><code class="language-python">from selenium import webdriver # 导入webdriver包
from selenium.webdriver.common.keys import Keys
import time
#driver = webdriver.Firefox() # 初始化一个火狐浏览器实例：driver
driver = webdriver.Chrome() # 初始化一个IE浏览器实例：driver
driver.maximize_window() # 最大化浏览器 
time.sleep(5) # 暂停5秒钟
driver.get(&quot;https://www.baidu.com&quot;) # 通过get()方法，打开一个url站点
driver.find_element_by_id(&quot;kw&quot;).click()
driver.find_element_by_id(&quot;kw&quot;).clear()
driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;java&quot;)
driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.ENTER)
</code></pre>
<h3>控制已经打开的chrome</h3>
<p>Chrome DevTools协议可以调试Chrome浏览器，利用它启动chrome后会打开一个端口，selenium通过此端口和chrome交互。
<code>chrome.exe --remote-debugging-port=9222 --user-data-dir="C:\selenum\AutomationProfile"</code>
<code>-user-data-dir</code>指定Chrome配置文件的目录，如果不指定，使用默认目录。不指定时，selenium控制代码如下：</p>
<pre><code class="language-python"># 对应你的chrome的用户数据存放路径
profile_dir=r&quot;C:\Users\xxxx\AppData\Local\Google\Chrome\User Data&quot;   
chrome_options = webdriver.ChromeOptions()
chrome_options.add_experimental_option(&quot;debuggerAddress&quot;, &quot;127.0.0.1:9222&quot;)
chrome_options.add_argument(&quot;user-data-dir=&quot;+os.path.abspath(profile_dir))
driver = webdriver.Chrome(chrome_options=chrome_options)
</code></pre>
<h2>Katalon Recorder插件安装</h2>
<hr />
<p>Katalon Recorder是一个chrome浏览器插件，直接在扩展市场可以安装。安装完成后，可以像录制宏一样录制测试脚本，测试脚本可以导出为python等语言脚本。
可以参考：<a href="https://www.jianshu.com/p/52ed88e89b57">Katalon Recorder 自动录制 Selenium 爬虫脚本</a> </p>
<h2>Selenium编程技巧</h2>
<hr />
<p>学习资料：
<a href="https://selenium-python-zh.readthedocs.io/en/latest/locating-elements.html">Selenium-Python中文文档</a></p>
<h3>滚动 浏览器 屏幕</h3>
<p>只有在屏幕显示范围内元素，才能被点击等操作。所以要操作这些元素，必须把它的位置滚动到显示区域。方法如下：</p>
<pre><code class="language-python"># 方法一
element.location_once_scrolled_into_view    # 此方法滚动不是很准确
# 方法二
driver.execute_script(&quot;window.scrollTo(0, document.body.scrollHeight);&quot;)    # 滚动一屏
</code></pre>
<h3>多窗口、多frame切换</h3>
<p>多窗口切换：</p>
<pre><code class="language-python">driver.get(&quot;http://www.baidu.com&quot;)
# 获取百度搜索窗口句柄
search_windows=driver.current_window_handle

#获取打开所有窗口句柄
all_handles=driver.window_handles
for handle in all_handles:
    if handle !=search_windows:
        driver.switch_to_window(handle)
        ......

        driver.close()    # 关闭当前窗口

driver.switch_to_window(search_windows)
driver.quit()     # 注销WebDriver，并关闭所有相关的窗口

</code></pre>
<p>多frame切换：</p>
<pre><code class="language-python"># 通过frame的Id来切换，也可以element来切换
driver.switch_to.frame('x-URS-iframe') 
.....
driver.find_element_by_id(&quot;dologin&quot;).click()
driver.switch_to.default_content()        # 跳回最外层的页面
</code></pre>
<h3>Element is not clickable at point错误及四种解决方法</h3>
<p>参考：<a href="https://blog.csdn.net/lilongsy/article/details/76152620">selenium报错Element is not clickable at point及四种解决方法</a>
四种原因和解决办法：
- 元素尚未加载
让执行等待一会儿。</p>
<pre><code class="language-python">from selenium.webdriver.support.ui import WebDriverWait
WebDriverWait(driver, 10).until(EC.title_contains(&quot;元素&quot;))
</code></pre>
<ul>
<li>元素在iframe里
元素在iframe里，在窗口里找是找不到元素的，更是无法点击。所以，要切换到iframe里去找元素。</li>
</ul>
<pre><code class="language-python">driver.switch_to_frame(&quot;frameName&quot;)  # 根据框架名来切换
driver.switch_to_frame(&quot;frameName.0.child&quot;)  # 子框架
driver.switch_to_default_content()  # 返回
</code></pre>
<ul>
<li>元素不在显示窗里
当元素不在浏览器的显示屏幕内，需要滚动屏幕，使之位于可视范围内。</li>
</ul>
<pre><code class="language-python"># 任选一种
ele.location_once_scrolled_into_view
driver.execute_script(&quot;window.scrollTo(0, document.body.scrollHeight);&quot;)
</code></pre>
<ul>
<li>要点击的元素被覆盖
可以使用事件链来解决。 例如下拉菜单，通过hover，让子菜单显示，就可以点击了。</li>
</ul>
<pre><code class="language-python">menu = driver.find_element_by_css_selector(&quot;.nav&quot;)
hidden_submenu = driver.find_element_by_css_selector(&quot;.nav #submenu1&quot;)
ActionChains(driver).move_to_element(menu).click(hidden_submenu).perform()
</code></pre>
<h3>selenium中POST请求</h3>
<p>参考：<a href="https://www.freebuf.com/column/169007.html">selenium爬虫中的post坑</a>
如果在selenium程序中，需要对一个rest接口发起POST请求，有三种方式：
- 第三方库，如：selenium-requests</p>
<pre><code class="language-python">from seleniumrequests import Firefox

webdriver = Firefox()

response = webdriver.request('POST', 'https://www.google.com/')
print(response)
</code></pre>
<ul>
<li>ajax</li>
</ul>
<pre><code class="language-python">brower = webdriver.Firefox(firefox_options=fireFoxOptions)
js = &quot;&quot;&quot;var xmlhttp=new XMLHttpRequest();
        xmlhttp.open(&quot;GET&quot;,&quot;http://127.0.0.1/get.php&quot;,false);
        xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
        xmlhttp.setRequestHeader(&quot;User-Agent&quot;,&quot;Mozilla/5.0&quot;);
        xmlhttp.send(&quot;test=1&quot;);
        return xmlhttp.responseText;
     &quot;&quot;&quot; 
brower.implicitly_wait(30)
#time.sleep(30)
resp = brower.execute_script(js)
</code></pre>
<ul>
<li>拼接form表单
其原理是解析了原生的post请求后，将其传递的参数重构为form表单，最后再将这些新生成的代码存入html网页。 最后，程序会再借用selenium定位submit元素，触发事件提交表单。
不推荐这种方式，太麻烦。</li>
</ul>