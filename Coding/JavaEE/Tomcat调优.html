<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<link rel="stylesheet" href="../theme/css/my.css" /><h1>Tomcat 类加载机制</h1>
<ul>
<li>Tomcat 类加载图
<img alt="Tomcat类加载图" src="_v_images/20210625110312139_22851.png" /></li>
<li>Common 类加载器，负责加载 Tomcat 和 Web 应用都复用的类</li>
<li>Catalina 类加载器，负责加载 Tomcat 专用的类，而这些被加载的类在 Web 应用中将不可见</li>
<li>Shared 类加载器，负责加载 Tomcat 下所有的 Web 应用程序都复用的类，而这些被加载的类在 Tomcat 中将不可见</li>
<li>WebApp 类加载器，负责加载具体的某个 Web 应用程序所使用到的类，而这些被加载的类在 Tomcat 和其他的 Web 应用程序都将不可见</li>
<li>Jsp 类加载器，每个 jsp 页面一个类加载器，不同的 jsp 页面有不同的类加载器，方便实现 jsp 页面的热插拔</li>
</ul>
<h1>JVM 之内存模型</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/44296601">汪十号：JVM 之内存模型</a></li>
<li>JVM 内存结构图
<img alt="JVM 内存结构图" src="_v_images/20210625110237476_29990.png" /></li>
</ul>
<h1>Tomcat 调优包括两个部分：</h1>
<ul>
<li>史上最强 Tomcat8 性能优化</li>
<li>调优一般从网络 IO、CPU、内存、硬盘 IO 等几个方面着手。</li>
<li>1、Tomcat 的自身调优</li>
<li>采用动静分离节约 Tomcat 的性能</li>
<li>调整 Tomcat 的执行器线程池</li>
</ul>
<pre><code class="language-xml">&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; maxThreads=&quot;500&quot; minSpareThreads=&quot;50&quot; prestartminSpareThreads=&quot;true&quot; maxQueueSize=&quot;100&quot;/&gt; 
&lt;!-- 参数说明： 
maxThreads：最大并发数，默认设置 200，一般建议在 500 ~ 1000，根据硬件设施和业务来判断 
minSpareThreads： Tomcat 初始化时创建的线程数，默认设置 25 
prestartminSpareThreads： 在 Tomcat 初始化的时候就初始化 minSpareThreads 的参数值，如果不等于 true，minSpareThreads 的值就没啥效果了 
maxQueueSize，最大的等待队列数，超过则拒绝请求 
--&gt; 
&lt;!--在Connector中设置executor属性指向上面的执行器--&gt; 
&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot;  redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<ul>
<li>调整 Tomcat 的连接器</li>
<li>修改 Tomcat 的运行模式<ul>
<li>tomcat7 及以下推荐使用 nio，tomcat8 建议使用 nio2</li>
</ul>
</li>
</ul>
<pre><code class="language-xml">&lt;Connector executor=&quot;tomcatThreadPool&quot;  port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<pre><code>- apr：安装起来最困难，但是从操作系统级别来解决异步的 IO 问题，大幅度的提高性能
</code></pre>
<ul>
<li>禁用 AJP 连接器<ul>
<li>AJP（Apache JServer Protocol）是针对与 Apache 结合使用的 tcp 协议，由于一般使用 nginx，所以可以禁用掉。</li>
<li><!-- 禁用AJP连接 --> <!-- <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /> --></li>
</ul>
</li>
<li>2、JVM 的调优</li>
<li>设置垃圾回收器</li>
<li>调优 Jvm 内存<ul>
<li><code>JAVA_OPTS="-Dfile.encoding=UTF-8-server -Xms1024m -Xmx2048m -XX:NewSize=512m -XX:MaxNewSize=1024m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=10-XX:NewRatio=2 -XX:+DisableExplicitGC"</code></li>
<li>-Xmx1024m 设置 JVM 最大可用内存为 1024MB</li>
<li>-Xms1024m 设置 JVM 最小内存为 1024m。此值可以设置与-Xmx 相同，以避免每次垃圾回收完成后 JVM 重新分配内存。</li>
<li>-XX:NewSize 设置年轻代大小</li>
<li>-XX:MaxNewSize 设置最大的年轻代大小</li>
<li>-XX:PermSize 设置永久代大小</li>
<li>-XX:MaxPermSize 设置最大永久代大小</li>
<li>-XX:NewRatio=4 设置年轻代（包括 Eden 和两个 Survivor 区）与终身代的比值（除去永久代）。设置为 4，则年轻代与终身代所占比值为 1：4，年轻代占整个堆栈的 1/5</li>
<li>-XX:MaxTenuringThreshold=0 设置垃圾最大年龄，默认为：15。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li>
<li>-XX:+DisableExplicitGC 这个将会忽略手动调用 GC 的代码使得 System.gc()的调用就会变成一个空调用，完全不会触发任何 GC。</li>
</ul>
</li>
</ul>