<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<link rel="stylesheet" href="../theme/css/my.css" /><p>阅读《Java事务设计策略》48-53页</p>
<p>对SQL事务隔离级别的简单理解</p>
<p>数据库死锁
数据库中死锁那些事儿
Spring事务传播性与隔离级别</p>
<p>一、事务的隔离级别
使用Spring 声明式事务时，有一个非常重要的概念就是事务属性。事务属性通常由事务的传播行为，事务的隔离级别，事务的超时值和事务只读标志组成。
org.springframework.transaction包里面的TransactionDefinition类
getTimeout()方法，它返回事务必须在多少秒内完成。 
isReadOnly(),事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的。 
getIsolationLevel()方法返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据。
在TransactionDefinition接口中定义了四个不同的事务隔离级别:
1) ISOLATION_DEFAULT 这是一个 PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别(读未提交).另外四个与JDBC的隔离级别相对应
2) ISOLATION_READ_UNCOMMITTED这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。
3) ISOLATION_READ_COMMITTED 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。
4) ISOLATION_REPEATABLE_READ 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)</p>
<p>SQL标准定义了4类隔离级别分别是：可串行化，可重复读，读已提交，读未提交。</p>
<p>l      可串行化 Serializable</p>
<p>是事务最高的 隔离级别 。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。因为 它采用了类似线程同步的概念，当一个事务开始操作数据时，其他所有的事务都不能进行除查询外的其他操作，只能等待当前事务完成提交。 由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。</p>
<p>l      可重复读 Repeatable Read</p>
<p>这是MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。 它采用的是数据缓存策略，即当事务开始后，第一次读取数据后会把数据缓存起来， 当再次进行相同操作时，直接返回缓存的数据，这样即使数据库内容发生了改变，当前事务内所读取的结果还是一致的。</p>
<p>l     读已提交 Read Committed</p>
<p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义： 一个事务只能看见已经提交事务所做的改变 。一个事务在结束时会执行一个命令，commit（提交）或者 rollback（回滚），前者即确认事务所做的操作，后者则为撤销整个事务的所有操作。此隔离级别的服务将不会看到其他并行服务在commit之前所进行的操作。</p>
<p>l     读未提交 Read Uncommitted</p>
<p>这是最低的隔离级别， 所有事务都可以看到其他未提交事务的执行结果 。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read），因为别的服务有可能会执行rollback操作，这样提前读取到的数据可能会出现问题。</p>
<p>四种级别的隔离，各有自己的优缺点，级别越高则安全性越高，但并发性越低，低级别的隔离则支持更高的并发处理，并要求较低的系统开销，究竟使用哪种，还有根据具体项目的相关要求而决定。</p>
<p>二、事务的传播性质
定义了关于客户端和被调用方法的事务边界。传播规则就是在说明新的事务是否要被启动或是挂起，或者方法是否要在事务环境中运行。
在TransactionDefinition接口中定义了七个事务传播行为:
1) PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务;
2) PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行;
3) PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异;
4)PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起;
5) PROPAGATION_NOT_SUPPORTED总是非事务地执行，并挂起任何存在的事务;
6) PROPAGATION_NEVER总是非事务地执行，如果存在一个活动事务，则抛出异常;
7) PROPAGATION_NESTED如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按 TransactionDefinition.PROPAGATION_REQUIRED 属性执行;</p>