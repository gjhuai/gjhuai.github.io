<p>[TOC]</p>
<h2>类型、bit</h2>
<ul>
<li>bit: 1 bit位 = 1 二进制数据</li>
<li>byte: 1 byte = 8 bit位 （-128 ~ 127）</li>
<li>字母: 1 字母 = 1 byte = 8 bit(位)</li>
<li>short: 16位</li>
<li>char: Unicode字符，16bit位</li>
<li>int: 32bit位，比如int 类型占用4个字节，32位</li>
<li>long: 64bit位</li>
<li>float: 32bit位</li>
<li>double: 64bit位</li>
<li>汉字：1 汉字 = 2 byte = 16 bit 
    （<strong><em>这里不是很准确，当编码不同的时候，1个汉字所占的字节数也会有所不同，有些编码是占 2个字节，有些则不是，可能是 3个或者 4个</em></strong>）</li>
</ul>
<h2>byte、char、int 区别与转换</h2>
<ul>
<li>byte 是字节数据类型 ，是有符号型的，占1 个字节；大小范围为-128—127;</li>
<li>char 是字符数据类型 ，是无符号型的，占2字节(Unicode码 ）；大小范围 是0—65535;</li>
<li>char是一个16位二进制的Unicode字符，JAVA用char来表示一个字符；</li>
<li>char可以表中文字符，byte不可以；</li>
<li>char、byte、int对于英文字符，可以相互转化</li>
</ul>
<pre><code class="language-java">byte g = 'b';   //b对应ASCII是98
char h = (char) g;
char i = 85;    //U对应ASCII是85
int j = 'h';    //h对应ASCII是104
</code></pre>
<h2>byte数组与16进制转换</h2>
<p><a href="https://blog.csdn.net/worm0527/article/details/69939307">java byte[]与十六进制字符串相互转换</a></p>
<h2>byte数组与10进制转换</h2>
<p>开始说说高位优先和低位优先，我们看如下代码：
int i=10;
那么i在内存中的布局如何哪？
假设内存是从低－－－&gt;高增长的
在低位优先的硬件里面，内存布局如下：
00001010 00000000 00000000 00000000
而在高位优先的内存中：
00000000 00000000 00000000 00001010
这就是我们经常听说的高位优先，低位优先。</p>
<hr />
<p>单片机的一个存储单元只能存储八位字节，题目已经指明‘两个8位二进制无符号数相加，其和可能超过8位’。存储这个超过8位的‘和’就不能用一个存储单元了，需要两个，有两个就有前后之分了，把‘和’的高于8位的高低位分开存储，低位在前高位在后就是这个意思。</p>
<p><a href="https://www.cnblogs.com/lizhenlin/p/6807856.html">byte[]数组和int之间的转换</a>
<a href="https://blog.csdn.net/sweetfather/article/details/79781521">如何判断变量在内存中如何放置的?低位在前还是高位在前</a></p>
<h2>原码、反码、补码</h2>
<p>1.byte的大小为8bits而int的大小为32bits
2.java的二进制采用的是补码形式
在这里先温习下计算机基础理论
byte是一个字节保存的，有8个位，即8个0、1。
8位的第一个位是符号位，
也就是说0000 0001代表的是数字1
1000 0000代表的就是-1
所以正数最大位0111 1111，也就是数字127
负数最大为1111 1111，也就是数字-128
上面说的是二进制原码，但是在java中采用的是补码的形式，下面介绍下什么是补码
1、反码：
一个数如果是正，则它的反码与原码相同；
一个数如果是负，则符号位为1，其余各位是对原码取反；
2、补码：利用溢出，我们可以将减法变成加法
对于十进制数，从9得到5可用减法：
9－4＝5 因为4+6＝10，我们可以将6作为4的补数
改写为加法：
9+6＝15（去掉高位1，也就是减10）得到5.
对于十六进制数，从c到5可用减法：
c－7＝5 因为7+9＝16 将9作为7的补数
改写为加法：
c+9＝15（去掉高位1，也就是减16）得到5.
在计算机中，如果我们用1个字节表示一个数，一个字节有8位，超过8位就进1，在内存中情况为（100000000），进位1被丢弃。
⑴一个数为正，则它的原码、反码、补码相同
⑵一个数为负，刚符号位为1，其余各位是对原码取反，然后整个数加1
- 1的原码为 10000001
- 1的反码为 11111110
+ 1
- 1的补码为 11111111
0的原码为 00000000
0的反码为 11111111（正零和负零的反码相同）
+1
0的补码为 100000000（舍掉打头的1，正零和负零的补码相同）
Integer.toHexString的参数是int，如果不进行&amp;0xff，那么当一个byte会转换成int时，由于int是32位，而byte只有8位这时会进行补位，
例如补码11111111的十进制数为-1转换为int时变为11111111111111111111111111111111好多1啊，呵呵！即0xffffffff但是这个数是不对的，这种补位就会造成误差。
和0xff相与后，高24比特就会被清0了，结果就对了。</p>
<hr />
<p>Java中的一个byte，其范围是-128~127的，而Integer.toHexString的参数本来是int，如果不进行&amp;0xff，那么当一个byte会转换成int时，对于负数，会做位扩展，举例来说，一个byte的-1（即0xff），会被转换成int的-1（即0xffffffff），那么转化出的结果就不是我们想要的了。
而0xff默认是整形，所以，一个byte跟0xff相与会先将那个byte转化成整形运算，这样，结果中的高的24个比特就总会被清0，于是结果总是我们想要的。</p>