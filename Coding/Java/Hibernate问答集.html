<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<link rel="stylesheet" href="../theme/css/my.css" /><h3><font color=red> Key Generator </font></h3>
<ol>
<li>Assigned
主键由外部程序负责生成，无需 Hibernate 参与。</li>
<li>hilo
通过 hi/lo 算法实现的主键生成机制，需要额外的数据库表保存主
键生成历史状态。</li>
<li>seqhilo
与 hilo 类似，通过 hi/lo 算法实现的主键生成机制，只是主键历史
状态保存在Sequence中，适用于支持Sequence的数据库，如Oracle。</li>
<li>increment
主键按数值顺序递增。此方式的实现机制为在当前应用实例中维持
一个变量，以保存着当前的最大值，之后每次需要生成主键的时候
将此值加 1 作为主键。
这种方式可能产生的问题是：如果当前有多个实例访问同一个数据
库，那么由于各个实例各自维护主键状态，不同实例可能生成同样
的主键，从而造成主键重复异常。因此，如果同一数据库有多个实
例访问，此方式必须避免使用。</li>
<li>identity
采用数据库提供的主键生成机制。如 DB2、SQL Server、MySQL
中的主键生成机制。</li>
<li>sequence
采用数据库提供的 sequence 机制生成主键。如 Oralce 中的
Sequence。</li>
<li>native
由 Hibernate 根据底层数据库自行判断采用 identity、hilo、sequence
其中一种作为主键生成方式。</li>
<li>uuid.hex
由 Hibernate 基于 128 位唯一值产生算法生成 16 进制数值（编码后
以长度 32 的字符串表示）作为主键。</li>
<li>uuid.string
与 uuid.hex 类似，只是生成的主键未进行编码（长度 16）。在某些
数据库中可能出现问题（如 PostgreSQL）。</li>
<li>
<p>foreign
使用外部表的字段作为主键。
一般而言，利用 uuid.hex 方式生成主键将提供最好的性能和数据库平台适
应性。</p>
</li>
<li>
<p>另外由于常用的数据库，如 Oracle、DB2、SQLServer、MySql 等，都提 供了易用的主键生成机制（Auto-Increase 字段或者 Sequence）。我们可以在数 据库提供的主键生成机制上，采用 generator-class=native 的主键生成方式。</p>
</li>
<li>
<p>对于并发 Insert 要求较高的系统，推荐采用 uuid.hex 作为主键生成 机制。</p>
</li>
<li>
<p>如果需要采用定制的主键产生算法，则在此处配置主键生成器，主键生成器必 须实现net.sf.hibernate.id.IdentifierGenerator 接口。</p>
</li>
</ol>
<h3><font color=red> Inverse 和 和 Cascade </font></h3>
<p><u>Inverse 指的是关联关系的控制方向，而 cascade 指的是层级之间的连锁操作。</u></p>
<p>Inverse，直译为“反转”。 关联关系中，inverse=”false”的为主动方，由主动方负责维护关联关系。具体可 参见一对多关系中的描述。</p>
<p>而 Cascade，译为“级联”，表明对象的级联关系，如 TUser 的 Cascade 设为 all， 就表明如果发生对 user 对象的操作，需要对 user 所关联的对象也进行同样的操作。如对 user 对象执行 save 操作，则必须对 user 对象相关联的 address 也执行 save 操作。</p>
<h3><font color=red> 锁机制</font></h3>
<p>Hibernate 支持两种锁机制：即通常所说的“悲观锁（Pessimistic Locking）” 和“乐观锁（Optimistic Locking）”。</p>
<p><strong>悲观锁（Pessimistic Locking）</strong></p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自 外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定 状态。<u>悲观锁的实现，往往依靠数据库提供的锁机制</u>（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。</p>
<p>一个典型的倚赖数据库的悲观锁调用：</p>
<pre><code class="language-java">String hqlStr =  &quot;from TUser as user where user.name='Erica'&quot;;
Query query = session.createQuery(hqlStr);
query.setLockMode(&quot;user&quot;,LockMode.UPGRADE); //加锁


// select * from t_user where name='Erica' for update
List userList = query.list();//执行查询，获取数据
</code></pre>
<p>这里 Hibernate 通过使用数据库的 for update 子句实现了悲观锁机制。
这条 sql 语句锁定了  t_user   表中所有符合检索条件（name='Erica'）的记录。 本次事务提交之前（事务提交时会释放事务过程中的锁），外界无法修改这些记录。</p>
<p>Hibernate 的加锁模式有：
- LockMode.NONE ： 无锁机制。
- LockMode.WRITE ：Hibernate 在 Insert 和 Update 记录的时候会自动 获取。
- LockMode.READ ： Hibernate 在读取记录的时候会自动获取。</p>
<p>以上这三种锁机制一般由Hibernate内部使用，如Hibernate为了保证Update 过程中对象不会被外界修改，会在 save 方法实现中自动为目标对象加上 WRITE 锁。</p>
<ul>
<li>LockMode.UPGRADE ：利用数据库的 for update 子句加锁。</li>
<li>LockMode. UPGRADE_NOWAIT ：Oracle 的特定实现，利用 Oracle 的 for  update nowait 子句实现加锁。</li>
</ul>
<p>上面这两种锁机制是我们在应用层较为常用的，加锁一般通过以下方法实现： Criteria.setLockMode、  Query.setLockMode、  Session.lock</p>
<p><strong> 乐观锁（Optimistic Locking ）</strong></p>
<p>乐观锁，大多是基于数据版本 （Version）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于 数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来 实现。</p>
<p>读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p>乐观锁机制避免了长事务中的数据库加锁开销 ，大大提升了大并发量下的系 统整体性能表现。
需要注意的是，乐观锁机制往往基于系统中的数据存储逻辑，因此也具备一定的局 限性，如在上例中，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户 余额更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在 系统设计阶段，我们应该充分考虑到这些情况出现的可能性，并进行相应调整（如 将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途 径，而不是将数据库表直接对外公开）。</p>
<h3><font color=red> Cache 管理 </font></h3>
<p>在我们的系统与第三方系统共享数据库的情况 下，Hibernate 的 Cache 机制可能失效。</p>
<p>如果在同一套系统中，基于 Hibernate 和基于 JDBC 的两种数据访问方式并存，那么 通过 JDBC 更新数据库的时候，Hibernate 同样无法获知数据更新的情况，从而导致脏数 据的出现。</p>
<p>Hibernate 中的 Cache 大致分为两层，第一层 Cache 在 Session 实现，属于事务 级数据缓冲，一旦事务结束，这个 Cache 也就失效。此层 Cache 为内置实现，无需我们 进行干涉。 第二层 Cache，是 Hibernate 中对其实例范围内的数据进行缓存的管理容器。也是 这里我们讨论的。 Hibernate提供了面向第三方 Cache 实现的接口,  第二级 Cache 实现有： EHCache、OSCache等。</p>
<p>cache usage 可选值有以下几种：
1. read-only
只读。
2. read-write
可读可写。
3. nonstrict-read-write
如果程序对并发数据修改要求不是非常严格，只是偶尔需要更新数据，可以采用 本选项，以减少无谓的检查，获得较好的性能。
4. transactional
事务性 cache。在事务性 Cache 中，Cache 的相关操作也被添加到事务之中， 如果由于某种原因导致事务失败，我们可以连同缓冲池中的数据一同回滚到事务 开始之前的状态。目前 Hibernate 内置的 Cache 中，只有 JBossCache 支持事务性的 Cache 实现。</p>
<h3><font color=red> Hibernate查询的N+1问题及解决方案</font></h3>
<p>Hibernate 数据库查询， 用的最多的是两个方法：
- Query.list();
- Query.iterate();</p>
<p>对于 list 方法而言，实际上 Hibernate 是通过一条 Select SQL 获取所有的记录。 并将其读出，填入到 POJO 中返回。</p>
<p>而 iterate 方法，则是首先通过一条 Select SQL 获取所有符合查询条件的记录的 id，再对这个 id 集合进行循环操作，通过单独的 Select SQL 取出每个 id 所对应的记 录，之后填入 POJO 中返回。</p>
<p>也就是说，对于 list 操作，需要一条 SQL 完成。而对于 iterate 操作，需要 n+1  条 SQL。</p>
<p>看上去 iterate 方法似乎有些多余，但在不同的情况下确依然有其独特的功效，如对 海量数据的查询，如果用 list 方法将结果集一次取出，内存的开销可能无法承受。</p>
<p>另一方面，对于我们现在的 Cache 机制而言，list 方法将不会从 Cache 中读取数据， 它总是一次性从数据库中直接读出所有符合条件的记录。而 iterate 方法因为每次根据 id 获取数据，这样的实现机制也就为从 Cache 读取数据提供了可能，hibernate 首先会 根据这个 id 在本地 Cache 内寻找对应的数据，如果没找到，再去数据库中检索。如果系 统设计中对 Cache 比较倚重，则请注意编码中这两种不同方法的应用组合，有针对性的改 善代码，最大程度提升系统的整体性能表现。</p>
<pre><code class="language-java">/**
* 会出现N+1问题，所谓的N+1指的是发出了N+1条sql语句
*
* 1:发出一条查询id列表的语句
* Hibernate: select student0_.id as col_0_0_ from t_student student0_
*
* N:根据id发出N条sql语句，加载相关的对象
* Hibernate: select student0_.id as id0_0_, student0_.name as name0_0_,
* student0_.createTime as createTime0_0_, student0_.classesid as classesid0_0_
* from t_student student0_ where student0_.id=?
*/
Iterator iter = session.createQuery(&quot;from Student&quot;).iterate();
while (iter.hasNext()) {
    Student student = (Student)iter.next();
    System.out.println(student.getName());
}
</code></pre>
<p>iterate() 是使用缓存的（session里面缓存，也即是一级缓存）</p>
<p>list() 和 iterate()配合使用</p>
<pre><code class="language-java">/**
*
* 在默认情况下，每次执行list查询实体对象都会发出查询语句，除非配置了查询缓存
* 虽然一级缓存中存在Student数据，但list不用，所以仍然发出查询语句，
*
* 其实list就是只向缓存中放入数据，而不利用缓存中的数据
*/
List students = session.createQuery(&quot;from Student&quot;).list();
for (Iterator iter=students.iterator(); iter.hasNext();) {
    Student student = (Student)iter.next();
    System.out.println(student.getName());
}
System.out.println(&quot;-----------------------------------------------------&quot;);
/**
* 避免了N+1问题
*
* 因为执行list操作后会将数据放到session的缓存中（一级缓存），所以采用iterate的时候
* 首先会发出一条查询id列表的语句，再根据id到缓存中加载相应的数据，如果缓存中存在与之匹配的数据
* 则不再发出根据id查询的sql语句，直接使用缓存中的数据
*
* Iterate方法如果缓存中存在数据，它可以提高性能，否则出现N+1问题
*
*/
Iterator iter = session.createQuery(&quot;from Student&quot;).iterate();
while (iter.hasNext()) {
    Student student = (Student)iter.next();
    System.out.println(student.getName());
}
</code></pre>
<h3><font color=red> 比较Hibernate的三种检索策略优缺点 </font></h3>
<ol>
<li>立即检索；
优点：对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便的从一个对象导航到与它关联的对象；
缺点：1.select语句太多；2.可能会加载应用程序不需要访问的对象白白浪费许多内存空间；</li>
<li>延迟检索：
优点：由应用程序决定需要加载哪些对象，可以避免可执行多余的select语句，以及避免加载应用程序不需要访问的对象。因此能提高检索性能，并且能节省内存空间；
缺点：应用程序如果希望访问游离状态代理类实例，必须保证他在持久化状态时已经被初始化；</li>
<li>迫切左外连接检索
优点：1对应用程序完全透明，不管对象处于持久化状态，还是游离状态，应用程序都可以方便地冲一个对象导航到与它关联的对象。2使用了外连接，select语句数目少；
缺点：1 可能会加载应用程序不需要访问的对象，白白浪费许多内存空间；2复杂的数据库表连接也会影响检索性能；</li>
</ol>
<h3><font color=red> Hibernate的实体Bean三种状态？这三种状态的转换过程？ </font></h3>
<h3><font color=red> 在数据库中条件查询速度很慢的时候,如何优化? </font></h3>
<ol>
<li>
<p>建索引</p>
</li>
<li>
<p>减少表之间的关联</p>
</li>
<li>
<p>优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据量大的表排在前面</p>
</li>
<li>
<p>简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</p>
</li>
</ol>
<h3><font color=red> session.load()和session.get()的区别 </font></h3>
<p>Session.load/get方法均可以根据指定的实体类和id从数据库读取记录，并返回与之对应的实体对象。其区别在于：</p>
<p>如果未能发现符合条件的记录，get方法返回null，而load方法会抛出一个ObjectNotFoundException。</p>
<p>Load方法可返回实体的代理类实例，而get方法永远直接返回实体类。</p>
<p>load方法可以充分利用内部缓存和二级缓存中的现有数据，而get方法则仅仅在内部缓存中进行数据查找，如没有发现对应数据，将越过二级缓存，直接调用SQL完成数据读取。</p>
<p>Session在加载实体对象时，将经过的过程：</p>
<p>首先，Hibernate中维持了两级缓存。第一级缓存由Session实例维护，其中保持了Session当前所有关联实体的数据，也称为内部缓存。而第二级缓存则存在于SessionFactory层次，由当前所有由本SessionFactory构造的Session实例共享。出于性能考虑，避免无谓的数据库访问，Session在调用数据库查询功能之前，会先在缓存中进行查询。首先在第一级缓存中，通过实体类型和id进行查找，如果第一级缓存查找命中，且数据状态合法，则直接返回。</p>
<p>之后，Session会在当前“NonExists”记录中进行查找，如果“NonExists”记录中存在同样的查询条件，则返回null。“NonExists”记录了当前Session实例在之前所有查询操作中，未能查询到有效数据的查询条件（相当于一个查询黑名单列表）。如此一来，如果Session中一个无效的查询条件重复出现，即可迅速作出判断，从而获得最佳的性能表现。</p>
<p>对于load方法而言，如果内部缓存中未发现有效数据，则查询第二级缓存，如果第二级缓存命中，则返回。</p>
<p>如在缓存中未发现有效数据，则发起数据库查询操作（Select SQL），如经过查询未发现对应记录，则将此次查询的信息在“NonExists”中加以记录，并返回null。</p>
<p>根据映射配置和Select SQL得到的ResultSet，创建对应的数据对象。</p>
<p>将其数据对象纳入当前Session实体管理容器（一级缓存）。</p>
<p>执行Interceptor.onLoad方法（如果有对应的Interceptor）。</p>
<p>将数据对象纳入二级缓存。</p>
<p>如果数据对象实现了LifeCycle接口，则调用数据对象的onLoad方法。</p>
<p>返回数据对象。</p>
<h3><font color=red> Session 管理 </font></h3>
<p>大多数情况下，Session 管理的目标聚焦于通过合理的设计，避免 Session 的频繁创建 和销毁，从而避免大量的内存开销和频繁的 JVM 垃圾回收，保证系统高效平滑运行。</p>
<p>在各种 Session 管理方案中， ThreadLocal 模式得到了大量使用。ThreadLocal 是 Java 中一种较为特殊的线程绑定机制。通过 ThreadLocal 存取的数据，总是与当前线程相关， 也就是说，JVM 为每个运行的线程，绑定了私有的本地实例存取空间，从而为多线程环境常出 现的并发访问问题提供了一种隔离机制。</p>
<p>首先，我们需要知道，SessionFactory 负责创建 Session，SessionFactory 是线程 安全的，多个并发线程可以同时访问一个 SessionFactory 并从中获取 Session 实例。而 Session 并非线程安全，也就是说，如果多个线程同时使用一个 Session 实例进行数据存取， 则将会导致 Session 数据存取逻辑混乱。 下面是一个典型的 Servlet，我们试图通过一个类 变量 session 实现 Session 的重用，以避免每次操作都要重新创建：</p>
<pre><code class="language-java">public class TestServlet extends HttpServlet {
     private Session session;
     public void doGet( HttpServletRequest request,  HttpServletResponse response)
          throws ServletException, IOException {
          session = getSession();


          doSomething();
          session.flush();
     }


     public void doSomething(){
          ......//基于session的存取操作
     }
}
</code></pre>
<p>代码看上去正确无误，甚至在我们单机测试的时候可能也不会发生什么问题，但这样的代 码一旦编译部署到实际运行环境中，接踵而来的莫名其妙的错误很可能会使得我们摸不找头脑。 问题出在哪里？</p>
<p>首先，Servlet 运行是多线程的，而应用服务器并不会为每个线程都创建一个 Servlet 实例，也就是说，TestServlet 在应用服务器中只有一个实例（在 Tomcat 中是这样，其他的 应用服务器可能有不同的实现），而这个实例会被许多个线程并发调用，doGet 方法也将被不 同的线程反复调用，可想而知，每次调用 doGet 方法，这个唯一的 TestServlet 实例的 session 变量都会被重置，线程 A 的运行过程中，其他的线程如果也被执行，那么 session 的引用将发生改变，之后线程 A 再调用 session，可能此时的 session 与其之前所用的 session 就不再一致，显然，错误也就不期而至。</p>
<p>ThreadLocal 的出现，使得这个问题迎刃而解。 我们对上面的例子进行一些小小的修改：</p>
<pre><code class="language-java">public class TestServlet extends HttpServlet {
     private ThreadLocal localSession = new ThreadLocal();
     public void doGet( HttpServletRequest request,  HttpServletResponse response)
          throws ServletException, IOException {
          localSession.set(getSession());
     doSomething();
     session.flush();
     }


     public void doSomething(){
          Session session = (Session)localSession.get();
     ......//基于session的存取操作
     }
}
</code></pre>
<p>可以看到，localSession 是一个 ThreadLocal 类型的对象，在 doGet 方法中，我们 通过其 set 方法将获取的 session 实例保存，而在 doSomething 方法中，通过 get 方法取 出 session 实例。</p>
<p>这也就是 ThreadLocal 的独特之处，它会为每个线程维护一个私有的变量空间。实际上， 其实现原理是在 JVM 中维护一个 Map，这个 Map 的 key 就是当前的线程对象，而 value 则是 线程通过 ThreadLocal.set 方法保存的对象实例。当线程调用 ThreadLocal.get 方法时， ThreadLocal 会根据当前线程对象的引用，取出 Map 中对应的对象返回。</p>
<p>这样，ThreadLocal 通过以各个线程对象的引用作为区分，从而将不同线程的变量隔离开 来。</p>
<p>回到上面的例子，通过应用 ThreadLocal 机制，线程 A 的 session 实例只能为线程 A  所用，同样，其他线程的 session 实例也各自从属于自己的线程。这样，我们就实现了线程安全的 Session 共享机制。</p>
<p><strong>spring对hibernate是如何避免session的线程不安全的呢？</strong></p>