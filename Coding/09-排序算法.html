<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<link rel="stylesheet" href="../theme/css/my.css" /><p>[TOC]</p>
<h2>选择排序与冒泡排序</h2>
<p><strong>相同点</strong>：每一轮都把最大或最小的元素筛选出来放在相应的位置上 。
<strong>不同点</strong>：冒泡排序每次比较和移动相邻的两项，而选择排序每次交换当前项和第n项。即是：</p>
<pre><code class="language-java">//冒泡： 
for i:=1 to n-1 do 
if (a[i]&gt;a[i+1]) then swap(i,i+1); 
//选择： 
for i:=1 to n-1 do 
if (a[i]&gt;a[n]) then swap(i,n); 
</code></pre>
<p>总的来说，两种排序比较的次数是相同的，但交换的次数，选择排序是更少的。虽然两者的时间复杂度都是 O（n^2) 但选择排序更快一点。</p>
<h3>选择排序</h3>
<pre><code class="language-C">/**
 * 每一趟从待排序的数据元素中选出最大（或最小）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。
 */
void selection_sort(int arr[],int len){
  int max;


  for(int i=len-1;i&gt;=1;i--) {
    max=i; // 假定第i个元素的关键字最大
    for(int j=0;j&lt;i;j++) // 找最大元素的下标
      if(arr[max]&lt;arr[j]) max=j;
    if(max!=i){ // 第i个元素和最大元素交换
      int t = arr[i];
      arr[i] = arr[max];
      arr[max] = t;
    }
  }
}
</code></pre>
<h3>冒泡排序</h3>
<pre><code class="language-C">void bubble_sort(int arr[],int len){
  for(int i=1;i&lt;len;i++) {
    for(int j=len-1;j&gt;=i;j--) {
      if(arr[j]&lt;arr[j-1]) {
        int t = arr[j-1];
        arr[j-1] = arr[j];
        arr[j] = t;
      }
    }
  }
}
</code></pre>
<h2>快速排序</h2>
<p>快速排序的原理： 以第一个记录为“枢轴”，查询记录序列，确定“枢轴“的位置。枢轴将待排序文件分成两部分：枢轴左面的记录的关键字都不大于它的关键字，而枢轴右面的记录的关键字都不小于它的关键字。对枢轴的左右两部分继续实施这一过程，直至全部文件有序。</p>
<pre><code class="language-C">int arr[] = { 14,10,11,5,6,15,0,15,16,14,0,8,17,15,7,19,17,1,18,7};


/* swap函数：交换v[k]与v[j]的值 */
inline void swap(int v[], int k, int j){
 int temp;
 temp = v[k];
 v[k] = v[j];
 v[j] = temp;
}


void qsort(int v[], int left, int right){
 int j, last;
 if (left &gt;= right) /* 若数组包含的元素个数少于两个 */
     return; /* 则不执行任何操作 */


 last=left; /* 用last记录中比关键字小间的最右位置*/


 for (j = left+1; j &lt;= right; j++) {/* 划分子集 */
     if (v[j] &lt; v[left]){
         swap(v, ++last, j);
     }
 }


 /*通过上述过程会形成 关键字（中left所在位置） 小小小...（last所在位置）大大大大（最后）*/
 swap(v, left, last); /* 恢复划分的元素 */


 /*小小。。。。关键字大大大大*/
 qsort(v, left, last-1);
 qsort(v, last+1, right);
}


void main(){
 int j;
 qsort(arr, 0, 19);


 for(j=0; j&lt;=19; j++){
     printf(&quot;%d &quot;, arr[j]);
 }
 printf(&quot;\n&quot;);
}
</code></pre>
<p>传统的快速排序是递归的，这就会受到递归栈深度的限制。比如在一台普通的PC上，当待排序元素达到10^6以上时，传统的递归快排会导致栈溢出异常，或者一个莫名其妙的错误结果。所以，对于巨大的数据规模，将快速排序消除递归是十分必要的。而消除递归，又将带来巨大的性能提升，把系统级的消耗降到最低。</p>
<p>消除递归的方法，就是模拟栈操作。但是从代码可以看出，这种模拟的消耗几乎可以忽略不计。因此消除递归的快排的效率是有保障的。</p>
<p>（虽然下面的代码没有使用随机化，但经过测试，它是目前所有快排编写方法中，效率最高，速度最快的！）</p>
<pre><code class="language-C">#define MAXARRAY 10000
#define PUSH(A,B) {sl[sp]=A;sr[sp]=B;sp++;}
#define POP(A,B) {sp--;A=sl[sp];B=sr[sp];}


void quicksort(int a[],int l,int r){
  static int sl[MAXARRAY], sr[MAXARRAY], sp;
  int i,j,p,t;
  sp=0;
  PUSH(l,r);
  while(sp){
    POP(l,r);
    i=l;
    j=r;
    p=a[(i+j)/2];
    while(i&lt;=j){
      while(a[i]&lt;p)i++;
      while(a[j]&gt;p)j--;
      if(i&lt;=j){
        t=a[i];
        a[i]=a[j];
        a[j]=t;
        i++;
        j--;
      }
    }
    if(l&lt;j)PUSH(l,j);
    if(i&lt;r)PUSH(i,r);
  }
}
</code></pre>
<h2>堆排序</h2>
<p>1.基本概念
树形选择排序(锦标赛排序)，1964年威洛姆斯(J.Willioms)提出了进一步改正的排序方法，即堆排序(heap sort)。
堆是n个元素的有限序列{ K1,K2,…,Kn }，它当且仅当满足如下关系：</p>
<p>这是一个上小、底大的堆。若是一个上大、底小的堆，只需把" &lt;= "改为" &gt;= "即可。堆是一种数据元素之间的逻辑关系，常用向量做存储结构。对于满二叉树，当对它的结点由上而下，自左至右编号之后，编号为 i 的结点是编号为 2i 和 2i+1 结点的双亲。反过来讲，结点 2i 是结点 i 的左孩子，结点 2i+1 是结点 i 的右孩子。图 9.7 表示完全二叉树和它在向量中的存储状态。结点编号对应向量中的下标号。</p>
<p>用堆的概念分析向量中的数据，它显然满足（上小、底大）堆的关系。不难看出满足堆的逻辑关系的一组数据，可画成二叉树的形状，并且它是一棵完全二叉树树形。因此，也可借助完全二叉树来描述堆的概念。若完全二叉树中任一非叶子结点的值小于等于（或大于等于）其左、右孩子结点的值，则从根结点开始按结点编号排列所得的结点序列就是一个堆。在图 9.8 中 (a) 、 (c) 是堆， (b) 、 (d) 不是堆。</p>
<p>2.算法思想
    堆排序利用了大根堆(或小根堆)堆顶记录的关键字最大(或最小)这一特征，使得在当前无序区中选取最大(或最小)关键字的记录变得简单。
（1）用大根堆排序的基本思想
- ① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区
- ② 再将关键字最大的记录R<a href="即堆顶">1</a>和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key
- ③ 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。
  ……
  直到无序区只有一个元素为止。</p>
<p>（2）大根堆排序算法的基本操作：
- ① 初始化操作：将R[1..n]构造为初始堆；
- ② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆(亦称重建堆)。</p>
<p>注意：
- ①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。
- ②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻，堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。</p>
<p>3.具体算法</p>
<pre><code class="language-C">template&lt;class T&gt;  (T r[],int n) { //n为文件的实际记录数，r[0]没有使用
    int i,m;node x;
    for(i=/2;i&gt;=1;i--)heappass(r,i,n);       //初建堆
    //以下for语句为输出堆顶元素、调整堆操作
    for(m=n-1;m&gt;=1;m--){      //逻辑堆尾下标m不断变小
         cout&lt;&lt;r[1].key&lt;&lt;&quot; &quot;;
          x=r[1];r[1]=r[m+1];r[m+1]=x;    //堆顶与堆尾元素对换
          heappass(r,1,m);//恢复堆
       }
     cout&lt;&lt;r[1].key&lt;&lt;endl;
  } //heapsort
</code></pre>